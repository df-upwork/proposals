1) Интеграция NetSuite и Adobe Commerce  
1.1) Для вашего случая лучший способ интеграции — REST API от NetSuite («SuiteTalk REST Web Services Platform»): https://docs.oracle.com/en/cloud/saas/netsuite/ns-online-help/chapter_1540391670.html  
1.1.1) Этот способ (в отличие от готовых модулей для Adobe Commerce или NetSuite и готовых интеграционных платформ) позволит правильно реализовать все перечисленные вами в описании проекта требования.  
1.1.2) Ниже в подпунктах 1.2-1.10 я анализирую каждое требование из вашего описания проекта и детально описываю, как конкретно это требование реализуется посредством «SuiteTalk REST Web Services Platform».
1.2) Общая архитектура интеграции:  
1.2.1) Я разработаю модуль для Adobe Commerce.  
1.2.2) Этот модуль будет взаимодействовать с NetSuite посредством способа пункта 1.1.
1.3) В целом для реализации архитектуры пункта 1.2 надо настроить в NetSuite аутентификацию моего модуля для Adobe Commerce  
1.3.1) Получение ключей «Consumer Key» и «Consumer Secret»  
«Consumer Key» и «Consumer Secret» — это идентификаторы внешнего приложения (в данном случае — моего модуля для Adobe Commerce) в NetSuite.  
1.3.1.1) В NetSuite нужно создать «Integration Record» (Setup → Integration → Manage Integrations → New).  
1.3.1.2) В «Integration Record» настраивается разрешённый способ аутентификации: в вашем случае лучше всего использовать «TBA»: Token Based Authentication.  
1.3.1.3) После создания «Integration Record» вы получите ключи: «Consumer Key» и «Consumer Secret» в случае «TBA».  
1.3.2) Получение ключей «Token ID» и «Token Secret»  
«Token ID» и «Token Secret» —  это ключи конкретной учётной записи NetSuite, которую мой модуль будет использовать для взаимодействия с NetSuite.  
Эти ключи привязаны к «Integration Record» пункта 1.3.1.1 выше.  
1.3.2.1) В NetSuite надо настроить «Role», которая будет иметь полномочия для выполнения всех указанных вами в описании проекта требований (например, для «Customer Sync» нужно предоставить этой роли полномочия на чтение/запись Customer Records через REST API).  
1.3.2.2) В NetSuite надо настроить учётную запись («User»), которую будет использовать мой модуль для Adobe Commerce.    
1.3.2.3) Для учётной записи пункта 1.3.2.2 надо будет настроить «Access Token» («User» → «Access Tokens» → «New»), где надо будет указать настроенную выше «Integration Record» (пункт 1.3.1.1).  
В результате NetSuite создаст «Token ID» и «Token Secret».  
1.3.3) Все 4 ключа («Consumer Key», «Consumer Secret», «Token ID», «Token Secret») будут предоставлены модулю для Adobe Commerce, который я разработаю (пункт 1.2.1 выше): конретно указаны в интерфейсе этого модуля в административной части Adobe Commerce.  
1.3.4) Также надо будет указать в настройках моего модуля для Adobe Commerce «Account ID» вашей компании в NetSuite: его можно увидеть в разделе «Setup» → «Company» → «Company Information» интерфейса NetSuite.  
Этот идентификатор используется в запросах по REST API к серверам NetSuite, чтобы NetSuite знал, что запросы относятся к вашей компании, а не к другой, например: `https://<ACCOUNT_ID>.suitetalk.api.netsuite.com/services/rest/record/v1/<...>`.
1.4) «Customer Sync: Real-time synchronization of customer data, including new registrations, updates, and deletions, between the website and NetSuite»  
При моём способе пункта 1.1 это реализуется так:  
1.4.1) Новые регистрации customers в Adobe Commerce  
1.4.1.1) В Adobe Commerce существует событие `customer_register_success`, которое срабатывает при успешной регистрации нового customer.   
1.4.1.2) Можно написать «Observer» (или «Plugin»), который слушает это событиеи вызывает кастомный код.  
1.4.1.3) При срабатывании события, мой модуль будет формировать JSON с данными customer и далее по протоколу HTTPS выполнять запрос типа `POST` к соответствующему эндпоинту SuiteTalk REST API (`/services/rest/record/v1/customer`), передавая нужные поля в body.  
1.4.1.4) NetSuite будет возвращает `internalId` созданной записи.    
1.4.1.5) Мой модуль будет сохранять этот `internalId` в Adobe Commerce, например, в кастомном поле customer'а или в связующей таблице, чтобы позднее при обновлениях понимать, к какой записи в NetSuite обращаться.  
1.4.2) Обновление данных customer из Adobe Commerce в NetSuite  
Аналогично пунктам 1.4.1.1-1.4.1.2, в Adobe Commerce можно слушать соответствующее событие и далее по протоколу HTTPS выполнять запрос типа `PATCH` или `PUT` (зависит от версии REST API NetSuite), передавая обновлённые данные и `internalId` customer'а в NetSuite.  
1.4.3) Обновление данных customer из NetSuite в Adobe Commerce  
Если предполагается, что в NetSuite тоже могут менять данные о клиенте (например, менеджер вносит правки), то нужно настроить обратные вызовы.  
В NetSuite может быть «SuiteScript» («User Event Script» или «Scheduled Script»), который при обновлении customer вызывет endpoint моего модуля для Adobe Commerce.
1.5) «Item Sync: Ensures real-time product data synchronization from NetSuite to Adobe Commerce, categorizing items for Sleek and Corp, and handling product updates and deletions»  
При моём способе пункта 1.1 с учётом вашего требования «real-time synchronization» синхронизацию товаров лучше всего реализовать push-стратегией NetSuite → Adobe Commerce:  
При создании/редактировании/удалении Item-записи в NetSuite автоматически вызывается скрипт («SuiteScript»), который будет передавать данные моему модулю в Adobe Commerce по REST API.  
Есть 2 способа реализации такого «SuiteScript»:  
1.5.1) «User Event Script» («After Submit»)  
Запускается сразу после сохранения записи Item в NetSuite.    
Этот способ хорош для единичных обновлений.    
Код на SuiteScript (JavaScript) будет формировать JSON с данными товара и передавать данные моему модулю в Adobe Commerce по REST API для создания/обновления/деактивации товара в Adobe Commerce.  
1.5.2) «Map/Reduce» или «Scheduled Script»  
Запускается по расписанию через регулярные интервалы времени.    
Этот способ хорош, если товары меняются очень часто, и вы не хотите нагружать NetSuite вызовами «на каждый Item» в реальном времени (способ 1.5.1).    
При этом способе скрипт ищет (через «Saved Search») все Items, у которых `lastModifiedDate` больше, чем при прошлом запуске, и синхронизирует их с Adobe Commerce.  
1.5.3) При действительно «огромном» потоке изменений иногда делают гибридный вариант — «User Event Script» ставит запись в очередь (custom record или внешнюю шину сообщений), а отдельный «Map/Reduce» её обрабатывает. 
Но в небольших/средних проектах хватает 1.5.1 или короткого интервала «Scheduled Script» (1.5.2).
1.6) «Sales Order Sync: Two-way real-time synchronization of sales orders between NetSuite and the website, including status updates, payment mapping, and guest user handling»  
При моём способе пункта 1.1 это реализуется так:  
1.6.1) Сценарий «Adobe Commerce → NetSuite» реализуется так:  
1.6.1.1) Покупатель размещает заказ в Adobe Commerce.    
1.6.1.2) Мой модуль для Adobe Commerce обрабатывает событие сохранения заказа (`sales_order_place_after`, аналогично пунктам 1.4.1.1-1.4.1.2) и вызывает NetSuite по REST API  (аналогично пункту 1.4.1.3), создавая в NetSuite «Sales Order»  
1.6.1.3) NetSuite (аналогично пункту 1.4.1.4) возвращает `internalId` (Sales Order ID) в ответ.    
1.6.1.4) Мой модуль сохраняет этот ID в Adobe Commerce, чтобы далее обновления выполнялись по тому же ID.  
1.6.2) Сценарий «NetSuite → Adobe Commerce» реализуется так:     
1.6.2.1) Менеджер в NetSuite обновляет Sales Order (меняет статус, указывает оплату, формирует частичную отгрузку, и т. д.).    
1.6.2.2) «User Event Script» (аналогично пункту 1.5.1) или «Scheduled Script» (аналогично пункту 1.5.2) в NetSuite отслеживает эти изменения и передаёт их моему модулю в Adobe Commerce через REST-эндпоинт моего модуля.  
1.6.2.3) Мой модуль:  
- обновляет статус заказа,    
- добавляет трекинг-номер отгрузки,    
- указывает, что заказ «завершён» (Complete) или «отменён» (Canceled) и т. д.
1.7) «Promotions and Tax: NetSuite-managed promotions and tax configurations will be automatically applied to sales orders on the website, with real-time syncing to ensure consistency»  
При моём способе пункта 1.1 это реализуется так:  
1.7.1) В NetSuite будет настроен «User Event Script» или «Scheduled Script» на «Promotion» («Record Type»: `promotionCode`), «SuitePromotions» и налоговые правила.    
1.7.2) При создании/изменении/удалении промо-кода NetSuite будет отправлять запрос к моему модулю по REST API модуля.  
1.7.3) Мой модуль будет обрабатывать запросы пункта 1.7.2 и обновлять в Adobe Commerce налоговые и скидочные правила.  
1.7.4) Таким образом, корзина покупателя в Adobe Commerce будет правильно отражать налоговые и скидочные правила из NetSuite.
1.8) «Item Fulfillment and Shipping Method Sync: Fulfillment processes and shipping methods will be managed in NetSuite, with updates reflected in Adobe Commerce»  
1.8.1) Сценарий «Item Fulfillment Sync» (NetSuite → Adobe Commerce)  
1.8.1.1) Создание/обновление Fulfillment в NetSuite  
Менеджер в NetSuite будет на основе Sales Order создавать «Item Fulfillment» («Record Type»: `itemFulfillment`).  
1.8.1.2) Синхронизация с Adobe Commerce будет выполняться аналогично пунктам 1.5.1 и 1.5.2.  
1.8.2) Сценарий «Shipping Method Sync» (NetSuite → Adobe Commerce)  
1.8.2.1) В NetSuite существуют «Shipping Items» («Record Type»: `shipItem`).  
1.8.2.2) При добавлении/изменении/удалении «Shipping Items» в NetSuite эти изменения будут синхронизироваться с Adobe Commerce аналогично пунктам 1.5.1 и 1.5.2.
1.9) «Cash Sale and RMA Sync: One-way synchronization of cash sales and RMAs from NetSuite to Adobe Commerce, ensuring seamless order and return management»  
1.9.1) Cash Sale  
1.9.1.1) Cash Sale — это сделка в NetSuite, при которой оплата происходит сразу, без отдельной процедуры выставления и закрытия Invoice.   
1.9.1.2) Как только в NetSuite появляется или обновляется запись типа `cashSale` — эти изменения будут синхронизироваться с Adobe Commerce аналогично пунктам 1.5.1 и 1.5.2.  
1.9.2) RMA (Return Authorization)   
1.9.2.1) RMA — это документ, фиксирующий возврат товаров от клиента.   
В дальнейшем в NetSuite могут создаваться «Item Receipt» (принятие товара на склад) и «Credit Memo» (денежный возврат).    
1.9.2.2) Аналогично 1.9.1.2: как только в NetSuite появляется или обновляется запись типа `returnAuthorization` — эти изменения будут синхронизироваться с Adobe Commerce аналогично пунктам 1.5.1 и 1.5.2.
1.10) «A custom record will store synchronization failures, with retries scheduled every 15 minutes. Persistent issues will trigger email notifications to the administrator.»   
При моём способе пункта 1.1 это реализуется так:  
1.10.1) При каждом «событии» (например, создании/редактировании Sales Order, Item, Fulfillment и т. д.), «User Event Script» (пример был описан выше в пункте 1.5.1) или Scheduled Script (пример был описан выше в пункте 1.5.2) будет пытаться передавать данные моему модулю в Adobe Commerce по протоколу REST.   
1.10.2) Если мой модуль (или система более высокого уровня: Adobe Commerce или серверное программное обеспечение) не был в состоянии обработать запрос от NetSuite, то NetSuite будет записывать отчёт о сбое в специальном месте (таблице базы данных) и повторять попытку позже.  
1.10.2.1) Таблица в NetSuite будет иметь следующие поля:  
- «Record Type» (какой объект мы пытались синхронизировать: Order, Item, Customer)    
- «Record ID» (какой конкретно идентификатор в NetSuite)    
- «Action» (Create, Update, Delete в Magento)    
- «Error Message» (текст ошибки, код, тело ответа Magento)    
- «Number of Retries» (сколько раз мы уже пытались)    
- «Last Attempt Date» (дата/время последней попытки)    
- «Next Attempt Date» (когда мы планируем снова попробовать)    
- «Status» (Pending, In Progress, Failed, Resolved и т. д.)  
1.10.3) По расписанию (каждые 15 минут) в NetSuite будет запускается «Scheduled Script» или «Map/Reduce Script», который на основе таблицы пункта 1.10.2.1 будет повторять запросы к Adobe Commerce.
2) Для розничного мебельного бизнеса в США в 2025 году использование указанной вами готовой оформительской темы Claue от Arrow Theme — не самое лучшее и сильно устаревшее решение.
Реализация этого решения наверняка приведёт вас только к потере времени и денег.
Никто из ваших основных конкурентов на розничном рынке онлайн продаж мебели в США подобные примитивные решения уже не использует.
А с учётом того, что после пандемии рынок мебели в США уже 4 года как падает (https://trends.google.com/trends/explore?date=2015-01-16%202025-01-16&geo=US&q=/m/0c_jw), то при реализации примитивного решения вы наверняка не получите ожидаемого результата.
