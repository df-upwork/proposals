1) You have generally enumerated the main possible reasons why a screen of a Python/Flask application shows outdated data from an SQLAlchemy database: «potential stale ORM instances, improper session handling with SQLAlchemy, or caching issues».
First of all, I will comment on these reasons in a bit more detail, based on my experience:
1.1) The most popular reason: objects are fetched from the database and stored somewhere, and then the application incorrectly reuses these cached objects instead of querying the database again upon subsequent access.
1.2) The second most popular reason — it is the misuse of a single session object across multiple HTTP requests
In most cases, it is better to create a separate session in a Flask application for each HTTP request.  
Более того, если используется Flask-SQLAlchemy с «из коробки» настроенным `scoped_session`, то в большинстве случаев оно само по себе создаёт и «отвязывает» сессии на каждый запрос (если правильно настроены хуки `app.teardown_appcontext`). Но если была ручная перенастройка или есть неочевидное переиспользование сессии через глобальные объекты, то могут возникнуть такие проблемы, о которых вы пишете.
1.3) The last sentence of 1.2 leads to the next reason: the changes in the session may not be committed.
1.4) Applied to a multithreaded or multiprocess environment: a misconfiguration of `scoped_session` can cause the SQLAlchemy session to be incorrectly «shared» when multiple requests (for example, in `gunicorn`/`uwsgi`) are handled in parallel by different threads or processes.
2) «Despite using `db.session.remove()` and `db.session.expire_all()` to refresh sessions and ORM instances, the problem persists»
These methods do not guarantee a complete reload of data or a re-creation of the session on each request.
2.1)`db.session.remove()` detaches the active session from the current context (for example, from `scoped_session`).
However, if existing references to objects from the old session remain somewhere in the code or in memory (for example, in a global variable, a singleton object, or a cache), they are not automatically updated.
2.2) `db.session.expire_all()` makes all objects in the current session obsolete, so the next time their attributes are accessed, SQLAlchemy will retrieve the data from the database again.
But if the same objects are still used in the code between requests, or (even worse) the same session object is still used (without exiting the request, without a complete restart), this does not save you from having a half-dead session or old objects in the following HTTP request.
2.3) I want to emphasize that even if you try to force these objects to be refreshed by calling `remove()` and `expire_all()`, but at the same time do not recreate the session for each request (or do not unload the old objects from memory), the problem will remain.
In my experience, this is exactly the classic case where developers think that calling `db.session.remove()` or `db.session.expire_all()` will solve all the problems, but in reality, the session may still be improperly shared between threads or HTTP requests, or somewhere in the code a reference to the old session remains.
3) «The data updates correctly when other functions modify the database»
This happens because these «other functions» may use a new SQLAlchemy session object or at least finish working with the session correctly (they do `commit()` / `rollback()`) and thereby reset the ORM cache.
These «other functions» could also explicitly call `flush()`, which will reset all previously cached information from the database.
----
I have completed 532 projects here on Upwork.
My GitHub profiles: https://github.com/dmitrii-fediuk and https://github.com/mage2pro
My websites: https://df.tips?order=views and https://mage2.pro?order=views