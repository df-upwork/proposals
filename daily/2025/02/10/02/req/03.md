## 1.
Клиент хочет выполнить следующий проект:
### 1.1. Title
AWS RDS Aurora MySQL Database Migration Expert Needed
### 1.2. Description
We are seeking an expert DBA to help us with a critical database migration project.
Our production database is using INT data types as primary keys and we need to migrate them to BIGINT. The database runs on AWS RDS Aurora Mysql (engine 8.0.mysql_aurora.3.05.2). The migration needs to run without any downtime.
There are in total six tables to be migrated with the biggest having 150M rows and 100GB in size. Other tables are referencing those tables but without using foreign key indexes.
The ideal candidate has a proven record to migrate mission critical production databases on the Amazon cloud.

### 1.3. Tags
MySQL
Amazon Web Services
SQL
Amazon RDS
MySQL Programming

## 2. Как правильно выполнить задачу клиента?
### 2.1.
В 1-й раз я тебя спросил:
~~~
Как правильно выполнить задачу клиента?
~~~

### 2.2.
Ты ответил:
~~~
Ниже приведён обобщённый подход, который обычно применяют в подобных сценариях для **миграции `INT` → `BIGINT`** на большом объёме данных в **Aurora MySQL**, сохраняя при этом минимальный (или нулевой) даунтайм. Основная идея — использовать **онлайн-перенос** данных (online schema change) или подход с **репликацией** и «переключением» (cutover) на новую схему.

---

## 1. Подготовка и анализ

1. **Проверка текущей схемы**  
   - Убедитесь, что нет жёстких связей по внешним ключам (Foreign Keys), раз уж по условию сказано, что они не используются. Если где-то всё же есть FK, то нужно планировать их изменение одновременно.
   - Уточните, какие именно столбцы в таблицах должны быть изменены на `BIGINT`. Часто вместе с первичным ключом (PK) меняют и связанные по смыслу колонки в других таблицах.
   - Оцените текущие индексы и объем данных. В примере — 150M строк и 100GB в одной из таблиц.

2. **Выбор инструмента для онлайн-миграции**  
   - **Percona Toolkit**: утилита [pt-online-schema-change](https://www.percona.com/doc/percona-toolkit/LATEST/pt-online-schema-change.html) позволяет выполнять `ALTER TABLE` без длительной блокировки, копируя данные в новую «теневую» таблицу (shadow table), а затем мгновенно переименовывая её.
   - **GitHub gh-ost**: аналогичный инструмент для онлайн-миграции, созданный в GitHub, также широко применяется в MySQL-среде.
   - **AWS DMS** (Database Migration Service): может быть использован, если хочется организовать параллельную репликацию на другой экземпляр Aurora/MySQL со скорейшим последующим cutover.
   - **Различные Live Migration методики**: например, создать клон Aurora (или новую базу), загрузить данные, включить репликацию (binlog/Binlog Replication или DMS), а затем переключить трафик.

3. **Тестовая среда**  
   - Перед запуском в продакшене необходимо на тестовой копии (staging) проверить выбранный метод изменения схемы, оценить скорость копирования и влияние на производительность.

---

## 2. Общий алгоритм онлайн-модификации (pt-online-schema-change или gh-ost)

Ниже – классический пример с **Percona pt-online-schema-change**, но аналогично это работает и с gh-ost.

1. **Создание резервной копии**  
   - Даже при онлайн-миграции важно иметь актуальный бэкап (snapshot RDS или dump — в зависимости от стратегии). Это защитит от непредвиденных ситуаций.

2. **Запуск инструмента для одной таблицы**  
   Допустим, вам нужно изменить структуру большой таблицы `table_name`, в которой есть первичный ключ `id INT`.  
   Примерная команда для pt-online-schema-change может выглядеть так:
   ```bash
   pt-online-schema-change \
     --alter="MODIFY COLUMN id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT" \
     --alter-foreign-keys-method=none \
     --nocheck-unique-key-change \
     D=mydatabase,t=table_name \
     --execute
   ```
   - `--alter="MODIFY COLUMN..."` указывает, что мы меняем тип колонки `id` на `BIGINT`.
   - `--alter-foreign-keys-method=none` учитывает, что у вас нет реальных внешних ключей, привязанных к этой таблице.
   - `--nocheck-unique-key-change` иногда требуется, когда меняется тип ключа и pt-online-schema-change опасается влияния на уникальность.
   - `--execute` означает, что изменения будут выполнены сразу (до этого можно запустить с `--dry-run`, чтобы проверить логику).

3. **Принцип работы pt-online-schema-change**  
   - Инструмент создаёт «теневую» таблицу (shadow table) с новой структурой.
   - Постепенно копирует в неё данные из исходной (в небольших батчах, работая в фоне, чтобы не блокировать основную операцию INSERT/UPDATE).
   - При копировании дополнительно отслеживает бинлоги (binlog) и применяет изменения, которые произошли в исходной таблице, в «теневую».
   - В конце выполнения мгновенно переименовывает исходную таблицу (например, в `table_name_old`) и «теневую» таблицу (в `table_name`), обеспечивая минимальный даунтайм (на время операции RENAME, обычно миллисекунды).

4. **Проверка результатов**  
   - После успешного окончания операции убедитесь, что новая таблица действительно имеет `BIGINT` в нужных столбцах.
   - Удостоверьтесь, что индекс первичного ключа корректно перенёсся.
   - Следите за производительностью: при больших объёмах возможен рост нагрузки на диск/CPU, поэтому операции лучше планировать в «окна обслуживания» (maintenance window) или периоды низкого трафика.

5. **Аналогично повторить для остальных таблиц**  
   - Процесс придётся сделать для всех шести таблиц, где нужно изменить тип колонок.
   - Если какие-то таблицы относительно маленькие, их можно мигрировать быстрее, но тоже желательно последовательно, чтобы не перегружать кластер.

---

## 3. Альтернативный вариант: репликация и cutover

Если нет желания (или возможности) работать с pt-online-schema-change/gh-ost непосредственно на боевой базе, можно использовать схему с **AWS DMS** (или binlog-реплика):

1. **Создать новую БД** (на том же кластере Aurora или на отдельном MySQL/Aurora).  
2. **В новой БД** вручную (или скриптами) создать те же таблицы, но уже с нужным типом (`BIGINT` вместо `INT`).
3. **Запустить AWS DMS** (или binlog-репликацию), чтобы копировать все данные из продакшен-БД в новую в режиме непрерывного обновления (Change Data Capture).
4. **Дождаться окончания** полной загрузки исторических данных (full load).  
5. **Убедиться в синхронизации**: когда задержка репликации (lag) минимальна, спланировать «переключение» (cutover).
6. **Перенастроить приложение** (или DNS/endpoint) на новую БД.  
   - Даунтайм в этом случае — время, за которое приложение «переключится» на новый endpoint. Обычно это секунды или меньше.
   - После переключения все запросы идут в новую базу, где уже `BIGINT`.  
7. **Проверить работоспособность**, а после — остановить старую базу или оставить как fallback, в зависимости от стратегии.

Этот метод часто удобен, если можно позволить себе временно дублировать инфраструктуру и если нужна гарантия, что вы не затрагиваете напрямую боевую базу «тяжёлой» операцией `ALTER TABLE`. Но иногда это сложнее в настройке и требует больше ресурсов.

---

## 4. Рекомендации по оптимизации и безопасности

1. **Мониторинг производительности**  
   - Следите за метриками RDS Aurora: CPU, Memory, IOPS, лаг по репликации (если используются read-replica), задержки в DMS (если он используется), время отклика SQL-запросов.
   
2. **Выделенное «окно» или «slow mode»**  
   - Если используете pt-online-schema-change/gh-ost, настройте параметры «throttle», чтобы инструмент при пиках нагрузки замедлялся, а не влиял на продакшен критически.

3. **Учет размера транзакции**  
   - При больших таблицах операции изменения типа колонки (`MODIFY COLUMN`) внутри одной транзакции могут привести к росту binlog- или redo/undo-логов. Инструменты для онлайн-миграции умеют это обходить, но всё же стоит держать в уме.

4. **Тесты на staging**  
   - Обязательно отрепетируйте процедуру на реплике или staging-копии, чтобы оценить реальное время выполнения.  

5. **План отката (rollback)**  
   - Если что-то пошло не так, нужен понятный rollback-план. Например, иметь резервную копию или «клон» базы до миграции.

---

## Итог

**Главная идея** для миграции `INT → BIGINT` на больших объёмах в Aurora MySQL — применить проверенные подходы онлайн-схемы: это либо **инструменты Percona (pt-online-schema-change) / gh-ost** для безостановочного `ALTER TABLE`, либо **стратегия с репликацией и переключением** (AWS DMS). Оба варианта позволяют достичь «нулевого» или почти нулевого даунтайма, если всё грамотно спланировать и протестировать заранее.

1. Убедитесь, что меняете все нужные таблицы и колонки согласованно.  
2. Проведите репетицию на тестовой среде, проверив время, нагрузку и риск блокировок.  
3. Запланируйте «окно» с минимальной нагрузкой и выполните миграцию.  
4. Используйте мониторинг и имейте план отката.

С таким подходом вы сможете **обновить типы первичных ключей на `BIGINT`** в ваших больших таблицах без критического простоя и с сохранением целостности данных.
~~~

## 3. `pt-online-schema-change`
### 3.1.
Во 2-й раз я тебя спросил:
~~~
В пункте 2.2 ты написал:
```
   - **Percona Toolkit**: утилита [pt-online-schema-change](https://www.percona.com/doc/percona-toolkit/LATEST/pt-online-schema-change.html) позволяет выполнять `ALTER TABLE` без длительной блокировки, копируя данные в новую «теневую» таблицу (shadow table), а затем мгновенно переименовывая её.
```
Почему ты предлагаешь использовать Percona Toolkit, если клиент использует «RDS Aurora Mysql», а не Percona?
В чём разница «RDS Aurora Mysql» и Percona?
Действительно ли `pt-online-schema-change` совместима с «RDS Aurora Mysql»?
~~~

### 3.2.
Ты ответил:
~~~
**Короткий ответ**:  
- **pt-online-schema-change** (часть Percona Toolkit) совместим со всеми вариантами MySQL, в том числе с Amazon RDS Aurora MySQL, поскольку он опирается на стандартный протокол и SQL-команды MySQL.  
- **Percona Server for MySQL** — это своя сборка MySQL от компании Percona, а **RDS Aurora MySQL** — полностью управляемый сервис MySQL-совместимой базы данных от AWS. Несмотря на разные «вендорские» варианты, они все основаны на MySQL и поддерживают схожий SQL-функционал. Поэтому инструменты Percona (в частности `pt-online-schema-change`) работают и на Aurora MySQL.  

---

## 1. Разница между RDS Aurora MySQL и Percona Server for MySQL

1. **Percona Server for MySQL**  
   - Является *форком* (дистрибуцией) MySQL с дополнительными улучшениями производительности, расширенной диагностикой и рядом собственных патчей.  
   - Перcona также развивает и поддерживает утилиты Percona Toolkit (включая `pt-online-schema-change`).  

2. **AWS RDS Aurora MySQL**  
   - Это *коммерческий сервис* от Amazon, который использует совместимость с MySQL (движок MySQL 5.7 или 8.0, в зависимости от выбранной версии).  
   - Aurora имеет собственную распределённую архитектуру хранения и встроенную масштабируемость. Но при этом *уровень SQL* (DDL, DML, протокол общения с сервером) остаётся совместимым с обычным MySQL.  

С точки зрения *использования MySQL-клиента или утилит*, RDS Aurora MySQL «выглядит» как обычный MySQL-сервер. Инструкция `ALTER TABLE`, работа с binlog, SQL-синтаксис, протокол MySQL — всё это совместимо.

---

## 2. Почему pt-online-schema-change работает и на Aurora

`pt-online-schema-change` не требует «именно Percona Server» — он написан для *MySQL-совместимой* СУБД. Утилита использует:

1. **Подключение через обычный MySQL-клиент** (TCP/IP) и стандартные SQL-команды (CREATE TABLE, INSERT, RENAME TABLE, и т.д.).  
2. **Binlog/replication механизмы**, которые тоже стандартны в MySQL (Aurora MySQL их поддерживает).  

Важно лишь, чтобы:
- Aurora была настроена на генерацию binlog (для корректного отслеживания изменений). Обычно это параметр `binlog_format` и некоторые другие настройки в Parameter Group RDS.  
- У учётной записи, под которой запускается `pt-online-schema-change`, были достаточно широкие привилегии на `ALTER TABLE`, `CREATE TABLE`, `DROP TABLE`, `RENAME TABLE`, а также доступ к binlog (REPLICATION CLIENT) — в зависимости от настроек.

С технической точки зрения команда `pt-online-schema-change` делает следующее:
1. Создаёт «теневую» таблицу с новой структурой (вместо `INT` становится `BIGINT`).  
2. «Построчно» копирует данные из старой таблицы в новую в фоновом режиме, подглядывая в binlog, чтобы синхронизировать изменения (INSERT/UPDATE/DELETE), которые произошли за время копирования.  
3. После окончания копирования *атомарно* переименовывает новую таблицу в имя старой, а старую — в «table_name_old» (или удаляет). Это даёт **минимальный даунтайм** (обычно доли секунды).  

Aurora MySQL успешно поддерживает все эти действия.

---

## 3. Почему упоминается Percona Toolkit

Percona Toolkit (включая `pt-online-schema-change`) — это *де-факто стандарт* для онлайн-изменения схемы в MySQL:

- **Просто и привычно**: многие DBA, работающие с большими MySQL-базами, используют именно эту утилиту.  
- **Надёжно**: она «обкатана» годами на большом числе инсталляций (MySQL Community, Percona, MariaDB, Aurora).  
- **Альтернативы**: существуют и другие инструменты (например, [gh-ost](https://github.com/github/gh-ost) от GitHub), но принцип у них похож.

Следовательно, **нет противоречия** между «Aurora MySQL» и «Percona Toolkit»; Aurora тут играет роль сервера MySQL, к которому `pt-online-schema-change` подключается.

---

### Вывод

1. **RDS Aurora MySQL** и **Percona Server for MySQL** — разные «сборки» и «оболочки», но внутри они оба «говорят» на MySQL-протоколе и поддерживают стандартный DDL/DML.  
2. **`pt-online-schema-change`** полностью совместим с Aurora MySQL, если у вас есть нужные права и включена поддержка binlog.  
3. Использование Percona Toolkit для *онлайн-миграции* (например, **`INT` → `BIGINT`**) оправдано и в среде Aurora MySQL, потому что Aurora сохраняет совместимость с MySQL на уровне протокола и SQL-функционала.
~~~


## 4.
Я хочу ответить клиенту так:
~~~
1) Вашу задачу лучше всего решать программой `pt-online-schema-change` из Percona Toolkit: https://docs.percona.com/percona-toolkit/pt-online-schema-change.html
2) Эта программа позволяет выполнять `ALTER` для таблиц  without locking them.
3) Хоть эта программа и является частью Percona Toolkit, она совместима с RDS Aurora MySQL.
4) В вашем случае задача будет решаться примерно так:
```
pt-online-schema-change \
	--alter="MODIFY COLUMN id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT" \
	--alter-foreign-keys-method=none \
	--nocheck-unique-key-change \
	D=<database>,t=<table> \
	--execute
```
~~~

## 5. Твоя задача
Есть ли в моём ответе фактические ошибки?
Есть ли в моём ответе логические ошибки?
Упустил ли я в ответе нечто важное?