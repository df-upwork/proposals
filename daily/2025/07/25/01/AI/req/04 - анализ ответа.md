## 1. `Def`
~~~
Def(A):
```
B
```
~~~
будет обозначать, что для понятия `B` я использую обозначение `A`.

## 2. `Def_P`
~~~
Def_P(A):
```
B
```
~~~
будет обозначать, что `B` является для меня проблемой, и для этой проблемы я использую обозначение `A`.

## 3. `Def_C`
### 3.1.
```
Def_C(P, A, B)
```
будет обозначать `Def(A, B)` в контексте пункта `P`.
Вне пункта `P` это правило не применяется.
Если до пункта `P` обозначение `A` имело другой смысл, то после пункта `P` обозначение `A` снова будет иметь этот смысл.
По сути, `Def_C` объявляет локальную переменную `A` с областью действия `P`.
В отличие от него, `Def` объявляет глобальную переменную `A` (значение которой действует для всех пунктов, кроме `P`).

### 3.2.
~~~
Def_C(P, A):
```
B
```
~~~
имеет то же значение, что и `Def_C(P, A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 3.3.
```
Def_C([P1, P2, …, Pn], A, B)
```
имеет значение, аналогичное `Def_C(P, A, B)`, только в этом случае обозначение `A` имеет значение `B` в контексте не одного пункта `P`, а всех пунктов [`P1`, `P2`, …, `Pn`], перечисленных в квадратных скобках.

### 3.4.
```
Def_C([P1-Pn], A, B)
```
имеет значение, аналогичное `Def_C([P1, P2, …, Pn], A, B)`: в этом случае обозначение `A` имеет значение `B` в контексте множества всех пунктов между `P1` и `Pn`, включая сами эти пункты.

### 3.5.
~~~
Def_C([P1, P2, …, Pn], A):
```
B
```
~~~
имеет то же значение, что и `Def_C([P1, P2, …, Pn], A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 3.6.
~~~
Def_C([P1-Pn], A):
```
B
```
~~~
имеет то же значение, что и `Def_C([P1-Pn], A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 4. `Def_F`
### 4.1.
Def_C(4-5, `F`):
```
Факт: некое событие, которое случилось в описываем мной случае.
```

### 4.2.
~~~
Def_F:
```
B
```
~~~
будет обозначать, что `B` — это `F`.

### 4.3.
~~~
Def_F(A):
```
B
```
~~~
будет обозначать, что `B` — это `F`, и для него я использую обозначение `A`.

## 5. `Def_Ph`
### 5.1.
Def_C(5, `Ph`):
```
Феномен: `F`, который вызывает у меня удивление.
```

### 5.2.
~~~
Def_Ph(A):
```
B
```
~~~
будет обозначать, что `B` — это `Ph`, и для него я использую обозначение `A`.

## 6. `Def_H`
### 6.1.
Def_C(6, `H`):
```
Гипотеза: некое предположение, требующее проверки.
```

### 6.2.
~~~
Def_H(A):
```
B
```
~~~
будет обозначать, что `B` — это `H`, и для него я использую обозначение `A`.

## 7. `Def_Set`
### 7.1.
```
Def_Set(S, I)
```
будет обозначать, что `S` — множество всех возможных `I`.

### 7.2.
```
Def_Set(S, {I1, I2, …, In})
```
будет обозначать, что `S` — множество, заданное точным перечислением всех его элементов: {`I1`, `I2`, …, `In`}.

## 8. `Def_I`
### 8.1.
```
Def_I(I, S)
```
будет обозначать, что `I` ∈ `S` (`I` — элемент множества `S`).

### 8.2.
~~~
Def_I(I, S):
```
B
```
~~~
будет обозначать, что `I` ∈ `S` и `B` — определение `I`.

## 9. `Use`
```
Use(A)
```
будет обозначать, что в описываемой мной ситуации я использую `A`.

## 10.
Потенциальный клиент опубликовал на Upwork следующий проект:
### 10.1. Title
EntraId and Keycloak Configuration Expert Needed

### 10.2. Description
```text
We are seeking an EntraId expert to assist in configuring Authorization using Keycloak. 
The ideal candidate should possess a strong understanding of both EntraId and Keycloak platforms to effectively manage user authentication and authorization processes. 
Your expertise will be crucial in ensuring seamless integration and optimal functionality. 
If you have experience in identity management systems and a passion for delivering high-quality results, we would love to hear from you!
```

### 10.3. Tags
Java
JavaScript
PHP
Amazon Web Services
Network Administration

## 11. Информация о клиенте
### 11.1. Местоположение
United States

## 11.2. Характеристики компании
### 11.2.1. Сектор экономики
Tech & IT
### 11.2.2. Количество сотрудников
10-99

## 11.3. Характеристики учётной записи на Upwork
### 11.3.1. Member since
Aug 31, 2022
#### 11.3.2. Hire rate (%)
0
#### 11.3.3. Количество опубликованных проектов (jobs posted)
3
#### 11.3.4. Total spent (USD)
0
#### 11.3.5. Количество оплаченных часов в почасовых проектах
0

## 12.
Def(`C`):
```
клиент пункта 10
```

## 13.
Def(`P`):
```
проект пункта 10
```

## 14.
Def(`PD`):
```
Описание `P` (пункт 10.2 выше)
```

## 15.
Def(`T`):
```
Задача, о которой `C` пишет в `PD`:
~~~
configuring Authorization using Keycloak
~~~
```

## 16.
Def(`D`, «мой ответ `C`»).

## 17.
Содержание `D`:
~~~markdown
1) In your case, I recommend using the «Identity Brokering» / «Identity Federation» architectural pattern:
1.1) Keycloak (`K`) delegates the authentication process to a trusted external identity provider (`IP`).
1.2) Microsoft Entra ID (`EI`) acts as the authoritative `IP`: it stores users’ credentials, verifies their authenticity (authentication), and provides user information.
1.3) `K` acts as an identity broker: an intermediary service that establishes a trust relationship with `EI`.
1.4) The end-user application (`A`) does not interact directly with `EI`.
Instead, it fully trusts `K`, which provides it with a unified interface for authentication and authorization.
2) My approach (point 1) provides the following advantages:
2.1) Centralized `IP` management.
If other identity providers are added in the future, all changes will be made centrally in `K`.
`A` will remain unchanged because it will still only interact with `K`.
`A` developers do not need to implement the logic for interacting with the various protocols and APIs of multiple `IP’s.
They only need to integrate with a single service (`K`) using a single standardized protocol.
2.2) Token enrichment and transformation.
`K` can receive information from the external `IP` and then enrich or transform it before passing it to `A`.
E.g., it can map groups from `EI` to `K`'s internal roles.
3) In my approach, `K` performs a dual role:
3.1) From the perspective of `A`, `K` is its `IP`.
`A` contacts `K` for authentication and receives tokens from it.
3.2) From the perspective of `EI`, `K` is a client application that requests authentication. 
In protocol terminology, it acts as «Service Provider» (`SP`) or «Relying Party» (`RP`).
4) The duality of point 3 is critical for troubleshooting. 
E.g., an authentication failure can be related to either the token that `K` receives from `EI` (its role as `SP`/`RP`) or the token that it issues to the end application (its role as `IP`). 
A clear distinction between these roles precisely localizes the source of the problem.
5) `K` supports 2 main protocols for identity federation: Security Assertion Markup Language (SAML) 2.0 and OpenID Connect (`OIDC`) 1.0.
In your case, I recommend `OIDC`:
5.1) The project’s technology stack, specified by you in the tags («Java», «JavaScript», «PHP», «Amazon Web Services») is oriented toward modern web technologies and cloud services.
5.2) `OIDC` is a more modern standard, built as a simple identity layer on top of the OAuth 2.0 authorization protocol. `OIDC` uses the JSON format and JWT («JSON Web Tokens») to transmit data. 
It was designed to meet the needs of modern web applications, mobile clients, and RESTful APIs.
6) My recommended interaction flow:
6.1) The user (`U`) attempts to access a protected resource in `A`.
6.2) `A`, upon detecting the absence of an active session, redirects `U` to the `K` login page.
6.3) `K`, in turn, sees that `U` is not authenticated, and redirects `U` to the configured external `IP`: `EI`.
6.4) `U` enters their corporate credentials on the `EI` sign-in page and is successfully authenticated.
6.5) `EI` generates an «ID Token» (`T`), containing claims about `U`, including its group identifiers, and redirects `U`'s browser back to the special «Redirect URI» in `K`.
6.6) `K` receives `T` from `EI`, verifies its digital signature and validity.
6.7) `K` extracts the claims from `T`.
6.8) Based on the claims, `K` either creates a new user account for `U` in its database or updates the existing one. 
The key process takes place here: mapping of group identifiers from the «groups» claim to `K`'s internal roles.
6.9) `K` creates its session for `U`.
6.10) `K` generates its tokens (`K-TT`) for `A`:
- It's «ID Token» (not to be confused with `T`)
- «Access Token».
`K-TT` contain the roles that were assigned to `U` inside `K`.
6.11) `K` redirects the browser of `U` back to the «Redirect URI» of `A`.
6.12) `A` receives `K-TT` from `K`, validates them, and extracts from them the information about the roles of `U`.
6.13) `A` decides on granting or denying `U` access to the requested resource.
---
My GitHub profile: https://github.com/dmitrii-fediuk
~~~

## 18.
Есть ли в `D` ошибки?