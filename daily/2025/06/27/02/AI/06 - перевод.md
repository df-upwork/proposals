## 1. `Def`
### 1.1.
```
Def(A, B)
```
будет обозначать, что для понятия `B` я использую обозначение `A`.

### 1.2.
~~~
Def(A):
```
B
```
~~~
имеет то же значение, что и `Def(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 2. `Def_P`
### 2.1.
```
Def_P(A)
```
будет обозначать, что `A` является для меня проблемой.

### 2.2.
```
Def_P(A, B)
```
будет обозначать, что `B` является для меня проблемой, и для этой проблемы я использую обозначение `A`.

### 2.3.
~~~
Def_P(A):
```
B
```
~~~
имеет то же значение, что и `Def_P(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 3. `Def_C`
### 3.1.
```
Def_C(P, A, B)
```
будет обозначать `Def(A, B)` в контексте пункта `P`.
Вне пункта `P` это правило не применяется.
Если до пункта `P` обозначение `A` имело другой смысл, то после пункта `P` обозначение `A` снова будет иметь этот смысл.
По сути, `Def_C` объявляет локальную переменную `A` с областью действия `P`.
В отличие от него, `Def` объявляет глобальную переменную `A` (значение которой действует для всех пунктов, кроме `P`).

### 3.2.
~~~
Def_C(P, A):
```
B
```
~~~
имеет то же значение, что и `Def_C(P, A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 3.3.
```
Def_C([P1, P2, …, Pn], A, B)
```
имеет значение, аналогичное `Def_C(P, A, B)`, только в этом случае обозначение `A` имеет значение `B` в контексте не одного пункта `P`, а всех пунктов [`P1`, `P2`, …, `Pn`], перечисленных в квадратных скобках.

### 3.4.
```
Def_C([P1-Pn], A, B)
```
имеет значение, аналогичное `Def_C([P1, P2, …, Pn], A, B)`: в этом случае обозначение `A` имеет значение `B` в контексте множества всех пунктов между `P1` и `Pn`, включая сами эти пункты.

### 3.5.
~~~
Def_C([P1, P2, …, Pn], A):
```
B
```
~~~
имеет то же значение, что и `Def_C([P1, P2, …, Pn], A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 3.6.
~~~
Def_C([P1-Pn], A):
```
B
```
~~~
имеет то же значение, что и `Def_C([P1-Pn], A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 4. `Def_F`
### 4.1.
Def_C(4-5, `F`):
```
Факт: некое событие, которое случилось в описываем мной случае.
```

### 4.2.
```
Def_F(B)
```
будет обозначать, что `B` — это `F`.

### 4.3.
~~~
Def_F:
```
B
```
~~~
имеет то же значение, что и `Def_F(B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 4.4.
```
Def_F(A, B)
```
будет обозначать, что `B` — это `F`, и для него я использую обозначение `A`.

### 4.5.
~~~
Def_F(A):
```
B
```
~~~
имеет то же значение, что и `Def_F(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 5. `Def_Ph`
### 5.1.
Def_C(5, `Ph`):
```
Феномен: `F`, который вызывает у меня удивление.
```

### 5.2.
```
Def_Ph(B)
```
будет обозначать, что `B` — это `Ph`.

### 5.3.
~~~
Def_Ph:
```
B
```
~~~
имеет то же значение, что и `Def_Ph(B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 5.4.
```
Def_Ph(A, B)
```
будет обозначать, что `B` — это `Ph`, и для него я использую обозначение `A`.

### 5.5.
~~~
Def_Ph(A):
```
B
```
~~~
имеет то же значение, что и `Def_Ph(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 6. `Def_H`
### 6.1.
Def_C(6, `H`):
```
Гипотеза: некое предположение, требующее проверки.
```

### 6.2.
```
Def_H(B)
```
будет обозначать, что `B` — это `H`.

### 6.3.
~~~
Def_H:
```
B
```
~~~
имеет то же значение, что и `Def_H(B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 6.4.
```
Def_H(A, B)
```
будет обозначать, что `B` — это `H`, и для него я использую обозначение `A`.

### 6.5.
~~~
Def_H(A):
```
B
```
~~~
имеет то же значение, что и `Def_H(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 7. `Def_Set`
```
Def_Set(S, I)
```
будет обозначать, что `S` — множество всех возможных `I`.

## 8. `Def_I`
```
Def_I(I, S)
```
будет обозначать, что `I` — элемент множества `S`.

## 9. `Use`
```
Use(A)
```
будет обозначать, что в описываемой мной ситуации я использую `A`.

## 10.
Потенциальный клиент опубликовал на Upwork следующий проект:
### 10.1. Title
Headless SQL Assistance

### 10.2. Description
```text
We are implementing a backup solution into a new enviorment. 
The standard backup solution is causing a problem with the SQL vms and their always on configuration so we need to deploy sql aware agents, however, the sql servers are headless so we need some assistance with the navigation via cmd prompt and powershell.
```

### 10.3. Tags
SQL
Microsoft Windows PowerShell
Database Administration
Windows Server
Backup
Data Backup

## 11. Информация о клиенте
### 11.1. Местоположение
United States
Santa Maria

## 11.2. Характеристики компании
### 11.2.1. Сектор экономики
неизвестно
### 11.2.2. Количество сотрудников
1,000+

## 11.3. Характеристики учётной записи на Upwork
### 11.3.1. Member since
Nov 27, 2018
#### 11.3.2. Hire rate (%)
34%
#### 11.3.3. Количество опубликованных проектов (jobs posted)
3
#### 11.3.4. Total spent
$100
#### 11.3.5. Количество оплаченных часов в почасовых проектах
0 

## 12.
Def(`C`):
```
клиент пункта 10
```

## 13.
Def(`P`):
```
проект пункта 10
```

## 14.
Def(`Ps`):
```
множество подобных `P` проектов 
```

## 15.
Def(`B1`):
```
«The standard backup solution», который `C` упоминает в следующей фразе пункта 10.2: 
~~~
The standard backup solution is causing a problem with the SQL vms and their always on configuration
~~~
```

## 16.
### 16.1.
Я тебя спросил:
~~~
Что `C` имеет в виду под `B1`?
~~~

### 16.2.
Ты ответил:
~~~
На основе предоставленной информации, вот наиболее вероятная интерпретация того, что клиент (`C`) подразумевает под `B1`.
B1 — это система резервного копирования, работающая на уровне гипервизора (например, VMware vSphere, Microsoft Hyper-V), которая создает снимки (snapshots) виртуальных машин в целом. 
Ключевая характеристика этой системы в данном контексте — она не является «application-aware» (не осведомлена о приложении) или не настроена должным образом для взаимодействия с SQL Server. 
Она копирует файлы виртуальной машины, но «не знает», что внутри работает СУБД, и не координирует свои действия с ней.

### Обоснование гипотезы `H1`

Эта гипотеза основывается на двух ключевых элементах из описания проекта (`P`):

1.  **Описание проблемы:** Проблема возникает именно у «SQL vms» с конфигурацией «always on». Это классический сценарий, где простое копирование файлов ВМ приводит к сбоям. Резервное копирование без координации с SQL Server может:

      * Создать несогласованную (crash-consistent) резервную копию, восстановление из которой может привести к потере данных.
      * Нарушить цепочку журналов транзакций (transaction log chain), что критически важно для работы Always On Availability Groups.
      * Предотвратить усечение (truncation) журнала транзакций, что со временем приводит к переполнению диска и остановке сервера.

2.  **Предлагаемое решение:** Клиент сам указывает, что решение — это «deploy sql aware agents» (развернуть агенты, осведомленные о SQL). 
Это прямое указание на то, чего не хватает `B1`. 
«SQL aware agent» — это компонент, который устанавливается внутри гостевой ОС и перед созданием снимка ВМ взаимодействует со службой `SQL Server VSS Writer`, чтобы гарантировать целостность и согласованность данных на уровне приложения.

### Возможные конкретные реализации `B1`
**Стороннее ПО для резервного копирования ВМ, работающее в режиме по умолчанию или с неверной конфигурацией.** 
Например, Veeam Backup & Replication, Acronis Cyber Protect, Commvault или другие. 
Эти продукты *умеют* делать application-aware бэкапы, но для этого их нужно специально настроить: активировать опцию «application-aware processing» и предоставить учетные данные для доступа внутрь гостевой ОС. 
Вероятно, клиент использует такое ПО, но эта опция либо отключена, либо настроена неверно.

**Встроенные средства резервного копирования гипервизора.**
Например, стандартные средства создания чекпоинтов в Hyper-V или снапшотов в VMware, которые затем копируются какой-то базовой системой. 
Сами по себе эти механизмы не взаимодействуют с приложениями внутри ВМ.

**Резервное копирование на уровне системы хранения данных (СХД).**
Некоторые СХД (SAN/NAS) поддерживают создание мгновенных снимков LUN'ов или томов. 
Это очень быстрый способ резервного копирования, но он, как правило, полностью «слеп» к тому, что происходит внутри виртуальных машин, и является классическим примером non-application-aware бэкапа.

**Вывод:** `B1` — это не конкретное название программы, а **класс систем резервного копирования**, которые по своей природе или из-за текущей конфигурации не способны корректно обрабатывать транзакционные приложения, такие как SQL Server в конфигурации Always On. 
Клиенту требуется специалист, который сможет настроить решение этой проблемы (`sql aware agents`) в «headless» среде, то есть через командную строку и PowerShell.
~~~

## 17.
Def(`T`):
```
Основная задача `C`, о которой он говорит в пункте 10.2:
~~~
We are implementing a backup solution into a new enviorment
~~~
```

## 18.
Def(`As`):
```
«sql aware agents», которых `C` упоминает в своей фразе пункта 10.2:
~~~
we need to deploy sql aware agents
~~~
```

## 19.
Def(`Ss`):
```
Альтернативы `As` для решения `T`.
```

## 20.
Def(`D`, «мой ответ `C`»).

## 21.
Содержание `D`:
```markdown
1) Наиболее сильным решением вашей задачи является не использование SQL-aware agents, а разработка индивидуального скрипта резервного копирования для конкретно вашей базы данных.
Лучше всего это сделать посредством `dbatools`: https://github.com/dataplat/dbatools
Так как ваша организация — большая (1,000+ people), то наверняка и базы данных имеют много индивидуальных особенностей, которые универсальные SQL-aware agents (например, от Veeam) просто не будут учитывать: такие агенты будут выполнять резервное копирование универсальным способом, который наверняка не будет самым оптимальным в вашей конкретной ситуации.
2) Однако, конечно, и посредством SQL-aware agents вашу задачу тоже можно решить.
Специфика решения будет зависеть от используемой вами системы резервного копирования: Veeam, Acronis, Commvault и т.п.
```

## 22.
Def(`D2`, «начальная часть `D`, переведённая с Russian на English»).

## 23.
Содержание `D2`:
```markdown
```

## 24.
Def(`F`, «фрагмент `D`»).

## 25.
Содержание `F`:
```text
2) Однако, конечно, и посредством SQL-aware agents вашу задачу тоже можно решить.
Специфика решения будет зависеть от используемой вами системы резервного копирования: Veeam, Acronis, Commvault и т.п.
```

## 26.
Переведи `F` на English, с учётом:
- контекста `D`
- `D2`: уже переведённой части `D`
- всех предыдущих пунктов моего запроса

## 27. Правила перевода
### 27.1.
Переводи именно в той стилистике, как написано на Russian.
Не делай перевод более вежливым, чем оригинал.

### 27.2.
Те предложения, которые сейчас полностью на English — оставь без изменения.

### 27.3.
#### 27.3.1.
Не используй Markdown: только plain text.
#### 27.3.2.
При этом можно и нужно использовать то форматирование, которое уже есть в оригинале: его не убирай.
#### 27.3.3.
Не форматируй веб-ссылки посредством Markdown, если они не отформатированы так в оригинале. 
Например, не пиши так:
```
[https://www.eca.web.tr/eca-nita-esnek-uclu-eviye-bataryasi-beyaz-102118110-308](https://www.eca.web.tr/eca-nita-esnek-uclu-eviye-bataryasi-beyaz-102118110-308)
```
если в оригинале скобок `[]()` нет.

### 27.4.
Форматируй перевод в точности как оригинал. 
В частности:
*) каждый абзац должен содержать ровно одно предложение
*) между абзацами не должно оставаться пустых строк.
*) кавычки используй те же, что и в оригинале: «» и ``.

### 27.5.
Не используй сокращения типа «don't». Все подобные фразы пиши полностью: «do not».

### 27.6.
Не используй жаргон.
Вместо этого используй официальные термины.
#### 27.6.1.
В частности, фразы в кавычках используй только в том случае, когда они являются точными цитатами.
Не используй фразы в кавычках для применения жаргонных фраз.
Например, следующий фрагмент текста недопустим, потому что там используется жаргонная фраза «пролетел»: 
```
Например, код, который пушит данные о покупке, подключён асинхронно и загружается с небольшой задержкой, а триггер уже «пролетел».
```

### 27.7.
При обсуждении программного обеспечения используй точные официальные термины на английском языке: именно в том виде, как они указаны в официальной англоязычной документации к этому программному обеспечению.

### 27.8.
Не используй «you need» и другие подобные обращённые к клиенту фразы, перекладывающие действия на него.
Помни: я пишу клиенту или потенциальному клиенту.
Делать в любом случае буду я, а не клиент.
Вместо «you need» используй 2 альтернативы:
#### 27.8.1.
Нейтральные фразы типа «it is necessary».
#### 27.8.2.
Глаголы в неопределённой форме.
Например, во фрагменте ниже использованы подобные глаголы «set up», «create»:
```
1.2) Set up the transfer of login events from WordPress to Power BI using Fabric / OneLake.
1.2.1) Set up a «Data Pipeline» from the WordPress database table that stores login events (see point 1.1) to Fabric / OneLake.
1.2.2) Set up a connection from Power BI to Fabric / OneLake to pass login events.
1.3) Create the data model in Power BI.
```
Обрати внимание, в этом фрагменте не говорится, кто именно будет выполнять описанные действия: ответственность не перекладывается на клиента, в отличие от «you need».

### 27.9.
Никогда не переводи понятие «сайт» / «веб-сайт» как «site». 
Вместо этого используй форму «website»: это является более профессиональным.

### 27.10.
Никогда не переводи понятие «пункт нумерованного списка» как «item».
Всегда переводи это как «point».