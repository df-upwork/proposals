# 1.
## 1.1.
`Aᨀ` ≔ (мой ответ `ꆜ`)

## 1.2.
Содержание `Aᨀ`:
~~~markdown
Задача моделирования ragged hierarchy в Alteryx One Platform решается так:
1) Подготовка данных (Основной Workflow)
Перед началом итеративной обработки необходимо консолидировать данные из всех исходных таблиц в единую структуру.
1.1) Импортировать данные.
Использовать инструмент «Input Data» для загрузки всех таблиц Excel, описывающих иерархию.
1.2) Консолидировать и нормализовать структуру.
Объединить данные из разных таблиц в единый поток данных со структурой списка смежности (Adjacency List), то есть в формате Parent-Child.
Этот этап может потребовать сложной логики для соединения таблиц, представляющих разные уровни или суб-иерархии (ragged hierarchy).
Если для связи исходных таблиц требуется логика, аналогичная SQL Conditional Outer Join (как указано в описании проекта), где условия включены в предикат `ON` (e.g., `... ON L.Key = R.Key AND [Condition]`), необходимо реализовать её на этом этапе, используя надежный метод, описанный в пункте 2.2.
Этот метод требует комбинации нескольких инструментов (e.g., «Record ID», «Join», «Filter», «Union») для точной репликации логики SQL и обеспечения корректного количества строк.
Результирующий набор данных (далее `Hierarchy_Data`) должен содержать как минимум поля идентификатора родителя (например, `ParentID`), идентификатора потомка (например, `ChildID`), а также все поля, необходимые для условной логики соединения (далее `ConditionFields`).
Единая структура Parent-Child необходима для универсальной реализации итеративной логики обхода иерархии.
1.3) Определить начальные узлы.
Определить узлы, с которых начнется обход иерархии (например, корневые узлы, где `ParentID` равен `Null`). Использовать инструмент «Filter».
1.4. Подготовить данные для итерации.
Для реализации обхода иерархии (например, для её развертывания в плоский список отношений Предок-Потомок) необходимо добавить служебные поля к начальным узлам. 
Использовать инструмент «Formula» для добавления полей:
- `AncestorID`: Идентификатор предка (изначально равен идентификатору самого узла).
- `CurrentID`: Идентификатор текущего узла (изначально равен идентификатору самого узла).
- `Level`: Уровень иерархии (изначально 0 или 1).
- `PathHistory`: Путь от корня иерархии до текущего узла для обнаружения циклических ссылок (изначально строка, содержащая идентификатор узла с разделителями, e.g., формула `'|' + ToString([CurrentID]) + '|'`).
Этот набор данных (далее `Initial_Nodes`) инициирует процесс.
2) Реализация Conditional Join в Alteryx
Инструмент «Join» в Alteryx поддерживает только соединения на основе равенства (equi-joins).
Поэтому для репликации условной логики необходимо использовать комбинацию инструментов после «Join».
2.1) Реализация Conditional Inner Join.
Если требуется включить в результат только те записи, для которых совпали ключи и выполнено условие:
2.1.1) Использовать инструмент «Join» для соединения по ключам.
2.1.2) Подключить инструмент «Filter» к выходу «J» (Joined) инструмента «Join».
2.1.3) Сконфигурировать «Filter» для проверки дополнительных условий (`ConditionFields`).
2.1.4) Выход «T» (True) инструмента «Filter» содержит результат Conditional Inner Join.
2.2) Реализация Conditional Outer Join (например, Left Outer Join).
Если требуется реплицировать логику SQL `LEFT OUTER JOIN`, где дополнительные условия включены в предикат `ON` (e.g., `... ON L.Key = R.Key AND [Condition]`), необходимо использовать подход, который определяет сам факт успешного соединения на основе всех условий.
Обоснование необходимости этого метода (паттерн «Double Join») заключается в различии между условиями, указанными в предикате `ON` и предикате `WHERE` в SQL.
При `LEFT OUTER JOIN` условия в предикате `ON` определяют, происходит ли соединение, но не приводят к фильтрации записей из левой таблицы, если условие ложно (поля из правой таблицы заполняются `Null`).
Условия в предикате `WHERE` применяются после соединения и фильтруют результирующий набор данных.
Стандартный подход в Alteryx (объединение выходов «L» и «J» инструмента «Join» через «Union») с последующим применением инструмента «Filter» эквивалентен логике предиката `WHERE`.
Этот подход некорректно обрабатывает условное соединение по предикату `ON`, так как может отфильтровать записи левой таблицы, которые должны быть сохранены.
Паттерн «Double Join» точно реплицирует логику предиката `ON`, что критически важно для сохранения целостности данных, особенно при отношениях N-to-M (Many-to-Many).
2.2.1) Обеспечить уникальность записей левой таблицы.
Для однозначной идентификации записей необходимо убедиться, что левый поток данных имеет уникальный идентификатор.
Если его нет, использовать инструмент «Record ID» для создания нового поля (e.g., `L_ID`).
2.2.2) Выполнить Conditional Inner Join.
Реализовать логику, описанную в пункте 2.1, используя подготовленный левый поток (шаг 2.2.1) и правый поток.
Результат (выход «T» инструмента «Filter», далее `Joined_Conditional`) содержит успешно соединенные записи, включая уникальный идентификатор (`L_ID`).
2.2.3) Идентифицировать истинно несоединенные записи (Left Unjoined).
Необходимо найти записи из левого потока, для которых не было найдено ни одного соответствия полному условию соединения.
2.2.3.1) Добавить второй инструмент «Join».
Соединить подготовленный левый поток (шаг 2.2.1, вход «L») и `Joined_Conditional` (шаг 2.2.2, вход «R»).
2.2.3.2) Сконфигурировать соединение по уникальному идентификатору (e.g., `L_ID`).
2.2.3.3) Выход «L» (Left Unjoined) этого инструмента содержит искомые несоединенные записи (далее `Unjoined_L`).
2.2.4) Финальное объединение.
Использовать инструмент «Union» для объединения `Joined_Conditional` (шаг 2.2.2) и `Unjoined_L` (шаг 2.2.3.3).
Инструмент «Union» автоматически согласует схемы данных, заполняя поля из правой таблицы значениями Null для потока `Unjoined_L` (при соответствующей конфигурации, e.g., «Auto Configure by Name»).
2.2.5) Завершение.
При необходимости использовать инструмент «Select» для удаления служебного уникального идентификатора (e.g., `L_ID`) и упорядочивания полей.
3) Создание Iterative Macro
Необходимо создать отдельный Workflow для реализации рекурсивной логики. 
В большинстве случаев для обхода иерархии в рекурсивном шаге используется логика Inner Join (нахождение существующих связей).
3.1) Установить тип Workflow.
В новом Workflow открыть панель «Workflow Configuration». 
На вкладке «Workflow» в разделе «Type» выбрать «Macro», затем «Iterative Macro».
«Iterative Macro» выполняет процесс циклически, передавая результаты одной итерации на вход следующей, что позволяет обрабатывать данные рекурсивно или до выполнения определенного условия. 
3.2) Определить входы макроса.
Добавить два инструмента «Macro Input» из категории «Interface».
3.2.1) Итерационный вход (например, `Input_I`).
Принимает данные для текущей итерации. 
Схема должна соответствовать `Initial_Nodes` (поля `AncestorID`, `CurrentID`, `Level`).
3.2.2) Фиксированный вход (например, `Input_H`).
Принимает полный набор данных иерархии (`Hierarchy_Data`).
3.3) Реализовать логику итерации и условное соединение.
Необходимо найти следующий уровень иерархии.
Для рекурсивного обхода иерархии применяется логика Conditional Inner Join (см. пункт 2.1).
Цель итеративного процесса — обнаружение существующих связей (потомков), удовлетворяющих заданным условиям, для продолжения обхода по этим ветвям.
Логика Conditional Outer Join (упомянутая в описании проблемы) применяется при необходимости сохранения записей, для которых условие не выполнено (например, на этапе консолидации данных в пункте 1.2), но не подходит для механизма рекурсивного обхода внутри «Iterative Macro».
Использование Outer Join приведет к невозможности завершения макроса, так как поток данных, передаваемый на итерационный выход (`Output_I`), никогда не станет пустым (стандартное условие остановки не будет достигнуто).
3.3.1) Добавить инструмент «Join». Соединить `Input_I` (вход «L») и `Input_H` (вход «R»).
3.3.2) Сконфигурировать соединение: `L.CurrentID` = `R.ParentID`.
3.3.3) Добавить инструмент «Filter», подключенный к выходу «J».
3.3.4) Сконфигурировать «Filter» на основе `ConditionFields` из `Input_H` (и, возможно, данных из `Input_I`).
Выход «T» (True) содержит потенциальных кандидатов для следующей итерации (далее `Candidates`).
3.3.5) Реализовать механизм обнаружения циклических ссылок.
Для предотвращения бесконечных циклов необходимо проверить, не был ли новый узел (`ChildID` из `Input_H`) уже посещен в текущей ветви иерархии.
Добавить второй инструмент «Filter», подключенный к потоку `Candidates`.
3.3.6) Сконфигурировать проверку цикла.
Использовать функцию для поиска идентификатора потомка (`R.ChildID`) внутри поля `PathHistory` (из `Input_I`).
E.g., формула `Contains([L.PathHistory], "|" + ToString([R.ChildID]) + "|")`.
Использование разделителей (как определено в пункте 1.4) обеспечивает надежность проверки, предотвращая ложные срабатывания на частичных совпадениях идентификаторов (e.g., ID 12 и ID 123).
3.3.7) Обработать результаты проверки.
Выход «F» (False) содержит валидные соединения без циклов (далее `Valid_Next_Level`).
Выход «T» (True) содержит обнаруженные циклические ссылки (далее `Cyclic_Records`).
3.4) Подготовить данные для следующей итерации.
Поток `Valid_Next_Level` (шаг 3.3.7) содержит успешные соединения. Необходимо обновить данные для следующего шага.
3.4.1) Добавить инструмент «Formula», подключенный к потоку `Valid_Next_Level`.
3.4.2) Обновить поля:
- `AncestorID`: оставить значение из `Input_I` (переносится через итерации).
- `CurrentID`: установить значение `ChildID` из `Input_H` (новый текущий узел).
- `Level`: увеличить значение на 1 (использовать формулу `[Level] + 1`).
- `PathHistory`: добавить новый узел (`CurrentID`) к существующему пути (использовать формулу `[PathHistory] + ToString([CurrentID]) + "|"`).
Системную переменную `[Engine.IterationNumber]` (которая начинается с 0) также можно использовать для расчета уровня.
Однако это требует учета начального уровня, заданного в пункте 1.4 (e.g., формула `[Начальный_Уровень] + [Engine.IterationNumber] + 1`).
Явная передача и инкрементация поля `Level` обеспечивает большую гибкость, если разные ветви иерархии начинаются с разных уровней.
3.4.3) Использовать инструмент «Select» для обеспечения соответствия схемы данных схеме `Input_I`.
Требования к строгости соответствия зависят от выбранного режима «Output Mode» в конфигурации макроса (см. пункт 4.3).
3.5) Определить выходы макроса.
Добавить два инструмента «Macro Output».
3.5.1) Выход результата (например, `Output_R`).
Подключить выход инструмента «Select» (шаг 3.4.3).
На этот выход поступают данные (связи Предок-Потомок), сгенерированные только в рамках текущей итерации (дельта).
Alteryx Engine автоматически выполняет операцию «Union» для накопления результатов всех итераций в финальном выходном потоке макроса.
3.5.2) Итерационный выход (например, `Output_I`).
Также подключить выход инструмента «Select» (шаг 3.4.3). 
Эти данные передаются обратно на `Input_I`. 
Макрос остановится, когда этот выход будет пуст.
3.5.3) Выход циклических данных (например, `Output_C`).
Подключить поток `Cyclic_Records` (шаг 3.3.7).
Этот выход позволяет изолировать и проанализировать записи, формирующие циклические ссылки в иерархии, не включая их в основной результат итеративного процесса.
4) Конфигурация параметров макроса
4.1) Открыть Interface Designer.
Перейти в меню «View» → «Interface Designer».
4.2) Настроить свойства итерации.
Перейти в раздел «Properties» (иконка гаечного ключа или шестеренки).
4.2.1) В поле «Iteration Input» выбрать `Input_I`.
4.2.2) В поле «Iteration Output» выбрать `Output_I`.
4.2.3) В поле «Maximum Number of Iterations» установить достаточно большое значение (например, 100).
Это значение служит механизмом защиты (fail-safe) для предотвращения непредвиденного бесконечного выполнения Workflow, хотя основная логика обнаружения циклических ссылок реализована внутри макроса (шаг 3.3.5).
Обоснование: Эти настройки определяют, как Alteryx Engine управляет потоком данных между итерациями.
4.3) Настроить режим вывода.
Перейти в раздел «Properties» в «Interface Designer».
В поле «Output Mode» выбрать режим объединения результатов итераций.
Рекомендуется использовать «Auto Configure by Name (Wait until all Iterations run)».
При использовании этого режима требуется совпадение имен и типов данных полей; строгий порядок полей не обязателен.
При использовании режима «Auto Configure by Position» требуется точное совпадение типов и порядка полей.
4.4) Сохранить макрос (например, как файл `ProcessHierarchy.yxmc`).
5) Выполнение (Основной Workflow)
5.1) Вставить макрос.
В основном Workflow кликнуть правой кнопкой мыши на холсте → «Insert» → «Macro...» и выбрать файл `ProcessHierarchy.yxmc`.
5.2) Подключить данные.
5.2.1) Соединить `Hierarchy_Data` (шаг 1.2) с входом `Input_H` макроса.
5.2.2) Соединить `Initial_Nodes` (шаг 1.4) с входом `Input_I` макроса.
5.3) Обработать результаты.
Выход `Output_R` макроса содержит развернутую иерархию (все связи Предок-Потомок, начиная с уровня 1).
Описанная логика «Iterative Macro» не включает сами начальные узлы (уровень 0) в этот выходной поток.
Для получения полного набора данных иерархии необходимо использовать инструмент «Union», чтобы объединить начальные узлы (`Initial_Nodes`) с результатом работы макроса (`Output_R`).
~~~

# 2. `᛭T`
Проанализируй `Aᨀ`:
1) Есть ли там логические ошибки?
2) Есть ли там фактические ошибки?

# 3. Требования к твоему ответу
## 3.1.
Отвечай на русском языке.
## 3.2.
Мой вопрос не пересказывай.
## 3.3.
Уже сформулированную мной информацию не пересказывай.
## 3.4.
Писать свою версию `Aᨀ` не нужно: просто укажи свои замечания по пунктам.
## 3.5.
До и после списка замечаний ничего не пиши.
## 3.6.
Нумерация замечаний должна быть сквозной.

# 4. Источники информации
## 4.1.
Используй авторитетные источники информации на английском языке, относящиеся к предметной области `P⁎` и `P†`.

## 4.2.
В первую очередь используй официальные источники: https://alteryx.com