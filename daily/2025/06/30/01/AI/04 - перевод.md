## 1. `Def`
### 1.1.
```
Def(A, B)
```
будет обозначать, что для понятия `B` я использую обозначение `A`.

### 1.2.
~~~
Def(A):
```
B
```
~~~
имеет то же значение, что и `Def(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 2. `Def_P`
### 2.1.
```
Def_P(A)
```
будет обозначать, что `A` является для меня проблемой.

### 2.2.
```
Def_P(A, B)
```
будет обозначать, что `B` является для меня проблемой, и для этой проблемы я использую обозначение `A`.

### 2.3.
~~~
Def_P(A):
```
B
```
~~~
имеет то же значение, что и `Def_P(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 3. `Def_C`
### 3.1.
```
Def_C(P, A, B)
```
будет обозначать `Def(A, B)` в контексте пункта `P`.
Вне пункта `P` это правило не применяется.
Если до пункта `P` обозначение `A` имело другой смысл, то после пункта `P` обозначение `A` снова будет иметь этот смысл.
По сути, `Def_C` объявляет локальную переменную `A` с областью действия `P`.
В отличие от него, `Def` объявляет глобальную переменную `A` (значение которой действует для всех пунктов, кроме `P`).

### 3.2.
~~~
Def_C(P, A):
```
B
```
~~~
имеет то же значение, что и `Def_C(P, A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 3.3.
```
Def_C([P1, P2, …, Pn], A, B)
```
имеет значение, аналогичное `Def_C(P, A, B)`, только в этом случае обозначение `A` имеет значение `B` в контексте не одного пункта `P`, а всех пунктов [`P1`, `P2`, …, `Pn`], перечисленных в квадратных скобках.

### 3.4.
```
Def_C([P1-Pn], A, B)
```
имеет значение, аналогичное `Def_C([P1, P2, …, Pn], A, B)`: в этом случае обозначение `A` имеет значение `B` в контексте множества всех пунктов между `P1` и `Pn`, включая сами эти пункты.

### 3.5.
~~~
Def_C([P1, P2, …, Pn], A):
```
B
```
~~~
имеет то же значение, что и `Def_C([P1, P2, …, Pn], A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 3.6.
~~~
Def_C([P1-Pn], A):
```
B
```
~~~
имеет то же значение, что и `Def_C([P1-Pn], A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 4. `Def_F`
### 4.1.
Def_C(4-5, `F`):
```
Факт: некое событие, которое случилось в описываем мной случае.
```

### 4.2.
```
Def_F(B)
```
будет обозначать, что `B` — это `F`.

### 4.3.
~~~
Def_F:
```
B
```
~~~
имеет то же значение, что и `Def_F(B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 4.4.
```
Def_F(A, B)
```
будет обозначать, что `B` — это `F`, и для него я использую обозначение `A`.

### 4.5.
~~~
Def_F(A):
```
B
```
~~~
имеет то же значение, что и `Def_F(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 5. `Def_Ph`
### 5.1.
Def_C(5, `Ph`):
```
Феномен: `F`, который вызывает у меня удивление.
```

### 5.2.
```
Def_Ph(B)
```
будет обозначать, что `B` — это `Ph`.

### 5.3.
~~~
Def_Ph:
```
B
```
~~~
имеет то же значение, что и `Def_Ph(B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 5.4.
```
Def_Ph(A, B)
```
будет обозначать, что `B` — это `Ph`, и для него я использую обозначение `A`.

### 5.5.
~~~
Def_Ph(A):
```
B
```
~~~
имеет то же значение, что и `Def_Ph(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 6. `Def_H`
### 6.1.
Def_C(6, `H`):
```
Гипотеза: некое предположение, требующее проверки.
```

### 6.2.
```
Def_H(B)
```
будет обозначать, что `B` — это `H`.

### 6.3.
~~~
Def_H:
```
B
```
~~~
имеет то же значение, что и `Def_H(B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 6.4.
```
Def_H(A, B)
```
будет обозначать, что `B` — это `H`, и для него я использую обозначение `A`.

### 6.5.
~~~
Def_H(A):
```
B
```
~~~
имеет то же значение, что и `Def_H(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 7. `Def_Set`
```
Def_Set(S, I)
```
будет обозначать, что `S` — множество всех возможных `I`.

## 8. `Def_I`
```
Def_I(I, S)
```
будет обозначать, что `I` — элемент множества `S`.

## 9. `Use`
```
Use(A)
```
будет обозначать, что в описываемой мной ситуации я использую `A`.

## 10.
Потенциальный клиент опубликовал на Upwork следующий проект:
### 10.1. Title
Azure IoT Backend Engineer Needed to Fix Production API and Portal Errors (Short-Term)

### 10.2. Description
```markdown
We operate a production IoT platform that connects field devices to Azure IoT Hub, Azure SQL, and a custom web portal for client-facing access. 
Currently, critical backend endpoints are failing and preventing organizations from managing their users and devices.
We need a senior Azure/.NET backend developer to diagnose and fix:
- `/api/user/roles` endpoint returning HTTP 500
- Broken user/device assignment for some organizations
- Missing or corrupted role/org mapping data
- Role seeding or creation logic failures
- Diagnostic logging issues (errors are silent or unreported)

Tech stack:
- Azure App Service, Azure SQL Database
- Azure IoT Hub (device provisioning, registry, device twin)
- .NET Core (RESTful API)
- React frontend (optional context only)
- Application Insights for logging

We estimate the fix to take 2–4 weeks and would like to start immediately. 
Strong experience with production Azure systems, SQL troubleshooting, and REST API diagnostics is essential.
```

### 10.3. Tags
C#
SQL
Microsoft Azure
Azure IoT HuB
Microsoft Azure SQL Database

### 10.4. Questions
#### 10.4.1. «Have you diagnosed and fixed 500 errors in an Azure App Service before? If so, describe the issue and how you resolved it»
#### 10.4.2. «Have you worked with Azure IoT Hub and device provisioning/telemetry? Briefly explain your role in that project.»

## 11. Информация о клиенте
### 11.1. Местоположение
Canada
Toronto

## 11.2. Характеристики компании
### 11.2.1. Сектор экономики
неизвестно
### 11.2.2. Количество сотрудников
10-99 people

## 11.3. Характеристики учётной записи на Upwork
### 11.3.1. Member since
Sep 25, 2020
#### 11.3.2. Hire rate (%)
50%
#### 11.3.3. Количество опубликованных проектов (jobs posted)
6
#### 11.3.4. Total spent
$310
#### 11.3.5. Количество оплаченных часов в почасовых проектах
0

## 12.
Def(`C`):
```
клиент пункта 10
```

## 13.
Def(`P`):
```
проект пункта 10
```

## 14.
Def(`Ps`):
```
множество подобных `P` проектов 
```

## 15.
Def(`D`):
```
Описание `P` (пункт 10.2 выше)
```

## 16.
Def_P(`P1`):
```
Одна из проблем, о которой `C` пишет в `D`:
~~~
`/api/user/roles` endpoint returning HTTP 500
~~~
```

## 17.
Def_P(`P2`):
```
Одна из проблем, о которой `C` пишет в `D`:
~~~
Broken user/device assignment for some organizations
~~~
```

## 18.
Def_P(`P3`):
```
Одна из проблем, о которой `C` пишет в `D`:
~~~
Missing or corrupted role/org mapping data
~~~
```

## 19.
Def_P(`P4`):
```
Одна из проблем, о которой `C` пишет в `D`:
~~~
Role seeding or creation logic failures
~~~
```

## 20.
Def_P(`P5`):
```
Одна из проблем, о которой `C` пишет в `D`:
~~~
errors are silent or unreported
~~~
```


## 21.
Def(`P1-D`):
```
диагностика `P1`
```

## 22.
Def(`P1-D-W1`):
```
`P1-D` посредством «App Service logs».
Платформа Azure App Service предоставляет встроенный набор инструментов для логирования, который является первой линией обороны при диагностике ошибок. 
Активация этих механизмов через портал Azure — это фундаментальный шаг, который необходимо выполнить перед началом любого глубокого анализа.
```

## 23.
Def(`P1-D-W2`):
```
`P1-D` посредством «Web Server Logging».
Журналы веб-сервера (IIS) фиксируют метаданные о каждом входящем HTTP-запросе, включая URL-адрес, HTTP-метод, код состояния ответа, время обработки, IP-адрес клиента и User-Agent.
Эти журналы чрезвычайно полезны для выявления общих паттернов сбоев. 
Например, анализ этих логов может показать, что все запросы к определенному эндпоинту или все POST-запросы завершаются с ошибкой 500, в то время как другие запросы обрабатываются корректно. 
Это помогает значительно сузить область поиска проблемы. 
Кроме того, наличие записи о запросе в журнале веб-сервера подтверждает, что запрос успешно прошел через сетевую инфраструктуру Azure и достиг вашего экземпляра App Service.
```

## 24.
Def(`P1-D-W3`):
```
`P1-D` посредством опции «Detailed Error Messages».
Эта опция заставляет IIS возвращать клиенту подробную HTML-страницу с описанием ошибки вместо стандартной страницы "500 - Internal Server Error".
```

## 25.
Def(`P1-D-W4`):
```
`P1-D` посредством «Failed Request Tracing».
Это мощный инструмент диагностики на уровне IIS, который создает подробные XML-файлы трассировки для запросов, завершившихся сбоем. 
Трассировка фиксирует каждый этап обработки запроса различными модулями IIS, показывая, сколько времени занял каждый этап и где именно произошла ошибка.
Этот механизм незаменим для диагностики проблем, связанных с конфигурацией. 
```

## 26.
Def(`P1-D-W5`):
```
`P1-D` посредством «Log Stream».
Функция Log Stream (Поток журналов) предоставляет возможность наблюдать за логами приложения и веб-сервера в режиме реального времени. 
Это незаменимый инструмент для отладки проблем, которые трудно воспроизвести, или для анализа сбоев, происходящих в момент запуска приложения. 
Практическое применение Log Stream заключается в открытии консоли потока и последующем выполнении действий, которые провоцируют ошибку. 
Например, можно перезапустить App Service и наблюдать за журналами инициализации, чтобы отловить сбои на этапе старта.
В потоке отображаются как логи веб-сервера, так и логи приложения, что позволяет получить комплексную картину происходящего.
```

## 27.
Def(`P1-D-W6`):
```
`P1-D` посредством «stdout».
Для приложений ASP.NET Core, развернутых в App Service, журналы стандартного вывода (stdout) являются критически важным, а зачастую и единственным, источником информации при диагностике сбоев на этапе запуска.
Многие фатальные ошибки, такие как HTTP Error 500.30 - ANCM In-Process Start Failure, происходят до того, как стандартные системы логирования, включая ILogger и Application Insights, успевают полностью инициализироваться и начать работу.
Причина этого кроется в архитектуре хостинга. Модуль ASP.NET Core (ANCM) для IIS выступает в роли обратного прокси. 
Он отвечает за запуск рабочего процесса вашего приложения ( dotnet.exe ) и перенаправление трафика к нему. 
Если процесс dotnet.exe падает сразу после запуска из-за необработанного исключения в коде инициализации (например, в Program.cs), ANCM фиксирует этот сбой и возвращает клиенту ошибку 500.31.
В такой ситуации журналы приложения не будут содержать никаких записей, так как само приложение так и не запустилось.
Единственный способ увидеть исходное исключение — это включить перенаправление стандартного вывода (stdout) и стандартного потока ошибок (stderr) процесса dotnet.exe в файл.
```

## 28.
Def(`P1-D-W7`):
```
`P1-D` посредством «Application Insights».
Для диагностики ошибок в коде приложения .NET на Azure это основной и самый мощный инструмент, на порядок более информативный, чем базовые логи App Service. Он позволяет видеть полные стеки исключений, трассировки зависимостей (например, неудачные SQL-запросы), параметры запросов и т. д. 
```

## 29.
Def(`D`, «мой ответ `C`»).

## 30.
Содержание `D`:
~~~markdown
Правильный способ диагностики сбоев с кодом 500 в Azure App Services:
1) В первую очередь надо ясно понимать смысл кода 500: «a generic error message, given when an unexpected condition was encountered and no more specific message is suitable»
https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#500
Поэтому стратегически правильный способ устранения подобных проблем — не строить гипотезы о причинах сбоя, а правильно реализовать систему диагностики сбоя, и эта система диагностики сама в явном виде укажет причину сбоя.
2) В первую очередь надо правильно связать Azure App Service с  Application Insights.
2.1) Надо в разделе «App Service» → «Settings» → «Environment variables» правильно настроить `APPLICATIONINSIGHTS_CONNECTION_STRING`.
2.2) В .NET-приложении должны быть установлены корректные пакеты NuGet для Application Insights SDK (в первую очередь, `Microsoft.ApplicationInsights.AspNetCore`).
2.3) В коде запуска приложения (обычно в файле `Program.cs`) должен содержаться вызов `services.AddApplicationInsightsTelemetry()`.
2.4) Проверить корректность интеграции Azure App Service с Application Insights проще всего посредством «Application Insights» → «Investigate» → «Live Metrics».
2.5) Если Live Metrics не показывает никаких данных для сбойного эндпоинта, это указывает на серьезный сбой при запуске, который мешает инициализации Application Insights SDK или даже не позволяет запросу достичь конвейера ASP.NET Core.
Пример такого сбоя: «500.30 - ANCM In-Process Start Failure». 
В таком случае надо провести диагностику способами пунктов 3-6 ниже. 
3) Надо зайти в раздел «Monitoring» → «App Service logs» и там включить 4 опции: 
3.1) «Application Logging» и «Web server logging».
При этом надо установить для параметра «Level» значение «Verbose».
3.2) «Detailed Error Messages».
Это позволяет сохранить точную HTML-страницу ошибки, которую сгенерировал бы IIS. 
Такая страница часто содержит более конкретные коды ошибок и сообщения, чем общий ответ 500. 
3.3) «Failed Request Tracing».
Это самый мощный инструмент для диагностики проблем в конвейере IIS, который генерирует подробную XML-трассировку активности каждого модуля для неудачного запроса.
4) В разделе «Monitoring» → «Log Stream» можно увидеть логи пункта 2 в реальном времени.
Например, можно вызвать ваш проблемный endpoint `/api/user/roles` и сразу увидеть, что система запишет в логи.
5) Диагностика посредством `stdout`.
5.1) Для захвата вывода `stdout` и `stderr` необходимо модифицировать конфигурацию модуля ANCM. 
Наиболее прямой способ сделать это в среде Azure App Service — использовать консоль Kudu для редактирования файла `web.config`.
Доступа к консоли Kudu: «Development Tools» → «Advanced Tools» → «Go».
Доступ к командной строке из Kudu: «Debug console» → «CMD».
Вся конфигурация, специфичная для модуля ANCM, находится внутри элемента `<aspNetCore>` в файле `web.config`.
Пример настройки `<aspNetCore>`:
```xml
<aspNetCore processPath="dotnet"
	arguments=".\YourApplication.dll"
	stdoutLogEnabled="true"
	stdoutLogFile="\\?\%home%\LogFiles\stdout"
	hostingModel="InProcess">
</aspNetCore>
```
5.2) После перезапуска приложения и воспроизведения ошибки файл журнала должен быть создан в указанной директории.
Содержимое файла журнала `stdout` является ключом к разгадке проблемы. 
Как правило, оно содержит полное сообщение об исключении и стек вызовов, которые указывают на точное место в коде, где произошел сбой. 
6) Самый мощный способ диагностики (когда способы пунктов 2-5 не помогают): «Development Tools» → «Advanced Tools» → «Go» → «Tools» → «Diagnostic dump».
~~~

## 31.
Def(`D2`, «начальная часть `D`, переведённая с Russian на English»).

## 32.
Содержание `D2`:
~~~markdown
The correct way to diagnose 500 errors in Azure App Services:
1) It is necessary to clearly understand the meaning of code 500: «a generic error message, given when an unexpected condition was encountered and no more specific message is suitable»
https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#500
Therefore, the strategically correct approach to resolving such problems is not to build hypotheses about the causes of the failure, but to properly implement a failure diagnostics system, and this diagnostics system will itself explicitly identify the cause of the failure.
2) First of all, it is necessary to correctly connect Azure App Service with Application Insights.
2.1) In the «App Service» → «Settings» → «Environment variables» section, it is necessary to correctly configure `APPLICATIONINSIGHTS_CONNECTION_STRING`.
2.2) The correct NuGet packages for the Application Insights SDK must be installed in the .NET application (primarily, `Microsoft.ApplicationInsights.AspNetCore`).
2.3) In the application startup code (usually in the `Program.cs` file), the `services.AddApplicationInsightsTelemetry()` call must be included.
2.4) The easiest way to verify the correct integration between Azure App Service and Application Insights is via «Application Insights» → «Investigate» → «Live Metrics».
2.5) If Live Metrics does not show any data for the failing endpoint, this indicates a serious startup failure that prevents the initialization of the Application Insights SDK or even prevents the request from reaching the ASP.NET Core pipeline.
An example of such a failure is: «500.30 - ANCM In-Process Start Failure».
In such a case, it is necessary to perform diagnostics using the methods of points 3-6 below.
3) In the «Monitoring» → «App Service logs» section, it is necessary to enable 4 options:
3.1) «Application Logging» and «Web server logging».
At the same time, it is necessary to set the «Level» parameter to «Verbose».
3.2) «Detailed Error Messages».
This makes it possible to save the exact HTML error page that would be generated by IIS.
Such a page often contains more specific error codes and messages than the generic 500 response.
3.3) «Failed Request Tracing».
This is the most powerful tool for diagnosing problems in the IIS pipeline, which generates a detailed XML trace of the activity of each module for a failed request.
4) In the «Monitoring» → «Log Stream» section, it is possible to see the logs from point 2 in real time.
For example, it is possible to call the problematic endpoint `/api/user/roles` and immediately see what the system will write to the logs.
5) Diagnostics via `stdout`.
5.1) To capture the `stdout` and `stderr` output, it is necessary to modify the ANCM module configuration. The most direct way to do this in the Azure App Service environment is to use the Kudu console to edit the `web.config` file.
Access to the Kudu console: «Development Tools» → «Advanced Tools» → «Go».
Access to the command line from Kudu: «Debug console» → «CMD».
The entire configuration specific to the ANCM module is located within the `<aspNetCore>` element in the `web.config` file.
An example of `<aspNetCore>` configuration:

```xml
<aspNetCore processPath="dotnet"
	arguments=".\YourApplication.dll"
	stdoutLogEnabled="true"
	stdoutLogFile="\\?\%home%\LogFiles\stdout"
	hostingModel="InProcess">
</aspNetCore>
```
~~~

## 33.
Def(`F`, «фрагмент `D`»).

## 34.
Содержание `F`:
~~~markdown
6) Самый мощный способ диагностики (когда способы пунктов 2-5 не помогают): «Development Tools» → «Advanced Tools» → «Go» → «Tools» → «Diagnostic dump».
~~~

## 35.
Переведи `F` на English, с учётом:
- контекста `D`
- `D2`: уже переведённой части `D`
- всех предыдущих пунктов моего запроса

## 36. Правила перевода
### 36.1.
Переводи именно в той стилистике, как написано на Russian.
Не делай перевод более вежливым, чем оригинал.

### 36.2.
Те предложения, которые сейчас полностью на English — оставь без изменения.

### 36.3.
#### 36.3.1.
Не используй Markdown: только plain text.
#### 36.3.2.
При этом можно и нужно использовать то форматирование, которое уже есть в оригинале: его не убирай.
#### 36.3.3.
Не форматируй веб-ссылки посредством Markdown, если они не отформатированы так в оригинале. 
Например, не пиши так:
```
[https://www.eca.web.tr/eca-nita-esnek-uclu-eviye-bataryasi-beyaz-102118110-308](https://www.eca.web.tr/eca-nita-esnek-uclu-eviye-bataryasi-beyaz-102118110-308)
```
если в оригинале скобок `[]()` нет.

### 36.4.
Форматируй перевод в точности как оригинал. 
В частности:
*) каждый абзац должен содержать ровно одно предложение
*) между абзацами не должно оставаться пустых строк.
*) кавычки используй те же, что и в оригинале: «» и ``.

### 36.5.
Не используй сокращения типа «don't». Все подобные фразы пиши полностью: «do not».

### 36.6.
Не используй жаргон.
Вместо этого используй официальные термины.
#### 36.6.1.
В частности, фразы в кавычках используй только в том случае, когда они являются точными цитатами.
Не используй фразы в кавычках для применения жаргонных фраз.
Например, следующий фрагмент текста недопустим, потому что там используется жаргонная фраза «пролетел»: 
```
Например, код, который пушит данные о покупке, подключён асинхронно и загружается с небольшой задержкой, а триггер уже «пролетел».
```

### 36.7.
При обсуждении программного обеспечения используй точные официальные термины на английском языке: именно в том виде, как они указаны в официальной англоязычной документации к этому программному обеспечению.

### 36.8.
Не используй «you need» и другие подобные обращённые к клиенту фразы, перекладывающие действия на него.
Помни: я пишу клиенту или потенциальному клиенту.
Делать в любом случае буду я, а не клиент.
Вместо «you need» используй 2 альтернативы:
#### 36.8.1.
Нейтральные фразы типа «it is necessary».
#### 36.8.2.
Глаголы в неопределённой форме.
Например, во фрагменте ниже использованы подобные глаголы «set up», «create»:
```
1.2) Set up the transfer of login events from WordPress to Power BI using Fabric / OneLake.
1.2.1) Set up a «Data Pipeline» from the WordPress database table that stores login events (see point 1.1) to Fabric / OneLake.
1.2.2) Set up a connection from Power BI to Fabric / OneLake to pass login events.
1.3) Create the data model in Power BI.
```
Обрати внимание, в этом фрагменте не говорится, кто именно будет выполнять описанные действия: ответственность не перекладывается на клиента, в отличие от «you need».

### 36.9.
Никогда не переводи понятие «сайт» / «веб-сайт» как «site». 
Вместо этого используй форму «website»: это является более профессиональным.

### 36.10.
Никогда не переводи понятие «пункт нумерованного списка» как «item».
Всегда переводи это как «point».