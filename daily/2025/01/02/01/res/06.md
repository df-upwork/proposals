Ниже краткая шпаргалка по тому, как можно аккуратнее «вырезать» JSON (или несколько JSON) из ответа (response_text) и затем распарсить их. Приведённый вариант поможет избежать «Extra data» ошибок и вытащить JSON даже если текст содержит что-то лишнее до/после или если в тексте встречается несколько возможных JSON-блоков.

---

### 1. Почему текущая реализация часто ломается?

Сейчас `_process_response` использует следующий подход:
1. Если видим ```json, то ищем между ними.
2. Если видим ``` , то тоже ищем между ним.
3. Иначе вырезаем часть после первой `{` или `[`.

Такое упрощённое «вырезание» текста легко ломается, если в тексте:
- несколько кусков JSON,
- встречаются другие служебные символы (запятые, фигурные скобки) до/после,
- лишний текст идёт *после* окончания JSON и т.п.

В результате, даже если JSON в целом корректен, при соединении с «хвостом» получается «Extra data» ошибка (или наоборот JSON оказывается неполным).

---

### 2. Улучшенный подход: парсить все JSON-блоки из текста последовательно

**Идея**:  
1. Вычистить так называемые «code fence» конструкции (```json ... ``` или просто ``` ... ```), сохранив при этом содержимое.  
2. Но если таких фрагментов нет – всё равно попытаться парсить целиком.  
3. Если встретились проблемы или в ответе потенциально может быть несколько JSON-объектов подряд, можно «пробовать» распарсить их каждый по отдельности.

Ниже один из возможных способов сделать это.

```python
import json
import re

def _process_response(response_text: str):
    """
    Парсим один или несколько JSON-блоков из ответа.
    Возвращаем либо список, либо словарь, либо список словарей (если было несколько JSON).
    Если вообще ничего не удалось извлечь, возвращаем пустой список.
    """
    response_text = response_text.strip()
    
    # 1) Находим *все* возможные куски вида ```json ... ``` или ``` ... ```
    # Используем "re.DOTALL", чтобы точки захватывали переводы строк
    code_fence_pattern = r"```(?:json)?(.*?)(?:```)"
    code_fenced_blocks = re.findall(code_fence_pattern, response_text, flags=re.DOTALL | re.IGNORECASE)
    
    # Если мы нашли какие-то блоки в ```, будем пробовать именно их парсить как JSON
    # Если не нашли, значит будем иметь в виду весь response_text
    candidates = code_fenced_blocks if code_fenced_blocks else [response_text]
    
    all_parsed = []
    
    for candidate in candidates:
        candidate = candidate.strip()
        
        # На случай, если кто-то пишет «Here is a JSON: { ... }», отрежем всё, что до первой '{' или '['
        brace_pos = candidate.find('{')
        bracket_pos = candidate.find('[')
        
        # Определим, что идёт раньше: '{' или '['
        if brace_pos == -1 and bracket_pos == -1:
            # нет вообще фигурных/квадратных скобок - парсить нечего
            continue
        
        if brace_pos == -1:  # значит '[' есть, а '{' нет
            start_pos = bracket_pos
        elif bracket_pos == -1:  # значит '{' есть, а '[' нет
            start_pos = brace_pos
        else:
            # берем минимальный индекс (раньше встречается)
            start_pos = min(brace_pos, bracket_pos)
        
        cleaned = candidate[start_pos:].strip()
        
        # Теперь пробуем распарсить cleaned как JSON. Если не вышло – игнорируем и переходим дальше.
        # Но если нужно, можно добавить «fallback»: например, обрезать лишний хвост в стиле "rfind('}')"
        # или rfind(']'), но это уже по вкусу.
        
        try:
            parsed = json.loads(cleaned)
            if parsed:
                # Добавим в общий список
                # Поскольку не знаем, может вернуться dict или list
                all_parsed.append(parsed)
        except json.JSONDecodeError:
            # пробуем fallback: ищем "последнюю закрывающую скобку" и обрезаем всё после неё
            # для объектов: '}'
            # для массивов: ']'
            # Простенькая эвристика - берём последний из символов
            close_brace_index = cleaned.rfind('}')
            close_bracket_index = cleaned.rfind(']')
            last_close = max(close_brace_index, close_bracket_index)
            if last_close != -1:
                fallback_text = cleaned[:last_close+1]
                try:
                    parsed = json.loads(fallback_text)
                    if parsed:
                        all_parsed.append(parsed)
                except json.JSONDecodeError:
                    pass
    
    # Если ничего не получилось, возвращаем пустой список
    if not all_parsed:
        return []
    
    # Если вышел ровно один элемент в списке, вернем его как есть:
    if len(all_parsed) == 1:
        return all_parsed[0]
    
    # Иначе вернём список
    return all_parsed
```

**Чем хорош этот метод:**
1. **Многократный поиск** всех фрагментов внутри ```...``` (и ```json ... ``` тоже) – более гибко, чем брать только *первый* или *последний*.
2. **Fallback** на «последнюю закрывающую скобку», если JSONDecodeError. В ряде случаев LLM может «вывалить» лишний текст после закрытия фигурной/квадратной скобки, и нам остаётся его игнорировать.
3. **Возвращает** либо *список* словарей, либо *один* словарь/список, если вышел всего один JSON.

---

### 3. Возможные дальнейшие улучшения

1. **Логирование** – в случае, если возникла `JSONDecodeError`, стоит логировать *весь* проблемный текст-кандидат.  
2. **Выброс исключения** – если принципиально для вашего кода «получить JSON или упасть», можно вместо `return []` бросать исключение.  
3. **Генерация user-friendly ошибок** – чтобы в логе было ясно, *какая* часть не распарсилась.  
4. **Локальный анализ**, если вам нужно не только сложить результат в список, но и учитывать, что какие-то JSON могут быть «не теми по формату».  

---

Таким образом, с более аккуратным поиском (RegEx + несколько fallback’ов) код не будет ломаться на «Extra data: line 41 column 1 (char 1712)» и подобных ошибках, а также сможет спокойно доставать несколько JSON подряд из ответа.