## 1. `Def`
### 1.1.
```
Def(A, B)
```
будет обозначать, что для понятия `B` я использую обозначение `A`.

### 1.2.
~~~
Def(A):
```
B
```
~~~
имеет то же значение, что и `Def(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 2. `Def_P`
### 2.1.
```
Def_P(A)
```
будет обозначать, что `A` является для меня проблемой.

### 2.2.
```
Def_P(A, B)
```
будет обозначать, что `B` является для меня проблемой, и для этой проблемы я использую обозначение `A`.

### 2.3.
~~~
Def_P(A):
```
B
```
~~~
имеет то же значение, что и `Def_P(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 3. `Def_C`
### 3.1.
```
Def_C(P, A, B)
```
будет обозначать `Def(A, B)` в контексте пункта `P`.
Вне пункта `P` это правило не применяется.
Если до пункта `P` обозначение `A` имело другой смысл, то после пункта `P` обозначение `A` снова будет иметь этот смысл.
По сути, `Def_C` объявляет локальную переменную `A` с областью действия `P`.
В отличие от него, `Def` объявляет глобальную переменную `A` (значение которой действует для всех пунктов, кроме `P`).

### 3.2.
~~~
Def_C(P, A):
```
B
```
~~~
имеет то же значение, что и `Def_C(P, A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 3.3.
```
Def_C([P1, P2, …, Pn], A, B)
```
имеет значение, аналогичное `Def_C(P, A, B)`, только в этом случае обозначение `A` имеет значение `B` в контексте не одного пункта `P`, а всех пунктов [`P1`, `P2`, …, `Pn`], перечисленных в квадратных скобках.

### 3.4.
```
Def_C([P1-Pn], A, B)
```
имеет значение, аналогичное `Def_C([P1, P2, …, Pn], A, B)`: в этом случае обозначение `A` имеет значение `B` в контексте множества всех пунктов между `P1` и `Pn`, включая сами эти пункты.

### 3.5.
~~~
Def_C([P1, P2, …, Pn], A):
```
B
```
~~~
имеет то же значение, что и `Def_C([P1, P2, …, Pn], A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 3.6.
~~~
Def_C([P1-Pn], A):
```
B
```
~~~
имеет то же значение, что и `Def_C([P1-Pn], A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 4. `Def_F`
### 4.1.
Def_C(4-5, `F`):
```
Факт: некое событие, которое случилось в описываем мной случае.
```

### 4.2.
```
Def_F(B)
```
будет обозначать, что `B` — это `F`.

### 4.3.
~~~
Def_F:
```
B
```
~~~
имеет то же значение, что и `Def_F(B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 4.4.
```
Def_F(A, B)
```
будет обозначать, что `B` — это `F`, и для него я использую обозначение `A`.

### 4.5.
~~~
Def_F(A):
```
B
```
~~~
имеет то же значение, что и `Def_F(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 5. `Def_Ph`
### 5.1.
Def_C(5, `Ph`):
```
Феномен: `F`, который вызывает у меня удивление.
```

### 5.2.
```
Def_Ph(B)
```
будет обозначать, что `B` — это `Ph`.

### 5.3.
~~~
Def_Ph:
```
B
```
~~~
имеет то же значение, что и `Def_Ph(B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 5.4.
```
Def_Ph(A, B)
```
будет обозначать, что `B` — это `Ph`, и для него я использую обозначение `A`.

### 5.5.
~~~
Def_Ph(A):
```
B
```
~~~
имеет то же значение, что и `Def_Ph(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 6. `Def_H`
### 6.1.
Def_C(6, `H`):
```
Гипотеза: некое предположение, требующее проверки.
```

### 6.2.
```
Def_H(B)
```
будет обозначать, что `B` — это `H`.

### 6.3.
~~~
Def_H:
```
B
```
~~~
имеет то же значение, что и `Def_H(B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 6.4.
```
Def_H(A, B)
```
будет обозначать, что `B` — это `H`, и для него я использую обозначение `A`.

### 6.5.
~~~
Def_H(A):
```
B
```
~~~
имеет то же значение, что и `Def_H(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 7. `Def_Set`
```
Def_Set(S, I)
```
будет обозначать, что `S` — множество всех возможных `I`.

## 8. `Def_I`
```
Def_I(I, S)
```
будет обозначать, что `I` — элемент множества `S`.

## 9. `Use`
```
Use(A)
```
будет обозначать, что в описываемой мной ситуации я использую `A`.

## 10.
Потенциальный клиент опубликовал на Upwork следующий проект:
### 10.1. Title
Headless SQL Assistance

### 10.2. Description
```text
We are implementing a backup solution into a new enviorment. 
The standard backup solution is causing a problem with the SQL vms and their always on configuration so we need to deploy sql aware agents, however, the sql servers are headless so we need some assistance with the navigation via cmd prompt and powershell.
```

### 10.3. Tags
SQL
Microsoft Windows PowerShell
Database Administration
Windows Server
Backup
Data Backup

## 11. Информация о клиенте
### 11.1. Местоположение
United States
Santa Maria

## 11.2. Характеристики компании
### 11.2.1. Сектор экономики
неизвестно
### 11.2.2. Количество сотрудников
1,000+

## 11.3. Характеристики учётной записи на Upwork
### 11.3.1. Member since
Nov 27, 2018
#### 11.3.2. Hire rate (%)
34%
#### 11.3.3. Количество опубликованных проектов (jobs posted)
3
#### 11.3.4. Total spent
$100
#### 11.3.5. Количество оплаченных часов в почасовых проектах
0 

## 12.
Def(`C`):
```
клиент пункта 10
```

## 13.
Def(`P`):
```
проект пункта 10
```

## 14.
Def(`Ps`):
```
множество подобных `P` проектов 
```

## 15.
Def(`B1`):
```
«The standard backup solution», который `C` упоминает в следующей фразе пункта 10.2: 
~~~
The standard backup solution is causing a problem with the SQL vms and their always on configuration
~~~
```

## 16.
### 16.1.
Я тебя спросил:
~~~
Что `C` имеет в виду под `B1`?
~~~

### 16.2.
Ты ответил:
~~~
На основе предоставленной информации, вот наиболее вероятная интерпретация того, что клиент (`C`) подразумевает под `B1`.
B1 — это система резервного копирования, работающая на уровне гипервизора (например, VMware vSphere, Microsoft Hyper-V), которая создает снимки (snapshots) виртуальных машин в целом. 
Ключевая характеристика этой системы в данном контексте — она не является «application-aware» (не осведомлена о приложении) или не настроена должным образом для взаимодействия с SQL Server. 
Она копирует файлы виртуальной машины, но «не знает», что внутри работает СУБД, и не координирует свои действия с ней.

### Обоснование гипотезы `H1`

Эта гипотеза основывается на двух ключевых элементах из описания проекта (`P`):

1.  **Описание проблемы:** Проблема возникает именно у «SQL vms» с конфигурацией «always on». Это классический сценарий, где простое копирование файлов ВМ приводит к сбоям. Резервное копирование без координации с SQL Server может:

      * Создать несогласованную (crash-consistent) резервную копию, восстановление из которой может привести к потере данных.
      * Нарушить цепочку журналов транзакций (transaction log chain), что критически важно для работы Always On Availability Groups.
      * Предотвратить усечение (truncation) журнала транзакций, что со временем приводит к переполнению диска и остановке сервера.

2.  **Предлагаемое решение:** Клиент сам указывает, что решение — это «deploy sql aware agents» (развернуть агенты, осведомленные о SQL). 
Это прямое указание на то, чего не хватает `B1`. 
«SQL aware agent» — это компонент, который устанавливается внутри гостевой ОС и перед созданием снимка ВМ взаимодействует со службой `SQL Server VSS Writer`, чтобы гарантировать целостность и согласованность данных на уровне приложения.

### Возможные конкретные реализации `B1`
**Стороннее ПО для резервного копирования ВМ, работающее в режиме по умолчанию или с неверной конфигурацией.** 
Например, Veeam Backup & Replication, Acronis Cyber Protect, Commvault или другие. 
Эти продукты *умеют* делать application-aware бэкапы, но для этого их нужно специально настроить: активировать опцию «application-aware processing» и предоставить учетные данные для доступа внутрь гостевой ОС. 
Вероятно, клиент использует такое ПО, но эта опция либо отключена, либо настроена неверно.

**Встроенные средства резервного копирования гипервизора.**
Например, стандартные средства создания чекпоинтов в Hyper-V или снапшотов в VMware, которые затем копируются какой-то базовой системой. 
Сами по себе эти механизмы не взаимодействуют с приложениями внутри ВМ.

**Резервное копирование на уровне системы хранения данных (СХД).**
Некоторые СХД (SAN/NAS) поддерживают создание мгновенных снимков LUN'ов или томов. 
Это очень быстрый способ резервного копирования, но он, как правило, полностью «слеп» к тому, что происходит внутри виртуальных машин, и является классическим примером non-application-aware бэкапа.

**Вывод:** `B1` — это не конкретное название программы, а **класс систем резервного копирования**, которые по своей природе или из-за текущей конфигурации не способны корректно обрабатывать транзакционные приложения, такие как SQL Server в конфигурации Always On. 
Клиенту требуется специалист, который сможет настроить решение этой проблемы (`sql aware agents`) в «headless» среде, то есть через командную строку и PowerShell.
~~~

## 17.
Def(`T`):
```
Основная задача `C`, о которой он говорит в пункте 10.2:
~~~
We are implementing a backup solution into a new enviorment
~~~
```

## 18.
Def(`As`):
```
«sql aware agents», которых `C` упоминает в своей фразе пункта 10.2:
~~~
we need to deploy sql aware agents
~~~
```

## 19.
Def(`Ss`):
```
Альтернативы `As` для решения `T`.
```

## 20.
Действительно ли `As` — это лучший способ решения `T`?
Каковы `Ss`?
Сравни `As` и `Ss`.

