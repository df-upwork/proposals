1) You have correctly briefly mentioned the main possible reasons why a Python/Flask application screen might show outdated data from an SQLAlchemy database: «potential stale ORM instances, improper session handling with SQLAlchemy, or caching issues».
First of all, I will comment on these reasons in a bit more detail, based on my experience:
1.1) The most popular reason: objects are fetched from the database and stored somewhere, and then the application incorrectly reuses these cached objects instead of querying the database again upon subsequent access.
First, it is necessary to check whether ORM objects are being stored in global variables (or in other data structures that are not cleared between requests).
It is also necessary to check for any additional caching (for example, `Flask-Caching` or third-party libraries) that can replace up-to-date data with outdated ones.
1.2) The second most popular reason is the misuse of a single session object across multiple HTTP requests
In most cases, it is better to create a separate session in a Flask application for each HTTP request.
Moreover, when using `flask-sqlalchemy` with the default configuration of `scoped_session`, it will generally handle the creation and teardown of sessions for each HTTP request (assuming the `app.teardown_appcontext` hooks are set up properly).
The standard «create/open a session → process a request → commit/rollback → close/remove the session» flow is generally handled by Flask extensions (for instance, `flask-sqlalchemy`) or by explicitly configuring `before_request` / `teardown_request` hooks.
However, if the configuration has been manually altered (for example, by `SQLALCHEMY_ENGINE_OPTIONS` or by `db = SQLAlchemy(app, ...)`, or if the `before_request` / `teardown_request` hooks have been redefined), or if there is subtle reuse of the session via global objects, problems similar to those you mention may occur.
1.3) Changes to the session may not be committed.
In particular, it is necessary to verify that the session is properly cleared in `after_request` or `teardown_request` (`commit`/`rollback` + `remove`).
1.4) Applied to a multithreaded or multiprocess environment: an incorrect configuration of `scoped_session` can lead to concurrency conflicts by inadvertently sharing the same SQLAlchemy session across parallel requests (for example, in `gunicorn`/`uwsgi`) processed by separate threads or processes.
`scoped_session` is automatically bound to the current context (for example, the thread context), but improper configuration can cause the same session's leakage between different requests.
1.5) It is necessary to ensure that there are no extensive or time-consuming tasks within the same SQLAlchemy session context, because they may cause the following problems related to yours:
1.5.1) While the session is pinned to a single transaction, other processes or threads can modify the database.
The longer this transaction remains active, the higher the chance that the session's local data will fall out of sync with the actual database state.
1.5.2) In some cases, long-running transactions can acquire locks (especially when isolation levels with row or table locking are in effect), preventing concurrent threads or processes from updating the same data and potentially leading to delays and deadlocks.
1.5.3) If during a long operation changes are made to objects (ORM instances) within the same session, but no intermediate `commit()`/`flush()` is performed, it may appear externally that the data has already been updated, although in fact it only exists in memory within a session and has not yet been synchronized with the database.
1.5.4) The longer the transaction, the harder it is to keep track of concurrent changes in the database.
If something goes wrong during a long-running operation and a `rollback()` is required, it will revert all changes introduced in the session throughout that entire process.
1.5.5) An increased risk of errors in a multithreaded environment (already mentioned in point 1.4 above):
If the application uses multiple threads or processes (for example, `gunicorn` with multiple workers), and at the same time some thread monopolizes the session and holds it for too long, other threads may get stuck waiting for access to the same resources.
2) «Despite using `db.session.remove()` and `db.session.expire_all()` to refresh sessions and ORM instances, the problem persists»
These methods do not guarantee a complete reload of data or a re-creation of the session on each request.
2.1) `db.session.remove()` detaches the active session from the current context (for example, from `scoped_session`).
However, if existing references to objects from the old session remain somewhere in the code or in memory (for example, in a global variable, a singleton object, or a cache), they are not automatically updated.
2.2) `db.session.expire_all()` makes all objects in the current session obsolete, so the next time their attributes are accessed, SQLAlchemy will retrieve the data from the database again.
But if the same objects are still used in the code between requests, or (even worse) the same session object is still used (without exiting the request, without a complete restart), this does not save you from having a half-dead session or old objects in the following HTTP request.
2.3) I want to emphasize that even if you try to force these objects to be refreshed by calling `remove()` and `expire_all()`, but at the same time do not recreate the session for each request (or do not unload the old objects from memory), the problem will remain.
In my experience, this is exactly the classic case where developers think that calling `db.session.remove()` or `db.session.expire_all()` will solve all the problems, but in reality, the session may still be improperly shared between threads or HTTP requests, or somewhere in the code a reference to the old session remains.
3) «The data updates correctly when other functions modify the database»
This happens because these «other functions» may use a new SQLAlchemy session object or at least finish working with the session correctly (they do `commit()` / `rollback()`) and thereby reset the ORM cache.
These «other functions» could also explicitly call `flush()`, resetting all previously cached information from the database.
----
I have completed 532 projects here on Upwork.
My GitHub profiles: https://github.com/dmitrii-fediuk and https://github.com/mage2pro
My websites: https://df.tips?order=views and https://mage2.pro?order=views