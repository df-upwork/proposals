1) В пунктах 2-5 я описываю your misconceptions.
В пунктах 7-11 я описываю мои рекомендации для правильное решение вашей задачи.
2) «Add #EXT-X-DISCONTINUITY on switch»
2.1) Согласно спецификации HLS (RFC 8216, https://datatracker.ietf.org/doc/html/rfc8216, hereafter — `HLS`), `#EXT-X-DISCONTINUITY` (hereafter — `ED`) указывает на разрыв в характеристиках потока (например, изменение временных меток, формата файла или параметров кодирования). 
Назначение `ED` — сигнализировать плееру (hereafter — `P`) о необходимости адаптации к изменениям.
2.2) Когда `P` встречает `ED`, `P` обязан выполнить hard reset своего декодера (hereafter — `D`) и временную шкалу, чтобы корректно обработать переход. 
Этот процесс («hard reset») часто приводит к видимым артефактам: зависанию кадра или буферизации.
Это прямо противоречит вашему требованию «without buffering or interruptions» (hereafter — `R1`).
2.3) На самом деле, `R1` достигается совсем другими способом: когда переключение происходит между идентичными, синхронизированными потоками, и в этом случае `ED` не требуется. 
2.4) Использование `ED`, маркирующего разрыв, как средства обеспечения `R1`, показывает ваше  фундаментальное непонимание `HLS`.
3) Игнорирование синхронизации источников (hereafter — `O`).
3.1) Фокус вашего проекта исключительно на функциях failover microservice (hereafter — `M`) при отсутствии требований к `O` указывает на то, что вы ожидаете решения `R1` только за счет `M`.
3.2) Бесшовное переключение требует, чтобы основной и резервный потоки были синхронизированы с точностью до кадра (frame-accurate) и имели идентичные временные метки 
Проблема синхронизации должна решаться на уровне энкодеров (например, timecode locking. `M` не может эффективно склеить несинхронизированные потоки без ресурсоемкого трансмуксинга. 
3.3) Таким образом,  вы ошибочно пытаетесь решить `R1` в конце цепочки доставки, а не в её начале.
4)
4.1) Вы полагаете, что введение `M` позволит централизованно управлять отказоустойчивостью и скрыть сложность инфраструктуры от `P`.
4.2) На самом же деле, `M` создает классическую архитектурную уязвимость. 
В отличие от распределенных CDN, обладающих сотнями точек присутствия (PoP), единичный кластер `M` становится узким местом:
4.2.1) `M` становится идеальной мишенью для атак DDoS.
4.2.2) Ошибка в логике парсинга манифеста или утечка памяти в коде `M` приведет к падению трансляции для всех `P` одновременно. 
4.2.3) В случае падения и перезагрузки `M`, тысячи `P` одновременно попытаются переподключиться. 
Это создаст мгновенную пиковую нагрузку («thundering herd»), которую «холодный» `M` может не выдержать, снова уйдя в ребут. 
5) «Implement automatic failover with health checks» (hereafter — `R2`)
`R2` ошибочно подразумевает, что прокси (`M`) сможет определить неисправность быстрее и точнее, чем `P`.
В видеостриминге существует понятие «Zombie Stream» — ситуация, когда энкодер завис, но HTTP-сервер на стороне `O` продолжает работать и отдавать старый манифест с кодом ответа `200 OK`.
Чтобы обнаружить проблему, `M` должен хранить состояние (Stateful): помнить последний номер последовательности (`MEDIA-SEQUENCE`) и сравнивать его с текущим. 
Если номер не меняется на протяжении target duration, поток считается мертвым.
Реализация такой stateful-логики для тысяч одновременных потоков требует использования быстрых in-memory баз данных (Redis) и сложной синхронизации, что превращает «microservice» в распределенную систему высокой сложности.
6) Ниже, в пунктах 7-11 я описываю мои рекомендации для правильного решение вашей задачи.
7) Отказ от разработки `M`.
8) Внедрить синхронизированное кодирование.
`R1` достигается только при идеальной синхронизации основного и резервного потоков на уровне энкодеров.
Фокус проекта должен быть смещен с разработки микросервиса на обеспечение frame-accurate alignment of `O`.
 Это подразумевает использование технологий, таких как Epoch Locking или синхронизация по таймкодам (Timecode Locking), например, в AWS Elemental MediaLive.
9) Использовать нативную функцию `HLS` — Redundant Streams — в качестве основного механизма отказоустойчивости. 
В мастер-плейлисте для каждого качества указываются несколько URL, ведущих к разным, но синхронизированным (пункт 8) `O` или CDN. 
`R2` выполняется непосредственно `P`, а не `M`.
10) Использовать современный стандарт HLS Content Steering (RFC 8216bis, https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-18) для динамического управления выбором CDN с серверной стороны без проксирования видеотрафика. 
Управление осуществляется через внешний сервер (steering server), который отдает `P` легковесные JSON-манифесты с приоритетами путей доставки (pathways). 
11) Использовать готовые облачные или коммерческие платформы для упаковки и обеспечения доступности контента на уровне `O`. 
Вместо разработки собственной логики предлагается положиться на функционал платформ, таких как AWS Elemental MediaPackage или Unified Streaming Platform. 
Эти сервисы имеют встроенные механизмы high availability и input redundancy.