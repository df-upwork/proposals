1) Причина вашей проблемы «wrong format» для меня очевидна — это фундаментальные различия в интерпретации временных меток драйверами PostgreSQL для Node.js (`node-postgres` или `pg`) и Python (`asyncpg`, `psycopg2`).
1.1) `node-postgres` по умолчанию конвертирует значения `TIMESTAMP` (без часового пояса) в локальное время процесса Node.js (определяемое переменной окружения TZ). 
Это часто приводит к путанице, если данные хранятся в UTC.
1.2) `asyncpg` (стандартный асинхронный драйвер для FastAPI) при работе с `TIMESTAMPTZ` всегда возвращает время в UTC, игнорируя настройку `TimeZone` сессии PostgreSQL.
1.3) Если в схеме БД используется `TIMESTAMP` вместо рекомендуемого `TIMESTAMPTZ`.
`TIMESTAMP` хранит значение "как есть", без информации о часовом поясе.
В сочетании с поведением драйвера `node-postgres`, использование этого типа данных часто приводит к тому, что данные, задуманные как локальное время, сохраняются без контекста. 
При миграции на Python, который может интерпретировать эти "наивные" значения как UTC, происходит временной сдвиг.
1.4) Python строго разделяет "наивные" и "осведомленные" объекты datetime. FastAPI/Pydantic сериализует их по-разному: "осведомленные" получают указатель часового пояса (например, Z или +00:00), а "наивные" — нет.
Если приложение Python возвращает "осведомленные" даты в UTC (что часто происходит при использовании `asyncpg` или `TIMESTAMPTZ`), клиентская часть видит формат UTC. 
Если ранее Node.js/Moment.js выполнял явную конвертацию в локальное время и возвращал его как "наивную" строку, клиентская часть будет воспринимать новый формат как ошибку. 
Также, если Python возвращает "наивные" даты (например, используя `datetime.utcnow()`), информация о часовом поясе теряется при сериализации
2) Наиболее вероятная причина вашей проблемы «null»: хранение проблемных дат в нестандартном формате.
Вероятно, вы в приложении на Python для обработки дат используете библиотеку Pydantic. 
Moment.js способен успешно разбирать самые разнообразные и даже неполные строковые представления дат.
Pydantic, напротив, придерживается строгой философии «fail fast» и по умолчанию ожидает, что строки с датой и временем будут соответствовать стандарту ISO 8601.
Когда FastAPI получает данные из базы данных для формирования ответа API, он, видимо, использует Pydantic-модели для валидации и типизации этих данных. 
Если в поле, аннотированное как `datetime`, попадает строка из базы данных в нестандартном формате (например, "10/27/2023", "27 Oct 2023" или даже пустая строка ""), Pydantic не сможет её разобрать и сгенерирует исключение `ValidationError`. 
Далее, это исключение, ловится частью `except` блока `try...except` вашего приложения, там ошибка «проглатывается», а значение проблемного поля принудительно устанавливается в `None`, которое при сериализации в JSON превращается в `null`.