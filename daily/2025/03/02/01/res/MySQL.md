Ниже приведён расширенный (но не абсолютно «исчерпывающий») список параметров MySQL, которые в некоторых сценариях могут приводить к более заметному замедлению для Node.js-приложений, чем для PHP‑скриптов. Это связано с тем, что Node.js более чувствителен к дополнительным накладным расходам при установлении соединения, обработке TLS, асинхронных задержках в сети и т. д. В то же время многие из этих опций влияют на производительность любого клиента (не только Node.js), однако в парах **Node.js + MySQL** их влияние может проявляться сильнее, чем в парах **PHP + MySQL** (где используется высокооптимизированная C-библиотека и/или Unix-socket по умолчанию).

> **Примечание:** Названия опций могут отличаться в разных версиях MySQL/MariaDB. Некоторые из них актуальны только для MySQL 5.7/8.0 или для MariaDB. Также возможны синонимы или различия в формате записи (например, `query_cache_type=0` против `query_cache_size=0`).

| **Опция (my.cnf)**            | **Почему может замедлять Node.js сильнее, чем PHP**                                                                                           |
|--------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------|
| **bind-address**               | Если MySQL привязан к определённому IP (например, `127.0.0.1`), а не к Unix socket, то Node.js при подключении по TCP может получать лишние накладные расходы (TCP overhead). PHP (mysqli) может автоматически использовать Unix socket при `localhost`, что быстрее.                                               |
| **skip-networking**            | Если включён `skip-networking`, то сервер не слушает TCP вообще, и подключение может идти только через Unix socket. Если Node.js неправильно сконфигурирован (т.е. пытается идти по TCP), он может «не найти» сервер или вынужден как-то обходить это ограничение, что приводит к ошибкам/замедлениям.               |
| **require_secure_transport**   | При включении (MySQL 8+) заставляет все соединения быть зашифрованными (TLS/SSL). У Node.js шифрование может давать заметный overhead, если драйвер не оптимизирован под локальные SSL-соединения. В PHP нередко SSL по умолчанию отключён или более эффективно отрабатывается нативной C-библиотекой.                                 |
| **ssl_cert**, **ssl_key**, **ssl_ca** и др. SSL-параметры | Принудительное использование SSL/TLS (особенно при локальном соединении) может сильнее влиять на Node.js‑драйвер, чем на нативный PHP‑драйвер. Любой дополнительный handshake и шифрование/дешифрование увеличивают задержку на каждый запрос, что в случае очень «коротких» запросов (SELECT 1) более заметно.                                 |
| **wait_timeout** / **interactive_timeout** | Если таймаут слишком мал, Node.js (который держит соединение открытым долго и использует асинхронные паузы/цикл событий) может чаще натыкаться на разрыв соединения. Это приводит к необходимости переподключаться и даёт дополнительную задержку. PHP-скрипты обычно отрабатывают быстрее и завершаются, не сталкиваясь с повторными коннектами.        |
| **net_read_timeout**, **net_write_timeout** | При низких значениях Node.js может натыкаться на таймауты, если event loop в какой-то момент притормозил. Для PHP синхронные операции обычно проходят без задержек в event loop, поэтому реже попадают в таймаут.                                                                                                                         |
| **thread_handling**            | Некоторые режимы (например, `thread_handling = pool-of-threads`) могут давать более высокие задержки при коротких запросах, если MySQL «раздаёт» запросы потоку из пула медленнее. PHP, как правило, подключается, отрабатывает запрос и завершается, а Node.js держит соединение постоянно и часто отправляет небольшие запросы.           |
| **thread_cache_size**          | Если недостаточен, MySQL может чаще пересоздавать потоки для каждого нового подключения. Node.js, особенно при обработке concurrency (несколько параллельных запросов или подъём/спад соединений), может сильнее страдать от этого, чем PHP-FPM (где всё более статично).                                                    |
| **performance_schema**         | При включённом Performance Schema (особенно со многими счётчиками и инструментами) overhead сбора метрик может сильнее сказываться на асинхронных драйверах, где много коротких транзакций. PHP обычно делает меньше, но более концентрированные подключения (каждый PHP‑скрипт краткосрочный). Node.js же может долго держать соединение и часто «стучать» в БД. |
| **table_open_cache** и **table_definition_cache** | Если эти кэши слишком малы, MySQL будет постоянно открывать/закрывать файлы описаний таблиц. В Node.js (где может быть много коротких запросов за время жизни одного процесса) это чаще приводит к overhead, а в PHP (который может завершаться быстрее) — менее заметно.                                                          |
| **query_cache_type**, **query_cache_size** (в MySQL 5.7, устарело в 8.0) | Если включён старый Query Cache на маленьком объёме памяти, он может приводить к блокировкам при частых `UPDATE`, ухудшая общую производительность. Node.js с частыми мелкими запросами может сильнее ощущать задержки из-за блокировок кэша. PHP-скрипты часто отрабатывают залпом и завершаются.                   |
| **join_buffer_size**, **sort_buffer_size**, **read_buffer_size**, **read_rnd_buffer_size** | Слишком маленькие значения могут повышать время выполнения даже простых запросов, если MySQL вынужден чаще обращаться к временным таблицам на диск (в т.ч. in-memory engine). Node.js (часто) делает больше «дробных» операций. PHP может работать «кусками» короче, и эффекты чуть менее заметны.                              |
| **tmp_table_size**, **max_heap_table_size** | Аналогично: если слишком малы, MySQL создаёт временные таблицы на диске. В случае частых мелких запросов (Node.js) эти операции могут накапливать задержку.                                                                                                                                            |
| **innodb_flush_log_at_trx_commit**          | При значении `1` (полная надёжность) каждая транзакция ждёт синхронной записи на диск. Для сверхкоротких запросов (например, `UPDATE test SET f=1`) в Node.js может быть заметнее, так как Node.js чаще делает небольшие «одиночные» операции, а в PHP, возможно, транзакции сгруппированы или отрабатывают иначе.                          |
| **innodb_buffer_pool_size**                 | Если очень мало памяти выделено под буферный пул, частые обращения к таблицам InnoDB (пусть даже MEMORY-таблицы не затрагивают InnoDB, но если есть внутренние объекты InnoDB) могут приводить к I/O. Node.js, как асинхронный клиент, может чаще сталкиваться с lock’ами и латентностью при параллельной работе.                    |
| **max_allowed_packet**                      | Если слишком мало, драйвер может делать дополнительную разбивку пакетов или отказы при отправке. Асинхронная модель Node.js сильнее страдает от повторных перепосылок/ошибок. PHP, как правило, управляет пакетами внутри C-кода чуть эффективнее.                                                        |
| **skip_name_resolve** (и наоборот, включённая name resolve) | Если MySQL пытается делать reverse DNS lookup для каждого соединения, это добавляет задержку при подключении. Node.js (особенно при создании новых коннектов в пуле) может часто упираться в эти задержки DNS‑резолвинга. В PHP скриптах, которые часто используют Unix socket, это обычно не проявляется. |

---

### Почему нет «абсолютно полного» списка?

Количество опций MySQL очень велико. Фактически любую опцию, которая вызывает дополнительные блокировки, повышает накладные расходы на запрос/подключение или включает «тяжёлые» подсистемы мониторинга, можно считать фактором снижения производительности *особенно* в паре с Node.js. 

В целом, если кратко:
- **Сетевая/SSL-конфигурация** (TCP vs Unix socket, SSL, bind-address)   
- **Таймауты и буферные настройки** (wait_timeout, net_*_timeout, thread_cache_size, table_open_cache и т. д.)  
- **Monitoring / Debug-опции** (performance_schema, general_log, slow_query_log с низкими threshold, и т.п.)  
- **InnoDB / Transactional settings** (innodb_flush_log_at_trx_commit, innodb_buffer_pool_size)  

— всё это может влиять на задержки при коротких запросах и сделать так, что Node.js будет казаться «в 2 раза медленнее» при простых операциях, чем нативный PHP‑драйвер.