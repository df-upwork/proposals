Основных причин, почему в приведённом примере Node.js-скрипт может показывать бóльшие задержки по сравнению с аналогичным PHP-скриптом, обычно несколько:

1. **Различия в низкоуровневых реализациях MySQL-клиента**  
   - В PHP используется расширение mysqli/mysqlnd, которое скомпилировано на C и обычно очень хорошо оптимизировано под «короткие» запросы и быстродействие на одной машине.  
   - В Node.js, даже если библиотека написана частично на C/C++ (как `mysql2`), всё равно сверху есть «обвязка» на JavaScript/TypeScript. Эта «обвязка» может давать дополнительную задержку, особенно заметную на сверхкоротких запросах (SELECT 1 или UPDATE одной строки).

2. **Особенности асинхронной модели исполнения в Node.js**  
   - Само по себе «асинхронное» выполнение Node.js не означает, что SQL-запрос выполняется медленнее на сервере БД. Однако внесистемные вызовы (I/O) проходят через event loop, промисы, callback’и и пр. Всё это добавляет «накладные расходы» (overhead), которые особенно заметны при большом числе простых и очень коротких запросов.  
   - Если бы запросы были «тяжёлые» (выполнялись сотни миллисекунд), доля overhead внутри Node.js/JS была бы не так заметна.

3. **Методика замера времени**  
   - В PHP мы используем `microtime(true)*1000`, в Node.js — `process.hrtime.bigint()`. Оба способа в принципе дают точные значения, однако:
     - В PHP вы делаете 10 итераций строго подряд в одном синхронном потоке, без переключения контекста.  
     - В Node.js каждая итерация завершается и вы вызываете `setTimeout(test, 250);`. Между окончанием запроса и запуском следующего цикла может происходить ещё куча «фона» (GC, другие события event loop).  
   - Хотя формально `MS` считается как разность `hrtime`, иногда встречаются случаи, когда изменение нагрузки на event loop или переключение задач даёт добавочную задержку.

4. **Влияние настроек MySQL и системы**  
   - Иногда MySQL настроен так, что соединение с PHP (через Unix-сокеты / через локальные оптимизации) быстрее, чем соединение c Node.js (через TCP-сокет или другое API).  
   - Проверить это можно, например, сравнив connect string: используете ли вы `localhost` vs `127.0.0.1`, Unix domain socket vs TCP, одинаковые ли драйвера, действительно ли у них одинаковая конфигурация (протокол, параметры подключения, pool и т.п.).  

5. **Версии окружения**  
   - PHP и его встроенные модули (mysqli, PDO_MySQL) довольно «зрелые» и оптимизированные под типовые запросы.  
   - Node.js постоянно меняется, и производительность может варьироваться от версии к версии. Иногда мелочи, вроде типа импорта (CommonJS vs ESM), влияют на производительность.  
   - Также важно проверить флаги запуска Node.js (например, `--require`, `--loader`, `--no-experimental-fetch` и т. д.) и не включены ли какие-либо отладочные фичи/трассировки.

6. **Реальное vs «сырое» сравнение**  
   - В реальном приложении обычно выполняются более тяжёлые запросы или комбинированные операции; тогда разница в пару десятых миллисекунд часто теряется на фоне общей нагрузки.  
   - При microbenchmark’ах (короткий SQL-запрос, повторяющийся много раз) любая небольшая задержка в одном из звеньев цепочки (драйвер, event loop, GC) становится заметной.  
   - PHP в данном случае может выигрывать, потому что вызывается (в коде) синхронно, выполняет запрос напрямую в C-библиотеке и возвращает результат без «лишних» уровней абстракции.

---

### Резюме

- **Главная причина**: у PHP есть высокопроизводительная C-библиотека для MySQL, а в Node.js сверху есть JS-обвязка и асинхронный цикл, что даёт дополнительный overhead на очень коротких запросах.  
- **Скорее всего**, при реальном «нагрузочном» или «многопоточном» сценарии картина может меняться: Node позволяет параллелить запросы, работать с конвейером асинхронно и может показывать хорошие результаты при больших нагрузках.  
- **Как проверить**: поэкспериментируйте с разными драйверами (например, `mysql2` в pool-режиме, использование Unix domain socket), разными методами замеров, разными размерами запросов. Проверьте, нет ли в Node.js дополнительных опций, влияющих на время (доп. логирование, неправильный режим TCP, IPv6 и т. п.).

В общем случае «двукратная» разница при сверхбыстрых запросах — это не редкость, когда сравнивают нативный C-расширение PHP и JavaScript-драйвер Node.js.