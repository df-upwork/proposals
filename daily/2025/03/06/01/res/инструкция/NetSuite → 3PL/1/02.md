Ниже приведён пример, как в **SuiteScript 2.x** можно программно «выполнить Saved Search и получить нужные данные заказов». Предположим, что вы уже создали Saved Search в NetSuite (пусть у неё есть внутренний ID `customsearch_export_orders`) и хотите в коде скрипта получить результаты этой Saved Search:

---

## Пример для **Scheduled Script** или **Map/Reduce Script** (один из вариантов)

### Шаг 1. Определите модули и объявите функцию

```js
/**
 * @NApiVersion 2.x
 * @NScriptType ScheduledScript  // или Map/Reduce, см. ниже
 */
define(['N/search', 'N/log'], function(search, log) {

    function execute(context) {
        try {
            // Загружаем Saved Search по её внутреннему ID
            var mySearch = search.load({
                id: 'customsearch_export_orders' 
            });

            // Объявим массив для хранения результатов
            var resultsArray = [];

            // Запускаем поиск и обходим результаты
            mySearch.run().each(function(result) {
                // Получаем нужные поля
                var salesOrderId = result.getValue({ name: 'internalid' });
                var tranId        = result.getValue({ name: 'tranid' });
                var entity        = result.getText({  name: 'entity' }); // например, текст клиента
                var total         = result.getValue({ name: 'total' });
                
                // Сохраняем в массив
                resultsArray.push({
                    salesOrderId: salesOrderId,
                    tranId: tranId,
                    entity: entity,
                    total: total
                });

                // Возвращаем true, чтобы продолжить итерацию
                return true;
            });
            
            // На этом этапе в resultsArray лежат все строки из Saved Search
            log.debug('Результаты', JSON.stringify(resultsArray));

            // Дальше — любая логика по формированию файла, выгрузке на SFTP и т. п.
            // Например, вы можете сформировать CSV-строки на базе этого массива.
            
        } catch (e) {
            log.error('Ошибка при выполнении Saved Search', e);
        }
    }

    return {
        execute: execute
    };
});
```

> **Важные моменты**:
> 1. В `search.load({...})` укажите **фактический ID** вашего Saved Search (его видно, если зайти в Saved Search и посмотреть на URL или на странице редактирования).
> 2. Метод `mySearch.run().each(...)` итеративно обходит результаты поиска. Функция-колбэк должна возвращать `true`, чтобы продолжать обход, или `false`, если нужно прервать.
> 3. Поля выбираются через `getValue(...)` или `getText(...)` в зависимости от того, нужно ли получить «внутреннее значение» (Value) или «отображаемый текст» (Text).
> 4. Вызов `mySearch.runPaged()` с циклом по `page.range` — более продвинутый вариант, если результатов **очень много** (больше 1000), но обычно `each()` достаточно в большинстве кейсов.

---

## Пример для **Map/Reduce Script** (более оптимально для больших объёмов данных)

Если у вас потенциально тысячи или десятки тысяч записей, может потребоваться **Map/Reduce Script**. Суть похожа, но логика делится на 4 основные функции — `getInputData`, `map`, `reduce`, `summarize`. Ниже упрощённый шаблон, где мы берём данные из Saved Search в `getInputData`:

```js
/**
 * @NApiVersion 2.x
 * @NScriptType MapReduceScript
 */
define(['N/search', 'N/log'], 
function(search, log) {

    function getInputData() {
        // Загружаем Saved Search
        var mySearch = search.load({
            id: 'customsearch_export_orders'
        });

        // Возвращаем объект search, чтобы NetSuite сама отдала
        // данные в map() по одной записи (или пакетами).
        return mySearch;
    }

    function map(context) {
        // context.value тут — одна строка результата в виде JSON-строки
        var searchResult = JSON.parse(context.value);

        // Получаем нужные поля
        var salesOrderId = searchResult.values.internalid.value;
        var tranId       = searchResult.values.tranid; 
        var entityName   = searchResult.values.entity ? searchResult.values.entity.text : '';
        var total        = searchResult.values.total;

        // Дополнительная логика, например формирование записи для reduce
        context.write({
            key: salesOrderId,
            value: {
                tranId: tranId,
                entityName: entityName,
                total: total
            }
        });
    }

    function reduce(context) {
        // Если нужно агрегировать данные, пишем здесь логику
        // context.values будет массивом данных из map() с одинаковым ключом
        log.debug('reduce', 'key=' + context.key + ' values=' + JSON.stringify(context.values));
        // Можно, например, суммировать что-то или формировать итоговую CSV-строку
    }

    function summarize(summary) {
        // Подведение итогов (логирование, отчёты и т. п.)
        log.audit('Summary', {
            mapSummary: summary.mapSummary,
            reduceSummary: summary.reduceSummary,
            inputSummary: summary.inputSummary
        });
    }

    return {
        getInputData: getInputData,
        map: map,
        reduce: reduce,
        summarize: summarize
    };
});
```

> В этом случае NetSuite автоматически будет «постранично» обрабатывать результаты Saved Search и распределять их по функциям `map()` и (опционально) `reduce()`. Это удобнее при больших объёмах данных, чтобы избежать лимитов по времени выполнения (governance) в Scheduled Script.

---

## Как узнать **какие поля** можно получить из Saved Search

1. **Заранее настройте Saved Search**:  
   - Задайте нужные поля в секции «Results».  
   - Допустим, вы хотите получать `internalid`, `tranid`, `entity`, `total` — убедитесь, что они добавлены в Columns.

2. **Проверьте список доступных для Search Columns**:  
   - В интерфейсе NetSuite, при редактировании Saved Search, на вкладке Results вы увидите, какие поля добавлены (Name, Summary Type и т. д.).
   - Если поле называется «Internal ID», то в SuiteScript обычно указывается как `{ name: 'internalid' }`.
   - Если это поле из связанного объекта (например, Customer Name), иногда нужно указать `join` (например, `customerMainJoin`) или сразу пользоваться `entity` (в зависимости от типа поиска).

3. В SuiteScript 2.x можно использовать методы:
   - `result.getValue({ name: 'pole' })`
   - `result.getText({  name: 'pole' })` для получения текстового значения справочника (списка)
   - или, в случае Map/Reduce, смотреть `result.values` в JSON.

---

## Краткое резюме:

- **Создаёте Saved Search** в интерфейсе NetSuite, задаёте критерии и колонки.  
- **Загружаете** Saved Search по ID в SuiteScript с помощью `search.load({ id: '...' })`.  
- **Запускаете** её через `mySearch.run()`.  
- **Обходите результаты** методами `each()` или `runPaged()`. Либо возвращаете сам `mySearch` в `Map/Reduce Script` в `getInputData()`.  
- **Извлекаете поля** с помощью `getValue() / getText()` (или `result.values` в Map/Reduce).  
- **Сохраняете** их в массив (Scheduled Script) или передаёте дальше по pipeline (Map/Reduce) для дальнейших действий (формирование файла, запись данных в другое место и т. д.).

Таким образом, конкретно «Выполнить Saved Search, получить нужные данные заказов» сводится к этим шагам: загрузить Saved Search по ID, вызвать `run()`, итеративно получить результаты и извлечь нужные поля.