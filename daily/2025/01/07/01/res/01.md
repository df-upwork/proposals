Ниже опишу общий подход, который обычно используют для реализации подобного поведения в Magento 2, когда при выборе «апгрейда» нужно подменять основной SKU на «расширенный» (например, 12345 → 12345S), **вместо** добавления отдельного дополнительного товара в корзину.

---

## 1. Общая идея

1. **На уровне каталога (админ-панель)**  
   - Для каждого «базового» товара (например, SKU = 12345) в Magento создаётся один или несколько связанных «апгрейдных» товаров (например, SKU = 12345S).  
   - Эти «апгрейдные» товары **не** показываются в общем поиске на сайте и не выводятся в листингах (т. е. у них стоит `visibility = Not Visible Individually`), но они полноценные продукты в Magento, чтобы у них был свой склад (Stock), цена и отдельный SKU для ERP.

2. **На странице товара (PDP)**  
   - Пользователю показываем опции апгрейда (выпадающий список или радиокнопки), где рядом указывается надбавка к цене (например, «+£100»).  
   - При выборе «апгрейда» пользователь **видит** только разницу в цене, но под капотом (т. е. в бэкенде) реальный SKU, который попадёт в корзину, будет отличаться.

3. **При добавлении в корзину**  
   - Проверяем, какую опцию выбрал пользователь.  
   - Если выбрана базовая опция, добавляем товар 12345.  
   - Если выбрана «апгрейдная» опция, в корзину добавляется товар 12345S (а не 12345).

4. **Сток (наличие) каждого товара**  
   - Так как «апгрейдная» позиция — это отдельный продукт, у неё свой собственный сток.  
   - Если для апгрейдного SKU нет остатков, то соответствующий вариант апгрейда на странице блокируется («grey out»), и пользователь не может его выбрать.

---

## 2. Способы реализации «подмены» товара

В Magento 2 есть несколько основных путей, как «перенаправить» логику с одного SKU на другой в момент добавления в корзину:

1. **Плагин (Plugin) к классу `\Magento\Checkout\Model\Cart`**  
   - Можно написать плагин (обёртку) на метод `addProduct()`.  
   - Там, исходя из выбранной пользователем опции, подменять SKU на нужный (например, 12345 → 12345S).  
   - Затем уже добавлять в корзину новый SKU, а не «старый».

2. **Обработчик события (Observer) на `checkout_cart_add_product_complete`** (или `sales_quote_add_item`)  
   - При срабатывании события можно посмотреть, какой товар был «запрошен» на добавление, и заменить его на нужный «апгрейдный» SKU.  
   - Подход похож на плагин, просто другой механизм «точки входа».

3. **Кастомный JavaScript/Controller на PDP**  
   - Иногда делают «в лоб» на уровне шаблона и JS: при выборе апгрейда подменяют `name="product"` или `name="sku"` на «дочерний» SKU.  
   - Далее форма уходит на стандартный контроллер `add to cart` уже с новым `product_id`.  
   - Но такой вариант обычно сложнее «универсально» поддерживать и протестировать, особенно если нужно учитывать кастомные опции, конфигурационные товары и т. д.

> На практике, **плагин** или **обработчик события** — самый гибкий и поддерживаемый способ, т. к. он сосредоточен в одном месте и не «запутывает» фронтенд-логику.

---

## 3. Настройка «апгрейдных» товаров и надбавки к цене

- В админке Magento у «апгрейдных» товаров (SKU = 12345S) мы указываем:  
  1. `Visibility = Not Visible Individually`  
  2. Собственный `Price`, например, £600 (против £500 у базового).  
  3. Отдельный запас на складе (Stock).  

- На странице базового товара создаём кастомное поле (можно через кастомный атрибут или через отдельную табличку) «Допустимые апгрейды». В нём связываем базовый SKU и «апгрейдный» SKUs.  
- Для расчёта «+£100» в интерфейсе можно:  
  - Взять базовую цену (например, £500)  
  - Сравнить с ценой апгрейдного SKU (например, £600)  
  - На фронте показывать текст «+£100» рядом с переключателем.  

В результате, когда пользователь выбирает вариант «апгрейд», при нажатии на «Add to cart» в корзину добавится товар `12345S` с ценой £600. Для пользователя это выглядит так, как будто он выбрал «базу + опцию».

---

## 4. Логика проверки остатков по «апгрейдам»

### 4.1. При загрузке PDP
- На момент загрузки PDP (или через AJAX) мы запрашиваем остатки (Stock) для **всех** связанных SKUs.  
- Если, например, для 12345S остаток 0, мы дизэйблим (grey out) этот вариант апгрейда, чтобы пользователь не мог его выбрать.

### 4.2. При добавлении в корзину
- Magento стандартно проверяет наличие товара. Если апгрейдный SKU «закончился», выдаст ошибку, но в идеале мы предупреждаем пользователя **ещё на PDP**, что товар недоступен.

---

## 5. Шаги разработки с учётом окружений

1. **Создание отдельного дев-окружения**  
   - Как указано в требовании: сперва на локальном/дев-сервере делаем все доработки.  
   - Затем переносим в staging для тестирования.  
   - После одобрения — выкатываем на продакшн.

2. **Разработка модуля**  
   - Создаём кастомный модуль, в котором:  
     - Создаём атрибут или связку «родитель → дочерние (апгрейдные) товары».  
     - Реализуем плагин или обсервер для подмены SKU при добавлении в корзину.  
     - (Опционально) выносим фронтенд-логику (проверку остатков, «i»-иконку с подсказкой и т. д.).

3. **Тестирование**  
   - Убеждаемся, что при выборе апгрейда в корзину падает правильный SKU.  
   - Проверяем расчёт цены, работу с остатками, синхронизацию с ERP и т. д.

---

### Итог

Чтобы при выборе апгрейда **не** добавлять «дополнительный» товар, а именно **заменять** SKU на другой при добавлении в корзину, обычно делают:

1. **Заводят реальный отдельный товар** в базе (с нужным SKU, ценой, остатками).  
2. **Скрывают** этот «дочерний» (апгрейдный) товар от поиска и каталога.  
3. **На PDP** создают механизмы (через атрибуты, кастомное поле, плагин/JS), позволяющие пользователю выбрать опцию и отобразить «+£X».  
4. **На уровне бэкенда** (через плагин/обсервер) подменяют SKU при добавлении в корзину.  

Таким образом и цена корректно отображается, и SKU попадает в ERP ровно тот, который нужен для логистики и учёта складов, а пользователь видит удобный интерфейс «апгрейдов».