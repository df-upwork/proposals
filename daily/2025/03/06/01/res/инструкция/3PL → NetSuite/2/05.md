Ниже приведено общее объяснение того, **как именно** в SuiteScript 2.x можно обновлять существующие заказы (Sales Order), их поля, а также создавать связанные записи (например, Item Fulfillment или кастомную запись). Пример иллюстрирует базовую логику: загрузили заказ по идентификатору, обновили нужные поля, сохранили заказ; при необходимости создали Item Fulfillment или Custom Record и заполнили нужные поля.

---

## 1. Обновление статуса или полей в существующем заказе (Sales Order)

### 1.1. Логика

1. **Определяем, какой заказ надо обновить**. Обычно это делается по уникальному идентификатору:  
   - *Internal ID* (внутренний ID записи в NetSuite),  
   - или *External ID* (какое-то внешнее поле, например, номер заказа из ERP/CRM/MarketPlace).  

2. **Загружаем заказ** через `record.load(...)`.  
3. **Устанавливаем** нужные поля (например, кастомные поля подтверждения, статус, tracking number и т. д.).  
4. **Сохраняем** изменения.

### 1.2. Пример кода

```javascript
/**
 * @NApiVersion 2.x
 * @NModuleScope SameAccount
 */
define(['N/record', 'N/search'], function(record, search) {

    function updateSalesOrder(soId, newStatus, trackingNumber) {
        // 1. Загружаем Sales Order по внутреннему ID
        var soRecord = record.load({
            type: record.Type.SALES_ORDER,
            id: soId,
            isDynamic: true // можно и false, если не нужны динамические манипуляции с линиями
        });

        // 2. Устанавливаем нужные поля
        // Пример: обновить статус через кастомное поле "custbody_3pl_order_status"
        // Обратите внимание, что реальный ID поля может отличаться
        soRecord.setValue({
            fieldId: 'custbody_3pl_order_status',
            value: newStatus
        });

        // Пример: записать tracking number
        soRecord.setValue({
            fieldId: 'custbody_tracking_number_3pl',
            value: trackingNumber
        });

        // 3. Сохраняем изменения
        var recordId = soRecord.save();
        log.audit('Sales Order Updated', 'SO ID: ' + recordId);

        return recordId;
    }

    return {
        updateSalesOrder: updateSalesOrder
    };
});
```

> **Важные моменты**:
> - Если нужно менять *стандартное* поле «Status», в некоторых случаях лучше **не напрямую** прописывать статус, а использовать изменение **Stage** (Pending Fulfillment → Partially Fulfilled → Closed) или **transform()** для создания Fulfillment.  
> - Если у вас есть **кастомное поле** (например, `custbody_3pl_order_status`), то можно прямо в него записывать новый статус (строковое/справочное значение).  
> - Если в файле вы получаете, скажем, «TrackingNumber» и «DateShipped», стоит добавить их в соответствующие поля заказа — либо в стандартные (если такие есть), либо в кастомные.

---

## 2. Создание записи Item Fulfillment

### 2.1. Когда это нужно

Чтобы отразить факт отгрузки заказа (полной или частичной), в NetSuite обычно **трансформируют** Sales Order в Item Fulfillment. Так система понимает, что товары действительно «уехали» со склада и заказ (или его часть) находится в статусе Fulfilled.

### 2.2. Пример кода

```javascript
/**
 * @NApiVersion 2.x
 * @NModuleScope SameAccount
 */
define(['N/record'], function(record) {

    function createItemFulfillment(soId, trackingNumber) {
        // 1. Трансформация SalesOrder -> ItemFulfillment
        var fulfillmentRecord = record.transform({
            fromType: record.Type.SALES_ORDER,
            fromId: soId,
            toType: record.Type.ITEM_FULFILLMENT,
            isDynamic: true
        });

        // 2. Установить поля Fulfillment (shipstatus, tracking number и т.п.)
        // Поле shipstatus: 'C' обычно означает "Shipped"
        fulfillmentRecord.setValue({
            fieldId: 'shipstatus',
            value: 'C'
        });

        // Tracking Number (ID может отличаться, проверьте в своей учётке)
        fulfillmentRecord.setValue({
            fieldId: 'custbody_tracking_number_3pl',
            value: trackingNumber
        });

        // 3. (Опционально) Обойти линии, отметить, что каждая из них отгружена
        // Если isDynamic: true, можно cursor'ом идти по линиям
        var lineCount = fulfillmentRecord.getLineCount({ sublistId: 'item' });
        for (var i = 0; i < lineCount; i++) {
            fulfillmentRecord.selectLine({
                sublistId: 'item',
                line: i
            });
            // Установка количества к отгрузке (в примере - всё целиком)
            var quantity = fulfillmentRecord.getCurrentSublistValue({
                sublistId: 'item',
                fieldId: 'quantity'
            });
            // Если частичная отгрузка, то здесь можно задать нужное число
            fulfillmentRecord.setCurrentSublistValue({
                sublistId: 'item',
                fieldId: 'quantity',
                value: quantity
            });
            fulfillmentRecord.commitLine({ sublistId: 'item' });
        }

        // 4. Сохранить Fulfillment
        var ffId = fulfillmentRecord.save();
        log.audit('Item Fulfillment Created', 'Fulfillment ID: ' + ffId);

        return ffId;
    }

    return {
        createItemFulfillment: createItemFulfillment
    };
});
```

> **Важные моменты**:
> - Трансформация работает только если статус и настройки Sales Order позволяют создать Fulfillment. Если заказ «Pending Approval» или «Closed», трансформация не сработает.  
> - В зависимости от настроек учётки вам может понадобиться включить `Advanced Shipping`, `Pick/Pack/Ship` или другие фичи в NetSuite.  

---

## 3. Создание пользовательской (Custom Record)

### 3.1. Когда это нужно

Если в процессе подтверждения заказа от 3PL нужно записывать какие-то данные, которые **не вписываются** в стандартные сущности (Sales Order, Fulfillment и т. д.), можно создать **кастомную запись** (Custom Record). Например, «customrecord_3pl_confirmations» с полями `custrecord_3pl_order_id`, `custrecord_3pl_tracking`, `custrecord_3pl_status` и т. п.

### 3.2. Пример кода

```javascript
/**
 * @NApiVersion 2.x
 * @NModuleScope SameAccount
 */
define(['N/record'], function(record) {

    function create3PLConfirmationRecord(orderId, status, trackingNumber) {
        // 1. Создаём новую кастомную запись
        var customRec = record.create({
            type: 'customrecord_3pl_confirmations', // ID вашей кастомной записи
            isDynamic: true
        });

        // 2. Устанавливаем нужные поля
        // Предположим, у нас есть поля "custrecord_3pl_order_id", "custrecord_3pl_status", "custrecord_3pl_tracking"
        customRec.setValue({
            fieldId: 'custrecord_3pl_order_id',
            value: orderId
        });
        customRec.setValue({
            fieldId: 'custrecord_3pl_status',
            value: status
        });
        customRec.setValue({
            fieldId: 'custrecord_3pl_tracking',
            value: trackingNumber
        });

        // 3. Сохраняем
        var newRecId = customRec.save();
        log.audit('3PL Confirmation Created', 'Custom Rec ID: ' + newRecId);

        return newRecId;
    }

    return {
        create3PLConfirmationRecord: create3PLConfirmationRecord
    };
});
```

> **Важные моменты**:
> - Имя типа записи (`type: 'customrecord_...'`) и имена полей (`fieldId: 'custrecord_...'`) должны соответствовать реальным настройкам вашей Custom Record.  
> - Custom Record можно связать с Sales Order (через поле типа «List/Record» = Sales Order или через текстовый идентификатор).

---

## 4. Как выбирать правильный подход

1. **Если нужно лишь обновить Sales Order**:  
   - Меняем его статус (кастомное поле, например `custbody_3pl_order_status`).  
   - Заполняем поля подтверждения (дата отгрузки, tracking number).  
   - При необходимости меняем нативный статус (Pending Fulfillment → Partially Fulfilled → Pending Billing и т. д.), но это часто делается через Fulfillment.  

2. **Если логика подразумевает «официальное» проведение отгрузки**:  
   - Нужно **создать Item Fulfillment**. Это правильнее для учёта остатков, списания товаров со склада и т. д.  

3. **Если требуется хранить дополнительные метаданные** (новую сущность или подробную информацию, не влезшую в стандартные поля):  
   - Создаём **Custom Record** и связываем её с заказом.

---

## 5. Типовые ошибки/подводные камни

1. **Отсутствие прав у скрипта**. Убедитесь, что у Script-пользователя (или роль, под которой работает SuiteScript) есть права на:  
   - Изменение заказа (Edit Sales Order),  
   - Создание Item Fulfillment (Create Item Fulfillment),  
   - Создание/редактирование кастомных записей (Create/Edit Custom Record).  

2. **Невозможность трансформировать заказ**. Если Sales Order находится не в том статусе (например, «Pending Approval»), то `record.transform(...)` выдаст ошибку. Нужно убедиться, что заказ «Pending Fulfillment» или аналогичный статус, при котором разрешена отгрузка.

3. **Серверная vs. клиентская среда**. Убедитесь, что используете скрипт типа **Server-Side** (Scheduled, Map/Reduce, User Event и т. п.), а не Client-Side, если работаете с SFTP или другими серверными модулями.  

4. **Ошибки мэппинга полей** (в частности, ID полей). При работе с кастомными полями проверьте точный ID каждого поля. Не путать «Label» и «ID».

5. **Небрежность при парсинге данных**. Если из 3PL приходит CSV/XML, убедитесь, что корректно парсите строки, разделители и учитываете случайные ошибки в данных.

---

### Итог

- **Обновить статус** в существующем заказе → используем `record.load()` + `setValue()` + `save()`.  
- **Создать связанную запись типа Item Fulfillment** (официальная отгрузка) → используем `record.transform()` от SalesOrder к ItemFulfillment.  
- **Сохранить дополнительные данные** вне стандартного объекта → создаём **Custom Record** и заполняем поля.

В контексте «automated file drop» и SuiteScript, всё это обычно делается в **шаге, когда вы парсите файл** от 3PL и для каждого полученного заказа (строки файла) принимаете решение:

1. Найти Sales Order.  
2. При необходимости — обновить поля.  
3. Если нужно отгрузить — создать Fulfillment.  
4. (Опционально) Создать дополнительную кастомную запись.

Таким образом, NetSuite будет корректно отражать процесс обработки/подтверждения заказов, полученных из 3PL.