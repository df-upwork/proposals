Ниже представлена сравнительная таблица, в которой основные аспекты **масштабирования (ресайза)** сопоставляются между **Core Image** и **Image I/O**.  

| **Критерий**                                                                          | **Core Image**                                                                                                                                                                                                              | **Image I/O**                                                                                                                                                                                                                                                     |
|:--------------------------------------------------------------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Уровень/Назначение**                                                                | • **Высокоуровневый** фреймворк для цепочечной GPU-обработки изображений (фильтры, эффекты).<br/>• Подходит для сложных сценариев: комбинирование фильтров, цветокоррекция, наложение эффектов и т. д.                                                            | • **Низкоуровневый** фреймворк для чтения/записи (декодирования/кодирования) изображений различных форматов (JPEG, PNG, TIFF и пр.).<br/>• Может выполнять даунсемплинг/создание миниатюр «на лету» при декодировании для экономии памяти и ускорения загрузки. |
| **Основной механизм масштабирования**                                                 | • Через **CIFilter** (например, `CILanczosScaleTransform`, `CIBicubicScaleTransform`, `CIAffineTransform`) или **пользовательские шейдеры** (CIKernel).<br/>• Выбор алгоритма (Lanczos, Bicubic, Bilinear) — **явный** и тонко настраиваемый.                      | • **Даунсемплинг при декодировании** (thumbnails) с помощью ключей `kCGImageSourceThumbnailMaxPixelSize`, `kCGImageSourceCreateThumbnailIfLarge` и т. п.<br/>• **Нет прямого выбора** «Bicubic»/«Lanczos» и т. п.: используется оптимизированное аппаратно-зависимое усреднение/редукция.            |
| **Выбор конкретного алгоритма интерполяции**                                          | • **Гибкий**: можно явно указать Lanczos, Bicubic, Bilinear и т. д. или написать свою реализацию через `CIKernel` (включая nearest neighbor).                                                                                | • **Не предоставляет** тонких настроек интерполяции (нет API для `kCGInterpolationQuality`).<br/>• Реальный метод ресемплинга зависит от механизма частичного декодирования (например, для JPEG — skip декодирования DCT-блоков и простое усреднение).             |
| **Типичные сценарии использования**                                                   | • Продвинутая графическая обработка, совмещение с другими фильтрами (blur, color correction, composite).<br/>• Пакетные операции на GPU, где важна **производительность** при больших объёмах данных.                                                            | • Быстрая генерация **миниатюр** (thumbnails) или «уменьшенных копий» изображений **во время** чтения из файла, чтобы не декодировать полный размер (экономия памяти и времени).<br/>• Предварительная обработка перед загрузкой в Core Graphics / Core Image.      |
| **Производительность**                                                                 | • Обычно **GPU-ускорение** (Metal/OpenGL). При сложных операциях с большими изображениями может быть намного быстрее CPU-подхода.<br/>• Для простейших задач (одноразовый ресайз) overhead инициализации цепочки фильтров может быть выше, чем в более простых API. | • **Оптимизирован под декодирование** (включая аппаратное ускорение JPEG/HEIF и т. п.).<br/>• «Масштабирование» главным образом происходит за счёт «неполного декодирования» (особенно при уменьшении).<br/>• Не предназначен для сложных многократных преобразований.                    |
| **Гибкость и расширяемость**                                                          | • **Очень гибкий**: помимо стандартных фильтров, можно писать свои шейдеры (CIKernel).<br/>• Поддержка цепочек: можно последовательно применять несколько фильтров.                                                                                                 | • **Ограниченный** в части ресайза: либо полная декодировка изображения, либо даунсемплинг при создании миниатюр.<br/>• Если нужен конкретный интерполяционный метод, как Lanczos или Bicubic, придётся загрузить всё через Image I/O и потом использовать Core Image/Core Graphics. |
| **Пример кода**                                                                        | **Core Image** (Swift-псевдокод):<br/>```swift\nlet inputCI = CIImage(image: uiImage)\nlet lanczosFilter = CIFilter(name: \"CILanczosScaleTransform\")!\nlanczosFilter.setValue(inputCI, forKey: kCIInputImageKey)\nlanczosFilter.setValue(0.5, forKey: kCIInputScaleKey)\n...\nlet outputCI = lanczosFilter.outputImage\n``` | **Image I/O** (Swift-псевдокод):<br/>```swift\nlet opts: [CFString: Any] = [\n    kCGImageSourceCreateThumbnailFromImageIfLarge: true,\n    kCGImageSourceThumbnailMaxPixelSize: 800\n]\nif let thumbnail = CGImageSourceCreateThumbnailAtIndex(src, 0, opts as CFDictionary) {\n    // thumbnail уже уменьшен\n}\n``` |
| **Дополнительные возможности**                                                         | • Можно интегрировать с **Core ML** (через `CICoreMLModelFilter`), получать суперразрешение (ESRGAN-подобные модели).<br/>• Широкий набор стандартных фильтров (коррекция цвета, размытие, шумоподавление, и т. д.).                                             | • Широкая поддержка форматов (JPEG, PNG, GIF, HEIF, TIFF, RAW и пр.).<br/>• Механизмы чтения/записи метаданных EXIF, IPTC, XMP и т. д.<br/>• Возможность быстро **превью** больших изображений без полной декодировки.                                                                                |

### Ключевые отличия

1. **Назначение**:  
   - **Core Image** — гибкая система GPU-фильтров для продвинутой обработки (включая масштабирование).  
   - **Image I/O** — библиотека для эффективного чтения/записи различных форматов, умеет «сразу» выдавать уменьшенную копию изображения (thumbnails), но не предоставляет широкого выбора интерполяционных алгоритмов.

2. **Ресайз и интерполяция**:  
   - **Core Image** даёт прямой выбор Lanczos/Bicubic/Bilinear либо кастомный `CIKernel`.  
   - **Image I/O** автоматически даунсемплирует изображение при декодировании (особенно полезно для крупных файлов), но не позволяет явно указать «Bicubic» или «Lanczos».

3. **Сценарии**:  
   - **Core Image** хорош для *качественного* и *сложного* масштабирования (последовательная обработка, цепочки фильтров).  
   - **Image I/O** удобен для *быстрой генерации миниатюр* и экономии памяти при чтении больших изображений (без их полной декодировки).

Таким образом, **Core Image** ориентирован на **глубокую GPU-обработку** с возможностью выбора конкретных алгоритмов ресемплинга, а **Image I/O** — на **эффективное чтение/запись** (с базовыми механизмами уменьшения изображений «на лету»).