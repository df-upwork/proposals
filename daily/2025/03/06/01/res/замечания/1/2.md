## 1. Общая структура SuiteScript

### 1.1. «import … from 'N/...';»

В «чистом» SuiteScript 2.0 (без TypeScript‑транспиляции) обычно используется формат:

```js
define(['N/file', 'N/record', 'N/search', 'N/sftp'], function(file, record, search, sftp) {
  
  function execute(context) {
    // ...
  }

  return {
    execute: execute
  };
});
```

Если вы используете TypeScript либо другую сборку, которая поддерживает `import ... from ...`, тогда синтаксис `import file from 'N/file';` допустим. Главное — чтобы в итоге NetSuite понимал, как подключать эти модули. Убедитесь, что у вас действительно настроен **environment** под TypeScript/ES модули для SuiteScript.

### 1.2. Тип скрипта

Вы используете функцию `export function execute()`, что характерно для **Scheduled Script** или для части **Map/Reduce Script** (например, `getInputData`, `map`, `reduce` и т. д.). Убедитесь, что:

- У вас **в записи Script** (Script Record) указан нужный **Script Type** (Scheduled или Map/Reduce).  
- Если это **Scheduled Script**, в Deployments вы сможете выбрать «Run now» или запланировать исполнение.  
- Если это **Map/Reduce**, нужно позаботиться о методах `getInputData()` / `map()` / `reduce()` / `summarize()`.

Как пример, вы назвали метод `execute()`, — это обычно Scheduled Script.

---

## 2. Отправка файлов из NetSuite на SFTP

Код выглядит концептуально верно:  
1. Собрали список заказов (через `search.load`).  
2. Сериализовали их в CSV-строку.  
3. Создали файл в File Cabinet (метод `file.create`).  
4. Установили соединение с SFTP (метод `sftp.createConnection`).  
5. Выполнили `conn.upload({file: f})`.

### 2.1. Модули

```js
import file from 'N/file';
import record from 'N/record';
import search from 'N/search';
import sftp from 'N/sftp';
```
— это корректные имена для SuiteScript‑модулей в 2.x.

### 2.2. Saved Search

```js
var s = search.load({id: 'customsearch_export_orders'});
```
— всё хорошо, если `customsearch_export_orders` существует и имеет нужные колонки.  

Обратите внимание, что метод `search.load` не позволяет менять критерии «на лету» (разве что через `run().each(...)` можно фильтровать вручную), так что убедитесь, что в Saved Search заданы корректные фильтры (например, «Статус = Pending Fulfillment» и т. д.).

### 2.3. Формирование CSV

```js
var csvA = [];
csvA.push('SalesOrderId,TranId,Entity,Total');
orders.forEach(function (o) {
  csvA.push([o.salesOrderId, o.tranId, o.entity, o.total].join(','));
});
var csv = csvA.join('\n');
```

Это рабочий вариант для примера, особых претензий нет. Можно только посоветовать проверить:
- Нужны ли кавычки для отдельных полей, если в данных встречаются запятые.  
- Требуются ли Windows‑концы строк (`\r\n`) или достаточно `\n`.  

### 2.4. file.create

```js
var f = file.create({
  contents: csv,
  description: 'Orders export for 3PL',
  encoding: file.Encoding.UTF_8,
  fileType: file.Type.CSV,
  folder: 123, // The folder ID in NetSuite File Cabinet
  name: 'export_orders.csv'
});
```

- Параметры `description`, `encoding`, `fileType` — нормально.  
- `folder: 123` — проверьте, что ID папки верный и что у скрипта есть права на запись туда.  
- `name: 'export_orders.csv'` — ок, файл сохранится именно с таким именем.

### 2.5. sftp.createConnection

```js
var conn = sftp.createConnection({
  directory: '/inbound',
  hostKey: 'ssh-rsa 2048 AAAAB3NzaC1yc2E...',
  port: 22,
  url: 'sftp.example.com',
  username: 'mySftpUser'
}); 
```

#### Важные нюансы:

1. **Параметры аутентификации**  
   - Часто требуется либо `password`, либо `pkey` + `passphrase`.  
   - Обязателен `hostKeyType` (например, `hostKeyType: sftp.HostKeyType.SSH_RSA`), если вы задаёте `hostKey`.  
   - Без указания `password/pkey` вы можете не подключиться к SFTP (если на сервере не разрешен анонимный вход).

2. **`directory: '/inbound'`**  
   - NetSuite при использовании `directory: '/inbound'` будет считать эту директорию «текущей» для операций `upload`, `download`, `list`.  
   - Если у вас в `upload` потом **не** указан `directory`, то по умолчанию файл уйдёт в `/inbound`.

### 2.6. Загрузка файла на SFTP

```js
conn.upload({ file: f });
```

- В SuiteScript 2.x метод `upload(options)` типично принимает `options.file` (NetSuite File object) и необязательные поля `options.replaceExisting` и `options.filename`.  
- Если `options.filename` не указали, NetSuite подставит `f.name`. Это обычно работает, если сервер не против перезаписи.  
- Если `directory` или `path` не задан в `upload`, NetSuite возьмёт директорию, указанную при `createConnection(...)`.  

Это в целом ок, но не забудьте проверить, что **с учётом прав** и **существования папки** на стороне SFTP, всё загрузится куда надо.

---

## 3. Скачивание файлов с SFTP в NetSuite

Структура «list → download → parse → update records» тоже выглядит правильно:

### 3.1. list()

```js
conn.list({ path: '<…>' }).forEach(function (rf) {
  if (rf.name && rf.name.toLowerCase().endsWith('.csv')) {
    // ...
  }
});
```

- Будет получен массив объектов вида `{ name: string, type: string, size: number, timestamp: Date }`.  
- Если `path` не указан, NetSuite возьмёт из `createConnection({ directory: ... })`.

### 3.2. download()

```js
var contents = conn.download({ directory: '<…>', filename: rf.name }).getContents();
```

- Здесь важно убедиться, что `'<…>'` совпадает с актуальным путём на SFTP.  
- Поскольку вы уже задали `directory` при `createConnection`, иногда можно просто указать `filename: rf.name` без `directory`, если путь совпадает.

### 3.3. Парсинг CSV

```js
var lines = contents.split(/\r?\n/);
for (var i = 1; i < lines.length; i++) {
  var line = lines[i].trim();
  if (line) {
    var fields = line.split(',');
    // ...
  }
}
```

- Рабочий базовый вариант.  
- Если CSV содержит запятые внутри полей, нужна логика «escaping» (парсинг с учётом кавычек). Но это уже нюанс формата.  
- Сдвиг `i = 1` пропускает заголовок, что логично.

### 3.4. Поиск в NetSuite

```js
var findOrder = function(id) {
  var s = search.create({
    columns: ['internalid'],
    filters: [
      ['mainline', 'is', 'T'],
      'AND',
      ['tranid', 'is', id]
    ],
    type: search.Type.SALES_ORDER
  }).run().getRange({start: 0, end: 1});
  
  if (!s || !s.length) {
    return null;
  }
  return record.load({
    type: record.Type.SALES_ORDER,
    id: s[0].getValue({ name: 'internalid' })
  });
};
```

#### Возможные нюансы:

1. **`search.Type.SALES_ORDER`**  
   - В большинстве официальных объявлений SuiteScript 2.x перечисление называется либо `search.Type.SALESORDER` (без подчёркивания), либо `record.Type.SALES_ORDER`.  
   - Проверьте, какое значение реально поддерживается вашей версией NetSuite. Часто для транзакций используют либо строку `'salesorder'`, либо `search.Type.SALESORDER`.  
   - Если у вас действительно есть константа `search.Type.SALES_ORDER` — окей, но скорее это опечатка, и надо менять на `search.Type.SALESORDER`.

2. **Поиск по `tranid`**  
   - Поле `tranid` — это «Document Number» (номер транзакции). Если у вас автонумерация вида «SO1001», CSV-документ и `tranid` должны совпадать. Если в CSV «1001», а в NetSuite «SO1001», поиск не найдёт совпадения. Нужно следить, чтобы формат совпадал.  
   - Иногда для интеграций удобнее использовать внешние ID (`externalid`) или кастомные поля.

3. **Производительность**  
   - `record.load` внутри цикла по каждой строчке может быть довольно ресурсоёмко. Если заказов много, лучше рассмотреть [Map/Reduce] подход или пачечное обновление (через `record.submitFields`, если это простые поля).

### 3.5. Обновление заказа

```js
o.setValue({ fieldId: 'custbody_shipping_status', value: fields[1] });
o.setValue({ fieldId: 'custbody_tracking_number', value: fields[2] });
o.save();
```

- Это стандартный способ обновить поля.  
- Если полей много, проверяйте лимиты Script Usage и время исполнения (особенно при большом количестве строк).  
- Часто бывает, что подтверждение 3PL возвращает «Item Fulfillment» данные (списание со склада, tracking number). Тогда вместо обновления самого Sales Order может потребоваться создать/редактировать Fulfillment-запись. Но это уже зависит от бизнес-процесса.

---

## 4. Суммируем замечания и рекомендации

1. **Уточнить аутентификацию SFTP**  
   - Обычно требуется указать либо `password`, либо `pkey`, `passphrase`, плюс `hostKeyType`. Пример:
     ```js
     var conn = sftp.createConnection({
       url: 'sftp.example.com',
       port: 22,
       hostKey: 'ssh-rsa 2048 AAAAB3NzaC1yc2E...',
       hostKeyType: sftp.HostKeyType.SSH_RSA,
       username: 'mySftpUser',
       password: 'myPassword', // или pkey, passphrase
       directory: '/inbound'
     });
     ```
   - Без этого часто соединение не проходит.

2. **Убедиться, что `search.Type.SALES_ORDER` действительно доступен**  
   - Проверьте в документации или используйте строку `'salesorder'`.  
   - Либо:  
     ```js
     type: search.Type.SALESORDER
     // или
     type: 'salesorder'
     ```

3. **Проверить соответствие `tranid` и формата номера заказа**  
   - Если у вас в CSV столбце указано «SO1001», то `tranid` = «SO1001» и всё найдётся. Если нет, — используйте другой фильтр или меняйте формат.

4. **Учесть производительность**  
   - Если заказов очень много, либо файлы большие, лучше применять **Map/Reduce Script**:  
     - На этапе `getInputData()` собрать имена файлов (или содержимое).  
     - На этапе `map()` разбирать строчки и формировать ключи.  
     - На этапе `reduce()` обновлять заказы.  
   - Либо разбивать скрипт на части, если Script Usage Limit превышается.

5. **Обработка ошибок**  
   - В реальном коде желательно везде расставить `try/catch` (или хотя бы внутри ключевых операций) и логгировать через `log.error(...)`.  
   - На SFTP-сервере может не оказаться файла, может быть отказ в доступе и т. д.

6. **(Опционально) Удаление или перенос обработанных файлов**  
   - Чтобы один и тот же файл не скачивался и не обрабатывался повторно, часто либо удаляют файл с SFTP, либо переносят в «archive» папку.  
   - Если это нужно процессу — стоит добавить `conn.remove({ path: '...' })` или `conn.move({...})` после успешного обновления заказа.

---

## 5. Вывод

**Ваш примерный ответ клиенту** (с демонстрацией кода) вполне наглядно показывает общую идею и даёт базовое понимание, **как** в NetSuite (SuiteScript 2.x) можно:

- Выгружать заказы (Saved Search → CSV → SFTP).  
- Подхватывать подтверждения (SFTP → CSV → Update Sales Orders).

**Критичных «фатальных» ошибок** в логике нет; это действительно базовый рабочий шаблон. Но обратите внимание на следующие моменты, которые часто становятся «подводными камнями» в реальном проекте:

1. **Авторизация и hostKeyType** при SFTP‑соединении.  
2. **Точная константа** для `search.Type.SALESORDER` (вместо `search.Type.SALES_ORDER`, если вашей версии NetSuite это не поддерживает).  
3. **Совпадение `tranid`** и реального номера заказов.  
4. **Обработка ошибок** (логгирование, уведомления) и производительность (Map/Reduce).  

Если учесть все эти нюансы — ваш подход будет более полно соответствовать реальному Production‑решению.