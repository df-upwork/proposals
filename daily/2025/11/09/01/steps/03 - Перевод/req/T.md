# 1.
## 1.1. 
`L_SOURCE` ≔ (Русский язык)

## 1.2. 
`L_TARGET` ≔ (English)

# 2.
## 2.1.
`D` ≔ (мой ответ `ꆜ`)

## 2.2.
Содержание `D`:
~~~markdown
1) «I'm currently using plain html/css for the front end. 
It looks outdated. 
What would be a better framework to use with my flask app? 
And what component library should we use?»

Ваше предложение использовать Tailwind CSS для модернизации интерфейса является верным направлением  
Учитывая текущий стек «simple html/css» на Flask, вы используете архитектуру серверного рендеринга, использующей шаблонизатор Jinja2.  
Двумя наиболее популярными и зрелыми библиотеками компонентов для Tailwind CSS являются Flowbite и DaisyUI.  
Основное техническое различие между ними заключается в их зависимости от JavaScript.  
Библиотеки, подобные Flowbite, требуют подключения отдельного файла JavaScript (`flowbite.min.js`) для работы интерактивных элементов, таких как выпадающие меню, модальные окна и вкладки.  
Это добавляет дополнительный клиентский слой, который необходимо инициализировать и которым нужно управлять, что усложняет интеграцию с серверными шаблонами Jinja2.  
Я рекомендую использовать DaisyUI.  
DaisyUI — это «Pure CSS» библиотека, которая устанавливается как Tailwind CSS plugin.  
Она не имеет никакой зависимости от JavaScript и не требует подключения дополнительных скриптов в браузере.  
DaisyUI предоставляет полный набор компонентов (включая интерактивные, реализованные с помощью одного CSS) и более 35 встроенных тем.  
Этот подход позволяет полностью модернизировать интерфейс, как вы и хотели, без добавления ненужной сложности на стороне клиента, сохраняя простоту и надёжность текущей архитектуры Flask.

2) «My app is hosted on Replit using their autoscale deployment with up to 4 machines. 
The app has multiple API endpoints that my dev customers use. 
What happens if there are many requests happening on the same time?
Can my app handle this?»

2.1) Flask, как фреймворк, абсолютно способен обрабатывать высокие нагрузки и обслуживать тысячи одновременных запросов.  
Проблема заключается в том, как Flask запускается в среде разработки, такой как Replit.  
Стандартный шаблон Replit для Flask использует команду `python3 main.py` для запуска приложения, как указано в их документации.  
Этот run command активирует встроенный сервер разработки Flask, также известный как Werkzeug development server.  
Официальная документация Flask категорически предостерегает от использования этого сервера в производственной среде.
В документации он описывается как не предназначенный для обеспечения безопасности, стабильности или эффективности.  
Его фундаментальным ограничением является его синхронная, однопоточная природа.  
Это означает, что Python процесс может выполнять только одну задачу в один момент времени и обрабатывает запросы строго последовательно: один запрос должен полностью завершиться, прежде чем Python процесс начнет обработку следующего.
Если ваше API получает 10 одновременных запросов, и каждый из них занимает 500 ms, первый запрос вернется через 500 ms, а десятый — только через 5000 ms, поскольку все остальные запросы блокируются.
Это приведет к каскадному увеличению времени отклика и массовым отказам по тайм-ауту для клиентов API.

2.2) Для обработки одновременных запросов Flask должен запускаться с использованием производственного WSGI (Web Server Gateway Interface) сервера.  
Отраслевым стандартом для Flask является Gunicorn, чистый Python WSGI HTTP-сервер.  
Gunicorn решает проблему параллелизма путем создания нескольких worker processes.  
Каждый worker process — это отдельный процесс Unix, который загружает полный экземпляр вашего Flask приложения в память, позволяя операционной системе распределять входящие запросы между ними для истинно параллельной обработки.  
Рекомендуемая конфигурация workers часто вычисляется по формуле `(2 × CPU cores) + 1` для балансировки нагрузки.  
Gunicorn также предлагает асинхронные типы worker, такие как gevent или eventlet, которые используют coroutines для обработки тысяч одновременных I/O-bound соединений на одном worker.

2.3) Внедрение Gunicorn является необходимым, но недостаточным шагом, поскольку платформа Replit Autoscale вносит второе, более фундаментальное ограничение. 
Replit Autoscale — это платформа, основанная на scale-to-zero, или «масштабировании до нуля».  
Эта архитектура предназначена для экономии средств путем полного отключения вашего приложения (scale down to zero), когда оно неактивно, что Replit определяет как 15-минутный период без трафика.  
Когда первый запрос поступает к «спящему» приложению, платформа должна инициировать cold start («холодный старт»).  
Cold start — это процесс выделения ресурсов, загрузки контейнера и инициализации Flask, который для сложных приложений Python может занимать от 30 до 40 секунд.  
Задержка cold start напрямую связана с количеством и размером импортируемых Python библиотек при запуске, что означает, что проблема будет усугубляться по мере роста приложения.  
Этот механизм создает второй, катастрофический сценарий сбоя для вашего API: всплеск одновременных запросов к «спящему» приложению приведет к тому, что первый запрос «зависнет» на 30+ секунд, а все остальные получат ошибку тайм-аута от балансировщика нагрузки.  
Это делает Replit Autoscale фундаментально неподходящим для API с dev customers, которые ожидают предсказуемой низкой задержки. 
Обширные отчеты сообщества подтверждают, что Replit оптимизирован для прототипирования и обучения, а не для надежной производственной эксплуатации, указывая на проблемы с производительностью и стабильностью.  
Цель «партнерства на несколько лет» находится в прямом противоречии с выбором Replit в качестве хостинг-платформы.

2.4) Ваш вопрос также выявляет третью, скрытую уязвимость, которая существует, даже если проблемы Gunicorn и cold start решены.  
Если приложение активно и способно масштабироваться, неконтролируемый всплеск запросов представляет собой Denial of Service (DoS) атаку или риск неконтролируемого расходования ресурсов.  
Эта проблема задокументирована как API4:2023 - Unrestricted Resource Consumption в списке OWASP API Security Top 10.  
OWASP определяет API4 как неспособность API защитить себя от чрезмерного потребления ресурсов, таких как CPU, память, или, в данном случае, количество API-вызовов. 
В вашем сценарии один dev customer может, случайно или злонамеренно, отправить миллион запросов, что приведет к Denial of Service для всех других клиентов и к непредсказуемым счетам за compute units от Replit.

2.5) Для решения этих трех проблем требуется комплексная стратегия, состоящая из немедленного внедрения мер контроля и долгосрочной миграции на производственную платформу.


2.6) Для устранения уязвимости OWASP API4 необходимо внедрить Rate Limiting.
Наиболее надежным решением в экосистеме Flask является расширение `Flask-Limiter` (hereafter — `FL`).
`FL` интегрируется с Flask и предоставляет decorators для routes, позволяя настроить детальные правила, такие как 100 per minute или 1000 per day, для конкретных API endpoints.  
Критически важно, что `key_func` может быть настроен на использование API-ключа клиента или `current_user`, обеспечивая Rate Limiting на уровне пользователя, а не IP-адреса.  
Когда клиент превышает этот лимит, `FL` автоматически возвращает HTTP-ошибку «429 Too Many Requests» без задействования логики вашего приложения.  
Это немедленно защищает приложение от злоупотреблений и гарантирует справедливое распределение ресурсов.  
`FL` требует storage backend, такой как Redis или Memcached, для отслеживания лимитов в production среде с несколькими worker, поскольку встроенное `memory://` хранилище не будет синхронизировано между процессами Gunicorn.

2.7) Для обеспечения долгосрочной надежности, предсказуемой производительности и устранения проблемы cold start необходима миграция с Replit на профессиональную PaaS (Platform as a Service).  
Платформы, такие как DigitalOcean App Platform или Railway, специально разработаны для производственного хостинга Flask приложений и предоставляют управляемые контейнеры, которые работают постоянно, что полностью устраняет cold starts.  
Они также предлагают управляемые базы данных PostgreSQL и Redis «в один клик», которые необходимы для `FL` и решения вашей проблемы с race condition.  

3) «I have a simple credit system where a user is deducted one credit per time they use my service. 
Say a user use 4 windows/instances of the web interface in parallell. 
How do I avoid errors in the database regarding the credit deduction?»

3.1) Ваше опасение относительно целостности данных при параллельных запросах абсолютно обосновано и описывает классическую проблему concurrency, известную как Race Condition.
Эта проблема возникает, если логика приложения реализована по паттерну read-modify-write: сначала считать баланс в память Python, вычесть кредит, а затем записать новый баланс обратно в базу данных.
Когда несколько запросов выполняют этот цикл concurrently, они могут считать одно и то же исходное значение до того, как один из них успеет его обновить.
Например, если 4 параллельных запроса одновременно считывают баланс 10, все они вычислят 10 - 1 = 9 и запишут 9, в результате чего будет списан только 1 кредит вместо 4.
3.2) Решение этой проблемы заключается в том, чтобы отказаться от вычислений в Python и делегировать операцию вычитания самой базе данных, используя технику Atomic Updates.
Вместо того чтобы считывать данные, нужно инструктировать базу данных напрямую уменьшить значение в соответствующей колонке с помощью SQL выражения вида `UPDATE users SET credits = credits - 1 WHERE id = :user_id`.
Базы данных, такие как PostgreSQL, гарантируют, что такая операция является atomic, то есть выполняется как единое, неделимое действие.
Это гарантирует корректность результата даже при высокой параллельной нагрузке, поскольку все операции сериализуются на уровне базы данных.
В контексте Flask приложения, использующего SQLAlchemy ORM, это достигается путем использования SQL expressions вместо Python arithmetic.
3.3) Дополнительно, надо обеспечить, что списание кредита и фактическое предоставление услуги происходят в рамках одной database transaction.
Если на любом этапе произойдет ошибка, transaction будет отменена (rollback), гарантируя, что кредиты не будут списаны без предоставления услуги, или наоборот.
Этот подход, сочетающий Atomic Updates и database transactions, полностью устраняет Race Condition и обеспечивает data integrity вашей системы кредитов.
~~~

# 3.
## 3.1.
`D2` ≔ (начальная часть `D`, переведённая с `L_SOURCE` на `L_TARGET`)

## 3.2.
Содержание `D2`:
~~~markdown
~~~

# 4.
## 4.1.
`F` ≔ (фрагмент `D`)

## 4.2.
Содержание `F`:
~~~markdown
STUB
~~~

# 5. `᛭T`
Переведи `F` на `L_TARGET`, с учётом:
- контекста `D`
- `D2`: уже переведённой части `D`
- `᛭O`

# 6. Правила перевода / Общие
## 6.1.
Переводи именно в той стилистике, как написано на `L_SOURCE`.
Не делай перевод более вежливым, чем оригинал.

## 6.2.
Те предложения, которые сейчас полностью на `L_TARGET` — оставь без изменения.

## 6.3.
### 6.3.1.
Не используй Markdown: только plain text.
### 6.3.2.
При этом можно и нужно использовать то форматирование, которое уже есть в оригинале: его не убирай.

## 6.4.
Форматируй перевод в точности как оригинал. 
В частности:
*) каждый абзац должен содержать ровно одно предложение
*) между абзацами не должно оставаться пустых строк.
*) кавычки используй те же, что и в оригинале: «» и ``.

## 6.5.
Не используй жаргон.
Вместо этого используй официальные термины.
### 6.5.1.
В частности, фразы в кавычках используй только в том случае, когда они являются точными цитатами.
Не используй фразы в кавычках для применения жаргонных фраз.
Например, следующий фрагмент текста недопустим, потому что там используется жаргонная фраза «пролетел»: 
```
Например, код, который пушит данные о покупке, подключён асинхронно и загружается с небольшой задержкой, а триггер уже «пролетел».
```

## 6.6.
При обсуждении программного обеспечения используй точные официальные термины на английском языке: именно в том виде, как они указаны в официальной англоязычной документации к этому программному обеспечению.

## 6.7.
### 6.7.1.
Не используй самовольно «you need» и другие подобные обращённые к `ꆜ` фразы, перекладывающие действия на него, если в исходном тексте явно не сказано подобное (типа «вы должны»).
Помни: я пишу `ꆜ`.
Делать в любом случае буду я, а не `ꆜ`.
Именно за то, что описываемую работу делать буду я, `ꆜ` мне будет платить.
Моя задача — показать мою компетенцию и предложить `ꆜ` решение его проблемы, а не переложить решение проблемы на `ꆜ`.

### 6.7.2. Пример
### 6.7.2.1. Пример `F`
```text
Установить и использовать готовый модуль для импорта структурированных данных в Magento.
```
### 6.7.2.2. Примеры допустимого перевода `F`
### 6.7.2.2.1.
```text
Install a ready-made module for importing structured data into Magento.
```
### 6.7.2.2.2.
```text
Installing a ready-made module for importing structured data into Magento.
```
### 6.7.2.3. Пример недопустимого перевода `F`
```text
You need to install a ready-made module for importing structured data into Magento.
```
### 6.7.2.
Не переводи фразы подобные §6.7.2.1, начиная их словом «To».
Пример недопустимого перевода §6.7.2.1:
```text
To install a ready-made module for importing structured data into Magento.
```

### 6.7.3. «It is necessary»
#### 6.7.3.1.
Иногда в контексте §6.7.1 уместно при переводе использовать конструкцию «it is necessary»: она нейтральна и не перекладывает работу на `ꆜ`.
#### 6.7.3.2. Пример `F`
```text
Лучшую из них я намеренно описываю последней (пункт 7): чтобы понять, что она — лучшая, надо сначала увидеть недостатки других.
```
### 6.7.2.3. Примеры допустимого перевода §6.7.3.2
```text
The best of them I intentionally describe last (point 7): to understand why it is the best, it is necessary to first see the disadvantages of the others.
```

## 6.8.
### 6.8.1.
Порой в исходном тексте термины на языке исходного текста дублируются (обычно, в круглых скобках) переводом этих терминов на язык перевода.
### 6.8.2.
Пример:
```text
Реализовать механизм сбора явной обратной связи (Explicit Feedback) в Chatbot Widget.
```
В примере для понятия «явной обратной связи» уже дан правильный перевод этого термина на английский язык: «Explicit Feedback».
### 6.8.3.
Когда ты видишь такие случаи как в §6.8.2, то не надо при переводе дублировать термин.
### 6.8.4.
Например, так переводить текст примера §6.8.2 неправильно:
```text
Implement the mechanism for collecting explicit feedback (Explicit Feedback) in the Chatbot Widget. 
```
В этом неправильном переводе термин «explicit feedback» дублируется.
### 6.8.5.
Правильный перевод в случаях типа §6.8.2 подразумевает убирание дубликата, например:
```text
Implement the mechanism for collecting explicit feedback in the Chatbot Widget. 
```
## 6.9. Правила перевода URL
### 6.9.1.
Если в `F` URL не оформлен посредством синтаксиса Markdown (`[текст URL](URL)`), то тебе запрещено добавлять этот синтаксис.
Вместо этого ты обязан включить URL в перевод в его исходном виде, без добавления `[]()`.
### 6.9.2. Пример
### 6.9.2.1. Пример `F`
```text
В Великобритании она введена в действие посредством «The National Insurance and Industrial Injuries (Turkey) Order, 1961» (S.I. 1961/584): https://www.legislation.gov.uk/uksi/1961/584  
``` 
### 6.9.2.2. Пример правильного перевода `F`
```text
In the United Kingdom, it was given effect by «The National Insurance and Industrial Injuries (Turkey) Order, 1961» (S.I. 1961/584): https://www.legislation.gov.uk/uksi/1961/584
``` 
### 6.9.2.3. Пример неправильного перевода `F`
```text
In the United Kingdom, it was given effect by «The National Insurance and Industrial Injuries (Turkey) Order, 1961» (S.I. 1961/584): [https://www.legislation.gov.uk/uksi/1961/584](https://www.legislation.gov.uk/uksi/1961/584)
``` 
Как видишь, в неправильном переводе URL захерачен в Markdown посредством `[]()`, хотя `F` так не сделано.

## 6.10.
При переводе важное значение имеет `D2`: уже переведённая часть `D`.
Используй её, в частности, чтобы единообразно переводить термины.
Чтобы не получилось так, что в `D2` используется один вариант перевода термина, а в твоём переводе `F` — другой вариант перевода того же самого термина.

## 6.11.
Все числительные должны писаться цифрами (а не прописью).

# 7. Правила перевода / На английский язык
## 7.1.
Не используй сокращения типа «don't». Все подобные фразы пиши полностью: «do not».

## 7.2.
Никогда не переводи понятие «сайт» / «веб-сайт» как «site». 
Вместо этого используй форму «website»: это является более профессиональным.

## 7.3.
### 7.3.1.
Никогда не переводи понятие «пункт нумерованного списка» как «item».
### 7.3.2.
Для пунктов нормативных актов вместо «item» используй тот термин, который принято использовать в данном юридическом контексте: «paragraph», «section» и т.п.
### 7.3.3.
Для всех остальных текстов переводи «item» как «point».

## 7.4.
Вместо «for example» в тексте на английском языке используй «e.g.».
При этом не забывай, что в начале предложения эта фраза должна начинатся с заглавной буквы: «E.g.»