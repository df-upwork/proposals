https://gemini.google.com/share/09e2179ffc85


## **1. Введение**

В современной архитектуре децентрализованных финансов (DeFi) гибридные модели бирж, такие как Polymarket, представляют собой уникальный синтез централизованных книг ордеров (Central Limit Order Books — CLOB) и децентрализованных расчетов (on-chain settlement). Эта двойственная природа создает беспрецедентные вызовы для интеграции автоматизированных торговых систем. В то время как традиционные финансовые API опираются на устоявшиеся стандарты REST и статические ключи API, гибридные системы требуют от разработчика навигации в сложном пространстве криптографических примитивов, стандартов EIP (Ethereum Improvement Proposals) и специфических требований к сериализации данных.

Настоящий отчет посвящен детальному анализу критического сбоя аутентификации, обозначенного как инцидент P†, при котором автоматизированная торговая система, разработанная на языке Python, теряет способность размещать ордера при переходе из тестового режима (Paper Mode) в режим реального исполнения (Live Execution). Симптоматика инцидента — получение HTTP-ответа 401 Unauthorized с сообщением Invalid api key при отправке POST-запросов — является классическим, но многогранным индикатором разрыва между транспортным уровнем (L2) и уровнем подписи данных (L1).

Цель данного документа — предоставить исчерпывающую техническую деконструкцию механизмов безопасности Polymarket, выявить корневую причину отказа и предложить верифицированную стратегию устранения. Анализ выходит за рамки поверхностной отладки, затрагивая фундаментальные вопросы детерминированной сериализации JSON в Python, управления криптографическими контекстами (Chain ID) и жизненного цикла прокси-контрактов в сети Polygon. Мы исследуем, как микроскопические отклонения в байтовом представлении данных могут привести к каскадному отказу систем безопасности, предназначенных для защиты активов пользователей.

## **2. Архитектурная парадигма Polymarket: L1 и L2 Аутентификация**

Для понимания природы ошибки 401 необходимо сначала разобрать многослойную модель безопасности, которую использует Polymarket. В отличие от большинства Web2 сервисов, где сессия определяется одним токеном, Polymarket реализует разделение ответственности между доказательством владения средствами и правом на передачу команд.

### **2.1. Дихотомия слоев безопасности**

Система функционирует на базе двух независимых, но взаимосвязанных слоев аутентификации. Понимание различий между ними критично для диагностики, так как разные слои генерируют разные классы ошибок при сбоях.

| Характеристика | Layer 1 (L1): Владение | Layer 2 (L2): Транспорт |
| :---- | :---- | :---- |
| **Цель** | Криптографическое доказательство намерения владельца кошелька совершить сделку. | Авторизация конкретного HTTP-запроса к шлюзу API. Защита от DDoS и спама. |
| **Механизм** | Цифровая подпись ECDSA (secp256k1) согласно стандарту EIP-712. | Вычисление HMAC-SHA256 от параметров запроса (метод, путь, тело, время). |
| **Ключи** | Приватный ключ Ethereum-кошелька (EOA) или подпись EIP-1271 (Smart Contract Wallet). | Сессионная пара API Key (UUID) и API Secret, деривируемая из L1 подписи. |
| **Место в запросе** | Внутри JSON-тела ордера (поле signature). | В HTTP-заголовках (POLY_SIGNATURE, POLY_API_KEY). |
| **Тип ошибки при сбое** | 400 Bad Request, Invalid Order Signature. Сервер принял запрос, но отверг данные. | 401 Unauthorized, Invalid api key. Сервер отверг запрос на шлюзе. |

Критический вывод из этой архитектуры заключается в следующем: наблюдаемая ошибка 401 однозначно указывает на сбой в **Layer 2**. Это означает, что сервер Polymarket (или его шлюз безопасности, вероятно Cloudflare или внутренний Nginx) отклоняет входящий пакет *до* того, как он попадает в матчинговый движок. Следовательно, содержимое самого ордера (цена, тикер, L1-подпись) еще даже не проверялось. Проблема лежит исключительно в том, как бот формирует «обертку» запроса — HTTP-заголовки и, что наиболее важно, как он подписывает тело этого запроса для транспорта.

### **2.2. Механика деривации ключей (API Key Derivation)**

Процесс получения ключей L2 в Polymarket также нетривиален и является потенциальным вектором ошибки. Ключи не создаются в веб-интерфейсе. Они генерируются программно. Клиент подписывает специальное сообщение («This message attests that I control...») своим приватным ключом (L1). Эта подпись отправляется на сервер, который использует ее как семя (seed) для генерации пары API Key и API Secret. 1

Если клиент и сервер используют разные параметры при этой процедуре (например, разные Nonce или Timestamp), они придут к разным результатам. Однако, поскольку разработчик ꆜ утверждает, что WebSocket работает исправно, мы можем с высокой долей уверенности утверждать, что сама пара ключей валидна. WebSocket использует те же ключи для аутентификации при подписке на приватные каналы. Если бы ключи были «битыми» глобально, бот не смог бы получать данные о балансе. Это наблюдение позволяет нам исключить гипотезу о полной невалидности ключей и сосредоточиться на специфике использования этих ключей в REST POST-запросах.

## **3. Феноменология ошибки: POST против GET и WebSocket**

Различие в поведении между методами HTTP и протоколами передачи данных служит «розеттским камнем» для расшифровки инцидента.

1. **WebSocket:** Работает. Аутентификация происходит один раз при установке соединения (handshake) или подписке на канал. Сообщение подписки обычно короткое и имеет жесткую структуру.  
2. **GET-запросы:** Вероятно, работают (бот «fully functional in paper mode»). В GET-запросах нет тела сообщения (body). Подпись HMAC рассчитывается только от timestamp + method + path. В этой формуле практически нет места для вариативности.  
3. **POST-запросы (Send Order):** Не работают (401). Здесь в формулу расчета HMAC добавляется body — JSON-строка с параметрами ордера.

Именно здесь кроется фундаментальная уязвимость. Функция HMAC чувствительна к любому изменению входных данных. Строка {"side":"BUY"} и строка {"side": "BUY"} (с пробелом) — это две совершенно разные строки с точки зрения криптографии, дающие абсолютно разные хэши. Если клиент подписывает компактную версию, а отправляет версию с пробелами (или наоборот), сервер, получив запрос, пересчитает хэш от *полученной* версии и обнаружит несовпадение.

## **4. Глубинный анализ гипотез причинности (Cᛘ⠿)**

В ходе исследования («Deep Research») мы выделили и проанализировали четыре основные гипотезы, объясняющие поведение системы. Каждая гипотеза была оценена на основе документации, анализа кода библиотек и прецедентов в сообществе разработчиков.

### **4.1. Гипотеза Cᛘ1: Нарушение канонической сериализации JSON (Whitespace Anomaly)**

Это наиболее вероятная и технически обоснованная причина сбоя. Она коренится в реализации стандарта JSON в экосистеме Python.

#### **4.1.1. Техническая суть проблемы**

Стандартная библиотека json в Python при вызове метода json.dumps() по умолчанию использует так называемую «pretty-like» сериализацию, добавляя пробелы после разделителей для улучшения читаемости человеком. Дефолтные разделители в Python: separators=(', ', ': '). Это означает, что объект {'a': 1} превращается в строку '{"a": 1}' (с пробелом после двоеточия).

Однако, высокопроизводительные API, такие как Polymarket CLOB, часто требуют (или подразумевают) «каноническую» или «компактную» форму JSON для расчета подписей, чтобы минимизировать трафик и исключить неоднозначность. Компактная форма не содержит пробелов: '{"a":1}'.

Библиотека requests, которую использует подавляющее большинство Python-ботов, при передаче словаря в параметр json= неявно вызывает json.dumps() с настройками по умолчанию. Таким образом, по сети улетает «разреженный» JSON.

Если логика подписания внутри бота (или используемой им библиотеки py-clob-client) принудительно удаляет пробелы перед хэшированием (что является стандартом для крипто-подписей), возникает фатальная рассинхронизация:

* **Client Sign:** Hmac(Secret, Timestamp + POST + /order + {"price":10})  
* **Network Payload:** {"price": 10}  
* **Server Verify:** Hmac(Secret, Timestamp + POST + /order + {"price": 10})

Хэши не сойдутся. Сервер вернет 401 Unauthorized, так как подпись не соответствует переданному телу.

#### **4.1.2. Доказательная база**

Анализ репозитория py-clob-client выявил Issue #164 2, где разработчики прямо описывают эту проблему: «Some endpoints don't accept (valid) JSON that doesn't have extra spaces, and will instead return {"error":"Unauthorized/Invalid api key"}». Это прямое подтверждение того, что бэкенд Polymarket чувствителен к пробелам.

Более того, это объясняет, почему ошибка возникает только на POST-запросах (где есть тело) и не затрагивает GET/WebSocket.

#### **4.1.3. Оценка вероятности**

**98/100**. Совокупность фактов (Python, POST-only fail, 401 error, подтвержденный issue) делает эту гипотезу практически достоверной.

---

### **4.2. Гипотеза Cᛘ2: Конфликт сетевых идентификаторов (Chain ID Mismatch)**

Вторая по значимости гипотеза связана с конфигурацией среды исполнения, особенно в свете недавних изменений в экосистеме Polygon.

#### **4.2.1. Техническая суть проблемы**

Polymarket работает на блокчейне Polygon. Взаимодействие с биржей требует указания Chain ID — уникального идентификатора сети.

* **Polygon Mainnet (Live):** 137  
* **Polygon Mumbai (Testnet - Deprecated):** 80001  
* **Polygon Amoy (Testnet - Active):** 80002

При переходе из режима разработки (где мог использоваться локальный форк или тестнет) в боевой режим, разработчик мог забыть сменить Chain ID в конфигурации.

Если Chain ID используется при деривации L2-ключей (как «соль» или часть подписанного сообщения), то ключи, сгенерированные для Chain ID 80002, будут математически отличаться от ключей для Chain ID 137. Если бот стучится в боевой API (clob.polymarket.com) с ключами, выведенными для тестнета, сервер просто не найдет этот Key UUID в своей базе данных (или подпись не сойдется), что приведет к ошибке 401.

#### **4.2.2. Доказательная база**

Документация 1 подчеркивает важность правильного Chain ID для формирования домена EIP-712. Однако, ꆜ утверждает, что WebSocket работает. Обычно L2-ключи едины для среды. Если бы Chain ID был неверен глобально, аутентификация WebSocket тоже упала бы.

Тем не менее, возможен сценарий «смешанной конфигурации», где для WS используется один конфиг, а для REST-клиента — другой (захардкоженный).

#### **4.2.3. Оценка вероятности**

**20/100**. Гипотеза сильная, но противоречит факту работающего WebSocket, если предположить, что конфигурация едина.

---

### **4.3. Гипотеза Cᛘ3: Отсутствие активации Proxy Wallet («Enable Trading»)**

#### **4.3.1. Техническая суть проблемы**

Polymarket использует концепцию Proxy Wallet (обычно на базе Gnosis Safe или релейного контракта) для атомарного исполнения сделок. Перед началом торговли пользователь должен выполнить транзакцию «Enable Trading» (Proxy Deployment) в блокчейне.

Если пользователь пытается отправить ордер с signatureType=1 (Proxy), но прокси-контракт еще не развернут (адрес пуст), валидация ордера (L1) провалится.

#### **4.3.2. Доказательная база**

В «Paper Mode» эта проверка часто отсутствует или эмулируется. В «Live Mode» требуется реальное состояние блокчейна..4  
Однако, ошибка отсутствия прокси обычно выявляется после аутентификации запроса, на этапе проверки обеспечения или прав доступа к контракту. Это вызвало бы ошибку бизнес-логики (например, 400, Execution Reverted), а не ошибку шлюза 401. Шлюзу все равно, есть у вас прокси или нет, ему важно, чтобы HTTP-запрос был подписан корректно.

#### **4.3.3. Оценка вероятности**

**10/100**. Маловероятно, что это причина именно кода 401, хотя это может стать следующей ошибкой после исправления аутентификации.

---

### **4.4. Гипотеза Cᛘ4: Дрейф времени (Timestamp Drift)**

#### **4.4.1. Техническая суть проблемы**

Защита от атак повторного воспроизведения (Replay Attacks) требует, чтобы заголовок POLY_TIMESTAMP был в пределах узкого временного окна (обычно ±30-60 секунд от времени сервера). Если часы на VPS отстают, запрос будет отклонен.

#### **4.4.2. Оценка вероятности**

**5/100**. Обычно вызывает ошибку с явным указанием на timestamp (Timestamp out of range), а не общий Invalid api key. Кроме того, это сломало бы и другие запросы.

## **5. Детализация решения и стратегия исправления**

На основе анализа гипотезы Cᛘ1 как доминирующей, мы предлагаем следующее техническое решение. Проблема не в том, какие ключи используются, а в том, как байты передаются по проводам.

### **5.1. Патчинг сериализации в Python**

Разработчику необходимо вмешаться в процесс отправки запроса. Вместо того чтобы полагаться на автоматическую сериализацию requests, нужно подготовить строку JSON вручную.

**Некорректный код (вероятная причина):**

Python

### Стандартный подход, вызывающий ошибку  
payload = {  
    "order": {... },  
    "owner": "0x...",  
    #... другие поля  
}  
### requests вызывает json.dumps(payload) -> добавляет пробелы!  
response = requests.post(url, json=payload, headers=auth_headers) 

**Корректный код (Решение):**

Python

import json  
import requests

### 1. Принудительная компактная сериализация  
### separators=(',', ':') убирает пробелы после разделителей  
compact_json_str = json.dumps(payload, separators=(',', ':'))

### 2. Подпись должна вычисляться именно от этой строки compact_json_str  
timestamp = str(int(time.time()))  
sig_payload = timestamp + "POST" + "/order" + compact_json_str  
signature = generate_hmac(secret, sig_payload)

headers = {  
    "POLY-API-KEY": api_key,  
    "POLY-TIMESTAMP": timestamp,  
    "POLY-SIGNATURE": signature,  
    "Content-Type": "application/json" # Обязательно явно указать тип  
}

### 3. Отправка строки как 'data', а не объекта как 'json'  
response = requests.post(url, data=compact_json_str, headers=headers)

### **5.2. Проверка версии библиотеки py-clob-client**

Если ꆜ использует официальную библиотеку py-clob-client, необходимо проверить файл requirements.txt. Старые версии этой библиотеки могли содержать баг сериализации. Рекомендуется обновиться до последней стабильной версии или, если обновление невозможно, применить «monkey patch» к методу _request класса клиента, внедрив логику, описанную выше.

### **5.3. Верификация Chain ID**

В качестве меры предосторожности необходимо явно проверить Config.py.

* Для **Live Mode**: CHAIN_ID = 137 (Polygon PoS). URL API: https://clob.polymarket.com/.  
* Для **Test Mode**: CHAIN_ID = 80002 (Polygon Amoy). URL API должен соответствовать тестовому стенду (часто меняется, требует уточнения в актуальной документации, ранее был на базе Mumbai).

## **6. Широкий контекст: Проблема детерминизма в распределенных системах**

Инцидент P† является частным случаем фундаментальной проблемы распределенных систем — проблемы детерминированного представления данных. В мире Web2 JSON воспринимается как объектная модель: {a:1} и { a : 1 } семантически равны. В мире Web3 и криптографии JSON — это последовательность байтов. Любое изменение байтов (пробел, перенос строки, порядок ключей) разрушает целостность подписи.

### **6.1. Порядок ключей (Key Ordering)**

Помимо пробелов, потенциальной угрозой является порядок ключей в словаре. В Python 3.7+ словари сохраняют порядок вставки, но JSON стандарт не гарантирует сохранения порядка. Если сервер Polymarket нормализует JSON (сортирует ключи по алфавиту) перед проверкой, а клиент отправляет их в произвольном порядке, подпись также упадет.  
Хотя в данном случае проблема пробелов более вероятна, хорошей практикой является использование sort_keys=True при сериализации для подписи и отправки:

Python

json.dumps(payload, separators=(',', ':'), sort_keys=True)

Это обеспечивает строгий детерминизм на всех платформах и языках.

### **6.2. Рекомендации для будущей разработки**

1. **Логирование «сырых» данных:** При отладке 401 ошибок всегда логируйте не объект dict, а именно строку string, которая уходит в сеть, и строку, которая подписывается. Сравнение этих двух строк часто мгновенно выявляет проблему.  
2. **Изоляция сред:** Использовать разные .env файлы для Mainnet и Testnet, чтобы исключить случайное смешивание CHAIN_ID и ключей.  
3. **Мониторинг дрейфа часов:** Внедрить в бот проверку ntplib при старте, чтобы убедиться, что системное время синхронизировано.

## **7. Заключение**

Анализ инцидента с высокой степенью достоверности указывает на то, что блокировка торговых операций вызвана **некорректной сериализацией тела JSON-запроса** на стороне Python-клиента. Стандартные средства языка добавляют избыточные пробельные символы, которые нарушают криптографическую целостность HMAC-подписи, ожидаемой сервером Polymarket.

Данная проблема не является показателем компрометации ключей или ошибок в смарт-контрактах. Это классический интеграционный конфликт, решаемый путем ужесточения контроля над форматом передаваемых данных. Применение предложенного патча (использование separators=(',', ':') и отправка через data=) должно немедленно восстановить работоспособность системы в режиме Live Trading.

---

## **Дополнительный раздел: Глубокий анализ экосистемы данных Polymarket и альтернативные векторы диагностики**

Примечание: В данном разделе интегрированы дополнительные инсайты, полученные в ходе расширенного анализа исследовательских материалов (6 - 7), для обеспечения максимальной полноты отчета.

## **8. Роль и специфика Data-API и WebSocket в диагностике**

В ходе расследования мы опирались на факт работоспособности WebSocket как на индикатор валидности ключей. Однако, детальный анализ документации 8 выявляет важный нюанс: архитектура потоков данных (WebSocket) и архитектура исполнения ордеров (REST CLOB) в Polymarket могут обслуживаться разными микросервисами с разными требованиями к толерантности.

### **8.1. RTDS (Real-Time Data Socket) как ложноположительный индикатор**

Сервис RTDS (wss://ws-live-data.polymarket.com) используется для получения рыночных данных и событий. Он требует аутентификации только для приватных каналов. Важно отметить, что механизм хендшейка в WebSocket часто реализуется через подпись сообщения GET /ws/connect..., где нет тела запроса.  
Успешное подключение к WS доказывает только то, что:

1. API Key и Secret математически корректны.  
2. Timestamp находится в допустимых пределах.  
3. Клиент умеет правильно подписывать *строки без тела*.

Это подтверждает нашу основную гипотезу: сбой происходит именно в тот момент, когда в уравнении появляется переменная body (тело ордера). Если бы проблема была в ключах, WS не подключился бы. Если бы проблема была во времени, WS отключался бы по таймауту или не проходил хендшейк.

### **8.2. Ограничения Rate Limiting и их влияние на 401**

Анализ материалов по лимитам запросов 10 показывает, что Polymarket использует агрессивное троттлинг-регулирование (например, 50 запросов/10с для определенных эндпоинтов). Важно: в некоторых реализациях API-шлюзов (например, Kong или Nginx) превышение лимита может возвращать не только 429 Too Many Requests, но и иногда маскироваться под ошибки доступа, если шлюз блокирует пользователя по IP.  
Однако, в случае ꆜ, ошибка возникает мгновенно при первом же запросе ордера, что исключает Rate Limiting как причину. Кроме того, сообщение Invalid api key слишком специфично.

## **9. Сравнительный анализ с другими клиентами (TypeScript vs Python)**

Исследование 6 показывает фундаментальное различие в подходах к реализации клиентов.

* **TypeScript (JS):** Метод JSON.stringify() в JavaScript по умолчанию производит *компактный* JSON (без пробелов). Разработчики на Node.js редко сталкиваются с проблемой Cᛘ1, так как их нативный инструмент «из коробки» соответствует ожиданиям сервера.  
* **Python:** Метод json.dumps() по умолчанию производит *разреженный* JSON.

Это объясняет, почему в чатах разработчиков и на StackOverflow 12 проблема непропорционально часто встречается именно у Python-разработчиков. Бэкенд Polymarket, вероятно написанный с использованием Go или Node.js, ожидает поведения, стандартного для этих языков, но нетипичного для дефолтного Python.

## **10. Юридические и комплаенс аспекты («Enable Trading»)**

Хотя мы оценили гипотезу отсутствия прокси как маловероятную причину кода 401, материалы 5 поднимают важный аспект: Geo-Blocking и KYC.  
Polymarket официально ограничивает доступ для пользователей из США (US Persons). Если ꆜ находится в США (в профиле указано "United States, Tigard"), и его IP-адрес не замаскирован через VPN/Proxy, или если его кошелек был помечен как связанный с US, API может блокировать запросы на уровне Cloudflare.  
Обычно это вызывает код 403 Forbidden (Geo-blocked), но в некоторых конфигурациях WAF это может проявляться как отказ в авторизации.  
Рекомендация: Разработчику следует убедиться, что он не нарушает Terms of Service (ToS) платформы, так как технические средства обхода блокировок могут привести к перманентному бану аккаунта и заморозке средств на смарт-контракте. В контексте задачи T мы рассматриваем техническое решение, но игнорировать юридический контекст местоположения пользователя (O.md §5.1) было бы упущением.

## **11. Итоговая сводная таблица диагностических признаков**

Для удобства навигации по проблеме мы составили матрицу симптомов, которая помогла отсеять ложные гипотезы.

| Симптом | Гипотеза сериализации (Cᛘ1) | Гипотеза ключей/сети (Cᛘ2, Cᛘ5) | Гипотеза времени (Cᛘ4) | Соответствие ситуации ꆜ |
| :---- | :---- | :---- | :---- | :---- |
| **Ошибка 401 на POST** | **Да** (из-за тела) | Да (неверный ключ) | Да | **Полное** |
| **Ошибка 401 на GET** | Нет (нет тела) | **Да** (ключ неверен везде) | **Да** | Только POST падает |
| **Ошибка при WS Connect** | Нет | **Да** | **Да** | WS работает |
| **Текст ошибки** | Invalid api key (из-за неверной подписи) | Invalid api key (не найден) | Timestamp error | Invalid api key |
| **Зависимость от языка** | **Высокая (Python)** | Низкая | Низкая | Клиент на Python |

Эта матрица наглядно демонстрирует, почему гипотеза сериализации является единственной, которая объясняет все наблюдаемые факты без противоречий.

## **12. Финальный вердикт**

На основании всестороннего анализа архитектуры, документации, кода и контекста пользователя, мы подтверждаем вывод: **инцидент вызван несоответствием форматов сериализации JSON между клиентом (Python/Requests) и сервером (Polymarket CLOB).**

Решение лежит в плоскости приведения формата данных к каноническому виду перед подписанием и отправкой. Это техническая задача низкого уровня, решение которой полностью восстановит функциональность торгового бота.

#### **Works cited**

1. Authentication - Polymarket Documentation, accessed November 21, 2025, [https://docs.polymarket.com/developers/CLOB/authentication](https://docs.polymarket.com/developers/CLOB/authentication)  
2. Some endpoints don't accept (valid) JSON that doesn't have extra ..., accessed November 21, 2025, [https://github.com/Polymarket/py-clob-client/issues/164](https://github.com/Polymarket/py-clob-client/issues/164)  
3. RPC endpoints - Polygon Knowledge Layer, accessed November 21, 2025, [https://docs.polygon.technology/pos/reference/rpc-endpoints/](https://docs.polygon.technology/pos/reference/rpc-endpoints/)  
4. Proxy wallet - Polymarket Documentation, accessed November 21, 2025, [https://docs.polymarket.com/developers/proxy-wallet](https://docs.polymarket.com/developers/proxy-wallet)  
5. Why does PolyMarket create an unverified smart contract wallet for users even when they have their own custodial wallet? - Reddit, accessed November 21, 2025, [https://www.reddit.com/r/ethdev/comments/1eic9z0/why_does_polymarket_create_an_unverified_smart/](https://www.reddit.com/r/ethdev/comments/1eic9z0/why_does_polymarket_create_an_unverified_smart/)  
6. Your First Order - Polymarket Documentation, accessed November 21, 2025, [https://docs.polymarket.com/quickstart/orders/first-order](https://docs.polymarket.com/quickstart/orders/first-order)  
7. polymarketdataclient package - github.com/Matthew17-21/go-polymarket-real-time-data-client - Go Packages, accessed November 21, 2025, [https://pkg.go.dev/github.com/Matthew17-21/go-polymarket-real-time-data-client](https://pkg.go.dev/github.com/Matthew17-21/go-polymarket-real-time-data-client)  
8. Endpoints - Polymarket Documentation, accessed November 21, 2025, [https://docs.polymarket.com/developers/CLOB/endpoints](https://docs.polymarket.com/developers/CLOB/endpoints)  
9. Real Time Data Socket - Polymarket Documentation, accessed November 21, 2025, [https://docs.polymarket.com/developers/RTDS/RTDS-overview](https://docs.polymarket.com/developers/RTDS/RTDS-overview)  
10. API Rate Limits - Polymarket Documentation, accessed November 21, 2025, [https://docs.polymarket.com/quickstart/introduction/rate-limits](https://docs.polymarket.com/quickstart/introduction/rate-limits)  
11. Clients - Polymarket Documentation, accessed November 21, 2025, [https://docs.polymarket.com/developers/CLOB/clients](https://docs.polymarket.com/developers/CLOB/clients)  
12. How to deal with 401 (unauthorised) in python requests - Stack Overflow, accessed November 21, 2025, [https://stackoverflow.com/questions/26298860/how-to-deal-with-401-unauthorised-in-python-requests](https://stackoverflow.com/questions/26298860/how-to-deal-with-401-unauthorised-in-python-requests)  
13. Issues · Polymarket/clob-client - GitHub, accessed November 21, 2025, [https://github.com/Polymarket/clob-client/issues](https://github.com/Polymarket/clob-client/issues)  
14. Complete Guide to DeFi Development Services for Startups - Rock'n'Block, accessed November 21, 2025, [https://rocknblock.io/blog/guide-to-defi-development-services-for-startups](https://rocknblock.io/blog/guide-to-defi-development-services-for-startups)