Ниже опишу общий подход к тому, как можно реализовать автоматическую проверку стоков основных и «апгрейдных» (upsell) продуктов на странице товара (PDP), чтобы при отсутствии товара на складе соответствующая опция «засераялась» (“greyed out”) и становилась недоступной для покупки.

---

## 1. Где хранить связи «базовый товар → апгрейдный товар»

Чтобы Magento «знала», какие SKU являются «апгрейдом» для данного «базового» товара, вам потребуется место, где эти связи будут храниться. Чаще всего делают одно из двух:

1. **Отдельный кастомный атрибут**  
   - Допустим, создаём в системе атрибут `upgrade_skus`, где хранится список (или JSON) SKU-апгрейдов для каждого товара.  
   - В админке на странице редактирования товара (базового) менеджер вносит, какие именно SKU апгрейдов возможны.  
   - Параллельно можно добавить поля для текста под иконку “i” (информационное окошко), если нужно вывести дополнительное описание апгрейда.

2. **Отдельная сущность (таблица) или Custom Option**  
   - Можно сделать совсем отдельный reference-таблицу в базе (через собственный модуль) и там хранить пары: `product_id` → `upgrade_product_id`, и плюс нужные поля (название/описание апгрейда, ценовая надбавка и т.д.).  

Подход с атрибутом часто проще в настройке с точки зрения «быстрых правок» через админку (особенно если апгрейдов не супер много). Если же вариантов очень много и/или нужна гибкая логика, тогда лучше пойти в сторону отдельной сущности/таблицы и UI-Form для привязок.  

---

## 2. Логика проверки наличия на складе (stock check)

### 2.1. Как получать данные о наличии?

В Magento 2 основным способом узнать, есть ли товар в наличии, являются объекты/интерфейсы:

- `Magento\CatalogInventory\Api\StockRegistryInterface`  
- `Magento\InventoryApi\Api\SourceItemsBySkuInterface` (если настроен MSI – Multi-Source Inventory)  
- или в более новых версиях через `Magento\InventorySalesApi\Api\IsProductSalableInterface` и т.д.  

Какой именно сервис использовать, зависит от того, **включён ли у вас Multi-Source Inventory (MSI)**. Если да, то вам нужно будет получать данные из соответствующих интерфейсов Inventory. Если нет (старый формат), чаще используют `StockRegistryInterface`.

### 2.2. Где именно делать запрос к стоку?

1. **На сервере во время формирования PDP**  
   - При загрузке PDP (product detail page) вы получаете SKU базового товара (допустим, `12345`) и список SKU апгрейдов (например, `12345S`, `12345X` и т.д.).  
   - Далее один раз вызываете нужный stock-сервис для каждого SKU (или берёте сразу массив SKU и запрашиваете массово – если используете метод, который работает с массивом, что предпочтительнее по производительности).  
   - Возвращаете на фронт уже структуру вида:  
     ```json
     {
       "12345": { "is_in_stock": true },
       "12345S": { "is_in_stock": false },
       ...
     }
     ```
   - На фронте (через knockout.js или ваш JS) проставляете класс “greyed out”/“disabled” для тех опций, у которых `is_in_stock = false`.

2. **Через Ajax запрос при выборе опций**  
   - Можно сделать так, чтобы при «выборе» апгрейда у пользователя во фронте отстреливал Ajax-запрос к вашему контроллеру/экшену. Тот проверяет наличие в стоке и отвечает, можно ли добавить в корзину.  
   - Но в большинстве UX-кейсов удобнее видеть «серую/недоступную» опцию сразу, не дожидаясь клика от пользователя.  

Обычно делают **первый вариант** – вы на бэкенде при формировании страницы PDP сразу узнаёте наличие всех возможных SKU, а на фронтенде показываете, какие из них доступны.  

---

## 3. Вариант архитектуры (шаг за шагом)

1. **Добавить кастомный атрибут** (или дополнительную таблицу) для хранения списка апгрейдных SKU, их описаний и наценки.  
2. **Разработать свой блок / ViewModel** в Magento, который:  
   - На этапе сборки PDP вычитывает текущий `product`, берёт из него основной SKU (допустим, `12345`).  
   - Считывает все связанные апгрейдные SKU (допустим, [`12345S`, `12345X`]).  
   - Через сервис stock-менеджмента делает массовый запрос на наличие.  
   - Формирует структуру данных (PHP-массив), которую потом отдаёт в шаблон (phtml/knockout) для рендера.  
3. **В phtml/knockout.js** (шаблон PDP) получаете структуру с инфой о стоке для каждого SKU. Для каждого апгрейда:  
   - Если `is_in_stock` = false, рисуете «disabled» опцию, делаете её неактивной и т.д.  
   - Если `is_in_stock` = true, всё стандартно.  
4. **При добавлении в корзину** (Add to Cart) если пользователь выбрал апгрейд, формируете тот самый «заменённый SKU» (вместо `12345`, идёт `12345S`).  
   - Либо через кастомную логику в `Add to Cart` контроллере (до отправки в `Quote`) подменяете `product_sku`.  
   - Либо используете некий «виртуальный» Configurable или Custom Option, но проще иногда напрямую подменять SKU на этапе добавления в корзину.

---

## 4. Особые нюансы

1. **Multi-Source Inventory (MSI)**  
   - Если у вас несколько складов, то вам нужно учитывать, что стандартный `is_in_stock` может зависеть от правил распределения. Возможно, вам надо будет сделать проверку через `IsProductSalableInterface` с учётом source-списка и т.д.  
2. **Кэширование**  
   - Учтите, что проверка стока может меняться достаточно часто, а страница PDP обычно кэшируется. Нужно либо использовать «hole punching»/Ajax для динамического отображения стока, либо уменьшить TTL кэша, либо грамотно организовать обнуление кэшей при изменении стока (Invalidate cache).  
3. **Скорость**  
   - Если апгрейдов у одного товара может быть 5–10, то не страшно. Если речь про сотни апгрейдов, нужно будет оптимизировать запросы (делать массовый запрос к стоку, а не циклом вызывать сервисы).  

---

## 5. Итоговая схема в упрощённом виде

1. **Админка**:  
   - У каждого «базового» товара есть дополнительное поле (атрибут) для привязки апгрейдных SKU и их наценки/описания.  

2. **При загрузке PDP**:  
   1. Magento (через ваш кастомный блок/ViewModel) берёт базовый товар → достаёт список апгрейдных SKU.  
   2. Массово делает запрос к stock-сервису, чтобы узнать `is_in_stock` для [ baseSKU, upgradeSKU1, upgradeSKU2, … ].  
   3. Собирает JSON (или массив) вида:  
      ```json
      {
        "baseSKU": { "in_stock": true,  "price": 500 },
        "upgradeSKU1": { "in_stock": false, "price": 600 }, 
        "upgradeSKU2": { "in_stock": true,  "price": 650 } 
      }
      ```
   4. Передаёт этот массив в шаблон.

3. **Фронт (phtml/knockout)**:  
   - Отрисовывает радио-кнопки (или селекты) «базовый вариант / upgrade1 / upgrade2»;  
   - Если `upgradeSKU1.in_stock = false` – показываем «серым»/disabled.  
   - Рядом показываем наценку (+£100, +£150 и т.д.), вычисленную как `price_upgrade - price_base`.  

4. **При нажатии “Add to cart”**:  
   - Если пользователь выбрал «upgradeSKU1» (допустим, 12345S), а он «in stock», передаём в корзину именно `12345S`.  
   - Если он не в наличии, кнопка недоступна для выбора.

---

### Резюме

Таким образом, реализация «серой»/недоступной опции для апгрейда сводится к тому, чтобы при загрузке страницы товара динамически проверить (через сток-сервис Magento 2) наличие всех возможных SKU и отобразить статус доступности во фронтенде. Затем при добавлении в корзину подменяем базовый SKU на SKU выбранного апгрейда, если тот в наличии.