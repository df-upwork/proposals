Ниже приведён пример того, **как** конкретно задействовать обработку ошибок и логирование в SuiteScript 2.x (включая Map/Reduce или Scheduled Script). Будем считать, что мы создаём Scheduled Script, который подключается к SFTP, скачивает файлы, обрабатывает их и обновляет записи в NetSuite.

## 1. Пример структуры SuiteScript-файла

Допустим, у нас есть файл `Import3PLConfirmations.js`, где мы:

- Подключаем модули `N/log` и `N/error` для логирования и генерации ошибок.
- Используем `try...catch` блоки в ключевых местах кода (например, при подключении к SFTP, при парсинге данных и т. д.).

**Обратите внимание**: в SuiteScript 2.x использовать глобальный объект `log` можно двумя способами:  
1. **Через импорт**: `define(['N/log'], function(log) { ... })` и далее `log.debug(...)`.  
2. **Через глобальный объект**: `log.debug(...)` без явного импорта.  

Выбор зависит от того, какая у вас версия фреймворка (часть проектов требует явный импорт). В примере ниже показан вариант с импортом.

```javascript
/**
 * @NApiVersion 2.x
 * @NScriptType ScheduledScript
 */
define(['N/log', 'N/error', 'N/sftp', 'N/file', 'N/record'],
  function(log, error, sftp, file, record) {

    function execute(context) {
      try {
        // 1. Подключаемся к SFTP
        var connection = sftp.createConnection({
          username: 'SFTP_USERNAME',
          passwordGuid: '*******', // или secureCredential
          url: 'SFTP_HOST',
          directory: '/inbound'
          // ... другие настройки
        });

        log.debug({
          title: 'SFTP',
          details: 'Connection established successfully.'
        });

        // 2. Получаем список файлов
        var fileList = connection.list({
          path: '/inbound'
        });

        // 3. Перебираем файлы
        fileList.forEach(function(remoteFile) {
          try {
            // Пример: пропускаем не-CSV файлы (или проверяем название)
            if (!remoteFile.name.endsWith('.csv')) {
              log.debug({
                title: 'Skip file',
                details: 'Skipping file: ' + remoteFile.name
              });
              return;
            }

            // 3.1. Скачиваем конкретный файл
            var fileContents = connection.download({
              path: '/inbound/' + remoteFile.name
            });
            log.debug({
              title: 'File Downloaded',
              details: 'Downloaded: ' + remoteFile.name
            });

            // 3.2. Сохраняем файл в NetSuite File Cabinet (опционально)
            var nsFile = file.create({
              name: remoteFile.name,
              fileType: file.Type.CSV,
              contents: fileContents.getContents()
            });
            nsFile.folder = 12345; // internal ID папки в File Cabinet
            var fileId = nsFile.save();

            // 3.3. Парсим содержимое CSV (простым split или другим методом)
            var csvData = fileContents.getContents().split('\n');
            csvData.forEach(function(line, idx) {
              if (idx === 0) return; // Пропустим заголовок, если он есть
              var fields = line.split(',');

              // Предположим: fields[0] - это ID заказа (Sales Order)
              // fields[1] - это статус или tracking number

              try {
                // 3.3.1. Обновляем заказ в NetSuite
                // (упрощённо - через поиск записи, update и т.п.)
                var salesOrderId = searchForSalesOrder(fields[0]); // псевдофункция
                if (salesOrderId) {
                  record.submitFields({
                    type: record.Type.SALES_ORDER,
                    id: salesOrderId,
                    values: {
                      custbody_3pl_status: fields[1] // к примеру, поле для статуса
                    }
                  });
                  log.debug({
                    title: 'Order Updated',
                    details: 'Order ' + fields[0] + ' updated with status ' + fields[1]
                  });
                }
              } catch (updateErr) {
                // Ловим ошибки на этапе апдейта конкретного заказа
                log.error({
                  title: 'Order Update Error',
                  details: 'Order: ' + fields[0] + ', Error: ' + updateErr.message
                });
              }
            });

            // 3.4. Переносим или удаляем файл на SFTP, чтобы не загружать повторно
            // connection.remove({ path: '/inbound/' + remoteFile.name });
            // ИЛИ
            // connection.move({
            //   fromPath: '/inbound/' + remoteFile.name,
            //   toPath: '/processed/' + remoteFile.name
            // });

          } catch (fileProcessErr) {
            // Ловим ошибки скачивания / чтения файла
            log.error({
              title: 'File Process Error',
              details: 'File: ' + remoteFile.name + ', Error: ' + fileProcessErr.message
            });
          }
        });

      } catch (err) {
        // Ловим любые ошибки на уровне всей функции execute
        log.error({
          title: 'SFTP Script Error',
          details: err
        });

        // Можно сгенерировать «бросок» системной ошибки NetSuite, 
        // чтобы отразить её в статусе выполнения скрипта
        throw error.create({
          name: 'SFTP_SCRIPT_ERROR',
          message: 'Error in SFTP integration: ' + err.message,
          notifyOff: false // true - если не хотим системного уведомления
        });
      }
    }

    // Псевдо-функция для поиска SalesOrder по внешнему ID или номеру
    function searchForSalesOrder(orderNumber) {
      // Здесь могла бы быть логика Saved Search
      // Возвращаем внутренний ID найденного заказа
      return 123; // условно
    }

    return {
      execute: execute
    };
});
```

### Ключевые моменты кода:

1. **`try...catch`**:
   - Используется вокруг всего процесса (вызова `sftp.createConnection`, скачивания списков файлов, перебора элементов массива). Это защищает от «падения» скрипта при любой ошибке.  
   - Внутри цикла `fileList.forEach` также есть отдельный `try...catch`, чтобы при ошибках в обработке конкретного файла не «рушить» весь процесс.  
   - При парсинге каждой строки CSV и обновлении заказа — ещё один «try...catch», чтобы не останавливать обработку остальных строк.

2. **Логирование** с помощью `log` (модуль `N/log`):
   - `log.debug({ title, details })` — для отладочной (debug) информации.  
   - `log.error({ title, details })` — для сообщений об ошибках, которые удобнее отслеживать в NetSuite.  
   - В SuiteScript также доступны `log.audit` и `log.emergency`, которые отличаются приоритетами и уровнем серьёзности сообщений.

3. **Генерация «системной» ошибки** через `error.create(...)`:
   - Позволяет выбросить ошибку, которую NetSuite зафиксирует в статусе выполнения Scheduled Script или Map/Reduce Script (в «Script Deployment» → «Status»).  
   - Параметр `notifyOff: false` означает, что системные администраторы получат уведомление по e-mail (если это настроено в NetSuite).

## 2. Где смотреть логи

После запуска скрипта (вручную через кнопку «Save & Execute» или по расписанию) можно посмотреть логи в разделе **Customization → Scripting → Script Deployments**:
1. Найти нужное Script Deployment (SCHEDULED).  
2. Перейти в **Script Execution Log** или **Log Entries** (зависит от версии интерфейса).  
3. Там будут записи `DEBUG`, `ERROR`, `AUDIT` или `EMERGENCY` со всеми подробностями.

## 3. Как настроить уведомления на ошибки

- В **Customization → Scripting → Script Deployments** можно указать контактные e-mail в поле **Log Email** или **Error Notification Email** (зависит от версии NetSuite) для получения уведомлений о сбоях.  
- Также можно использовать функцию `throw error.create(...)`, чтобы NetSuite автоматически посылал системное уведомление о критических ошибках.

---

### Резюме

1. **Логирование** (`log.debug`, `log.error` и т. д.) позволяет отслеживать ход выполнения скрипта и быстро понимать, где произошла ошибка.  
2. **Блоки `try...catch`** помогают «локализовать» ошибки: если что-то случится в одном участке кода (например, при скачивании конкретного файла или обновлении конкретного заказа), остальная часть скрипта продолжит работать.  
3. При необходимости можно «докинуть» системную ошибку (`throw error.create`) — тогда NetSuite будет считать скрипт завершившимся с ошибкой и (если настроено) отправит уведомление.

Таким образом, «обработка ошибок и логи» — это комбинация из `try...catch` (с `throw`) и методов `log.xxx(...)`, которые в сумме дают полный контроль над отладкой и диагностикой интеграции с SFTP.