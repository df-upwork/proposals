## 1. `Def`
### 1.1.
```
Def(A, B)
```
будет обозначать, что для понятия `B` я использую обозначение `A`.

### 1.2.
~~~
Def(A):
```
B
```
~~~
имеет то же значение, что и `Def(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 2. `Def_P`
### 2.1.
```
Def_P(A)
```
будет обозначать, что `A` является для меня проблемой.

### 2.2.
```
Def_P(A, B)
```
будет обозначать, что `B` является для меня проблемой, и для этой проблемы я использую обозначение `A`.

### 2.3.
~~~
Def_P(A):
```
B
```
~~~
имеет то же значение, что и `Def_P(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 3. `Def_C`
### 3.1.
```
Def_C(P, A, B)
```
будет обозначать `Def(A, B)` в контексте пункта `P`.
Вне пункта `P` это правило не применяется.
Если до пункта `P` обозначение `A` имело другой смысл, то после пункта `P` обозначение `A` снова будет иметь этот смысл.
По сути, `Def_C` объявляет локальную переменную `A` с областью действия `P`.
В отличие от него, `Def` объявляет глобальную переменную `A` (значение которой действует для всех пунктов, кроме `P`).

### 3.2.
~~~
Def_C(P, A):
```
B
```
~~~
имеет то же значение, что и `Def_C(P, A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 3.3.
```
Def_C([P1, P2, …, Pn], A, B)
```
имеет значение, аналогичное `Def_C(P, A, B)`, только в этом случае обозначение `A` имеет значение `B` в контексте не одного пункта `P`, а всех пунктов [`P1`, `P2`, …, `Pn`], перечисленных в квадратных скобках.

### 3.4.
```
Def_C([P1-Pn], A, B)
```
имеет значение, аналогичное `Def_C([P1, P2, …, Pn], A, B)`: в этом случае обозначение `A` имеет значение `B` в контексте множества всех пунктов между `P1` и `Pn`, включая сами эти пункты.

### 3.5.
~~~
Def_C([P1, P2, …, Pn], A):
```
B
```
~~~
имеет то же значение, что и `Def_C([P1, P2, …, Pn], A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 3.6.
~~~
Def_C([P1-Pn], A):
```
B
```
~~~
имеет то же значение, что и `Def_C([P1-Pn], A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 4. `Def_F`
### 4.1.
Def_C(4-5, `F`):
```
Факт: некое событие, которое случилось в описываем мной случае.
```

### 4.2.
```
Def_F(B)
```
будет обозначать, что `B` — это `F`.

### 4.3.
~~~
Def_F:
```
B
```
~~~
имеет то же значение, что и `Def_F(B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 4.4.
```
Def_F(A, B)
```
будет обозначать, что `B` — это `F`, и для него я использую обозначение `A`.

### 4.5.
~~~
Def_F(A):
```
B
```
~~~
имеет то же значение, что и `Def_F(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 5. `Def_Ph`
### 5.1.
Def_C(5, `Ph`):
```
Феномен: `F`, который вызывает у меня удивление.
```

### 5.2.
```
Def_Ph(B)
```
будет обозначать, что `B` — это `Ph`.

### 5.3.
~~~
Def_Ph:
```
B
```
~~~
имеет то же значение, что и `Def_Ph(B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 5.4.
```
Def_Ph(A, B)
```
будет обозначать, что `B` — это `Ph`, и для него я использую обозначение `A`.

### 5.5.
~~~
Def_Ph(A):
```
B
```
~~~
имеет то же значение, что и `Def_Ph(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 6. `Def_H`
### 6.1.
Def_C(6, `H`):
```
Гипотеза: некое предположение, требующее проверки.
```

### 6.2.
```
Def_H(B)
```
будет обозначать, что `B` — это `H`.

### 6.3.
~~~
Def_H:
```
B
```
~~~
имеет то же значение, что и `Def_H(B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 6.4.
```
Def_H(A, B)
```
будет обозначать, что `B` — это `H`, и для него я использую обозначение `A`.

### 6.5.
~~~
Def_H(A):
```
B
```
~~~
имеет то же значение, что и `Def_H(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 7. `Def_Set`
```
Def_Set(S, I)
```
будет обозначать, что `S` — множество всех возможных `I`.

## 8. `Def_I`
```
Def_I(I, S)
```
будет обозначать, что `I` — элемент множества `S`.

## 9. `Use`
```
Use(A)
```
будет обозначать, что в описываемой мной ситуации я использую `A`.

## 10.
Потенциальный клиент опубликовал на Upwork следующий проект:
### 10.1. Title
Ardupilot: Implement Positition Hold in GUIDED_NOGPS mode using SET_ATTITUDE_TARGET

### 10.2. Description
```text
The goal is to implement position hold in GUIDED_NOGPS flight mode.
There is a ROS2 topic that publish current position and orientation to the target point (will be provided). The data is available only in a radios of 1m from the target. 
Based on that data, we need to implement position hold. 
Since the data is not continuously, we VISION_POSITION_ESTIMATE.
In addition, we don't have any GPS, therefore, we have to use SET_ATTITUDE_TARGET.

Environment:
Companion computer: Jetson Orin NX (Ubuntu 22.04)
Sensor: Realsense D455
Simulator: Gazebo harmonic
ROS2 humble
C++ or Python (preferred)

step 1: Implement it in gazebo simulator
step 2: support/debug real flight
```

### 10.3. Tags
Python
C++
arudpilot
Control Engineering
Robotics

## 11. Информация о клиенте
### 11.1. Местоположение
Israel
Ramat Gan

## 11.2. Характеристики компании
### 11.2.1. Сектор экономики
неизвестно
### 11.2.2. Количество сотрудников
10-99 people

## 11.3. Характеристики учётной записи на Upwork
### 11.3.1. Member since
Apr 5, 2020
#### 11.3.2. Hire rate (%)
25
#### 11.3.3. Количество опубликованных проектов (jobs posted)
8
#### 11.3.4. Total spent
250
#### 11.3.5. Количество оплаченных часов в почасовых проектах
0

## 12.
Def(`C`):
```
клиент пункта 10
```

## 13.
Def(`P`):
```
проект пункта 10
```

## 14.
Def(`Ps`):
```
множество подобных `P` проектов 
```

## 15.
Def(`D`):
```
Описание `P` (пункт 10.2 выше)
```

## 16.
Def(`T`):
```
Конкретная подзадача, о которой `C` пишет в `D`:
~~~
implement position hold in GUIDED_NOGPS flight mode
~~~
Эта подзадача не включает следующие этапы общей задачи:
- Конфигурация Системы и Подготовка Окружения
- Разработка и Настройка Симуляционной Среды
- Интеграционное Тестирование и Отладка в Симуляторе
- Перенос Системы на Реальное Оборудование и Летные Испытания
```

## 17.
Def(`S1`):
```
Моё решение `T`
```

## 18. 
Содержание `S1`:
~~~
1) Sending `VISION_POSITION_ESTIMATE` to the Extended Kalman Filter (EKF) while in `GUIDED_NOGPS` mode is incorrect and will not affect the quadcopter's position hold:
1.1) `VISION_POSITION_ESTIMATE` is intended to transmit position data directly to the EKF in the flight controller from an external system (e.g., a visual odometry system).
The EKF then combines these external data with readings from the inertial sensors (Inertial Measurement Unit, IMU) to estimate the quadcopter's state (position and velocity).
The flight controller then uses this estimate for autonomous position hold in modes such as `Loiter` or `Guided`.
To operate in this scenario without a physical GPS module, the EKF parameters must be configured to use an external navigation source.
1.2) The `GUIDED_NOGPS` flight mode does not use position or velocity data for stabilization and exclusively accepts commands to set the attitude (`SET_ATTITUDE_TARGET`).
This mode was developed specifically to give companion computers low-level control over the quadcopter's attitude, similar to how a pilot controls it in `Stabilize` or `AltHold` modes.
The simplicity of this mode is evident in the source code:  https://github.com/ArduPilot/ardupilot/blob/master/ArduCopter/mode_guided_nogps.cpp
Its primary function is to call the angle control handler, effectively making it a transparent channel for attitude commands. 
2) For the position hold task, applying a simple single-loop PID controller, whose output is directly linked to the tilt angles, often leads to instability, oscillations, and overshoot.
A more reliable and widespread approach in robotics is the use of a cascaded (multi-loop) control architecture:
2.1) The outer loop (the position controller) converts the position error (the difference between the target and current position) into a target velocity.
If the quadcopter is to the right of the target, the controller generates a command to move to the left at a certain velocity.
The magnitude of this velocity is proportional to the distance from the target.
The input to this loop is the position error , and the output is the target velocity vector.
2.2) The inner loop (the velocity controller) minimizes the velocity error (the difference between the target and current velocity).
To change the velocity, an acceleration must be applied.
Thus, the input to this loop is the velocity error, and the output is the target acceleration vector.
3) For the specific task of holding the quadcopter at a single point (where the target velocity is zero), the architecture of point 2 can be simplified to a single PID controller operating on the position error:
3.1) The proportional term (`P`) responds to the current position error: `Output_P = Kp * error`. 
It provides the main restoring force toward the target.
3.2) The derivative term (`D`) reacts to the rate of change of the error, which is equivalent to counteracting the current velocity of the quadcopter: `Output_D = Kd * d(error)/dt`. 
It provides damping to prevent overshoot and oscillations.
3.3) The integral term (`I`) accumulates the error over time: `Output_I = Ki * integral(error)`. 
It compensates for constant external disturbances (e.g., wind) or systematic errors (e.g., imperfect calibration), which lead to static errors (e.g., when the quadcopter hovers slightly off the target).
3.4) The final output of the PID controllers for each of the horizontal axes (`X` and `Y`) is the desired acceleration `[ax, ay]`, which must be provided to the quadcopter to return it to the target point.
4) The PID controller from point 3 issues an abstract acceleration command, but a quadcopter is controlled by changing its orientation in space.
Therefore, a transformation step (based on the laws of dynamics) is necessary.
A quadcopter creates a lift force mainly directed along its vertical axis (`Z`).
To create horizontal acceleration, it must tilt (create roll or pitch), directing part of the thrust vector into the horizontal plane.
The target roll and pitch can be calculated from `[ax, ay]`:
```
roll = asin(ay / acceleration)
pitch = -asin(ax / acceleration)
```
The resulting Euler angles (roll and pitch) and the desired yaw angle (which can be considered constant, e.g., 0°, for the position hold task to maintain the heading) must be converted into a quaternion (as required by `SET_ATTITUDE_TARGET`).
5) Since in your case the position data arrives intermittently, a naive PID implementation will cause 2 problems:
5.1) A sudden loss of data can cause the integral term to grow excessively, leading to a large overshoot when the data returns.
5.2) The abrupt arrival of a new position after a pause will create a spike in the derivative term, resulting in sharp, jerky movements of the quadcopter.
6) The correct solution to point 5 is to continuously monitor the timestamp of the last received position message.
If the time since the last message exceeds a predefined threshold, the controller must enter a safe mode (e.g., hold its current attitude) and suspend PID updates until the data feed stabilizes. 
~~~

## 19.
Def(`F`, «фрагмент `S1`»).

## 20.
Содержание `F`:
~~~markdown
2) For the position hold task, applying a simple single-loop PID controller, whose output is directly linked to the tilt angles, often leads to instability, oscillations, and overshoot.
A more reliable and widespread approach in robotics is the use of a cascaded (multi-loop) control architecture:
2.1) The outer loop (the position controller) converts the position error (the difference between the target and current position) into a target velocity.
If the quadcopter is to the right of the target, the controller generates a command to move to the left at a certain velocity.
The magnitude of this velocity is proportional to the distance from the target.
The input to this loop is the position error , and the output is the target velocity vector.
2.2) The inner loop (the velocity controller) minimizes the velocity error (the difference between the target and current velocity).
To change the velocity, an acceleration must be applied.
Thus, the input to this loop is the velocity error, and the output is the target acceleration vector.
~~~

## 21. Твоя задача
Попробуй сократить текст `F` не меньше чем на 117 символов, но не больше чем на 130 символов.
Текст должен остаться на английском языке.
Текст не должен использовать жаргон. 