## 1.
Клиент хочет выполнить следующий проект:
### 1.1. Title
Linux server administrator with strong Centos 7 experience needed

### 1.2. Description
I have a server running  the Centos 7 operating system hosted by Linode. 
Cpanel is installed on the server.  
The server hosts 2 PHP applications written on top of the Zend 2.0 framework with a mySQL database.  
Cloudflare is handling the DNS.
The two PHP apps are constantly timing out and "going down" - several times a day. 
Sometimes multiple times per hour.  
We can get everything back online almost immediately by logging into the WHM panel and restarting the PHP-FPM service.
We've had several people look at the server, but no one has been able to pinpoint the problem.
I need an absolute expert to help resolve this problem.  
If your first instinct is to Google the error message, please do not bother responding.  
We are looking for someone with experience who can help us diagnose and fix this issue quickly.
When responding, please include as much detail regarding your experience as possible.

### 1.3. Местоположение клиента
United States
Champlain

### 1.4. Tags
Linux
Linux System Administration
CentOS
Apache HTTP Server
cPanel
php-fpm

## 2. Наиболее вероятные причины проблемы клиента
### 2.1.
Я тебя спросил:
~~~
В пункте 1.2 клиент пишет:
```
The two PHP apps are constantly timing out and "going down" - several times a day. 
Sometimes multiple times per hour.  
We can get everything back online almost immediately by logging into the WHM panel and restarting the PHP-FPM service.
```
Перечисли наиболее вероятные причины проблемы клиента.
~~~

### 2.2.
Ты ответил:
~~~
Ниже приведён перечень наиболее распространённых и вероятных причин, из-за которых PHP-приложения на базе CentOS 7 могут регулярно “падать” и требовать перезапуска PHP-FPM:

1. **Недостаток системных ресурсов или их неправильное распределение**  
   - **Недостаток оперативной памяти**: если PHP-FPM запущено в конфигурации с слишком большим количеством процессов или неправильно рассчитанными `pm.max_children`, процессы могут “съедать” память, приводя к падению службы.  
   - **Ограничения по CPU**: слишком высокая нагрузка (например, из-за больших объёмов трафика или тяжёлых скриптов) может приводить к тормозам и зависаниям процессов.  
   - **Недостаточно оптимизирована конфигурация Apache (или Nginx, если используется в качестве фронтенда)**: неправильно настроенное взаимодействие между веб-сервером и PHP-FPM (например, нехватка рабочих процессов или несоответствующие таймауты) может вызывать сбои.

2. **Неправильная конфигурация PHP-FPM**  
   - **Недостаточно/слишком агрессивные таймауты** (`request_terminate_timeout`, `max_execution_time`, `max_input_time`): если время выполнения скриптов или время приёма данных невысокое, запросы могут “убиваться” раньше завершения.  
   - **Лимиты на загрузку файлов или превышение `memory_limit`**: при загрузке больших файлов или при генерации тяжёлых ответов, PHP-FPM может падать из-за превышения лимитов.  
   - **Утечки памяти в Zend/PHP-модулях**: бывает, что некорректное расширение или библиотека могут приводить к постепенной утечке памяти, из-за чего процесс PHP-FPM уходит в нерабочее состояние.

3. **Проблемы в коде самих PHP-приложений**  
   - **Длительные запросы к базе данных**: если в коде есть неэффективные запросы (например, большие JOIN'ы, отсутствующие индексы), может происходить блокировка или слишком долгая обработка, приводя к таймаутам.  
   - **Неправильно обрабатываемые исключения**: если ошибки в коде не перехватываются, некорректная обработка может приводить к крашу рабочих процессов PHP-FPM.  
   - **Накопление временных файлов или логов**: при неправильном управлении логами или кэшами дисковое пространство может внезапно заполняться, что влияет на работу PHP.

4. **Проблемы с базой данных (MySQL)**  
   - **Нестабильность или частые перебои в работе MySQL**: если служба MySQL периодически “виснет” или слишком загружена, PHP-FPM начинает ожидать ответа и падает, если превышено время ожидания.  
   - **Высокое количество соединений**: при большой нагрузке если не ограничено количество соединений, база может не успевать их обслуживать.

5. **Конфликт/проблемы в работе Cloudflare или DNS**  
   - **Неверные настройки проксирования**: в некоторых случаях настройки Cloudflare (таймауты, ограничения на размер ответа и т.д.) могут вызывать проблемы при обработке определённого трафика, что приводит к сбоям на уровне приложения.  
   - **DNS или задержка на пути**: если конфигурация DNS или прокси неправильно настроена, приложение может периодически терять соединение.

6. **Ошибки в настройках cPanel/WHM**  
   - **Автоматическое обновление и несовместимости**: бывает, что после обновлений cPanel/WHM некоторые директивы PHP или Apache сбиваются.  
   - **Неправильная версия PHP, конфликт модулей**: если на сервере установлены несколько версий PHP и модули конфликтуют между собой, это может вести к непредсказуемым сбоям.

7. **Аппаратные или сетевые проблемы**  
   - **Сбои в работе хостинг-провайдера (Linode)**: нестабильная инфраструктура, проблемы с оборудованием или внутренние сети могут приводить к частичной недоступности сервиса и, как следствие, “подвисанию” PHP-FPM.  
   - **Ошибки в работе диска (I/O)**: если диск перегружен операциями ввода-вывода, процессы PHP-FPM могут зависать, пока ожидают освобождения ресурсов.

---

Чтобы выяснить точную причину, обычно требуется:
- Анализ логов PHP-FPM, Apache (или Nginx) и системных логов (`/var/log/messages`, `/var/log/syslog`, `/var/log/dmesg` на CentOS) на предмет критических ошибок или повторяющихся сообщений об отказах.
- Мониторинг системных ресурсов (CPU, RAM, I/O) в динамике с помощью инструментов вроде `top`, `htop`, `sar`, `vmstat`.
- Проверка конфигурации PHP-FPM (pool configuration), актуальных значений переменных (например, `pm.max_children`, `pm.start_servers`, `pm.min_spare_servers` и т.д.).
- Проверка MySQL-логов (slow query log) на предмет “тяжёлых” запросов.  
- Анализ конфигураций Cloudflare (таймаутов, правил брандмауэра, корректной прокси на доменах и поддоменах).

Чаще всего подобные случаи решаются комплексной настройкой и отладкой: начиная с оптимизации кода PHP-приложений (прежде всего базы данных), грамотного распределения ресурсов в PHP-FPM/Apache и заканчивая проверкой серверной инфраструктуры (нагрузка, логи, конфигурация Cloudflare).
~~~

## 3. «Недостаток оперативной памяти»
### 3.1.
Я тебя спросил:
~~~
В пункте 2.2 ты писал:
```
   - **Недостаток оперативной памяти**: если PHP-FPM запущено в конфигурации с слишком большим количеством процессов или неправильно рассчитанными `pm.max_children`, процессы могут “съедать” память, приводя к падению службы.  
```
Опиши подробнее, каким образом это может приводить к падению службы.
~~~

### 3.2.
Ты ответил:
~~~
Когда у PHP-FPM задано слишком большое число процессов (через настройки `pm.max_children`, `pm.start_servers`, `pm.min_spare_servers`, и т.д.) или параметры выбраны без учёта доступной оперативной памяти, происходит следующее:

1. **Каждый процесс PHP-FPM потребляет часть памяти**  
   - В зависимости от того, какие библиотеки подгружены, каковы настройки PHP (особенно `memory_limit`) и какие сценарии (скрипты) выполняются, каждый новый процесс может “съедать” ощутимый кусок оперативной памяти (RAM).  

2. **Растёт суммарное потребление памяти всей службой**  
   - Если `pm.max_children` выставлено слишком высоко, в пиковые моменты нагрузка может привести к запуску большого числа дочерних процессов.  
   - Общий объём памяти, необходимый всем этим процессам, может превышать доступный системный объём RAM.

3. **Перегрузка памяти и возможный переход в swap**  
   - Когда оперативной памяти не хватает, ОС может начать использовать swap (виртуальную память на диске).  
   - Обращение к swap сильно замедляет систему и может вызвать большие задержки в работе PHP-FPM (таймауты).  

4. **Срабатывание OOM Killer**  
   - При острой нехватке оперативной памяти ядро Linux (на CentOS, как и в других дистрибутивах) может запустить механизм Out Of Memory Killer (OOM Killer).  
   - OOM Killer “выбирает” процессы для завершения (kill), чтобы освободить системные ресурсы.  
   - Часто жертвами становятся тяжёлые процессы — именно те, которые потребляют больше всего памяти. В данном случае под удар может попасть и главный процесс PHP-FPM, и его дочерние процессы.

5. **Итог: служба «падает»**  
   - Если ядро “убивает” главный процесс PHP-FPM или большое число его рабочих процессов, служба фактически перестаёт работать, и сайт “ложится”.  
   - В логах (системных и PHP-FPM) может отображаться соответствующее сообщение об убитом процессе (например, `Out of memory: Kill process ...`).

6. **Симптомы и последствия**  
   - Приложение начинает выдавать 5xx-ошибки (например, 502 или 503), страницы не грузятся.  
   - Пользователи видят таймауты или недоступность ресурса.  
   - Администратору приходится вручную перезапускать PHP-FPM или система делает это автоматически (иногда cPanel/WHM могут иметь встроенный механизм мониторинга).

---

### Как диагностировать

1. **Просмотр системных логов и логов PHP-FPM**  
   - В `/var/log/messages`, `/var/log/dmesg` или `/var/log/syslog` (зависит от настроек CentOS) ищите упоминание OOM Killer.  
   - В логах PHP-FPM проверьте наличие сообщений о критических ошибках, превышении лимитов по памяти и т.д.

2. **Мониторинг ресурсов в режиме реального времени**  
   - Запуск утилит `top`, `htop` или систем мониторинга (например, Netdata, Munin) для отслеживания, какой объём RAM потребляют процессы PHP-FPM.  
   - Проверка нагрузки на swap: если swap используется активно и достигает больших значений, это сигнал о неправильном распределении памяти.

3. **Оценка текущих параметров PHP-FPM**  
   - В pool-конфигурациях (обычно расположены в `/etc/php-fpm.d/`) посмотрите значение `pm`, `pm.max_children`, `pm.start_servers`, `pm.min_spare_servers`, `pm.max_spare_servers`, а также `request_terminate_timeout`, `max_execution_time`.  
   - Оцените, какую пиковую нагрузку реально выдержать при имеющихся ресурсах (процессор/память).

4. **Оптимизация настроек**  
   - При ограниченных ресурсах сервера уменьшите `pm.max_children`: это снизит риск, что слишком много процессов одновременно будут потреблять память.  
   - Используйте тип управления процессами `dynamic` или `ondemand` (вместо `static`), чтобы процессы запускались по мере необходимости (однако учтите, что при очень резких пиках нагрузки это может немного увеличить время отклика).  
   - Установите адекватные таймауты (request_terminate_timeout), чтобы “зависшие” процессы не держали ресурсы.  
   - Следите, чтобы `memory_limit` в php.ini и `pm.max_children` были согласованы с физическими ресурсами сервера.

Таким образом, неправильно настроенная конфигурация PHP-FPM, при которой на одном сервере пытаются одновременно работать слишком много процессов, часто становится причиной нехватки памяти. Итоговый результат — служба PHP-FPM “падает” из-за срабатывания OOM Killer, или она начинает настолько сильно использовать swap, что фактически перестаёт отвечать на запросы до ручного или автоматического перезапуска.
~~~

## 4. Что клиент имеет в виду под «going down»?
### 4.1.
Я тебя спросил:
~~~
В пункте 1.2 клиент пишет:
```
The two PHP apps are constantly timing out and "going down"
```
Что клиент имеет в виду под «going down»?
~~~

### 4.2.
Ты ответил:
~~~
Под «going down» клиент, скорее всего, имеет в виду, что приложения перестают отвечать на запросы или работают настолько медленно, что с точки зрения пользователей (или мониторинговых систем) они становятся недоступны. Практически это может выглядеть как:

1. **Таймаут при загрузке страницы**: в браузере долго идёт загрузка, а потом выводится сообщение об ошибке соединения или истекшем времени ожидания (например, 504 Gateway Timeout, 503 Service Unavailable, 500 Internal Server Error и т.д.).  
2. **Пустая страница или обрыв соединения**: пользователь видит “белый экран” или «Connection reset/closed».  
3. **Полная недоступность URL**: на запрос отвечают ошибки Cloudflare (например, 520, 521 и проч.), если запрос идёт через прокси.  

Фактически для посетителей сайта и самого владельца кажется, что сервер «упал» (не отвечает), пока кто-то не зайдёт в WHM и не перезапустит PHP-FPM.
~~~

## 5. Что клиент имеет в виду под «timing out»?
### 5.1.
Я тебя спросил:
~~~
В пункте 1.2 клиент пишет:
```
The two PHP apps are constantly timing out and "going down"
```
Что клиент имеет в виду под «timing out»?
~~~

### 5.2.
Ты ответил:
~~~
Под «timing out» в данном контексте клиент, скорее всего, имеет в виду ситуацию, когда при обращении к приложению сервер не успевает ответить в отведённое время и запрос прерывается (выдаётся ошибка о превышенном времени ожидания). На практике это выражается в том, что:

1. **Пользователь ждёт слишком долго** — браузер или прокси (например, Cloudflare) не получает ответ от сервера в течение заданного тайм-лимита (часто 30 или 60 секунд, в зависимости от настроек), и в итоге соединение обрывается.
2. **Отображается ошибка таймаута** — это может быть 504 Gateway Timeout, 524 (Cloudflare), 408 Request Timeout или аналогичная ошибка, указывающая, что сервер не ответил вовремя.
3. **Приложение не откликается** — фактически PHP-приложение “зависает” (не может закончить работу над запросом из-за недостатка ресурсов, блокировок или слишком тяжёлой задачи), и система фиксирует это как «timeout».  

Таким образом, “timing out” означает, что на запрос к приложению не приходит своевременный ответ, и пользователь видит сообщение об истечении времени ожидания (или просто ничего не видит, получая пустую страницу), пока администратор не перезапустит службу PHP-FPM.
~~~

## 6. В чём клиент видит разницу между «going down» и «timing out»?
### 6.1.
Я тебя спросил:
~~~
В пункте 1.2 клиент пишет:
```
The two PHP apps are constantly timing out and "going down"
```
В чём клиент видит разницу между «going down» (пункт 4) и «timing out» (пункт 5)?
Сравни их в таблице.
~~~

### 6.2.
Ты ответил:
~~~
Ниже приведена сравнительная таблица, отражающая, в чём клиент (по контексту из задания) видит разницу между «going down» и «timing out».

| **Критерий**                            | **“Timing out”**                                                   | **“Going down”**                                                                                                                                           |
|-----------------------------------------|--------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Что происходит**                      | Сервер не успевает ответить в отведённое время, запрос прерывается | Приложение (или весь сервер) фактически перестаёт отвечать на запросы, становится «недоступным» или «упавшим»                                             |
| **Как выглядит для пользователя**       | - Долго вращается «колёсико» загрузки<br>- В итоге выдается ошибка о превышении времени ожидания (504 Gateway Timeout, 524 и т.п.) | - Сайт сразу выдает ошибку (500, 503, 521, 520 и т.п.), пустую страницу, либо вовсе не отвечает<br>- Может казаться, что сервер «выключен» или «сломан» |
| **Основной признак**                    | Наличие задержки, которая превышает таймаут системы (PHP-FPM, Cloudflare и т.д.) | Полная или почти полная недоступность приложения (нет реакции без ручного перезапуска)                                                                     |
| **Типичные причины**                    | - Зависание скрипта (длительные операции, тяжёлые запросы к БД)<br>- Недостаток ресурсов, из-за чего процесс долго обрабатывается или блокируется<br>- Проблемы с соединением (но всё ещё есть попытка ответа) | - Критический сбой в работе PHP-FPM (OOM Killer, краш процесса, исчерпанная память)<br>- Серьёзная ошибка конфигурации или конфликт модулей, ведущий к полной остановке службы<br>- Ошибка в настройках сервера, приводящая к «падению» сервиса |
| **Необходимость перезапуска**           | Может временно помочь дождаться окончания процессов или оптимизировать код, но зачастую без перезапуска сервис продолжает работать, хотя и с перебоями | Как правило, требуется ручной или автоматический (через WHM/cPanel) перезапуск, чтобы сервис снова начал корректно отвечать                                                                     |
| **Как формулирует клиент**              | «Приложения постоянно выдают таймауты» (запросы превышают время ожидания) | «Приложения уходят в офлайн/“падают”» (полная недоступность, сервер будто «выключен»)                                                                                                           |

Таким образом, **“timing out”** в понимании клиента — это ситуация, когда приложение ещё как-то пытается обработать запрос, но не укладывается в отведённые лимиты по времени. **“Going down”** — более серьёзное состояние, означающее фактический «падёж» службы (PHP-FPM или всего сервера), при котором никакие запросы не обрабатываются до тех пор, пока администратор не выполнит перезапуск.
~~~

## 7. Связаны ли проблемы клиента «going down» и «timing out» между собой?
### 7.1.
Я тебя спросил:
~~~
Связаны ли проблемы клиента «going down» и «timing out» между собой?
Какой ты видишь эту связь?
~~~

### 7.2.
Ты ответил:
~~~
Да, чаще всего «going down» (полная недоступность) и «timing out» (превышение времени ожидания) оказываются тесно связаны и являются звеньями одной цепочки. Проще говоря, «timing out» может быть симптомом перегрузки или сбоя в работе сервера (или самого PHP-приложения), а «going down» — более серьёзным проявлением той же проблемы, при котором сервис перестаёт отвечать вовсе. Ниже — основные сценарии связи:

1. **“Timing out” как предвестник “going down”**  
   - Из-за накопившейся нагрузки, долгих запросов к базе данных или нехватки ресурсов (CPU, RAM) система начинает долго обрабатывать запросы, и они «вываливаются» в таймаут.  
   - Если нагрузка или сбой сохраняются, процессы PHP-FPM могут окончательно «зависнуть», вызвать ошибки в конфигурации (например, исчерпание доступной памяти, срабатывание OOM Killer). В итоге сервис «падает» и становится совсем недоступным.

2. **“Going down” и последующие таймауты**  
   - При резком краше (например, когда PHP-FPM убит OOM Killer или сама служба аварийно остановлена) все новые входящие запросы получают мгновенную ошибку или «виснут» без ответа.  
   - Внешне это может восприниматься и как «полное падение», и одновременно как «таймаут» (например, Cloudflare будет выдавать ошибки 520, 524 или 504), так как она не получает ответа от сервера.

3. **Общая первопричина**  
   - Как правило, и таймауты, и падения вызваны одной или несколькими общими проблемами:  
     - неправильная конфигурация PHP-FPM (слишком много процессов, нехватка памяти);  
     - тяжёлые запросы в базе данных;  
     - ошибки в коде, приводящие к блокировкам или утечкам памяти;  
     - неверные настройки веб-сервера или Cloudflare, вызывающие конфликт таймаутов.  

4. **Почему клиент указывает оба симптома**  
   - Клиент замечает, что иногда сайт начинает «подвисать» (таймауты), а в иные моменты — «исчезает» с радаров без ответа (going down).  
   - Для клиента это выглядит как разные стадии одной и той же проблемы: сначала сайт долго грузится и вылетает по времени, а затем и вовсе требует перезапуска, так как перестаёт отвечать совсем.

Таким образом, «timing out» — это более мягкая форма сбоя (сервер или скрипт ещё жив, но не укладывается в отведённые лимиты), тогда как «going down» — крайнее состояние, когда сервис фактически полностью перестаёт отвечать, и без ручного перезапуска (или автоматического механизма мониторинга) ситуация не решается. В большинстве случаев оба явления вызваны одними и теми же факторами перегрузки или конфигурации, просто проявляются они на разных этапах «ухудшения» работы сервера.
~~~

## 8. Совокупная проблема клиента
### 8.1.
Я тебя спросил:
~~~
Как бы ты в целом назвал и описал совокупную проблему клиента «going down» и «timing out»?
~~~

### 8.2.
Ты ответил:
~~~
Ниже — обобщённое описание совокупной проблемы, с которой столкнулся клиент, когда приложения «timing out» и «going down» одновременно.

### Как выглядит проблема в целом
Клиент наблюдает **нестабильную работу** своих PHP-приложений на сервере с CentOS 7 и cPanel/WHM:  
1. **Приложения «timing out»** — запросы к сайту не успевают обработаться в установленные временные рамки, в результате чего пользователь видит ошибки «504 Gateway Timeout», «524 A Timeout Occurred (Cloudflare)» или аналогичные. Это означает, что сервер (или PHP-FPM) **слишком долго** выполняет код и не укладывается в таймаут.  
2. **Приложения «going down»** — в более тяжёлых случаях службы (PHP-FPM, Apache) **фактически перестают отвечать** на запросы и «падают» до тех пор, пока не будет выполнен перезапуск (через WHM или вручную). Здесь уже речь идёт не просто о долгой обработке, а о **полной недоступности** приложения (ошибки 500, 503, 521 или отсутствие каких-либо ответов вообще).

### Суть объединяющей проблемы
Оба симптома — «таймауты» и «падение» — указывают на **нехватку ресурсов или сбой в конфигурации**, из-за чего PHP-приложения работают на пределе. Когда система перегружена, она сначала начинает «зависать» и выдавать таймауты, а при достижении критических значений (например, при исчерпании памяти) полностью «ложится», и процесс PHP-FPM приходится перезапускать.

Чаще всего такие ситуации возникают из-за:
- **Ошибок в конфигурации PHP-FPM** (слишком много дочерних процессов, некорректные таймауты, превышение `memory_limit`).  
- **Проблем в коде** (очень тяжёлые запросы к базе, неэффективные циклы, утечки памяти, некорректно обработанные ошибки).  
- **Недостатка аппаратных ресурсов** (мало RAM, интенсивная нагрузка на диск, большой поток одновременных запросов).  
- **Сбоев в работе MySQL** (долгие или зависающие запросы, блокировки транзакций).  
- **Проблем с проксированием или DNS** (например, неверные настройки Cloudflare, приводящие к частым 524/520 ошибкам).

Таким образом, **общая проблема** сводится к тому, что под нагрузкой (или при некорректных настройках) сервер начинает **сильно замедляться**, «валить» запросы в таймауты, а затем и вовсе «падать», требуя ручного перезапуска, чтобы вернуться в работоспособное состояние.
~~~

## 9. «Ограничения по CPU»
### 9.1.
Я тебя спросил:
~~~
В пункте 2.2 ты писал:
```
   - **Ограничения по CPU**: слишком высокая нагрузка (например, из-за больших объёмов трафика или тяжёлых скриптов) может приводить к тормозам и зависаниям процессов.  
```
Опиши подробнее, каким образом это может приводить к «going down» (пункт 4)?
~~~

### 9.2.
Ты ответил:
~~~
Когда сервер сильно загружен по процессору (например, слишком много одновременно выполняемых PHP-процессов или тяжёлые скрипты, которые интенсивно используют CPU), это может привести к цепочке событий, в итоге вызывающих «going down» — фактическую недоступность приложений. Ниже разберём, почему это происходит.

---

### 1. Рост времени выполнения запросов

1. **Недостаточно «свободного» процессорного времени**  
   - Если CPU загружен на 100% (или близко к этому), каждый новый процесс или поток (будь то PHP-FPM или база данных) вынужден ждать, когда освободится квант процессорного времени.  
   - Из-за этого сильно вырастают задержки в обработке запросов.

2. **Очередь необработанных запросов растёт**  
   - Веб-сервер (Apache или Nginx) продолжает получать новые входящие соединения, и каждый запрос ставится в очередь на выполнение в PHP-FPM.  
   - Когда очередь становится слишком большой, время ожидания ответа (таймауты) неизбежно растёт.

3. **Таймауты как промежуточный симптом**  
   - В этот момент пользователь может получать ошибки вида 504, 524 (Cloudflare) или «Request Timeout».  
   - Сервер ещё не «упал», но уже не успевает обслуживать запросы вовремя.

---

### 2. Перегрузка, взаимная блокировка и исчерпание других ресурсов

1. **Параллельная нагрузка по цепочке**  
   - Обработка тяжёлых скриптов и высокая одновременная нагрузка по CPU могут приводить к тому, что PHP-процессы держат открытыми соединения с MySQL дольше обычного.  
   - Это провоцирует блокировки в базе, рост числа активных соединений, возможные задержки на уровне диска (I/O).  

2. **Рост потребления памяти**  
   - При высокой загрузке CPU PHP-процессы выполняются медленнее и «живут» дольше. Каждому процессу продолжает быть нужна своя порция памяти.  
   - Если процессы не успевают быстро завершаться, общее потребление RAM в системе увеличивается, усиливая риск срабатывания OOM Killer.

3. **Возможные сбои в других службах**  
   - Если база данных или другие системные службы (например, DNS) тоже испытывают задержки по CPU, они могут переставать своевременно отвечать.  
   - В такой ситуации даже «лёгкие» запросы могут «подвисать» из-за несвоевременного ответа вспомогательных сервисов.

---

### 3. Накопление критических ошибок и фактическое «падение»

1. **PHP-FPM «зависает» или «забивается»**  
   - Когда слишком много процессов PHP-FPM одновременно работают, сервис может «застрять» в состоянии, когда все воркеры заняты, а новые запросы не могут получить свободный процесс для исполнения.  
   - Иногда это приводит к тому, что PHP-FPM перестаёт обрабатывать новые соединения и фактически «зависает».

2. **Переход в состояние полной недоступности («going down»)**  
   - В крайнем случае, при критической загрузке CPU система может перестать отвечать даже на внутренние команды (например, не успевает корректно обрабатывать процессы или служба просто «крашится»).  
   - Пользователи получают мгновенные 5xx-ошибки или видят, что сайт вообще не отвечает — то есть «going down».

3. **Необходим перезапуск**  
   - В такой ситуации единственный способ быстро вернуть работу — принудительно перезапустить PHP-FPM (или весь веб-сервер). Это именно то, что делает клиент через WHM, чтобы сайты снова стали доступны.

---

### 4. Итого: как высокая нагрузка на CPU превращается в «going down»

1. **Начало**: нагрузка на процессор растёт (тяжёлые скрипты, много трафика).  
2. **Промежуточный этап**: система «задыхается», появляются ошибки таймаута (503, 504 и т.д.).  
3. **Критический момент**: слишком длинные очереди процессов и возможное срабатывание дополнительных ограничений (по памяти, по кол-ву процессов), что может привести к «зависанию» или остановке PHP-FPM.  
4. **Результат**: PHP-FPM (и/или сам веб-сервер) перестаёт обрабатывать запросы, пользователь видит «падение» сайта.

Таким образом, **«слишком высокая нагрузка по CPU»** способна вызвать цепочку проблем (таймауты, рост очередей, блокировки, утечки памяти), которые в итоге приводят к тому, что сервис перестаёт отвечать на запросы без ручного или автоматического перезапуска — то есть фактически «падает» с точки зрения клиента.
~~~

## 10. «Недостаточно оптимизирована конфигурация Apache (или Nginx, если используется в качестве фронтенда)»
### 10.1.
Я тебя спросил:
~~~
В пункте 2.2 ты писал:
```
   - **Недостаточно оптимизирована конфигурация Apache (или Nginx, если используется в качестве фронтенда)**: неправильно настроенное взаимодействие между веб-сервером и PHP-FPM (например, нехватка рабочих процессов или несоответствующие таймауты) может вызывать сбои.
```
Опиши подробнее, каким образом это может приводить к «going down» (пункт 4)?
~~~

### 10.2.
Ты ответил:
~~~
Когда конфигурация веб-сервера (Apache или Nginx) **не оптимизирована** для работы с PHP-FPM, возникает ряд проблем, которые приводят к «going down» — т.е. фактической недоступности приложения. Ниже разберём основные цепочки причинно-следственных связей.

---

## 1. Несоответствие числа рабочих процессов/воркеров реальной нагрузке

1. **Чрезмерно низкие лимиты**  
   - Если в конфигурации Apache (через MPM-параметры вроде `MaxRequestWorkers`, `ServerLimit` и т.д.) или в Nginx (`worker_processes`, `worker_connections`) установлено слишком маленькое количество рабочих процессов/воркеров, сервер при пике нагрузки просто «захлёбывается».  
   - Новые соединения ставятся в очередь, растут задержки, а затем начинаются таймауты.

2. **Чрезмерно высокие лимиты**  
   - Обратная ситуация: если лимиты выставлены слишком высоко (особенно в сочетании с PHP-FPM, где тоже может быть завышенный `pm.max_children`), то при одновременных запросах каждый воркер запускает PHP-процесс, и общее потребление CPU и памяти может резко возрасти.  
   - Как итог — перегрузка ресурсов (CPU/RAM), возможное срабатывание OOM Killer и «падение» службы.

3. **Неправильный баланс**  
   - Важна согласованность между параметрами Apache/Nginx (число воркеров, очереди) и параметрами PHP-FPM (число дочерних процессов). Любой **дисбаланс** (например, веб-сервер принимает больше одновременных соединений, чем способен обработать пул PHP-FPM) приводит к накоплению запросов и сбоям.

---

## 2. Несогласованные таймауты между веб-сервером и PHP-FPM

1. **Разные значения таймаута**  
   - Если, к примеру, Apache (или Nginx) имеет `ProxyReadTimeout`/`fastcgi_read_timeout` в 60 секунд, а PHP-FPM использует большее время выполнения (или наоборот), то при интенсивной нагрузке веб-сервер может прекращать соединения раньше, чем скрипт успеет завершиться.  
   - Это вызывает частые 504/502 ошибки, которые при накоплении и повторных запросах нагружают систему ещё сильнее.

2. **Зависание соединений**  
   - При несоответствующих таймаутах (особенно если веб-сервер ждёт ответа дольше, чем реально настроен PHP-FPM) часть рабочих процессов «зависает» в режиме ожидания.  
   - Со временем все воркеры становятся занятыми «зависшими» запросами, а новые соединения не могут быть приняты — фактически сайт не отвечает.

---

## 3. Неверная конфигурация обратного прокси (Reverse Proxy)

Если Nginx или Apache настроены как прокси, передающий запросы на PHP-FPM (через FastCGI или FPM-сокет), могут возникать ситуации:

1. **Конфликт путей и сокетов**  
   - При некорректной конфигурации fastcgi-пасса (например, неправильный путь к сокету PHP-FPM или конфликт в алиасах) веб-сервер периодически не находит нужный сокет или порт.  
   - Запросы возвращают 502 Bad Gateway, и для пользователя кажется, что сайт «упал».

2. **Ошибки буферизации**  
   - Если буферов Nginx или ProxyBuffer Apache недостаточно (особенно при больших ответах), могут возникать ситуации, когда соединение разрывается при передаче данных от PHP-FPM.  
   - В результате — частые ошибки, «таймауты» и затем полная недоступность (если служба забита зависшими коннектами).

---

## 4. Рост очереди запросов до критического уровня

1. **Apache/Nginx перестаёт обрабатывать новые соединения**  
   - При неправильной конфигурации (например, слишком агрессивные `KeepAlive`-настройки в Apache) соединения могут удерживаться долго, и число доступных воркеров сокращается.  
   - Когда все воркеры заняты, новые входящие запросы получают мгновенный отказ (5xx) или уходят в бесконечное ожидание.

2. **Аварийный сценарий «going down»**  
   - В момент, когда очередь переполнена, фактически **все** пользователи видят ошибку или недоответ (таймаут).  
   - Снаружи это выглядит, будто сервер «упал» (не отвечает совсем), хотя технически он просто не имеет свободных ресурсов (воркеров или процессов) для обработки новых запросов.

---

## 5. Итоговая картина: почему это приводит к «going down»

- **Слишком маленький пул воркеров** —> сайт не выдерживает пиков, «подвисает» и начинает выдавать таймауты или 503.  
- **Слишком большой пул воркеров** —> превышение доступной памяти или CPU, что может «повалить» PHP-FPM и даже ОС (OOM Killer).  
- **Несоответствие настроек таймаута** —> массовые 504/502, быстрая «убиваемость» соединений или зависания, ведущие к полной недоступности.  
- **Ошибки проксирования** —> периодические «Bad Gateway» или невозможность найти сокет, в результате чего все запросы перестают обрабатываться.

В конечном счёте веб-сервер и PHP-FPM либо **“задушат”** друг друга, либо «зависнут» в состоянии, когда **никаких** новых запросов обработать не могут. Это выглядит для клиента и пользователей как полная «авария» или «падение» сайта, требуя ручного перезапуска (через WHM/cPanel или командной строкой).
~~~

## 11. «Недостаточно/слишком агрессивные таймауты»
### 11.1.
Я тебя спросил:
~~~
В пункте 2.2 ты писал:
- **Недостаточно/слишком агрессивные таймауты** (`request_terminate_timeout`, `max_execution_time`, `max_input_time`): если время выполнения скриптов или время приёма данных невысокое, запросы могут “убиваться” раньше завершения.

Опиши подробнее, каким образом это может приводить к «going down» (пункт 4)?
~~~

### 11.2.
Ты ответил:
~~~
Когда в конфигурациях PHP-FPM, php.ini или веб-сервера выставлены неверные таймауты (либо слишком короткие, либо слишком длинные), это может вызвать цепочку событий, которая в итоге приведёт к полной недоступности приложения («going down»). Рассмотрим оба варианта подробнее:

---

## 1. **Слишком короткие таймауты**  

### 1.1. Ранняя «убийство» запросов  
- Параметры вроде `max_execution_time`, `request_terminate_timeout`, `max_input_time` задают, сколько времени даётся скрипту на выполнение или приём данных.  
- Если эти значения **слишком низкие**, скрипты, которым нужно чуть больше времени (например, из-за сложных SQL-запросов или высоких объёмов данных), будут прерываться до завершения.  

### 1.2. «Массовые» ошибки и рост нагрузки  
- Пользователи начинают получать 500/504 ошибки (запросы прерываются по таймауту).  
- При этом некоторые процессы PHP-FPM могут «зависать» в момент убийства, оставляя за собой частично выделенные ресурсы (память, открытые соединения к БД).  
- Если несколько процессов завершаются некорректно (особенно под нагрузкой), сервис может начать сбоить из-за «захваченных» ресурсов или несвоевременно закрытых соединений.

### 1.3. Накопление некорректных процессов и «going down»  
- Постепенно число «подвисших» или «убитых» процессов растёт, конфигурация PHP-FPM может выйти из строя (например, перестаёт порождать новые воркеры или уходит в ошибку).  
- В итоге сервис доходит до состояния, когда **вообще не может** обрабатывать новые запросы, и сайты фактически «падают».  
- Администратору остаётся только вручную перезапустить PHP-FPM или Apache, чтобы восстановить работу.

---

## 2. **Слишком длинные таймауты**  

### 2.1. Длительное «удержание» процессов  
- Если `max_execution_time` или `request_terminate_timeout` чрезмерно велики (например, несколько минут), скрипты могут «висеть» очень долго, даже если они попали в тупиковое состояние (блокировка в БД, бесконечный цикл и т.д.).  
- Такие зависшие процессы продолжают удерживать системные ресурсы (CPU, RAM, соединения к БД) в течение всего срока «длинного» таймаута.

### 2.2. Перегрузка памяти и очередей  
- При высокой нагрузке (много одновременно «зависших» процессов) общее потребление оперативной памяти растёт, а очередь необработанных запросов увеличивается.  
- Система начинает тормозить, и новые запросы **либо тоже зависают**, либо выбрасывают «таймауты» (504, 524 и проч.), пока все воркеры заняты «долгоиграющими» скриптами.

### 2.3. Критическое состояние и «падение»  
- Если память (RAM) близка к исчерпанию, срабатывает OOM Killer, который может убить главный процесс PHP-FPM. Либо сама служба «зависает» настолько, что перестаёт отвечать даже на внутренние сигналы.  
- Результат: **полная недоступность** (приложение «going down») до тех пор, пока не произойдёт ручной или автоматический перезапуск.

---

## 3. **Обобщающая цепочка при неправильных таймаутах**

1. **Неверные настройки**: таймауты слишком короткие → скрипты часто прерываются, сервис «ломается» из-за большого числа обрывов.  
   **Либо** таймауты слишком длинные → ресурсы блокируются на длительное время, растут очереди, система уходит в «ступор».  
2. **Промежуточная стадия**: появляются массовые «таймауты» на стороне пользователей (ошибки 504, 524, 500).  
3. **Апофеоз**: при накоплении критического числа зависших процессов или прерванных соединений сервис перестаёт обрабатываться корректно и **полностью «падает»**.  
4. **Требуется перезапуск**: клиент вынужден заходить в WHM/систему мониторинга, чтобы перезапустить PHP-FPM или Apache и вернуть приложения к жизни.

---

Таким образом, **неправильно настроенные таймауты** могут не только провоцировать большое количество ошибок «timeout», но и вести к **полной остановке** (падению) PHP-FPM/Apache при определённых условиях нагрузки и поведения кода приложения.
~~~

## 12. «Лимиты на загрузку файлов»
### 12.1.
Я тебя спросил:
~~~
В пункте 2.2 ты писал:
- **Лимиты на загрузку файлов или превышение `memory_limit`**: при загрузке больших файлов или при генерации тяжёлых ответов, PHP-FPM может падать из-за превышения лимитов.

Опиши подробнее, каким образом «лимиты на загрузку файлов» могут приводить к «going down» (пункт 4)?
~~~

### 12.2.
Ты ответил:
~~~
Когда в конфигурации PHP (php.ini или настройках PHP-FPM pool) установлены определённые лимиты на загрузку файлов (например, `upload_max_filesize`, `post_max_size`) и при этом пользователи или процессы приложения пытаются загружать большие файлы, может возникнуть цепочка проблем, которые в итоге приводят к «going down» — фактическому «падению» приложения. Ниже описан механизм, как это происходит.

---

### 1. Накопление запросов с большими файлами
1. **Недооценка размера входящего файла**  
   - Если пользователь (или скрипт) пытается загрузить файл, превышающий допустимый лимит (например, `upload_max_filesize = 10M`, а файл в 100 МБ), PHP начинает принимать данные, пока не достигнет предела или не произойдёт сбой в процессе загрузки.  
   - В процессе загрузки PHP-ФПМ (или соответствующий воркер) может занять память под буферизацию входящего контента.

2. **Замедление или блокировка обработки**  
   - Пока файл не будет полностью принят (или пока не сработает ошибка превышения лимита), процесс PHP-FPM может «зависать» на одном запросе.  
   - Из-за этого другие запросы могут ждать своей очереди и, в зависимости от настроек `pm.max_children` и `pm.*_spare_servers`, «забивать» пул воркеров.

---

### 2. Увеличение потребления памяти и ресурсов
1. **Большие входные данные → рост RAM**  
   - При обработке больших файлов (особенно если код приложения читает их целиком в память) PHP-процесс может резко увеличить потребление оперативной памяти.  
   - Это усиливается, если одновременно загружается несколько крупных файлов: у каждого процесса — свой кусок памяти.

2. **Риск выхода за `memory_limit`**  
   - Если в скрипте не заложена грамотная обработка потоковой загрузки, а `memory_limit` выставлен слишком низко или наоборот слишком высоко (и позволяет процессу “съесть” всю доступную ОЗУ), можно получить либо резкое падение с ошибкой `Allowed memory size of X bytes exhausted`, либо рост суммарного потребления памяти вплоть до срабатывания OOM Killer.

3. **Рост нагрузки на диск (I/O)**  
   - При загрузке больших файлов сервер вынужден временно хранить их в каталогах `/tmp` или других папках (в зависимости от настроек).  
   - Если таких запросов много, растёт нагрузка на дисковую подсистему, что дополнительно замедляет работу и может приводить к зависаниям или таймаутам.

---

### 3. Сбой (краш) PHP-FPM или полная остановка сервиса
1. **Зависание процессов при превышении лимитов**  
   - Когда процесс достигает `post_max_size`, PHP может «оборвать» загрузку и выдать пользователю ошибку. Но если в приложении нет корректной обработки таких ошибок, воркер PHP-FPM может “зависнуть” в ожидании.  
   - Несколько зависших воркеров «выедают» все доступные слоты процессов, и новые запросы в очередь уже не попадают — результатом становится недоступность приложения.

2. **Срабатывание OOM Killer**  
   - Если потребление памяти из-за нескольких одновременных больших загрузок превышает физические ресурсы, ядро Linux может убить процесс PHP-FPM.  
   - В этом случае сервис «падает» (иногда полностью, если убит главный процесс), и на сайте наблюдается та самая ситуация «going down», пока не произойдёт перезапуск.

3. **Перегрузка и отказ в обслуживании**  
   - При заполнении всех воркеров PHP-FPM и/или исчерпании ресурсов (память, CPU, I/O) сервер может перестать отвечать на запросы, выдавая 5xx-ошибки.  
   - Для клиента это выглядит как полная недоступность приложения, требующая ручного перезапуска или автоматического механизма восстановления (например, через WHM).

---

### 4. Итоговая взаимосвязь «лимитов на загрузку» и «going down»
- **Большие файлы** → **большое потребление ресурсов** (RAM, I/O).  
- **Превышение лимитов** → **ошибки в загрузке, возможное зависание воркеров**.  
- **Зависшие или убитые процессы** → **приложения фактически перестают отвечать** (going down).  

Таким образом, если настройки PHP не оптимизированы для обработки загрузки больших файлов, попытки загрузить их могут приводить к «забиванию» всех PHP-процессов или аварийному завершению службы. С точки зрения пользователя сайт попросту перестаёт отвечать — «падает» до ручного перезапуска.
~~~

## 13. «Утечки памяти в Zend/PHP-модулях»
### 13.1.
Я тебя спросил:
~~~
В пункте 2.2 ты писал:
- **Утечки памяти в Zend/PHP-модулях**: бывает, что некорректное расширение или библиотека могут приводить к постепенной утечке памяти, из-за чего процесс PHP-FPM уходит в нерабочее состояние.

Опиши подробнее, каким образом «утечки памяти в Zend/PHP-модулях» могут приводить к «going down» (пункт 4)?
~~~

### 13.2.
Ты ответил:
~~~
Когда в модулях PHP или Zend Engine (например, в кастомных расширениях, декодерах, библиотеках для работы с графикой и т.д.) есть **утечка памяти**, они постоянно «накапливают» использование RAM, не освобождая её по завершении обработки запросов. Это может происходить незаметно, но каждое выполнение скрипта добавляет немного «утекшей» памяти. Ниже — почему это в итоге приводит к «going down» (полной недоступности приложения):

---

### 1. Постепенное увеличение потребления памяти в рабочих процессах

1. **Неправильная работа модуля**  
   Если какой-то PHP-модуль (расширение) неправильно освобождает память (или вовсе не освобождает её при выходе из функции), то с каждым запросом объём занятой памяти в одном или нескольких PHP-FPM-процессах продолжает расти.

2. **Долгоживущие процессы (PHP-FPM)**  
   В отличие от классического `mod_php` (когда процесс Apache может перезапускаться чаще), PHP-FPM-пулы могут работать достаточно долго (или фактически постоянно) — пока не достигнут лимита по числу обработанных запросов (`pm.max_requests`) или не будут перезапущены вручную. Если процессы работают часами или сутками, утечки памяти накапливаются внутри каждого воркера.

---

### 2. Исчерпание ресурсов и замедление работы

1. **Рост потребления RAM каждым процессом**  
   По мере роста памяти внутри процессов суммарное использование RAM на сервере начинает приближаться к максимуму (особенно если `pm.max_children` настроен на большое количество воркеров).

2. **Уход в swap**  
   Когда физической памяти не хватает, система переходит к использованию swap (дискового раздела под виртуальную память). Это радикально замедляет выполнение запросов, так как доступ к диску на порядки медленнее, чем к оперативной памяти.

3. **Первыe таймауты**  
   Из-за резкого падения производительности (все воркеры могут быть загружены по максимуму, а оставшиеся процессы PHP-FPM — «увязнуть» в swap) пользователи начинают получать ошибки таймаута (503, 504, 524). В этот момент сервис ещё жив, но практически не отвечает.

---

### 3. Срабатывание OOM Killer и фактическое «падение»

1. **Out Of Memory (OOM)**  
   Если утечка продолжается, а памяти физически уже нет, ядро Linux может запустить **OOM Killer**. Он «выбирает» наиболее ресурсоёмкие процессы (а это часто и будет `php-fpm`) и насильно завершает (kill) их, чтобы освободить системную память.

2. **«Падение» PHP-FPM**  
   При убийстве критического числа дочерних процессов или самого главного процесса PHP-FPM сервис перестаёт обслуживать запросы — в логах видны записи вида `Out of memory: Kill process <PID>`. С точки зрения пользователей сайт становится полностью недоступен, то есть **«going down»**.

3. **Необходим принудительный перезапуск**  
   После срабатывания OOM Killer или «зависания» из-за swap сервер может фактически «повиснуть» до ручного перезапуска (или до тех пор, пока встроенные механизмы мониторинга WHM/cPanel не перезапустят службу автоматически).

---

### 4. Роль «утечек» в постоянном воспроизведении проблемы

- **Даже при нормальной нагрузке** сайты будут «падать» раз в N часов/дней, потому что память «утекает» по чуть-чуть, и в итоге сервер достигает критической точки, когда свободной RAM уже не остаётся.  
- **Без решения первопричины** (исправления кода расширения/библиотеки, обновления модуля, либо настройки ограничений `max_requests` и т.д.) проблема будет повторяться циклично, требуя периодического перезапуска служб.

---

### 5. Как понять, что дело в утечке памяти

1. **Мониторинг памяти**  
   - Запустить утилиты `top`, `htop`, Munin или Netdata и посмотреть, как растёт потребление памяти у процессов `php-fpm`.  
   - Если память постепенно «ползёт» вверх (при прочих равных нагрузках), это признак утечки.

2. **Логи OOM Killer**  
   - В `/var/log/messages`, `/var/log/dmesg` (CentOS) иногда можно увидеть явные упоминания об убитых процессах и причину «Out of memory».

3. **Проверка версии Zend/PHP-модулей**  
   - Известно, что некоторые версии IonCube, Zend Guard, ImageMagick, GD, OPCache и прочих расширений имели баги, приводящие к утечкам памяти (особенно в устаревших релизах).

4. **Ограничение на число запросов**  
   - Если при установке в PHP-FPM параметра `pm.max_requests=100` (или другого небольшого значения), после чего утечки перестают приводить к «падению», это почти наверняка подтверждает, что воркеры «слишком долго» живут и «забирают» память по чуть-чуть.

---

### Итог

**Утечки памяти** в Zend/PHP-модулях — это скрытая, но крайне опасная проблема, потому что со временем **любой** (даже мощный) сервер начинает испытывать нехватку RAM, уходит в swap и/или срабатывает механизм OOM Killer. Всё это приводит к тому, что службы (в частности, PHP-FPM) **«падают»** (going down) и перестают отвечать на запросы, пока администратор не выполнит перезапуск или не устранит причину утечки.
~~~

## 14. «Длительные запросы к базе данных»
### 14.1.
Я тебя спросил:
~~~
В пункте 2.2 ты писал:
- **Длительные запросы к базе данных**: если в коде есть неэффективные запросы (например, большие JOIN'ы, отсутствующие индексы), может происходить блокировка или слишком долгая обработка, приводя к таймаутам.

Опиши подробнее, каким образом «длительные запросы к базе данных» могут приводить к «going down» (пункт 4)?
~~~

### 14.2.
Ты ответил:
~~~
Когда в коде приложения есть **неэффективные** или **длительно выполняющиеся** SQL-запросы (большие `JOIN`-операции, отсутствие индексов, сложные подзапросы и т.п.), это может приводить не только к таймаутам, но и к полной недоступности приложения («going down»). Ниже показана типичная цепочка таких событий:

---

## 1. Продолжительная блокировка и «зависание» PHP-процесса

1. **Длительное ожидание ответа от БД**  
   - PHP-скрипт отправляет к базе «тяжёлый» запрос (например, с большими `JOIN`’ами или без необходимых индексов).  
   - Обработка может занять секунды, десятки секунд и даже минуты.  
   - Пока PHP ждет результат, соответствующий процесс (воркер) PHP-FPM находится в режиме ожидания (blocking I/O).

2. **Удерживание соединения**  
   - Время выполнения запроса к базе данных (MySQL или другой) напрямую влияет на занятость PHP-процесса.  
   - Чем дольше идёт запрос, тем дольше PHP-процесс «захвачен» этим соединением и не может обслужить другие запросы.

3. **Рост очереди запросов**  
   - Если несколько пользователей одновременно вызывают подобные «тяжёлые» запросы, число занятых PHP-процессов начинает быстро расти.  
   - Веб-сервер (Apache/Nginx) ставит новые входящие запросы в очередь, ожидая освободившихся воркеров.

---

## 2. «Проливной дождь» на уровне БД (блокировки и конкуренция)

1. **Взаимные блокировки (Locks)**  
   - Длительные запросы с модификацией данных (INSERT/UPDATE/DELETE) или даже SELECT-операции в определённых режимах изоляции транзакций могут удерживать блокировки на таблицах или строках.  
   - Другие запросы (даже «лёгкие») могут «стоять» в очереди на блокировку и тоже подвисать. 

2. **Увеличение времени ответа БД**  
   - Из-за блокировок и конкурентного доступа даже небольшие запросы начинают дольше выполняться.  
   - В итоге всё больше PHP-процессов оказываются в состоянии ожидания ответа от базы.

3. **Рост нагрузки и возможный отказ в обслуживании**  
   - Если MySQL настроен на ограниченное число соединений (`max_connections`), под большим валом запросов оно может быстро исчерпаться.  
   - При превышении лимита подключения к БД новые запросы получают ошибку вроде «Too many connections». Это тоже может приводить к «падению» приложения, если код не обрабатывает такое исключение правильно.

---

## 3. Нехватка ресурсов на уровне PHP-FPM и ОС

1. **Избыточный расход памяти**  
   - Если PHP-процессы висят долго, то их память, выделенная под выполнение скриптов, продолжает быть занята.  
   - Под нагрузкой суммарное потребление RAM растёт и может достичь критических значений.  
   - В итоге может сработать OOM Killer, убивший главный процесс PHP-FPM или MySQL — после чего сайт «ложится» целиком.

2. **Заполнение пула PHP-FPM**  
   - Параметры `pm.max_children`, `pm.start_servers`, `pm.min_spare_servers` определяют, сколько одновременно может быть активных PHP-процессов.  
   - Если все эти процессы «зависли» в ожидании ответа от БД, **не остаётся свободных воркеров**, чтобы обработать новые запросы.  
   - Веб-сервер начинает отклонять запросы (5xx) или «вечно» ожидать свободного воркера, что воспринимается как «зависание» или полная недоступность приложения.

---

## 4. «Going down»: когда сервер перестаёт отвечать

1. **Массовые таймауты**  
   - По мере роста очереди и увеличения времени выполнения запросов пользователи начинают всё чаще получать ошибки вида 504 Gateway Timeout, 524 A Timeout Occurred (Cloudflare) или даже 500 Internal Server Error.  
   - При внешнем мониторинге складывается впечатление, что сервер «упал» (нет ответа, только таймауты).

2. **Критический сбой**  
   - Если база данных достигает предела соединений, начинает «виснуть» или «падать» (например, из-за перегрузки по CPU/RAM), то даже простые запросы перестают обрабатываться.  
   - PHP-FPM (или Apache) могут перейти в состояние, когда процессы висят в бесконечных ожиданиях, и система фактически **перестаёт быть доступной**.

3. **Необходимость ручного/автоматического перезапуска**  
   - В итоге администратор (или авто-мониторинг cPanel/WHM) вынужден перезапустить PHP-FPM, MySQL или весь сервер, чтобы освободить блокировки, закрыть «зависшие» соединения и вернуть приложение «к жизни».  
   - Для пользователя это выглядит как «сайт окончательно упал, пока кто-то не нажал кнопку “Restart”».

---

## 5. Итоговая взаимосвязь

1. **Наличие «тяжёлых» или плохо индексированных запросов** →  
2. **Длительное время выполнения и ожидания** →  
3. **Занятые PHP-процессы, блокировки в БД, рост очередей** →  
4. **Перегрузка (CPU, RAM) или стопор пула PHP-FPM** →  
5. **Фактическая недоступность приложения («going down»)**.

Таким образом, **проблема «длительных запросов к базе данных»** способна вызывать каскад блокировок и долгих ожиданий, из-за которых:

- Все доступные процессы PHP-FPM оказываются «заблокированными»;  
- Сервер перегружается по памяти или CPU;  
- В результате сайт перестаёт отвечать на новые запросы, и пользователи видят полную недоступность до перезапуска служб.
~~~

## 15. «Неправильно обрабатываемые исключения»
### 15.1.
Я тебя спросил:
~~~
В пункте 2.2 ты писал:
- **Неправильно обрабатываемые исключения**: если ошибки в коде не перехватываются, некорректная обработка может приводить к крашу рабочих процессов PHP-FPM.

Опиши подробнее, каким образом «неправильно обрабатываемые исключения» могут приводить к «going down» (пункт 4)?
~~~

### 15.2.
Ты ответил:
~~~
Когда в коде PHP-приложения возникают исключения (Exceptions), которые **не перехватываются** (unhandled exceptions) или обрабатываются **неправильным** образом, это может запустить цепочку ошибок, в результате которой служба PHP-FPM перестаёт работать стабильно и фактически «падает» («going down»). Вот как это происходит более детально:

---

## 1. Фатальные ошибки и аварийное завершение (краш) рабочих процессов

1. **Необработанная ошибка в коде**  
   - Если в коде появляется исключение, которое не перехвачено блоками `try/catch`, PHP трактует это как фатальную ошибку (Fatal error), особенно если включена строгая обработка ошибок.  
   - Фатальная ошибка может привести к немедленному завершению процесса (дочернего воркера PHP-FPM), который выполнял текущий запрос.

2. **Крах воркера (child process)**  
   - Когда воркер завершается аварийно, PHP-FPM автоматически может попытаться создать новый воркер.  
   - Если таких фатальных ошибок происходит много (например, при повторяющихся запросах к «проблемному» участку кода), PHP-FPM постоянно будет терять и воссоздавать воркеры — это создаёт дополнительную нагрузку на память и CPU.

3. **Исчерпание воркеров**  
   - В некоторых случаях воркеры могут «зависнуть» в процессе ошибочной обработки исключений (например, если ошибка оставила состояние процесса в невалидной точке), что мешает им завершиться корректно.  
   - Если ограничение по количеству процессов (например, `pm.max_children`) достигнуто и при этом воркеры зависают или крашатся с высокой частотой, всё больше запросов будет оставаться необработанными, в итоге приводя к сбоям и недоступности.

---

## 2. Накопление последствий необработанных исключений

1. **Утечки ресурсов**  
   - При фатальных ошибках скрипт может не освободить захваченные ресурсы: соединения к базе данных, дескрипторы файлов, память для больших массивов и т. д.  
   - Повторяясь, эти необработанные исключения приводят к утечкам, и со временем система (PHP-FPM) начинает испытывать нехватку RAM или блокировку соединений MySQL.

2. **Рост нагрузки на систему**  
   - Если код продолжает генерировать исключения (например, в цикле или при каждом запросе), процессор тратит ресурсы на создание стэка исключения и логи.  
   - В логах может скапливаться огромное количество записей об ошибках, что вызывает повышенный I/O на диске и дополнительную нагрузку при чтении/записи лог-файлов.

3. **Ухудшение пропускной способности**  
   - Воркеры PHP-FPM, которые «спотыкаются» на необработанных исключениях, не освобождаются для нормальных запросов. В результате растёт очередь входящих HTTP-запросов, пользователи получают таймауты.  
   - Постепенно ситуация доходит до точки, где PHP-FPM перестаёт успевать отвечать, и сервис выглядит «упавшим».

---

## 3. Полная недоступность («going down»)

1. **Массовое аварийное завершение**  
   - Если исключения критичны, PHP-FPM может потерять бóльшую часть рабочих процессов (или даже сам менеджер процессов) за короткое время.  
   - В этом случае сервис перестаёт обслуживать запросы — пользователь видит ошибки 5xx, а в худшем случае сервер не отдаёт никакого ответа вовсе.

2. **Срабатывание защитных механизмов (OOM Killer и т.п.)**  
   - Если фатальные ошибки сопровождаются утечками памяти и резким ростом потребления ресурсов, ядро Linux может убить главный процесс PHP-FPM, чтобы освободить системную память.  
   - Результат всё тот же — «падение» (приложение перестаёт функционировать без перезапуска).

3. **Необходимость ручного перезапуска**  
   - Администратор или автоматизированный мониторинг замечают, что сайты недоступны (падают в статус «down»).  
   - Приходится заходить в WHM, в систему мониторинга или подключаться по SSH, чтобы выполнить `systemctl restart php-fpm` (или аналогичную команду) и вернуть сервис в рабочее состояние.

---

### Итог

«Неправильно обрабатываемые исключения» — это не просто локальная ошибка в коде, а потенциальный триггер для **цепной реакции**, которая приводит к частым сбоям рабочих процессов, утечкам ресурсов и накоплению критических ошибок. Всё это может **обрушить** (fully «bring down») службу PHP-FPM или даже целый сервер, делая сайт полностью недоступным, пока не будет устранена первопричина и выполнен перезапуск сервисов.
~~~

## 16. «Накопление временных файлов или логов»
### 16.1.
Я тебя спросил:
~~~
В пункте 2.2 ты писал:
- **Накопление временных файлов или логов**: при неправильном управлении логами или кэшами дисковое пространство может внезапно заполняться, что влияет на работу PHP.

Опиши подробнее, каким образом «накопление временных файлов или логов» модет приводить к «going down» (пункт 4)?
~~~

### 16.2.
Ты ответил:
~~~
Накопление временных файлов (например, в `/tmp`, `/var/tmp`, кэше сессий, директориях для загрузок) или избыточных логов (включая логи PHP-FPM, Apache/Nginx, MySQL) способно **полностью занять дисковое пространство** или вызвать сбои при записи файлов. Это может привести к тому, что приложения (включая PHP-FPM) станут недоступны — «going down». Ниже разберём детали этой цепочки.

---

## 1. Заполнение дискового пространства

1. **Рост объёма временных и лог-файлов**  
   - Если логи (error.log, access.log) постоянно дополняются, а ротация (logrotate) не настроена должным образом, их размер может неконтролируемо расти.  
   - Аналогичная ситуация с временными файлами: скрипты, загружающие данные, генерирующие кэш, или создающие временные документы, могут оставлять их «как есть» без удаления.

2. **Нехватка места для записи**  
   - Как только свободное место на разделе (чаще всего это корневой раздел `/` или `/var`) заканчивается, любая попытка записи (создание новых логов, загрузка файлов, запись кэша) будет выдавать ошибку «No space left on device».  
   - PHP и другие службы могут не суметь создать/записать файлы, что приводит к сбоям в их работе.

---

## 2. Сбой в работе PHP-FPM и сопутствующих сервисов

1. **Невозможность сохранять сессии**  
   - Если PHP-сессии хранятся в файловой системе (по умолчанию в `/var/lib/php/session` или `/tmp`), при переполнении диска запись новых сессий становится невозможной.  
   - Пользователи могут получать ошибки при авторизации, а скрипты — при сохранении/чтении данных сессии.

2. **Ошибки в логировании**  
   - При попытке записать логи (ошибки, предупреждения) в файл, который больше не может быть расширен, PHP-FPM или веб-сервер могут «падать» с фатальными ошибками.  
   - В итоге процесс «раскручивается» дальше: отсутствие возможности записать лог может мешать корректному завершению воркера.

3. **Нарушения в работе MySQL**  
   - Если логи MySQL или системные файлы (`ibdata`, binlog-и) тоже не могут быть записаны, база данных начинает выдавать критические ошибки вплоть до аварийного завершения.  
   - Как следствие, PHP-приложения теряют соединение с базой и массово «обрушиваются».

---

## 3. Эффект «снежного кома» и полная недоступность («going down»)

1. **Замедление процессов**  
   - Когда система пытается записать что-то на переполненный диск, операции ввода-вывода (`I/O`) начинают работать с ошибками и задержками, вызывая повышенную нагрузку на CPU и возможные зависания воркеров PHP-FPM.  
   - Запросы «зависают» в ожидании записи логов/файлов и многократно превышают таймауты.

2. **Переполнение очереди PHP-FPM**  
   - Из-за роста времени обработки и невозможности завершить скрипты вовремя все воркеры могут оказаться заняты.  
   - Новые запросы начнут получать 5xx-ошибки или уходить в «вечное ожидание», и для пользователя сайт фактически перестаёт отвечать.

3. **Аварийное завершение служб**  
   - Если MySQL не может продолжать работу без записи на диск, она «падает» (crash).  
   - PHP-FPM, не получая ответов от БД (или не имея возможности записать сессии/кэш), также переходит в состояние сбоя.  
   - В результате приложения полностью недоступны до тех пор, пока не освободят место на диске и не перезапустят сервисы.

---

## 4. Итого: как «накопление временных файлов или логов» ведёт к падению

1. **Временные файлы/логи беспорядочно растут** → диск переполняется.  
2. **PHP-FPM, веб-сервер, MySQL не могут корректно писать/читать** → начинаются ошибки записи, сессии не создаются, база не журналируется.  
3. **Системные процессы «захлёбываются»** → воркеры PHP-FPM зависают или падают, MySQL выдаёт критические ошибки, сайт не отвечает.  
4. **Сайт фактически «ложится»** (going down) → необходима очистка/ротация логов и перезапуск служб.

Таким образом, **без регулярной очистки** или корректной настройки ротации логов и временных файлов **диск может заполниться** настолько, что любые операции записи будут невозможны. Это влечёт за собой цепную реакцию отказов (PHP-FPM, MySQL, веб-сервер), и сайт полностью перестаёт работать, пока администратор не устранит проблему (освободит место и перезапустит сервисы).
~~~

## 17. «Неверные настройки проксирования»
### 17.1.
Я тебя спросил:
~~~
В пункте 2.2 ты писал:
- **Неверные настройки проксирования**: в некоторых случаях настройки Cloudflare (таймауты, ограничения на размер ответа и т.д.) могут вызывать проблемы при обработке определённого трафика, что приводит к сбоям на уровне приложения.

Опиши подробнее, каким образом «неверные настройки проксирования» могут приводить к «going down» (пункт 4)?
~~~

### 17.2.
Ты ответил:
~~~
Неправильные или некорректно согласованные настройки Cloudflare (а иногда и других CDN/прокси-сервисов) могут привести к тому, что **приложение перестаёт отвечать** на запросы или выглядит «упавшим» (going down). Ниже описан механизм, как это может происходить.

---

## 1. Несогласованные таймауты и ограничения размеров ответа

1. **Таймаут на стороне Cloudflare**  
   - По умолчанию Cloudflare имеет собственные лимиты времени ожидания ответа от сервера (например, 100 секунд для HTTP-запроса в бесплатном тарифном плане).  
   - Если реальный бэкенд (ваш сервер с PHP-FPM) медленно обрабатывает запрос или вообще «подвис», Cloudflare прерывает соединение и отдаёт пользователю ошибку 524 (A Timeout Occurred), 522 (Connection timed out) или 504 (Gateway Timeout).  
   - Если таких ошибок много, пользователи начинают думать, что сайт «упал», ведь все обращения заканчиваются таймаутом.

2. **Ограничения на размер ответа**  
   - Если Cloudflare настроен на ограничение размера ответа или скорость отдачи (чаще встречается в тарифных планах с определёнными лимитами), большой ответ от сервера может блокироваться, а сам запрос — прерываться.  
   - Внешне это проявляется как «зависание» или «падение» сайта, так как пользователь не получает корректного ответа.

3. **Цепная реакция**  
   - Получая массовые таймауты или обрывы, клиенты (браузеры, боты, любые обращающиеся к сайту сущности) продолжают слать повторные запросы.  
   - Это может ещё сильнее нагрузить бэкенд, увеличить очереди в PHP-FPM и вызвать «настоящий» крах или «подвисание» (going down).

---

## 2. Неверные DNS-записи и SSL-конфигурация

1. **Ошибки в A/AAAA/CNAME-записях**  
   - Если DNS-записи неправильно указывают на IP-адрес (либо на старый адрес сервера), Cloudflare будет пытаться обращаться к несуществующему/неверному бэкенду.  
   - В таком случае Cloudflare сразу отдаст пользователям ошибку (521 Web Server Is Down или 522 Connection timed out), и сайт будет казаться полностью «упавшим».

2. **Несоответствие SSL-сертификатов (Full, Full Strict, Flexible)**  
   - Cloudflare предлагает разные режимы шифрования (Flexible, Full, Full Strict).  
   - При неверном выборе режима (например, «Full Strict», а на сервере не установлен корректный SSL-сертификат) Cloudflare будет разрывать соединение при попытке установить HTTPS-туннель до вашего веб-сервера.  
   - Пользователи вместо сайта увидят сообщение о недоступности ресурса.

3. **Редирект-петли**  
   - Частая ситуация: если Cloudflare настроен в режиме Flexible SSL (проксирует трафик по HTTPS снаружи, а до сервера идёт HTTP), а на самом сервере настроен автоматический редирект с HTTP на HTTPS, возникает бесконечная петля редиректов.  
   - В итоге для пользователей сайт либо не грузится вообще, либо выдаёт 522/525/Too Many Redirects, что фактически означает «падение».

---

## 3. Блокировки или фильтры Cloudflare (WAF, Firewall Rules)

1. **Избыточные правила брандмауэра (Firewall Rules)**  
   - Администратор может настроить слишком строгие firewall-правила в Cloudflare (например, блокировать определённые IP-диапазоны или типы запросов).  
   - Если под эти правила попадает легитимный трафик (или даже сам сервер при внутренних запросах), Cloudflare будет возвращать ошибку (403 Forbidden, 1020 Access Denied и т.д.).  
   - Для пользователя сайт становится недоступен.

2. **WAF (Web Application Firewall) и «ложные срабатывания»**  
   - Cloudflare WAF может блокировать запросы, если они выглядят «подозрительно» (длинные URL, специфический payload).  
   - Если логика WAF настроена неправильно (false positives), многие реальные пользовательские запросы отклоняются, и создаётся впечатление, что сайт «упал» (особенно если блокируются все POST-запросы или весь трафик из определённых регионов).

3. **Rate Limiting / Under Attack Mode**  
   - При активации режима «Under Attack» или жёстких лимитов на число обращений в секунду Cloudflare может начинать показывать страницы проверки (Challenge pages) или вообще блокировать часть запросов.  
   - Если этот процесс зациклен или настроен некорректно, пользователи могут не пройти проверку и оказаться «заблокированными», фактически сайт для них «не работает».

---

## 4. Конфликт настроек прокси и реального веб-сервера

1. **Proxy vs. Direct**  
   - Если сайт частично доступен напрямую (например, по IP без прохождения через Cloudflare) и частично через Cloudflare, может возникнуть конфликт cookie/сессий, leading to логические ошибки или краши в самом приложении.  
   - В отдельных случаях PHP-FPM может «сыпаться» от неконсистентных данных (особенно при сложной авторизации или при генерации URL’ов).

2. **Сбой записи реального клиентского IP**  
   - При работе через Cloudflare важно правильно считывать IP-адрес клиента (via `HTTP_X_FORWARDED_FOR` или `CF-Connecting-IP`).  
   - Если приложение или серверная часть неправильно обрабатывают заголовки, может включаться защита (например, защита от «подозрительных IP»), блокируя всех посетителей.  
   - Массовые блокировки выглядят как полноценный «даун».

3. **Несовпадение keepalive-таймаутов и буферов**  
   - Если настройки keepalive (время «удержания» соединения) отличаются на стороне Cloudflare и реального сервера, соединения могут разрываться в середине передачи данных.  
   - Возникают массовые ошибки 520/521/524, и создаётся впечатление, что сервер упал.

---

## 5. Итог: как «проксирование» превращается в «going down»

1. **Неправильная (или конфликтная) конфигурация DNS/SSL/таймаутов/Firewall** в Cloudflare.  
2. **Частые ошибки 52x (522, 524, 521, 520)** или непрекращающиеся «Timeout»/«Access Denied» для пользователей.  
3. Пользователи (и мониторинги) видят, что сайт стабильно не открывается → **«Сайт упал»**.  
4. В ряде случаев это приводит к реальному «падению» бэкенда, если сервер начинает «сыпаться» от шквала некорректных или зацикленных запросов (например, из-за бесконечных повторных попыток Cloudflare).

Таким образом, **«неверные настройки проксирования»** через Cloudflare (неправильные таймауты, лимиты, DNS-записи, SSL-режимы, WAF/брандмауэр) могут вызвать как ложное ощущение «падения» (хотя сам сервер работает, но не отвечает корректно через Cloudflare), так и настоящие сбои на сервере (из-за зацикленных или заблокированных запросов). В обоих случаях итог один: **пользователи видят, что сайт не доступен** (going down), пока не будут исправлены настройки или выполнен перезапуск/корректировка конфигурации.
~~~

## 18. «бывает, что после обновлений cPanel/WHM некоторые директивы PHP или Apache сбиваются»
### 18.1.
Я тебя спросил:
~~~
В пункте 2.2 ты писал:
бывает, что после обновлений cPanel/WHM некоторые директивы PHP или Apache сбиваются.

Опиши подробнее, сбой каких конкретно директив мог привести к «going down» (пункт 4)?
~~~

### 18.2.
Ты ответил:
~~~
Ниже перечислены **примеры** директив и настроек, которые часто сбиваются или перезаписываются после обновлений cPanel/WHM и могут в итоге приводить к «going down» (то есть полной недоступности сайтов, пока не будет выполнен перезапуск). Эти настройки затрагивают как **Apache** (иногда в связке с PHP-FPM), так и **PHP** (через php.ini и pool-конфиги):

---

## 1. Настройки Apache (HTTP-сервера)

1. **MPM (Multi-Processing Module) и связанные лимиты**  
   - **`MaxRequestWorkers` (ранее MaxClients)**, `ServerLimit`, `StartServers`, `MinSpareServers`, `MaxSpareServers`.  
   - Если после обновления cPanel/WHM эти параметры были сброшены до значений, которые не соответствуют реальной нагрузке, при пиковом трафике Apache может либо создавать слишком мало воркеров (и «захлёбываться» в очереди запросов), либо наоборот — порождать их слишком много, расходуя всю память и «падая» из-за OOM Killer.  

2. **KeepAlive и таймауты**  
   - **`KeepAlive`**, `KeepAliveTimeout`, `Timeout`.  
   - Бывает, что после обновлений KeepAlive снова включается (или наоборот отключается), и при больших значениях `KeepAliveTimeout` множество «зависших» соединений продолжительное время удерживают воркеры. Это ведёт к быстрому исчерпанию рабочих процессов и «падению» сервера под нагрузкой.

3. **Proxy / FastCGI директивы (если используется Nginx/Apache в режиме прокси к PHP-FPM)**  
   - **`ProxyPass` / `ProxyFCGISetEnvIf`** и аналогичные директивы.  
   - При обновлениях cPanel/WHM конфиги могут перезаписываться, из-за чего сбиваются пути к сокету PHP-FPM или настройки таймаутов (например, `ProxyTimeout`, `ProxyReadTimeout`).  
   - В результате сайт начинает возвращать 502/504, а при массовых ошибках PHP-FPM «уходит» в недоступное состояние.

4. **Дополнительные `Include`-файлы (Apache include files)**  
   - cPanel/WHM может регенерировать конфигурационные файлы и игнорировать или удалять вручную прописанные `Include`-директивы.  
   - Если там были важные настройки перезаписи (Rewrite), нестандартные таймауты или ограничения, их исчезновение может привести к неправильной работе виртуальных хостов.

---

## 2. Настройки PHP (php.ini и конфигурация PHP-FPM)

1. **Ограничения по памяти и времени**  
   - **`memory_limit`**, `max_execution_time`, `max_input_time`, `request_terminate_timeout`.  
   - После обновлений cPanel/WHM эти настройки могут вернуться к «умолчанию» (иногда достаточно низким) или, наоборот, стать слишком большими.  
   - В первом случае сервер начинает агрессивно обрывать тяжелые запросы, вызывая массовые ошибки и потенциальную нестабильность воркеров. Во втором — PHP-процессы могут поглощать всю доступную память и «ронять» PHP-FPM.

2. **`upload_max_filesize` и `post_max_size`**  
   - Если значения снижаются, а сайт продолжает обрабатывать большие загрузки, PHP начинает «ломаться» на файлах, превышающих лимит; воркеры могут «подвисать» или аварийно завершаться.  
   - В обратном случае (слишком большие значения) при массовой загрузке крупных файлов легко «выбить» сервер из строя по памяти или по I/O.

3. **Пулы PHP-FPM (в файлах `/etc/php-fpm.d/*.conf`)**  
   - **`pm`**, `pm.max_children`, `pm.start_servers`, `pm.min_spare_servers`, `pm.max_spare_servers`, `pm.max_requests`.  
   - cPanel может перезаписывать конфиг по пулу (особенно если используется EasyApache и MultiPHP Manager). Если вдруг `pm.max_children` в одном из пулов выставляется на очень большое значение — при пиковой нагрузке расходуется весь объём RAM, и служба падает. Если же значение слишком низкое, запросы «застревают» в очереди и сайты выглядят «упавшими» из-за постоянных 503/504 таймаутов.

4. **Настройки расширений (modules) или OPCache**  
   - cPanel обновляет версию PHP или определённые модули, пересобирая конфиг и сбрасывая, к примеру, настройки OPcache, Zend Guard Loader, IonCube Loader и др.  
   - Если какой-то модуль, нужный для нормальной работы, перестаёт загружаться или конфликтует с новой версией, могут возникать фатальные ошибки и краши PHP-FPM.

5. **php.ini внутри конкретных виртуальных хостов**  
   - Иногда администраторы вносят локальные изменения (через `.user.ini` или `.htaccess`) — при обновлениях cPanel пути к этим файлам могут «слетать», а сам файл php.ini может вернуться к дефолту.  
   - В результате некоторые critical-директивы (таймауты, memory_limit, разрешение на сторонние расширения) перестают действовать, и сайт уходит в режим ошибок.

---

## 3. Настройки MySQL/MariaDB через WHM (косвенно влияющие на PHP-FPM)

Хотя это не совсем директивы PHP/Apache, но **после обновления WHM** настройки MySQL тоже могут «сбиться» (например, `max_connections`, `innodb_buffer_pool_size`). Если `max_connections` занижено или буфер InnoDB становится слишком маленьким, под нагрузкой БД начинает «тормозить» или выдавать «Too many connections», что снова ведёт к «падению» сайта со стороны PHP-FPM.

---

## 4. Примеры ситуаций, когда сбитые директивы приводят к «going down»

1. **Слишком много доступных воркеров (Apache или PHP-FPM)**  
   - После апдейта оказалось, что `MaxRequestWorkers` или `pm.max_children` установлен на огромную цифру. При наплыве трафика воркеры массово создаются, «съедают» всю RAM, срабатывает OOM Killer — в итоге PHP-FPM (или Apache) полностью прекращает работать.

2. **Слишком маленькие лимиты или отключён KeepAlive**  
   - Если `MaxRequestWorkers`/`pm.max_children` задаётся слишком низко, сервер мгновенно упирается в лимит воркеров, и все новые запросы получают 503/504. Для пользователя это выглядит как «сайт упал».  
   - Если `KeepAlive` внезапно включился с большим `KeepAliveTimeout`, часть воркеров будет «висеть» на неактивных соединениях, пока новые запросы «выбивают» лимит.

3. **Сброшенные значения `memory_limit`**  
   - Если оно случайно стало слишком высоким (например, 1–2 ГБ на один процесс PHP), то пара-тройка тяжёлых скриптов могут «съесть» всю оперативную память. Результат — массовый своп или OOM Killer.  
   - Если же `memory_limit` стал слишком маленьким, а код периодически требует больше памяти, PHP-фатальные ошибки будут следовать одна за другой, что в конечном итоге может «положить» пул PHP-FPM из-за постоянных крашей воркеров.

4. **Неверные пути к сокетам PHP-FPM после обновления**  
   - cPanel в некоторых случаях меняет логику формирования сокетов (особенно при использовании MultiPHP). Если конфигурация Apache не совпадает с реальным путём к сокету, начинаются ошибки 502/503, и весь сайт может оказаться недоступным, пока проблема не будет исправлена вручную.

---

### Итог

Обновления cPanel/WHM способны **перезаписывать** или **сбрасывать** часть настроек, необходимых для стабильной работы Apache, PHP-FPM и MySQL. Любое серьёзное расхождение параметров (таймаутов, лимитов, путей к сокетам, версий модулей) с теми, что были до обновления, может **спровоцировать** перегрузку по ресурсам, зависание воркеров или массовые ошибки, ведущие к полной **недоступности** сайта — то есть тому самому «going down».
~~~

## 19. «Ошибки в работе диска (I/O)»
### 19.1.
Я тебя спросил:
~~~
В пункте 2.2 ты писал:
```
   - **Ошибки в работе диска (I/O)**: если диск перегружен операциями ввода-вывода, процессы PHP-FPM могут зависать, пока ожидают освобождения ресурсов.
```
Опиши подробнее, каким образом «ошибки в работе диска (I/O)» могли привести PHP applications клиента к «going down» (пункт 4)?
~~~

### 19.2.
Ты ответил:
~~~
Когда на сервере возникают проблемы с диском или подсистемой ввода-вывода (I/O) — будь то аппаратные сбои, перегрузка по количеству операций или медленная (или повреждённая) дисковая подсистема, — это способно привести к тому, что приложения (в частности, PHP-FPM) перестают отвечать вовремя и фактически «падают» («going down»). Ниже рассмотрим основные механизмы этого процесса.

---

## 1. Перегрузка операций чтения/записи (I/O congestion)

1. **Увеличенные задержки (latency) при доступе к файлам**  
   - Если диск сильно загружен операциями (например, сервер постоянно пишет логи, временные файлы, загружает/обрабатывает большие файлы, идёт бэкап или антивирусная проверка), время чтения или записи данных может возрасти в разы.  
   - PHP-приложения (через PHP-FPM) подчас обращаются к файлам сессий, кэшей, загружаемым изображениям и т.д. Если эти операции выполняются крайне медленно, каждый воркер PHP-FPM начинает «зависать» в ожидании завершения I/O.

2. **Рост очередей запросов**  
   - Когда все PHP-процессы «упираются» в задержки при работе с диском, они занимают воркеры дольше обычного. Новые запросы не могут быстро получить свободный процесс, растёт очередь.  
   - Веб-сервер (Apache/Nginx) может постепенно исчерпать все доступные воркеры, и пользователи начнут получать ошибки таймаута (504/524) или 503 Service Unavailable.

3. **Переход в состояние «зависания»**  
   - Если задержки (latency) по диску становятся критическими, фактически вся обработка PHP-скриптов может встать в очередь, и ни один процесс не сможет завершиться вовремя.  
   - Это выглядит как «сайт не отвечает» — фактически «going down» до тех пор, пока не освободится дисковая подсистема или не будет сделан перезапуск.

---

## 2. Аппаратные ошибки и сбои диска

1. **Аппаратные проблемы (bad blocks, деградировавший RAID)**  
   - Если сервер находится в состоянии, когда диск сбоит (повреждённые сектора, деградация RAID-массива), чтение или запись могут фактически «подвисать» на низком уровне.  
   - Операционная система пытается повторять операции, что может вызывать длительные фризы (задержки в секундах или даже минутах).  

2. **Фатальные ошибки и переход в режим «read-only»**  
   - При критических аппаратных ошибках файловая система может перейти в режим «только чтение» (read-only). В этом состоянии любые попытки записи (логирование, запись сессий и т.д.) приводят к ошибкам.  
   - PHP-FPM при невозможности записи необходимых временных файлов может «упасть» (краш), а пользователи перестанут получать контент.

3. **Перекрытие «уникальных» ресурсов**  
   - Если системные области (например, `/var/lib/php/session`, файлы конфигурации, сокеты PHP-FPM) оказались на повреждённом участке диска и ОС не может к ним получить доступ, сервисы перестают корректно работать.  
   - В результате PHP-FPM не стартует или работает с перебоями, выдавая фатальные ошибки — сайт оказывается «down».

---

## 3. Рост нагрузки на CPU из-за блокирующего ожидания (I/O wait)

1. **Высокий показатель iowait**  
   - В Linux параметр iowait (%wa) в `top`/`htop` отражает, сколько времени CPU простаивает, ожидая операций ввода-вывода. Если этот показатель высокий, это значит, что многие процессы ждут завершения I/O, а не выполняются сразу.  
   - При iowait в десятки процентов система начинает работать рывками, а время выполнения любых задач увеличивается.

2. **Эффект «снежного кома»**  
   - Медленная запись логов → длинные очереди ожидания → новые PHP-процессы не успевают завершиться → ещё больше задержек, потенциально переходящих в таймауты.  
   - Дальше нагрузка может «домино» повлиять на MySQL (если база находится на том же диске), заставляя всю связку PHP-FPM+MySQL «подвиснуть».

3. **Исчерпание лимитов и последующий «крах»**  
   - Пока процессы «застряли» в дисковом вводе-выводе, новые подключающиеся пользователи быстро заполняют все слоты PHP-FPM.  
   - Веб-сервер перестаёт обслуживать запросы, а снаружи это выглядит, будто «сайт умер». Без ручного вмешательства (убийства зависших процессов, разгрузки сервера, перезагрузки служб) ситуация может не разрешиться автоматически.

---

## 4. Повреждение или блокировка файлов журналов и сессий

1. **Ошибки записи в логи**  
   - PHP-FPM, Apache и другие службы могут не уметь корректно обойтись без возможности писать логи. Если логи (особенно error_log) недоступны или заблокированы из-за ошибок диска, некоторые воркеры могут «застревать».  
   - В худшем случае процесс аварийно завершается, что вызывает серию крашей воркеров.

2. **Невозможность прочитать или записать PHP-сессии**  
   - Если файлы сессий расположены в каталоге на проблемном разделе диска, при попытке открыть или сохранить эти файлы PHP-FPM «зависает».  
   - Массовые запросы от пользователей, которые должны записать/прочитать сессии, приводят к лавинообразному росту блокировок, и ни один запрос не может завершиться.

3. **Фатальные ошибки приложений**  
   - Если приложение критически зависит от чтения/записи (например, кэш-шаблонов, конфигурационных файлов), и диск стал недоступен, код может сразу выдавать фатальные исключения.  
   - Как только «ключевые» файлы не читаются, приложение не инициализируется и «падает».

---

## 5. Итоговая связь «I/O-проблема → going down»

1. **Диск или файловая система в некорректном состоянии** →  
2. **Задержки (latency) при доступе к логам, сессиям, кэшам** →  
3. **Зависание и переполнение очереди PHP-FPM** →  
4. **Массовые таймауты, ошибки 5xx, фактическая недоступность** (going down) — приложение «лежит» до устранения проблемы (перезапуск, замена диска, освобождение I/O).  

Таким образом, **ошибки или перегрузка диска** способны устроить ситуацию, когда **все запросы** к приложению «зависают», и сервер перестаёт отвечать на уровне PHP-FPM/Apache/MySQL. Для клиента и пользователей это выглядит как «полное падение» сайта, пока не будут устранены проблемы с подсистемой ввода-вывода.
~~~

## 20. Таблица вероятностей
### 20.1.
Я тебя спросил:
~~~
Итак, в пункте 3 и в пунктах с 9 по 19 ты совокупно перечислил 12 вероятных причины проблемы клиента (по одной причине на пункт).
Построй таблицу с 3 колонками:
- номер причины (из пункта 3)
- вероятность, что именно эта причина является источником проблемы клиента  (в процентах)
- твоё пояснение: почему ты думаешь, что вероятность именно такая
Строки таблицы упорядочи по убыванию вероятностей.
~~~

### 20.2.
Ты ответил:
#### 20.2.1. Ответ 1
~~~
Ниже представлена сводная таблица из **12 наиболее вероятных причин** (по материалам пунктов **3** и **9–19**) с оценкой их вероятности (в процентах) и кратким пояснением, почему вероятность именно такая. Таблица упорядочена по убыванию вероятностей.

| **№ причины** | **Вероятность** | **Почему именно так**                                                                                                                                                                                                                 |
|:------------:|:---------------:|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **3. Недостаток оперативной памяти**                | **20%** | Частая и типичная причина регулярных «падений» PHP-FPM: при неверных настройках (`pm.max_children`) или небольшом объёме RAM процессы быстро «съедают» память, система уходит в swap или срабатывает OOM Killer, и службы «ложатся».                                   |
| **9. Ограничения по CPU**                           | **15%** | Если на сервере высокая нагрузка (много одновременных запросов, тяжёлые скрипты), PHP-FPM может упираться в 100% CPU. Запросы подвисают, очередь растёт, и в итоге сервис перестаёт отвечать, переходя в состояние «going down».                                      |
| **10. Недостаточно оптимизирована конфигурация Apache/Nginx** | **12%** | Некорректные параметры (число воркеров, `MaxRequestWorkers`, таймауты проксирования) часто приводят к тому, что либо воркеров слишком много (и сервер уходит в нехватку ресурсов), либо слишком мало (и все запросы простаивают в очереди), вызывая «падение» сайта. |
| **14. Длительные запросы к базе данных**            | **11%** | «Тяжёлые» SQL (нет индексов, большие JOIN) заставляют PHP-процессы долго ждать ответ от MySQL, расходуя воркеры и память. При пике обращений пул PHP-FPM исчерпывается, и сайт уходит в таймауты/полную недоступность.                                                 |
| **11. Недостаточно/слишком агрессивные таймауты**   | **10%** | Слишком короткие таймауты «убивают» запросы раньше времени, вызывая каскад ошибок; слишком длинные приводят к длительным «зависаниям» процессов. И то, и другое может обрушить пул воркеров, что выглядит как «going down».                                            |
| **13. Утечки памяти в Zend/PHP-модулях**            | **8%**  | Если какое-то расширение (например, IonCube, ImageMagick) «утекает» в память, каждый воркер со временем занимает всё больше RAM. Это накапливается и может закончиться крахом PHP-FPM (OOM Killer), из-за чего сайты регулярно «падают».                              |
| **17. Неверные настройки проксирования (Cloudflare)**| **7%**  | Ошибки с DNS/SSL-режимами, несоответствие таймаутов или блокирующие WAF-правила приводят к тому, что Cloudflare начинает отдавать 52x-ошибки. В глазах пользователей (и мониторингов) сайт будто «лёг», хотя корень проблемы — неверная конфигурация прокси.         |
| **18. Ошибки в настройках cPanel/WHM**              | **6%**  | После автоматических обновлений cPanel/WHM иногда сбиваются директивы Apache/PHP-FPM (число воркеров, пути к сокетам, `memory_limit` и т.д.). Неверные значения легко приводят к тому, что сервер не выдерживает нагрузку и перестаёт отвечать.                       |
| **19. Ошибки в работе диска (I/O)**                 | **4%**  | При перегруженном или сбоящем диске (bad blocks, деградация RAID) процессы PHP-FPM долго ждут завершения операций чтения/записи или вовсе «зависают». В результате — массовые таймауты и фактическое «падение» приложения.                                           |
| **12. Лимиты на загрузку файлов**                   | **3%**  | Попытки загрузить файлы, превышающие `post_max_size` / `upload_max_filesize`, либо некорректная обработка больших загрузок могут «подвешивать» воркеры PHP-FPM, приводя к недоступности. Однако это обычно специфично для сайтов с крупными аплоадами.              |
| **16. Накопление временных файлов или логов**       | **3%**  | Если диск переполняется логами/временными файлами, PHP-FPM не может сохранить сессии или логи, и начинает «падать» либо зависать из-за ошибок записи. Быстро решается очисткой/ротацией, поэтому встречается реже, но может вызывать полный «даун».                  |
| **15. Неправильно обрабатываемые исключения**       | **1%**  | Фатальные ошибки и необработанные Exception могут приводить к крашу отдельных воркеров. Массовые сбои в коде действительно могут «положить» сервис, но это обычно специфичная ошибка в самом приложении и встречается реже в готовых фреймворках.                      |

**Итого**: на практике чаще всего встречается комбинация нескольких факторов — например, недостаточно оптимизированный PHP-FPM (лимиты по памяти) **плюс** тяжёлые запросы к базе или конфликты с Cloudflare. Именно комплексная проверка настроек, логов и кода помогает точно определить, какой пункт из списка стал решающим в регулярных «падениях» сервера.
~~~

#### 20.2.2. Ответ 2
~~~
Ниже сводная таблица из **12** возможных причин (в порядке убывания вероятности), с указанием их исходного номера из предыдущих пунктов и кратким пояснением.

| № причины (из п.3, 9–19) | Вероятность | Пояснение                                                                                                                                                                                                                                                                                                                               |
|:-------------------------:|:-----------:|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **1. Недостаток оперативной памяти**<br>(п.3) | **18%**       | Очень характерно для ситуации, когда PHP-FPM «спасается» перезапуском. При пиковых нагрузках воркеры съедают всю ОЗУ, могут уходить в swap или срабатывать OOM Killer. Сайт «падает», пока не будет произведён ручной рестарт.                                                                                                          |
| **7. Длительные запросы к базе**<br>(п.14)    | **16%**       | Если в Zend-приложениях есть тяжёлые SQL-запросы (без индексов, с большими JOIN), PHP-процессы «зависают» в ожидании ответа от БД. В итоге пул воркеров быстро переполняется, начинаются таймауты (504/524), а затем и полная недоступность, требующая перезапуска.                                                                        |
| **11. Ошибки в настройках cPanel/WHM**<br>(п.18) | **14%**       | На серверах с cPanel обновления могут сбивать критичные параметры (количество воркеров, пути к сокету PHP-FPM, `memory_limit` и т. п.). Из-за этого конфигурация становится несбалансированной, что приводит к массовым сбоям и «падению» PHP-FPM.                                                                                      |
| **3. Недостаточно оптимизирована конфигурация Apache/Nginx**<br>(п.10) | **12%**       | Неверные лимиты MPM (MaxRequestWorkers), неподходящие `KeepAlive`, либо неправильная передача запросов к PHP-FPM (ProxyPass, fastcgi) могут перегружать сервер или приводить к блокировкам. В результате при пике трафика сайт «ложится» до ручного рестарта.                                                                            |
| **4. Недостаточно/слишком агрессивные таймауты**<br>(п.11) | **10%**       | Если `request_terminate_timeout`, `max_execution_time` и т. п. слишком короткие — скрипты обрываются и воркеры могут «зависать». Если слишком длинные — PHP-процессы висят вечно, расходуя ресурсы. Оба сценария могут закончиться полной недоступностью.                                                                                  |
| **10. Неверные настройки проксирования (Cloudflare)**<br>(п.17) | **8%**        | Сбойные DNS-записи, таймауты Cloudflare (524/522) или ошибки SSL-конфигурации могут «снаружи» создавать впечатление, что сайт «упал». Плюс при постоянных переподключениях сам сервер может перегружаться, если конфигурация прокси настроена неверно.                                                                                   |
| **2. Ограничения по CPU**<br>(п.9)             | **6%**        | Если скрипты слишком тяжёлые или tрафик высок, CPU уходит в 100%. PHP-FPM начинает обрабатываться медленно, очередь растёт, и, в конце концов, сервис фактически «виснет». Перезапуск даёт временное облегчение.                                                                                                                           |
| **6. Утечки памяти в Zend/PHP-модулях**<br>(п.13) | **5%**        | Постепенное «съедание» памяти при каждом запросе (например, из-за багнутого расширения) приводит к тому, что через некоторое время воркеры занимают всю RAM. Часто сопровождается срабатыванием OOM Killer и «падением» всего пула PHP-FPM.                                                                                             |
| **5. Лимиты на загрузку файлов / превышение `memory_limit`**<br>(п.12) | **4%**        | Большие файлы при загрузке могут блокировать воркеры надолго или приводить к резкому скачку использования памяти. При массовых загрузках служба «упирается» в лимиты и падает.                                                                                                                      |
| **9. Накопление временных файлов или логов**<br>(п.16) | **3%**        | Если `/tmp`, каталог сессий или логов переполнен, записи больше не выполняются, и PHP-FPM (или MySQL) начинает выдавать фатальные ошибки. Сайт перестаёт работать, пока не освободится место и не будет сделан рестарт.                                                                                                                   |
| **12. Ошибки в работе диска (I/O)**<br>(п.19)   | **2%**        | Проблемы с диском (I/O wait, повреждения, «read-only» режим) вызывают сильные задержки в работе PHP (зависание воркеров, невозможность записать логи/сессии). Сайт фактически «застывает» и выглядит упавшим.                                                                                                                             |
| **8. Неправильно обрабатываемые исключения**<br>(п.15) | **2%**        | Некорректная обработка (или полное игнорирование) исключений в коде может приводить к фатальным ошибкам и аварийному завершению PHP-процессов. Если таких ошибок много, пул PHP-FPM «сыплется» и перестаёт отвечать.                                                                                                                       |

**Важно**: приведённые проценты — это ориентировочная оценка вероятности, с учётом общего опыта подобных инцидентов. На практике точная причина (или сочетание причин) выясняется при глубоком анализе логов, мониторинге системных ресурсов и проверке конфигурации PHP-FPM/Apache/MySQL/Cloudflare.
~~~

#### 20.2.3. Ответ 3 
~~~
Ниже представлена сводная таблица из 12 возможных причин (каждая соответствует пунктам из сообщения №3 и пунктов №9–19), упорядоченная **по убыванию вероятности**, с кратким обоснованием:

| **№ (из п.3 и пп.9–19)** | **Вероятность** | **Почему именно такая вероятность**                                                                                                                                                                                                                                                                                                                                                                                                           |
|:------------------------:|:---------------:|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **7. Длительные запросы к базе данных**<br>(п.14) | **20%** |  Очень распространён корень проблемы при «падении» PHP-приложений: пара «тяжёлых» запросов к БД, особенно без индексов или с большими JOIN’ами, может быстро «забивать» все процессы PHP-FPM, вызывать блокировки и таймауты. Регулярная необходимость «ручного перезапуска» часто связана с тем, что MySQL/BД подвисает или долго обрабатывает запросы.                                                                 |
| **1. Недостаток оперативной памяти**<br>(п.3) | **15%** |  Частая причина, когда пул PHP-FPM настроен с избыточным количеством процессов или код потребляет много памяти. При исчерпании RAM возможен OOM Killer, убивающий PHP-FPM, после чего приложение «падает». Несколько перезагрузок в день — типичный симптом.                                                                                                                                                                              |
| **4. Недостаточно/слишком агрессивные таймауты**<br>(п.11) | **15%** |  Если таймауты выставлены неверно (слишком короткие или слишком длинные), приложения либо часто обрываются (503/504), либо повисают в «долгих» скриптах, что может приводить к переполнению пула PHP-FPM и полной недоступности. Многие админы не обращают внимания на точные значения `request_terminate_timeout`, `max_execution_time` и т.д., что делает этот пункт очень вероятным.                                                  |
| **2. Ограничения по CPU**<br>(п.9) | **10%** |  Если процессы PHP или MySQL «закручивают» процессор до 100%, система начинает «задыхаться», запросы не успевают обрабатываться, и в итоге сервер «ложится». Многократные падения за день нередко указывают на пики нагрузки по CPU (например, тяжёлые скрипты или внезапные наплывы трафика).                                                                                                                                               |
| **10. Неверные настройки проксирования (Cloudflare)**<br>(п.17) | **10%** |  Cloudflare может выдавать частые 52x-ошибки (522, 524, 520), если таймауты или SSL-режим настроены неверно. Внешне выглядит так, будто сайт «упал»; нередко администраторы «перекидывают вину» на сервер, тогда как фактически трафик отсекается на стороне Cloudflare. При регулярной переустановке / переотключении прокси проблема может «всплывать» неоднократно.                                                            |
| **11. Ошибки в настройках cPanel/WHM**<br>(п.18) | **10%** |  После автоматических обновлений cPanel/WHM конфигурации Apache/PHP-FPM могут сбиваться: меняются лимиты, таймауты, пути к сокету. Если это произошло (или продолжает происходить), приложение может «падать» много раз в день, пока настройки не будут зафиксированы и проверены.                                                                                                                                                |
| **6. Утечки памяти (Zend/PHP-модули)**<br>(п.13) | **5%**  |  Утечки памяти встречаются реже, но если они есть, то PHP-FPM «раздувается» по RAM и в итоге «падает» (OOM Killer или краш воркеров). Цикличность падений (например, раз в несколько часов) может указывать на утечку. Однако по сравнению с проблемами конфигурации и БД, это менее частый сценарий, потому что утечки чаще сопровождаются специфическими ошибками в логах и их проще отследить мониторингом памяти.                |
| **9. Накопление временных файлов или логов**<br>(п.16) | **5%**  |  Если дисковое пространство переполняется логами или временными файлами, сайт «ложится», когда становится невозможна запись сессий/логов. Не слишком распространено на сравнительно новом Linode-сервере (где обычно есть мониторинг места), но при длительном отсутствии обслуживания вполне реально.                                                                                                                                    |
| **3. Недостаточно оптимизирована конфигурация Apache/Nginx**<br>(п.10) | **5%**  |  Слишком большой или наоборот слишком маленький пул воркеров, неверные `KeepAlive`-настройки, конфликт `ProxyPass` — всё это может приводить к частым 503/504 и, в конечном итоге, к полной недоступности. Однако чаще главная проблема всё же кроется в PHP-FPM или MySQL, нежели в чистой конфигурации веб-сервера.                                                                                                                  |
| **5. Лимиты на загрузку файлов**<br>(п.12) | **3%**  |  Если много пользователей или скрипты пытаются загружать большие файлы, при неправильных `upload_max_filesize`/`post_max_size` это может «убить» PHP-FPM (или застревать в полуобработанном состоянии). Проблема обычно возникает на файлообменных сайтах, либо когда в приложении есть функционал массовой загрузки. Если у клиента «приложения только с Zend 2.0», вероятность чуть ниже, но исключать нельзя.                                       |
| **8. Неправильно обрабатываемые исключения**<br>(п.15) | **1.5%** |  Полный «крах» из-за непойманных исключений в PHP не так уж част. Обычно такие ошибки видны сразу по логам (Fatal Error или Exception) и воспроизводятся на конкретных запросах. Но если код действительно с ошибками в обработке, может происходить регулярный краш воркеров. Вероятность не самая высокая, поскольку клиент бы уже заметил постоянные PHP Fatal Error в логах.                                                                |
| **12. Ошибки в работе диска (I/O)**<br>(п.19) | **0.5%** |  Физические проблемы с диском (I/O) на Linode-серверах случаются, но реже. Обычно при таком сценарии в логах системы (dmesg, messages) появлялись бы явные ошибки. Без указаний на сбои со стороны хостинга или «страшные» SMART-отчёты вероятность невысока. Однако полностью исключать нельзя, так как любые I/O-задержки могут «повалить» PHP-FPM.                                                                                 |

### Краткое резюме
- Самые вероятные корневые проблемы, из-за которых **регулярно** приходится перезапускать PHP-FPM, — это **длительные запросы к базе**, **недостаток памяти** и **неверные таймауты** (каждый из этих пунктов часто встречается в практике).  
- Также с высокой вероятностью стоит проверить **ограничения CPU**, **Cloudflare** и **конфигурации cPanel/WHM**, так как и там нередко скрываются причины «падения» приложений.  
- Остальные пункты встречаются реже, но при специфических условиях тоже могут быть критическими.
~~~