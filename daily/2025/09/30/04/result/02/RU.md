Благодаря вашему подробному описанию проблемы я выделил 2 наиболее вероятные причины, которые могут вызывать эту проблему независимо друг от друга или в сочетании.
Я излагаю их в пунктах 1 и 2 ниже.
Причина «WordPress sessions», на которую вам указала поддержка LearnDash — гораздо менее вероятна.
Я разбираю её в пункте 3.

1) Причина #1: Некорректная конфигурация кэширования или промежуточных слоев (Proxy/CDN).
1.1) Суть:
Эта причина наиболее вероятно проявляется по сценарию 1.1.1.
Сценарий 1.1.2 является гораздо менее вероятным по причине 1.2.3.
1.1.1) Неправильная работа Page Caching и Redirect Caching
Это наиболее распространенный механизм.
Аутентификация в WordPress основана на cookies (имена начинаются с `wordpress_logged_in_`).
Системы Page Caching (e.g., на уровне веб-сервера Apache, Proxy, CDN или плагины кэширования) должны быть настроены так, чтобы пропускать запрос к WordPress (Bypass Cache) при наличии этих cookies.
Использование механизма Vary Cache (варьирование кэша) в данном случае некорректно.
Значение аутентификационных cookies уникально для каждой сессии пользователя.
Варьирование кэша по уникальному значению приведет к созданию отдельной записи в кэше для каждой сессии.
Это полностью нивелирует эффективность Page Caching (Cache Hit Rate).
Если конфигурация некорректна, система кэширования игнорирует эти cookies и обрабатывает запрос как анонимный.
Когда авторизованный пользователь запрашивает защищенный URL (e.g., курс или урок), система кэширования может вернуть ответ, ранее сохраненный для гостя (Cache HIT).
Если для этого URL был закэширован ответ перенаправления (HTTP 302 на страницу входа, который генерируется для гостей), пользователь немедленно перенаправляется обратно на страницу входа.
В этом сценарии запрос обслуживается системой кэширования.
PHP может не выполняться вовсе (если кэш обслуживается веб-сервером Apache, Proxy или CDN).
Альтернативно, выполнение PHP может прерываться на ранней стадии (e.g., через механизм Drop-in `advanced-cache.php` при использовании плагинов кэширования WordPress).

1.1.2) Неправильная работа Cookie Stripping
Промежуточный слой (e.g., CDN, Proxy, Load Balancer или конфигурация веб-сервера Apache) может быть некорректно настроен на удаление (Stripping) аутентификационных cookies перед тем, как запрос достигнет приложения WordPress.
В этом сценарии запрос достигает ядра WordPress.
Однако, поскольку аутентификационные cookies отсутствуют, функция `is_user_logged_in()` возвращает `false`.
Чтобы защитить контент, WordPress (часто через функцию `auth_redirect()`) или LearnDash немедленно инициирует перенаправление на страницу входа.

1.2) Обоснование:
1.2.1) Вы пишете, очистка кэша или вход через режим инкогнито/приватный браузер часто «исправляет» проблему временно.
1.2.2) Это указывает на то, что пользователь получает некорректное состояние (Stale State).
Это является сильным индикатором получения закэшированного перенаправления (Сценарий 1.1.1).
Действия на стороне клиента (Client-Side Actions) не могут исправить конфигурацию сервера, но они могут временно обойти проблему за счет изменения состояния запроса или локального кэша.
Это происходит через 2 механизма:

1.2.2.1) Взаимодействие с Browser Cache.
В Сценарии 1.1.1 система Server-Side Caching некорректно возвращает закэшированный ответ перенаправления (e.g., HTTP 302).
Если этот ответ содержит заголовки управления кэшем (e.g., `Cache-Control` или `Expires`), добавленные caching layer, браузер может сохранить его локально.
В этом случае браузер выполняет перенаправление локально, не обращаясь к серверу повторно.
Очистка кэша браузера или режим инкогнито заставляют браузер отбросить локально сохраненный ответ и отправить новый запрос на сервер.

1.2.2.2) Временный обход Server-Side Cache.
Режим инкогнито или очистка cookies требуют повторного входа в систему.
Процесс входа (Login Process) изменяет характеристики сессии.
E.g., ответ `wp-login.php` содержит заголовок `Set-Cookie`.
Некоторые системы кэширования могут интерпретировать это как сигнал для временного отключения кэша для этой сессии (e.g., механизм Hit-for-Pass).
Также запрос, следующий сразу после входа, может содержать специфический заголовок `Referer`.
Эти факторы могут позволить первому запросу после входа успешно достичь WordPress, минуя некорректный закэшированный ответ.
Однако при последующих запросах, когда эти условия больше не выполняются, проблема возвращается.

1.2.3) Симптом 1.2.1 делает Сценарий 1.1.2 гораздо менее вероятным, чем Сценарий 1.1.1.
Если бы конфигурация инфраструктуры была однородной, постоянное правило удаления cookies применялось бы к каждому запросу, и действия на стороне клиента не приводили бы к временному решению.
Однако в неоднородной среде с несколькими серверами (e.g., за балансировщиком нагрузки), где конфигурация может быть неидентичной, возможно, что только часть узлов некорректно удаляет cookies.
В таком случае начало новой сессии может направить пользователя на корректно работающий узел, что создаст видимость временного исправления проблемы.

2) Причина #2: Неправильная работа Object Caching.
2.1) Суть:
В тегах проекта вы указали Redis и Memcached.
Если ваша система использует эти технологии для Object Caching, критически важные данные для аутентификации (Authentication) кэшируются в памяти.
WordPress использует Session Tokens (хранящиеся в `wp_usermeta`) для отслеживания состояния входа пользователя.
При высокой нагрузке состояние этих токенов в Object Cache может перестать соответствовать актуальному состоянию базы данных MariaDB (Inconsistent State).
Когда пользователь переходит на защищенную страницу, WordPress выполняет Authentication Check с помощью функции `wp_validate_auth_cookie()`.
При наличии Persistent Object Cache эта функция использует его как первичный источник данных (Primary Data Source) для получения Session Tokens (e.g., через `get_user_meta()`).
Если WordPress читает некорректный (устаревший или поврежденный) Session Token из кэша (Cache HIT), проверка завершается неудачей.
В результате WordPress считает пользователя неаутентифицированным (функция `is_user_logged_in()` возвращает `false`) и инициирует перенаправление на страницу входа.
Это может происходить по двум сценариям.

2.1.1) Stale Cache
Когда Session Tokens обновляются в базе данных (e.g., при входе, выходе или автоматическом продлении сессии), соответствующие данные в Object Cache должны быть инвалидированы (Invalidated) или обновлены.
Если механизм инвалидации работает некорректно (e.g., из-за ошибки в конфигурации, конфликта плагинов или проблем с репликацией базы данных), последующие запросы могут получить устаревшие данные (Stale Data) из кэша.
Использование устаревшего токена приводит к сбою Authentication.

2.1.2) Race Condition
При высокой нагрузке и параллельных запросах (e.g., AJAX) может возникнуть Race Condition при обновлении Session Tokens в кэше.
Хотя базовые операции (e.g., GET, SET) в Redis и Memcached являются атомарными (atomic), Race Condition возникает на уровне прикладной логики (Application Logic) в цикле Read-Modify-Write.
Этот цикл (приложение читает массив токенов из кэша, изменяет его в PHP и записывает обратно) не является атомарным.
Если несколько процессов одновременно изменяют этот массив, это может привести к потере обновления (Lost Update) и несогласованности состояния (Inconsistent State) в кэше.
Чтение некорректного состояния Session Tokens приводит к сбою Authentication.

2.2) Обоснование:
2.2.1) Сочетание высокой активности пользователей (которая есть на production, но нет на staging) и использования внешнего Object Cache создает условия для возникновения Stale Cache и Race Condition.
2.2.2) Этот механизм объясняет, почему пользователи перенаправляются, «even though they are already logged in».
Authentication cookie присутствует в браузере, но Authentication Check завершается неудачей из-за временной несогласованности Session Tokens в Object Cache во время конкретного запроса.

3) Причина #3: Проблемы с нативными PHP-сессиями (PHP Native Sessions).
3.1) Суть:
Эта причина гораздо менее вероятна (обоснование в пункте 3.2), но её следует рассмотреть, так как есть признаки использования PHP Native Sessions (`$_SESSION`) в вашей системе.
Хотя WordPress Core не использует `$_SESSION` для Authentication, некоторые плагины (e.g., BuddyBoss, указанный в тегах) могут их активировать.
Ваши действия по удалению файлов в `/tmp` (deleting /tmp session files) также предполагают их использование.
Если `$_SESSION` активны, это создает Concurrency Challenges при высокой нагрузке (которая есть на production, но нет на staging).
Конкретные проблемы зависят от конфигурации PHP `session.save_handler` и проявляются в двух основных сценариях:
3.1.1) Session Locking.
Если используется стандартный обработчик (`session.save_handler = files`), параллельные запросы (e.g., AJAX) блокируют друг друга при вызове `session_start()`.
Это приводит к Resource Contention и значительным задержкам.
3.1.2) Race Conditions.
Если используется внешний обработчик (e.g., Redis или Memcached, указанные в тегах) с отключенной или неэффективной блокировкой, параллельные запросы могут повреждать данные сессии (Data Corruption).

3.2) Обоснование низкой вероятности.
Эти сценарии вряд ли являются прямой причиной цикла перенаправлений из-за несоответствия симптомов (Symptom Mismatch).
3.2.1) Session Locking (пункт 3.1.1) приводит к Performance Bottlenecks.
Симптомы обычно включают ошибки сервера (e.g., HTTP `504 Gateway Timeout` или HTTP `500 Internal Server Error`), а не чистое перенаправление (HTTP `302`) на страницу входа.
3.2.2) Race Conditions (пункт 3.1.2) вызывают Data Corruption в `$_SESSION`.
Это может повлиять на логику плагинов (LearnDash/BuddyBoss), но не влияет на стандартный механизм Authentication WordPress Core.
WordPress Core Authentication основан на cookies и Session Tokens, а не на `$_SESSION`.
3.2.3) В целом, эти механизмы способствуют общей нестабильности системы под нагрузкой, а не конкретно этой проблеме с циклом входа.
