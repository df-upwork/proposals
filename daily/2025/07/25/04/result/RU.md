1) Firebase предоставляет нативный механизм для реализации широковещательных рассылок: FCM Topic Messaging.
2) Предлагаемая мной архитектура:
2.1) Серверная часть (`S`) использует Firebase Admin SDK для выполнения привилегированных операций, таких как управление подписками устройств на темы и отправка сообщений по этим темам. 
`S` отвечает за всю серверную логику.  
2.2) Клиентская часть (`C`):
- запрашивает у пользователя (`U`) разрешение на получение уведомлений
- получает от FCM уникальный регистрационный токен (`T`) устройства и передаёт `T` на `S` для последующей подписки.
3) Высокоуровневая схема взаимодействия:
3.1) `C` получает `T` и отправляет его на `S`. 
3.2) `S` подписывает устройство с этим `T` на общую тему. 
3.3) В дальнейшем, для отправки широковещательного уведомления, авторизованный администратор (`A`) через защищённый API-эндпоинт `/api/broadcast` (`E1`) отправляет одно сообщение в FCM, указывая в качестве адресата эту общую тему. 
3.4) FCM, в свою очередь, доставляет это сообщение всем подписанным устройствам.
4) Ключевое архитектурное ограничение FCM для веб-клиентов заключается в том, что они не могут самостоятельно подписываться на темы. 
Эта операция должна выполняться `S`. 
Следовательно, необходимо создать серверный API-эндпоинт `/api/subscribe` (`E2`), который будет принимать регистрационный `T` от `C` и выполнять подписку от его имени.
5) Доступ к `E1` и `E2` должен быть строго ограничен. 
Незащищённые endpoints для широковещательной рассылки — это открытая дверь для спама и атак. 
 Я рекомендую реализовать эту защиту из 2 этапов:
5.1) Аутентификация: убедиться, что запрос исходит от известного, вошедшего в систему `A` (в случае `E1`) и `U` (в случае `E2`).
Для `E1` я рекомендую использовать ID-токены Firebase (`AT`), которые `A` будет отправлять с каждым запросом.
5.2) Авторизация: убедиться, что у `A` / `U` есть права на выполнение этого действия. 
5.2.1) Я рекомендую добавить `A` a custom claim (`AC`), например `{admin: true}`, и проверять его на `S`.
5.2.2) Назначение `AC` должно производиться через отдельный, высокозащищенный механизм, например, через Cloud Function, доступную только существующим `A`, или через серверный скрипт.
6) Для работы с FCM в `C` необходимо установить клиентский SDK и настроить Service Worker.
7) Браузер не предоставит `T`, пока `U` явно не разрешит сайту показывать уведомления.
Поэтому нужно запросить у `U` разрешение на получение уведомлений.
8) Крайне важно помнить, что `T` может меняться.
Лучшая практика — получать `T` при каждой загрузке `C` и отправлять на `S`, если он отличается от ранее сохранённого.
9) Для того чтобы `S` могло аутентифицироваться и выполнять вызовы API Firebase, ему необходима идентификация.
Эту роль выполняет сервисный аккаунт (`SA`): специальный тип учётной записи Google, предназначенный для не-человеческих взаимодействий, таких как взаимодействие между серверами.
Включение файла ключа `SA` в Docker-образ является грубым нарушением безопасности.
Правильный подход — инъекция учётных данных в контейнер во время его запуска.
10) Полный процесс подписки `U`:
10.1) `U` открывает `C` в браузере.
10.2) `C` инициирует запрос разрешения на показ уведомлений.
10.3) `U` нажимает «Разрешить».
10.4) `C` запрашивает у FCM `T`.
10.5) `C` отправляет токен в `S` на `E2`.
10.6) `S` подписывает `T` на общую тему `all_users`.
10.7) Устройство `U` готово к приёму широковещательных уведомлений.
11) Процедура инициирования широковещательного уведомления:
11.1) `А` входит в свою учётную запись в специальной административной панели.
11.2) `А` получает от Firebase `AT`, содержащий `AC`.
11.3) `А` формирует сообщение (заголовок и текст) и нажимает «Отправить».
11.4) Приложение администратора делает POST-запрос на `E1`, прикрепляя `AT` в заголовок `Authorization: Bearer <AT>`.
11.5) `E1` проверяет валидность токена и наличие `AC`.
Если проверка пройдена, `S` конструирует объект сообщения для FCM и вызывает метод `send`.
11.6) FCM получает запрос и доставляет уведомление на все устройства, подписанные на тему `all_users`.
