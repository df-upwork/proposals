https://gemini.google.com/share/62e5aee8757b

## **Эволюция парадигмы безопасности в экосистеме Python: Контекст перехода к версии 3.13**

Выпуск Python 3.13 ознаменовал собой фундаментальный сдвиг в подходах к обеспечению сетевой безопасности, выходящий далеко за рамки рядового обновления интерпретатора. Для субъектов ꆜ — системных администраторов, DevOps-инженеров, разработчиков Python и специалистов по кибербезопасности — этот переход стал катализатором выявления скрытого технического долга в глобальной инфраструктуре открытых ключей (PKI). В центре внимания оказалась модификация стандартной библиотеки ssl, которая, базируясь на криптографических примитивах OpenSSL, изменила настройки инициализации контекста безопасности по умолчанию. Если ранее экосистема Python отдавала приоритет совместимости и успешному установлению соединений, то версия 3.13 взяла курс на строгое соответствие стандартам IETF, в частности RFC 5280, регламентирующему профиль использования сертификатов X.509 и списков отзыва (CRL).1

Это стратегическое решение разработчиков CPython привело к тому, что огромный пласт сертификатов, генерируемых внутренними корпоративными центрами сертификации (CA), системами оркестрации контейнеров и решениями для инспекции трафика (MITM-прокси), внезапно перешел в разряд "недоверенных". Проблема усугубляется тем, что многие из этих сертификатов функционировали годами, создавая ложное чувство безопасности и корректности конфигурации. Внедрение флагов VERIFY_X509_STRICT и VERIFY_X509_PARTIAL_CHAIN в функцию ssl.create_default_context() стало лакмусовой бумажкой, проявившей несоответствие реальных практик эксплуатации PKI формальным требованиям стандартов безопасности.2 Анализ ситуации требует глубокого погружения не только в код Python, но и в архитектуру X.509, поведение библиотеки OpenSSL и специфику работы проприетарных решений от таких вендоров, как Zscaler, Microsoft и Broadcom.

## **Анатомия изменений в модуле SSL: Технический анализ флагов верификации**

Для понимания природы проблем, с которыми столкнулся субъект ꆜ в среде P⁎ (Python 3.13), необходимо детально рассмотреть механизм, лежащий в основе изменений. До версии 3.13 функция ssl.create_default_context() инициализировала контекст SSL с набором флагов, который можно охарактеризовать как "снисходительный". Это позволяло устанавливать зашифрованные соединения даже при наличии определенных структурных нарушений в цепочке сертификатов, если криптографическая подпись была валидной.

В Python 3.13 в настройки по умолчанию были добавлены два критических флага, напрямую влияющих на процесс верификации цепочки доверия OpenSSL:

1. **ssl.VERIFY_X509_STRICT**: Этот флаг переводит библиотеку OpenSSL в режим строгой проверки на соответствие RFC 5280. В этом режиме отключаются многие эвристические обходные пути, которые ранее позволяли игнорировать отсутствие обязательных расширений или некорректные значения полей. Например, сертификат CA теперь обязан иметь корректно настроенные расширения Basic Constraints и Key Usage. Любое отклонение от стандарта трактуется не как предупреждение, а как фатальная ошибка верификации, приводящая к разрыву соединения.1  
2. **ssl.VERIFY_X509_PARTIAL_CHAIN**: Данный флаг изменяет логику построения цепочки доверия. Он позволяет верификации завершиться на промежуточном сертификате, если тот находится в хранилище доверенных корней, не требуя обязательного наличия самоподписанного корневого сертификата. Хотя это изменение само по себе является прогрессивным и полезным (позволяя, например, доверять конкретному промежуточному CA организации), в сочетании со строгим режимом оно может приводить к неожиданным ошибкам, если промежуточный сертификат имеет дефекты в расширениях Authority Key Identifier (AKI).3

Таблица 1 иллюстрирует различия в поведении версий Python при обработке сертификатов с типичными дефектами.

| Характеристика сертификата | Поведение Python 3.12 (и ранее) | Поведение Python 3.13 | Причина изменения |
| :---- | :---- | :---- | :---- |
| CA без расширения Key Usage | Соединение установлено (Ignored) | Ошибка: CA cert does not include key usage extension | VERIFY_X509_STRICT требует явного разрешения на подпись сертификатов. |
| CA с Basic Constraints без флага critical | Соединение установлено (Ignored) | Ошибка: Basic Constraints of CA cert not marked critical | RFC 5280 требует критичности для CA, чтобы предотвратить использование пользовательских сертификатов как CA. |
| Корневой CA с несовпадающим AKI/SKI | Соединение установлено (Heuristic match) | Ошибка: Missing Authority Key Identifier или ошибка сопоставления | Строгая проверка идентификаторов ключей для построения цепочки. |
| Самоподписанный сертификат в цепочке | Требует явного добавления в Trust Store | Ошибка: self-signed certificate in certificate chain | Ужесточение политик доверия и отказ от небезопасных умолчаний. |

Эти изменения не являются ошибкой ("багом") в коде Python; они представляют собой преднамеренное усиление безопасности.3 Однако для конечных пользователей эффект неотличим от серьезной регрессии, так как ломает существующие рабочие процессы.

## **Проблема отсутствия расширения Key Usage: Кейс внутренних сервисов и оркестраторов**

Одной из наиболее распространенных проблем, выявленных в ходе анализа, является отказ в верификации сертификатов центров сертификации из-за отсутствия или некорректной конфигурации расширения Key Usage (Использование ключа). Ошибка проявляется сообщением certificate verify failed: CA cert does not include key usage extension.5 Эта проблема затрагивает широкий спектр программного обеспечения, от облачных платформ до локальных кластеров Kubernetes.

### **Механизм возникновения конфликта**

Расширение Key Usage (OID 2.5.29.15) представляет собой битовую маску, определяющую допустимые операции для открытого ключа, содержащегося в сертификате. Для сертификата, который используется в качестве Центра Сертификации (CA) для подписи других сертификатов, бит keyCertSign (бит 5) должен быть установлен. Согласно RFC 5280, если сертификат является CA, это расширение должно присутствовать.

В Python 3.13 флаг VERIFY_X509_STRICT заставляет OpenSSL явно проверять наличие этого расширения и соответствующего бита у любого сертификата в цепочке, который выступает в роли эмитента. Если расширение отсутствует, OpenSSL не может гарантировать, что владелец ключа имел полномочия на выпуск дочерних сертификатов, и прерывает рукопожатие.

### **Анализ инцидента в экосистеме Kubernetes (MicroK8s)**

Показательным примером является ситуация с MicroK8s, популярным дистрибутивом Kubernetes от Canonical. Пользователи столкнулись с невозможностью взаимодействия с API кластера через Python-клиенты (например, библиотеку kopf или официальный kubernetes SDK) после обновления среды до Python 3.13.6

Исследование скриптов генерации сертификатов в MicroK8s (microk8s-resources/actions/common/utils.sh) показало, что корневой CA кластера генерировался командой OpenSSL, которая устанавливала расширение Basic Constraints: CA:TRUE, но опускала расширение Key Usage.

Bash

# Фрагмент проблемной генерации (реконструкция на основе )  
openssl req -x509 -new -nodes -key ca.key -days 365 -out ca.crt

В предыдущих версиях Python отсутствие Key Usage при наличии Basic Constraints: CA:TRUE не блокировало работу. Строгий режим Python 3.13 выявил этот дефект. Это привело к параличу автоматизации: операторы Kubernetes, написанные на Python, перестали запускаться, так как не могли подтвердить подлинность API-сервера.6

### **Проблемы в корпоративных платформах (Broadcom Tanzu)**

Аналогичная ситуация наблюдается в продуктах Broadcom, в частности, в Tanzu Platform for Cloud Foundry и OpsManager. Внутренний сервис TLS CA этих платформ генерирует сертификаты без расширения Key Usage.5 Это создает критическую проблему для администраторов, использующих CLI-инструменты на базе Python для управления платформой. В отличие от MicroK8s, где пользователь может вручную перегенерировать сертификаты, в закрытых проприетарных системах типа OpsManager пользователь часто лишен такой возможности без вмешательства вендора.

### **Обоснованность проблемы**

Проблема полностью обоснована с точки зрения стандартов безопасности. Использование ключа без явного разрешения на подпись сертификатов (keyCertSign) создает риск компрометации PKI. Если ключ, предназначенный только для цифровой подписи документов (digitalSignature), будет использован для выпуска поддельного сертификата (при отсутствии проверки Key Usage), это позволит злоумышленнику осуществить атаку MITM. Python 3.13 закрывает эту уязвимость, принуждая вендоров исправлять генераторы сертификатов.

## **Критичность базовых ограничений: Архитектурный конфликт с системами SSL-инспекции**

Вторая категория массовых сбоев связана с расширением Basic Constraints (Основные ограничения). Ошибка формулируется как certificate verify failed: Basic Constraints of CA cert not marked critical.2 Этот класс проблем наиболее характерен для корпоративных сред, использующих глубокую инспекцию пакетов (DPI) и SSL-перехват (SSL Interception).

### **Философия "Критичности" (Criticality) в X.509**

В стандарте X.509 v3 каждое расширение имеет флаг "critical". Если этот флаг установлен (TRUE), система, проверяющая сертификат, обязана понимать и обрабатывать это расширение. Если она его не понимает, сертификат должен быть отвергнут. Если флаг не установлен (FALSE), неизвестное расширение можно проигнорировать.

RFC 5280 требует, чтобы для сертификатов CA расширение Basic Constraints (которое говорит "Я являюсь CA") было помечено как critical. Это сделано для предотвращения ситуации, когда ПО, не умеющее обрабатывать Basic Constraints, ошибочно примет сертификат CA за обычный сертификат или, что хуже, примет сертификат конечного пользователя (где CA:FALSE или расширение отсутствует) за CA, если злоумышленник попытается использовать его для подписи.

### **Казус Zscaler и MITM-прокси**

Решения компании Zscaler, широко используемые для защиты корпоративного периметра, генерируют промежуточные сертификаты "на лету" для подмены SSL-сертификатов посещаемых сайтов (технология Man-in-the-Middle). Исследование показало, что корневые и промежуточные сертификаты Zscaler, распространяемые во многих организациях, содержат расширение Basic Constraints: CA:TRUE, но флаг critical для него не установлен.2

До выхода Python 3.13 большинство клиентов (браузеры, старые версии OpenSSL, Java) игнорировали отсутствие флага критичности, фокусируясь лишь на значении CA:TRUE. Строгий режим Python 3.13 бескомпромиссен: некритическое расширение Basic Constraints в сертификате CA является нарушением RFC.

### **Последствия для инфраструктуры разработки**

Масштаб этой проблемы огромен, так как она блокирует работу ключевых инструментов разработки:

1. **Менеджеры пакетов:** pip, poetry, conda не могут загружать пакеты из PyPI или Anaconda Repository, так как трафик проходит через Zscaler, который подменяет сертификат репозитория на свой, "дефектный" сертификат. Пользователи видят ошибки соединения при попытке выполнить pip install.2  
2. **Облачные CLI:** Инструменты, такие как AWS CLI или Azure CLI, работающие через корпоративный прокси, теряют связь с управляющими API.  
3. **Почтовые библиотеки:** Модуль smtplib в Python 3.13 отказывается соединяться с почтовыми серверами, если их сертификаты подписаны такими CA.10

### **Анализ обоснованности**

Требование критичности для Basic Constraints является фундаментальным для безопасности PKI. Отсутствие этого флага теоретически позволяет использовать сертификат в контекстах, где он не должен быть доверенным эмитентом. Сбой в Python 3.13 выявляет многолетнее пренебрежение стандартами со стороны крупных вендоров безопасности (Zscaler и др.), которые приоритизировали совместимость над корректностью. Следовательно, проблема не в Python, а в конфигурации прокси-серверов.

## **Идентификатор ключа центра сертификации (AKI): Кризис цепочек доверия в Azure CLI**

Третий значимый вектор проблем связан с ошибкой certificate verify failed: Missing Authority Key Identifier. Этот сбой стал особенно заметен у пользователей Azure CLI версии 2.77.0 и выше, работающих в средах со сложной иерархией сертификатов.11

### **Роль AKI в построении путей сертификации**

Расширение Authority Key Identifier (AKI) (OID 2.5.29.35) содержит идентификатор открытого ключа, которым был подписан данный сертификат. Оно необходимо для быстрого и однозначного нахождения родительского сертификата в хранилище доверенных сертификатов, особенно когда существует несколько сертификатов с одинаковым именем субъекта (Subject DN), но разными ключами (например, при ротации ключей корневого CA).

В режиме VERIFY_X509_STRICT OpenSSL требует наличия AKI для всех сертификатов, кроме корневых самоподписанных (где AKI совпадает с SKI — Subject Key Identifier).

### **Инцидент с Azure CLI и корпоративными прокси**

Пользователи Azure CLI столкнулись с ситуацией, когда авторизация (az login) перестала работать за корпоративными прокси.13 Прокси-серверы, осуществляющие перехват трафика к login.microsoftonline.com, выдавали сертификаты, в которых отсутствовало поле AKI.

Интересно, что проблема проявилась даже в сценариях, где корневые сертификаты были корректно добавлены в доверенные. Расследование, проведенное сообществом на GitHub 12, показало, что проблема может быть связана с тем, как OpenSSL в строгом режиме обрабатывает корневые сертификаты, у которых AKI присутствует и совпадает с SKI. Существует техническая дискуссия о том, является ли наличие AKI, совпадающего с SKI в корневом сертификате, нарушением RFC 5280. Формально RFC разрешает это, но рекомендует опускать AKI для корней. OpenSSL в строгом режиме может интерпретировать это как ошибку или требовать точного совпадения цепочки, которое нарушается при динамической генерации сертификатов прокси-сервером.

### **Обоснованность проблемы**

В данном случае обоснованность поведения Python 3.13 является предметом дискуссий. С одной стороны, требование AKI упрощает и делает более детерминированным построение цепочки доверия. С другой стороны, ошибка "Missing AKI" часто возникает на сертификатах, которые функционально безопасны, но сгенерированы устаревшим ПО. В отличие от проблем с Key Usage и Basic Constraints, где нарушение безопасности очевидно, требование AKI в некоторых граничных случаях (например, самоподписанные корни в интранете) может выглядеть избыточным. Тем не менее, оно соответствует вектору на ужесточение формализации PKI.

## **Системные и средовые факторы: Игнорирование переменных окружения и хранилищ доверия**

Помимо прямых криптографических ошибок, переход на Python 3.13 выявил проблемы с механизмами конфигурации доверия. Субъект ꆜ часто полагается на переменные окружения REQUESTS_CA_BUNDLE или SSL_CERT_FILE для указания пути к корпоративному бандлу сертификатов.

### **Изменение поведения загрузки сертификатов**

Наблюдения пользователей 4 свидетельствуют о том, что в ряде конфигураций Python 3.13 перестает учитывать эти переменные так, как это делали предыдущие версии. Это связано с тем, что ssl.create_default_context() теперь инициализирует хранилище доверия с использованием системных путей по умолчанию более агрессивно. Если приложение явно не вызывает методы загрузки верификационных локаций, полагаясь на неявную магию библиотек типа requests (которые, в свою очередь, зависят от certifi или системных настроек), новые флаги строгости могут перекрывать пользовательские настройки.

Особенно острой является проблема в Windows, где Python традиционно использует свой собственный магазин сертификатов (через библиотеку certifi), игнорируя системное хранилище Windows (Windows Certificate Store). Корпоративные политики часто пушат сертификаты именно в системное хранилище. Ранее утилиты типа pip-system-certs решали эту проблему, но ужесточение проверок в 3.13 сделало эти патчи менее надежными, если сами сертификаты в системном хранилище не соответствуют RFC 5280 (например, не имеют AKI).

## **Стратегический анализ обоснованности изменений и дорожная карта адаптации**

Анализ показывает, что проблемы, с которыми столкнулся субъект ꆜ в P⁎, являются не дефектами платформы Python, а проявлением **глобального технического долга в управлении PKI**. Экосистема Python долгое время работала в режиме "совместимость превыше всего", что позволяло вендорам и администраторам игнорировать требования стандартов. Версия 3.13 положила этому конец.

### **Обоснованность проблем (Резюме)**

1. **Key Usage:** Абсолютно обосновано. Отсутствие флага подписи у CA — критическая уязвимость.  
2. **Basic Constraints (Critical):** Абсолютно обосновано. Некритичность позволяет трактовать CA как конечную сущность.  
3. **AKI:** Обосновано с точки зрения архитектурной чистоты и предотвращения спуфинга цепочек, хотя и вызывает наибольшее количество проблем совместимости с легаси-системами.

### **Рекомендации и пути решения**

Для решения задачи ᛭T и восстановления работоспособности систем предлагается многоуровневая стратегия.

#### **1. Исправление инфраструктуры (Приоритетный путь)**

Это единственный путь, устраняющий причину, а не симптом.

* **Для MicroK8s/Kubernetes:** Необходимо обновить скрипты генерации сертификатов, добавив флаги -addext "keyUsage=critical,digitalSignature,keyCertSign" при создании CA.6  
* **Для Zscaler/Proxies:** Администраторы безопасности должны инициировать процедуру ротации сертификатов SSL-инспекции. Необходимо сгенерировать новый CSR с корректными расширениями (включая критический Basic Constraints) и подписать его корневым CA организации, либо потребовать от вендора (Zscaler) патч для их генератора.8  
* **Для внутренних CA:** Провести аудит всех самоподписанных сертификатов на наличие AKI и SKI.

#### **2. Программная адаптация (Для разработчиков)**

Если исправление инфраструктуры невозможно немедленно, разработчики могут временно ослабить проверки в своих приложениях, убирая флаг VERIFY_X509_STRICT из контекста.

Python

import ssl  
# Получение контекста по умолчанию  
context = ssl.create_default_context()  
# Снятие флага строгости (возврат к поведению Python 3.12)  
context.verify_flags &= ~ssl.VERIFY_X509_STRICT

Этот метод следует применять с осторожностью и только как временную меру.7

#### **3. Решения для конечных пользователей (Workarounds)**

* **Azure CLI:** Использование пакета pip-system-certs для принудительного использования системного хранилища Windows (где проверки могут быть мягче на уровне ОС).15  
* **Переменные окружения:** В некоторых случаях помогает явное указание пути к корректному бандлу через REQUESTS_CA_BUNDLE, но только если сам бандл содержит валидные (с точки зрения RFC) сертификаты.  
* **Downgrade:** Откат на Python 3.12 или Azure CLI 2.76.0 является крайней мерой, позволяющей восстановить работу до момента исправления сертификатов.13

### **Заключение**

Переход на Python 3.13 стал стресс-тестом для мировой PKI-инфраструктуры. Выявленные проблемы демонстрируют, что безопасность — это не статичное состояние, а процесс постоянной адаптации к стандартам. Несмотря на болезненность перехода, действия команды Python направлены на долгосрочное оздоровление экосистемы и устранение уязвимостей, которые могли бы быть эксплуатированы в будущем. Для субъекта ꆜ это сигнал к необходимости проведения глубокого аудита и модернизации своих систем управления сертификатами.

#### **Works cited**

1. What's New In Python 3.13 — Python 3.14.2 documentation, accessed December 11, 2025, [https://docs.python.org/3/whatsnew/3.13.html](https://docs.python.org/3/whatsnew/3.13.html)  
2. Change in python 3.13 that breaks certificate trust - Zscaler Community, accessed December 11, 2025, [https://community.zscaler.com/s/question/0D54u0000AfJDtECQW/change-in-python-313-that-breaks-certificate-trust](https://community.zscaler.com/s/question/0D54u0000AfJDtECQW/change-in-python-313-that-breaks-certificate-trust)  
3. `ssl.create_default_context()`: add `VERIFY_X509_STRICT` and `VERIFY_X509_PARTIAL_CHAIN` to the default `verify_flags` · Issue #107361 · python/cpython - GitHub, accessed December 11, 2025, [https://github.com/python/cpython/issues/107361](https://github.com/python/cpython/issues/107361)  
4. Does Python 3.13 ignore SSL_CERT_FILE environment variable by design?, accessed December 11, 2025, [https://stackoverflow.com/questions/79123649/does-python-3-13-ignore-ssl-cert-file-environment-variable-by-design](https://stackoverflow.com/questions/79123649/does-python-3-13-ignore-ssl-cert-file-environment-variable-by-design)  
5. Opsmanager internal service TLS_CA certificate does not include "key usage extension", accessed December 11, 2025, [https://knowledge.broadcom.com/external/article/409321/opsmanager-internal-service-tlsca-certif.html](https://knowledge.broadcom.com/external/article/409321/opsmanager-internal-service-tlsca-certif.html)  
6. root CA certificate does not include key usage extension · Issue #4864 · canonical/microk8s, accessed December 11, 2025, [https://github.com/canonical/microk8s/issues/4864](https://github.com/canonical/microk8s/issues/4864)  
7. How to Avoid Errors with Self-Signed Certificates When Basic Constraints are Not Critical in Python 3.13 with VERIFY_X509_STRICT | ytyng.com, accessed December 11, 2025, [https://www.ytyng.com/en/blog/python3-13-ssl-basic-constraints-critical-alert-ignore/](https://www.ytyng.com/en/blog/python3-13-ssl-basic-constraints-critical-alert-ignore/)  
8. Python 3.13 Zscaler certificate non-conform, accessed December 11, 2025, [https://community.zscaler.com/s/question/0D5PJ00000Yzt5r0AB/python-313-zscaler-certificate-nonconform](https://community.zscaler.com/s/question/0D5PJ00000Yzt5r0AB/python-313-zscaler-certificate-nonconform)  
9. SSL issue with new enforced VERIFY_X509_STRICT context flag in Python 3.13 #145, accessed December 11, 2025, [https://github.com/python-poetry/install.python-poetry.org/issues/145](https://github.com/python-poetry/install.python-poetry.org/issues/145)  
10. Python v3.13 has broken Email delivery due to an SSL change - Stack Overflow, accessed December 11, 2025, [https://stackoverflow.com/questions/79358216/python-v3-13-has-broken-email-delivery-due-to-an-ssl-change](https://stackoverflow.com/questions/79358216/python-v3-13-has-broken-email-delivery-due-to-an-ssl-change)  
11. az cli pipelines build list errors with Internal/VPN CA Certs ..., accessed December 11, 2025, [https://developercommunity.visualstudio.com/t/az-cli-pipelines-build-list-errors-with/10993415?sort=active&topics=ide2](https://developercommunity.visualstudio.com/t/az-cli-pipelines-build-list-errors-with/10993415?sort=active&topics=ide2)  
12. verify_flag `VERIFY_X509_STRICT`: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: Missing Authority Key Identifier (_ssl.c:1032) · Issue #28391 - GitHub, accessed December 11, 2025, [https://github.com/openssl/openssl/issues/28391](https://github.com/openssl/openssl/issues/28391)  
13. AZ Login fails with SSL intercept for 2.77.0 · Issue #32206 · Azure/azure-cli - GitHub, accessed December 11, 2025, [https://github.com/Azure/azure-cli/issues/32206](https://github.com/Azure/azure-cli/issues/32206)  
14. az login fails with CERTIFICATE_VERIFY_FAILED and I am not behind a proxy #20921, accessed December 11, 2025, [https://github.com/Azure/azure-cli/issues/20921](https://github.com/Azure/azure-cli/issues/20921)  
15. 2.77.0 raises error: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: Missing Authority Key Identifier (_ssl.c:1032) · Issue #32083 · Azure/azure-cli - GitHub, accessed December 11, 2025, [https://github.com/Azure/azure-cli/issues/32083](https://github.com/Azure/azure-cli/issues/32083)  
16. Configuring Software Protection Intermediate CA Certificate - Zscaler Help, accessed December 11, 2025, [https://help.zscaler.com/zia/configuring-software-protection-intermediate-ca-certificate](https://help.zscaler.com/zia/configuring-software-protection-intermediate-ca-certificate)