## 1.
Клиент хочет выполнить следующий проект:
### 1.1. Title
Job to Close Open Workbooks
### 1.2. Description
I have an Excel Macro Workbook that is used by 10-15 staff at a business. They regularly leave the Workbook open on their desktop when they leave work for the day. This can be a problem when we want to release an update to that workbook.
I would like a job I can run on the network that would scan the open files and if one of our Excel Macro Workbooks is found to be open that workbook is closed gracefully, so that we are able to then replace that workbook with a new version.
If required the user running this job would have Admin privileges on the network.
Key Note: The Excel Macro Workbook is essentially an interface for the users and no information or details in the workbook need to be saved. Although if it is possible as part of the job the Excel Macro Workbook can be saved before it is closed.

### 1.3. Tags
Automation
Microsoft VBScript
Microsoft Excel

## 2. Высокоуровневая проблема клиента
### 2.1.
В 1-й раз я тебя спросил:
~~~
Похоже, что высокоуровневая проблема клиента заключается в доставке обновлений его «Excel Macro Workbook» его пользователям, верно?
Я правильно понимаю?

~~~

### 2.1.
Ты ответил:
~~~
Да, вы все верно понимаете. Главная задача – обеспечить возможность обновлять «Excel Macro Workbook», при этом пользователи часто оставляют файл открытым, и это мешает замене на новую версию. Проект направлен именно на решение этой проблемы: автоматизировано определить, у кого открыта нужная книга, и закрыть ее (при необходимости с сохранением), чтобы затем беспрепятственно установить обновленную версию.
~~~

## 3. Что такое вообще «Excel Macro Workbook»?
### 3.1.
В 2-й раз я тебя спросил:
~~~
Что такое вообще «Excel Macro Workbook»?

~~~

### 3.2.
Ты ответил:
~~~
**Excel Macro Workbook** — это рабочая книга Microsoft Excel, внутри которой содержатся макросы, написанные на языке Visual Basic for Applications (VBA). Обычно такие файлы имеют расширение `.xlsm` (в более старых версиях Excel могли встречаться форматы `.xls` с макросами, но в современных реалиях чаще всего используют `.xlsm`).

**Зачем нужны макросы?**  
В Excel макросы позволяют автоматизировать рутинные операции или реализовывать сложную логику прямо в среде электронной таблицы. Например, можно:

1. Выполнять серию часто повторяющихся действий (копирование, форматирование, построение отчетов) по нажатию одной кнопки.  
2. Взаимодействовать с другими файлами, базами данных и приложениями.  
3. Создавать пользовательские формы, диалоговые окна, кнопки и другие элементы интерфейса, упрощающие работу.  
4. Обрабатывать данные по сложным алгоритмам, которые не всегда возможно (или удобно) выполнить стандартными формулами Excel.

**В чем особенность «Macro Workbook»?**  
*Macro Workbook* — это та же Excel-книга, но с поддержкой встраиваемого кода VBA. При сохранении появляется предупреждение о «macro-enabled» формате, так как такие файлы потенциально могут содержать исполняемый код, который влияет на безопасность. Поэтому, когда вы открываете такую книгу на другом компьютере, Excel может попросить включить содержимое макросов или отобразить предупреждение, в зависимости от уровня настройки безопасности.

Именно поэтому, если для бизнеса создана некая рабочая книга с кнопками, формами и дополнительной логикой, то чаще всего она будет «Excel Macro Workbook». Пользователям достаточно открыть файл, а далее можно пользоваться функционалом, заложенным автором макросов (например, автоматическая подготовка отчетов, формирование документов и прочее).

--- 

Таким образом, **«Excel Macro Workbook»** — это рабочая книга с расширением `.xlsm`, которая содержит (или может содержать) VBA-макросы для автоматизации и расширения стандартного функционала Excel.
~~~

## 4. Зачем клиент вообще предоставляет свою «Excel Macro Workbook» своим 10-15 сотрудникам?
### 4.1.
В 3-й раз я тебя спросил:
~~~
Зачем клиент вообще предоставляет свою «Excel Macro Workbook» своим 10-15 сотрудникам (причём, как я понял: в режиме только для чтения).
Какую задачу бизнеса клиент при этом решает?
~~~

### 4.2.
Ты ответил:
~~~
Судя по описанию, у клиента есть единый Excel-файл с макросами, который выступает в роли некоего «инструмента» или «интерфейса» для сотрудников. Ниже — основные возможные причины, зачем бизнес вообще предоставляет такой файл своим 10–15 сотрудникам (и при этом часто в режиме только для чтения):

1. **Единый стандарт автоматизации**  
   Excel Macro Workbook может содержать готовые скрипты, функции и формы, которые упрощают и автоматизируют повседневные задачи — например, формирование отчетов, загрузку/выгрузку данных, анализ, построение графиков. Использование одного стандартного файла исключает ситуацию, когда у каждого сотрудника «своя версия» Excel-книги, что может приводить к несовместимостям и ошибкам.

2. **Упрощение для непрофессиональных пользователей**  
   Макросы позволяют «запрятать» всю сложную логику в код, а сотрудникам дать только удобные кнопки/формы. Таким образом, даже не слишком технически подкованные пользователи могут выполнять сложные операции по нажатию пары кнопок.

3. **Минимизация ошибок и контроль качества**  
   Когда все пользуются одной и той же книгой, в которой прописана проверка вводимых данных, форматирование, валидация и другие элементы контроля, вероятность ошибок снижается. Это особенно актуально, если макросы валидируют данные перед выгрузкой или автоматически фиксируют какие-либо действия.

4. **Управление доступом и безопасностью**  
   Если книга предоставляется в режиме «только для чтения», пользователи не могут случайно (или умышленно) изменить макросы или испортить важные настройки. Администратор или автор макросов может централизованно обновлять файл (в том числе усовершенствованные макросы) и быть уверенным, что сотрудники будут использовать именно актуальную версию.

5. **Единая точка обновления**  
   Чтобы не «гоняться» за несколькими отдельными копиями книги по всем рабочим местам, владелец макросов выпускает обновления централизованно. Как только готова новая версия, достаточно заменить один файл на сетевом ресурсе, к которому у сотрудников есть доступ. Тогда все пользователи автоматически начинают работать с последней версией.  
   — Именно поэтому так важна возможность «закрыть» открытые у пользователей экземпляры книги: она должна корректно обновиться при замене файла.

6. **Унифицированный интерфейс для сбора/обработки данных**  
   Макросы могут быть связаны, например, с базой данных, CRM-системой или другими внешними источниками. «Excel Macro Workbook» тогда служит своеобразным «интерфейсным модулем», который позволяет сотрудникам взаимодействовать с корпоративными системами без необходимости изучать дополнительные приложения.

---

Таким образом, **ключевая бизнес-задача** при распространении «Excel Macro Workbook» в режиме только для чтения — это **предоставить сотрудникам удобное, защищенное и единообразное средство автоматизации и обработки данных**, где сама логика и скрипты управляются централизованно и могут регулярно обновляться без риска «расползания» по ПК сотрудников разных, несовместимых версий.
~~~

## 5. Способы решения задачи
### 5.1.
В 4-й раз я тебя спросил:
~~~
Как ты видишь из описания проекта, клиент предлагает следующий способ решения своей проблемы:
```
I would like a job I can run on the network that would scan the open files and if one of our Excel Macro Workbooks is found to be open that workbook is closed gracefully
```
Какие ещё есть способы решить проблему клиента, помимо предложенного клиентом способа?
Какой из способов — лучший?
~~~

### 5.2.
Ты ответил:
~~~
Ниже перечислены *разные подходы*, которые позволяют решить **ту же самую задачу** (обновлять «Excel Macro Workbook» без конфликтов при открытом файле) *помимо* варианта «пройтись по рабочим станциям и принудительно закрыть у всех открытую книгу». В конце обсуждения даю комментарий, *какой* способ может считаться оптимальным или наилучшим.

---

## 1. Принудительное закрытие открытых файлов (то, что предложил клиент)

### Суть
- *Идея*: Администратор по сети запускает «скрипт/задачу», которая ищет у пользователей запущенные экземпляры Excel, выявляет, открыт ли нужный файл (по имени или другим критериям), и закрывает его.
- При этом можно (если нужно) попытаться сохранить изменения или закрыть без сохранения (так как заказчик говорит, что данные в файле не важны — это интерфейс).

### Плюсы
- Простая и понятная реализация: не требует существенных перестроек.
- Работает быстро, когда нужно срочно «выбить» пользователей из файла.

### Минусы
- Требует админ-доступа (или другого механизма) к рабочим станциям.
- Может вызвать негативную реакцию сотрудников, если их работа прерывается «в лоб».
- Нужно каждый раз вручную или по расписанию запускать данную задачу.
- Риск неожиданного закрытия, если пользователь не успел сохранить свои наработки (хотя заказчик уточняет, что сохранять особо нечего, иногда же может быть важной даже промежуточная работа).

---

## 2. Создать *отдельный* файл-хранилище макросов (Excel надстройка) и «легкую» оболочку

### Суть
- Разделить логику макросов и пользовательский интерфейс.
- Основной VBA-код хранить в виде «Надстройки Excel» (файл с расширением `.xlam` или `.xla`), размещенной в доступном для всех (сетевом или облачном) месте.
- Пользователи работают с «лёгким» файлом (или даже вовсе без отдельного файла — кнопки появляются во вкладке надстроек Excel).  

При обновлении надстройки администраторам не нужно «закрывать» файлы, потому что:
1. Надстройка может обновляться независимо — возможно, Excel «подхватит» новую версию при следующем запуске.  
2. Пользователи часто и не замечают, что им подменили «движок» макросов.

### Плюсы
- Централизованное хранение логики и автоматическое обновление при следующем запуске Excel.
- Не нужно целенаправленно «убивать» файлы пользователей.
- Позволяет сохранить гибкость: можно быстро вносить изменения и быть уверенным, что все работают с актуальной версией макроса.

### Минусы
- Нужно переконфигурировать текущий проект, вынести код в надстройку, а пользовательскую часть (шаблон, интерфейс) — сделать отдельно.
- Могут потребоваться дополнительные действия у пользователей по настройке пути к надстройке.

---

## 3. Система автоматического обновления внутри самой книги (VBA «AutoUpdate»)

### Суть
1. При открытии файла макрос проверяет на сетевом ресурсе, не появилась ли новая версия книги.  
2. Если новая версия есть, пользователь получает уведомление и/или книга **автоматически закрывается**, скачивает новую и открывает ее вместо старой.  
3. Таким образом, при каждом запуске пользователь «сам» обновляется без вмешательства администратора.

### Плюсы
- Удобно для конечных пользователей (обновляется при запуске).
- Нет необходимости «силовым» методом закрывать чьи-то файлы: обновление произойдет в следующий раз при открытии.
- Все работают (рано или поздно) с последней версией.

### Минусы
- Если требуется «прямо сейчас» замена файла (например, критическая ошибка), то пользователи, которые *уже* открыли старый файл и не закроют его до конца дня, будут продолжать работать на старой версии.
- Нужно написать и отладить соответствующую логику автообновления в VBA, обработку ошибок при загрузке нового файла и т.п.
- Пользователи могут иногда не согласиться закрывать файл, если им нужно срочно доделать работу на старой версии.

---

## 4. Ограничить время использования файла или автоматически закрывать при бездействии

### Суть
- В самом Excel Workbook реализовать макрос, который, например, каждые 30 минут проверяет, активно ли окно, и если пользователь «не двигается», то закрывает файл (или просит пользователя подтвердить, что он здесь).
- Параллельно можно внедрить политику, что после рабочего дня (скажем, в 19:00) книга *автоматически* закрывается.

### Плюсы
- Снижает вероятность того, что книга останется открытой в нерабочее время.
- Удобно, если пользователи часто забывают закрывать, а нужен «чистый» доступ.

### Минусы
- Может быть раздражающим, если сотрудник отлучился на некоторое время, а данные вдруг теряются.  
- Требует дополнительного VBA-кода, который не всегда корректно срабатывает (ошибки, отключенные макросы и т. п.).
- Не решает вопрос оперативного закрытия *по требованию* (например, админ внезапно хочет внести правки, а пользователь ещё активен и Excel не закрыт).

---

## 5. Общая организация работы через SharePoint / OneDrive / другой облачный сервис

### Суть
- Хранить «исходный» файл в облаке (SharePoint или аналог), где есть механизмы блокировки/совместного редактирования.
- При обновлении файла можно уведомить пользователей, что им нужно закрыть старую версию.  
- В SharePoint есть механизмы «форсированного» удаления блокировок или оповещения пользователей.
- Можно также вести версионность, где новая версия «заливается» поверх старой, а открытый у пользователя файл фактически становится «копией» (не мешающей замене).

### Плюсы
- Удобно, если в компании уже используется SharePoint / Office 365.
- Есть штатные средства совместной работы, версионирования и блокировок.

### Минусы
- Требуется развернутая инфраструктура (либо подписка на Office 365/SharePoint).
- Пользователи всё равно могут долго держать старую копию открытой.

---

## 6. Превратить Excel-книгу в отдельное приложение (VSTO / .NET / Add-in)

### Суть
- Перенести (или переписать) VBA-макросы на более продвинутую технологию (например, Office Add-in на .NET / VSTO), которая может храниться/распространяться централизованно, как приложение.  
- Excel становится лишь «хостом», а код загружается при запуске надстройки.

### Плюсы
- Более гибкие возможности обновления (можно деплоить новую версию надстройки через групповые политики).
- Современные инструменты разработки, лучше контроль над версиями, безопасностью.

### Минусы
- Сильное усложнение разработки: переход на VSTO или Office Add-in требует других навыков, это уже не просто VBA.
- Нужно тестировать совместимость, обновления могут тоже ломаться и потребовать инфраструктуры (MSI-пакеты, ClickOnce и т. п.).

---

## 7. Полный отказ от дистрибуции книг: сделать веб-интерфейс или thin-client

### Суть
- Вместо того, чтобы распространять Excel-файл, настраивается веб-приложение (или тонкий клиент), куда сотрудники заходят из браузера или лёгкого клиента на ПК.  
- Всё хранится и обрабатывается на сервере, а сотрудники видят только интерфейс.

### Плюсы
- Решается проблема версий «раз и навсегда»: обновления происходят на сервере. У пользователей всегда самая свежая версия.
- Управление доступом, логированием и безопасностью упрощается.

### Минусы
- Нужно фактически написать (или купить) отдельную веб-программу, повторяющую логику.  
- Если в компании критически завязаны на Excel и там много уникальных макросов/формул, миграция будет дорогостоящей и долгой.

---

## Что выбрать в итоге?

### 1. «Принудительное закрытие» — хороший *временный/оперативный* вариант
Если текущая система построена «как есть» (один `.xlsm`-файл для всех) и **нет времени на серьёзные доработки**, то скрипт/задача, закрывающая открытые файлы, действительно **быстро решает** проблему. Это может быть самым простым вариантом *для немедленного внедрения*, чтобы не «гоняться» за каждым компьютером.  

Однако у него есть **минусы** (требуются админ-права, риск потерять несохранённые данные, возможное недовольство пользователей и т. п.).

### 2. Оптимальный подход в большинстве случаев — **автообновление** или **Excel Add-in**
Если смотреть в *долгосрочной перспективе* и снижать риск конфликтов, то **более элегантные** решения — это:
- **Вынести макросы в надстройку** (`.xlam`) и обновлять её централизованно (при запуске Excel).
- Или внедрить **систему автообновления** в сам `.xlsm`: при открытии проверять последнюю версию на сервере и подменять файл, если он устарел.

Таким образом, **при каждой загрузке** у сотрудников автоматически будет актуальный код, а *проблема принудительного закрытия* если и останется, то только для крайних случаев (например, «сейчас критическая ошибка, надо снять блокировку»).

---

### Итоговое резюме

1. **Если нужна «быстрая заплатка»** — подойдёт предложенный клиентом скрипт, который сканирует компьютеры и «убивает» процесс/закрывает Excel-файл. Это действительно решает задачу в лоб.  
2. **Если смотреть в будущее** — лучше **перейти на автообновление** (через VBA в самой книге) или **использовать Excel Add-in** (надстройку), так что отпадёт необходимость вообще что-то «насильно закрывать».  

**Какой способ «лучший»?**  
На практике — способ с автоматическим обновлением (или надстройкой) обычно считается наиболее «правильным» и удобным как для пользователей, так и для администраторов, поскольку он устраняет саму причину проблемы (необходимость замены физического файла), а не просто «закрывает» старый вариант силовым методом.  
~~~

## 6. Решение задачи способом клиента
### 6.1
В 5-й раз я тебя спросил:
~~~
Как правильно решить задачу клиента предложенным клиентом способом? (пункт 1 твоего ответа пункта 5.2 выше)
~~~

### 6.2.
Ты ответил:
~~~
Ниже приведён примерный **алгоритм** и **варианты кода** (на VBScript и/или PowerShell), которые позволяют реализовать именно тот способ, который описал клиент: «по сети найти, у кого открыт файл, и закрыть его». При этом мы постараемся сделать «закрытие» **максимально** безопасным (через COM‑автоматизацию Excel), а не просто «убить» процесс или оборвать сетевое соединение.

---

# 1. Общая логика решения

1. **Определить список компьютеров**, на которых потенциально может быть открыт нужный Excel-файл (либо перебрать всех пользователей / все машины в домене, либо смотреть только тех, кто «состоит» в данной группе AD).

2. **На каждом компьютере** (удалённо) попытаться:
   - Найти запущенные процессы `EXCEL.EXE` (один или несколько экземпляров).
   - Подключиться к уже работающему Excel (через `GetObject(,"Excel.Application")`) — это даёт доступ к *запущенной* сессии Excel.
   - Перебрать все открытые в ней Workbooks.
   - Если среди них есть нужный «Excel Macro Workbook» (по имени файла, пути или любому уникальному признаку), закрыть её через метод `Workbook.Close` (при необходимости с сохранением или без).

3. Повторить это для **каждого** найденного экземпляра Excel на **каждой** машине.  

4. После того как все открытые копии «Excel Macro Workbook» будут закрыты, можно безопасно заменить файл на новую версию.

> **Важный момент**: для такого подхода нужны достаточные права на удалённый запуск скриптов (например, админские привилегии на компьютерах сотрудников), иначе придётся прибегнуть к более жёсткому варианту — «убить» процесс или «отключить файл» через `net file /close` на файловом сервере. Но тогда закрытие не будет «гладким» (Excel отреагирует ошибкой «файл стал недоступен»).

---

# 2. Пример реализации на VBScript с удалённым запуском (psexec)

Ниже — один из **возможных** вариантов, как организовать скрипт на VBScript, который **локально** (на компьютере, где запущен) закрывает нужную книгу в открытом Excel. Дальше мы покажем, как «удалённо» запустить его у пользователей.

### 2.1. Скрипт `CloseExcelWorkbook.vbs`

```vb
Option Explicit

' Имя (или часть пути) книги, которую хотим закрыть:
Const TARGET_FILE_NAME = "MyExcelMacroWorkbook.xlsm"
' Сохранять ли изменения перед закрытием:
Const SAVE_CHANGES = False

Dim xlApp, wbk, foundWorkbook, i

On Error Resume Next
Set xlApp = GetObject(,"Excel.Application")

If Err.Number <> 0 Then
    ' Значит, Excel не запущен
    WScript.Quit 0
End If
On Error GoTo 0

If xlApp Is Nothing Then
    ' Excel не найден
    WScript.Quit 0
End If

foundWorkbook = False

' Перебираем все открытые книги
For i = xlApp.Workbooks.Count To 1 Step -1
    Set wbk = xlApp.Workbooks(i)
    ' Сравниваем имя/путь книги с тем, что мы ищем
    ' Можно сравнить только имя файла (wbk.Name), 
    ' или полный путь (wbk.FullName).
    ' Для надёжности используем LCase:
    If InStr(LCase(wbk.FullName), LCase(TARGET_FILE_NAME)) > 0 Then
        ' Закрываем книгу
        wbk.Close SAVE_CHANGES
        foundWorkbook = True
    End If
Next

' Если нужно, можно автоматом закрыть Excel, если книг не осталось:
If xlApp.Workbooks.Count = 0 Then
    xlApp.Quit
End If

Set wbk = Nothing
Set xlApp = Nothing

If foundWorkbook Then
    WScript.Echo "Found and closed workbook: " & TARGET_FILE_NAME
Else
    WScript.Echo "Workbook not found: " & TARGET_FILE_NAME
End If
```

#### Как работает:
1. `GetObject(, "Excel.Application")` пытается «подключиться» к **уже запущенному** экземпляру Excel. Если Excel не запущен (ошибка 429), мы просто завершаем скрипт.
2. Перебираем все открытые книги через `xlApp.Workbooks`.
3. Проверяем, содержит ли `wbk.FullName` (или `wbk.Name`) целевую подстроку `MyExcelMacroWorkbook.xlsm`.
4. Если совпадает — **закрываем** книгу (при необходимости с сохранением).
5. По желанию можем выгружать Excel полностью, если после закрытия целевой книги *не осталось* открытых книг.
6. Скрипт выводит итог в `Echo`.

> Обратите внимание: этот скрипт **закрывает книгу только в том экземпляре Excel**, куда удалось «прицепиться». Если у пользователя запущено **несколько** процессов Excel (бывает!), придётся либо повторить тот же вызов для каждого процесса, либо (чуть сложнее) использовать WMI для перебора процессов Excel и подключаться к каждому.

### 2.2. Запуск скрипта у пользователя (пример с PsExec)

Чтобы **удалённо** запустить `CloseExcelWorkbook.vbs` на машине `UserPC`, можно использовать утилиту [PsExec](https://learn.microsoft.com/en-us/sysinternals/downloads/psexec) от Sysinternals:

```cmd
psexec \\UserPC -s -d cscript //nologo C:\Scripts\CloseExcelWorkbook.vbs
```

- `\\UserPC` — имя (или IP) удалённого компьютера.  
- `-s` — запуск от имени локальной системной учётной записи (вместо текущего пользователя). Иногда лучше использовать `-u domain\admin -p password`, если нужны конкретные права.  
- `-d` — не ждать завершения, просто «запустить и вернуться».  
- `cscript //nologo C:\Scripts\CloseExcelWorkbook.vbs` — команда, которая локально выполнится на `UserPC`.

В более «продвинутом» сценарии вы можете:
1. Получить список всех активных компьютеров / пользователей (например, из Active Directory).
2. Циклом «пробежаться» по этим машинам, вызывая `psexec`.
3. На каждой машине скрипт закроет нужный файл, если он там действительно открыт.

---

# 3. Пример реализации на PowerShell с удалённым запуском (PowerShell Remoting)

**Альтернативно** можно решить задачу через PowerShell. Основные подходы похожи, но PowerShell позволяет чуть гибче работать с WMI, удалёнными сессиями и т.д.

### 3.1. Локальный PowerShell-скрипт (закрытие книги)

Пример кода, который **локально** закрывает определённую книгу, если найдёт её в текущем процессе Excel:

```powershell
# Пример: CloseExcelWorkbook.ps1

param(
    [string]$TargetFileName = "MyExcelMacroWorkbook.xlsm",
    [bool]$SaveChanges = $false
)

try {
    # Пытаемся получить доступ к запущенной сессии Excel
    $xl = [Runtime.Interopservices.Marshal]::GetActiveObject("Excel.Application")
} catch {
    Write-Host "Excel is not running."
    return
}

if ($xl -eq $null) {
    Write-Host "Excel not found."
    return
}

$found = $false

# Перебираем рабочие книги
for ($i = $xl.Workbooks.Count; $i -ge 1; $i--) {
    $wb = $xl.Workbooks.Item($i)
    if ($wb.FullName.ToLower().Contains($TargetFileName.ToLower())) {
        $wb.Close($SaveChanges)
        Write-Host "Closed workbook:" $wb.FullName
        $found = $true
    }
}

# Закроем Excel, если не осталось открытых книг:
if ($xl.Workbooks.Count -eq 0) {
    $xl.Quit()
}

[System.Runtime.Interopservices.Marshal]::ReleaseComObject($xl) | Out-Null
$xl = $null

if (-not $found) {
    Write-Host "Workbook not found:" $TargetFileName
}
```

### 3.2. Удалённое выполнение (PowerShell Remoting)

Допустим, у вас включён PowerShell Remoting (WinRM) и у вас есть права на удалённую сессию. Тогда вы можете запустить скрипт **на конкретном удалённом компьютере**:

```powershell
Invoke-Command -ComputerName UserPC -FilePath "C:\Scripts\CloseExcelWorkbook.ps1" -ArgumentList "MyExcelMacroWorkbook.xlsm", $false
```

- `-ComputerName UserPC` — имя (или IP) удалённой машины.
- `-FilePath` — путь к локальному скрипту, который будет скопирован и выполнен на удалённой машине.
- `-ArgumentList` — параметры (имя книги, сохранять ли).

Чтобы **массово** закрыть файл на *списке* компьютеров, можно:

```powershell
$computers = @("UserPC1","UserPC2","UserPC3")
foreach($c in $computers) {
    Invoke-Command -ComputerName $c -FilePath "C:\Scripts\CloseExcelWorkbook.ps1" `
        -ArgumentList "MyExcelMacroWorkbook.xlsm", $false
}
```

---

# 4. Если нужно искать «кто держит файл» на файловом сервере

Часто перед закрытием надо понять, *у кого именно* открыт нужный `.xlsm`. Если Excel-файл лежит на **сетевом ресурсе Windows**, можно:

1. На файловом сервере (где лежит файл) посмотреть список открытых файлов через:
   ```cmd
   net file
   ```
   или использовать **консоль «Управление компьютером → Общие папки → Открытые файлы»**.
   
2. Найти нужный файл (будет указан путь) и посмотреть, какой «User» и «Станция (Machine)» держит его открытым.

3. Получив список машин, далее выполнить один из вариантов выше (PsExec или PowerShell Remoting) — чтобы закрыть Excel на этих машинах.

> **Внимание**: если из консоли «Открытые файлы» на сервере нажать «Разъединить» или выполнить `net file <ID> /close`, Excel у пользователя «споткнётся» — файл станет «недоступен». Это *не всегда* «красивое» закрытие, но **самый простой** способ при отсутствии прав на удалённый запуск и необходимости *срочно* освободить файл.

---

# 5. Итоговые рекомендации

1. **Минимально работоспособный путь**:  
   - **(A)** на файловом сервере выяснить, у кого открыт нужный файл, и  
   - **(B)** через PsExec (или PowerShell Remoting) запустить на каждом ПК скрипт, который «подцепится» к работающему Excel и закроет «Excel Macro Workbook» (без или с сохранением).  
   Этот метод требует некоторых прав (Admin или эквивалентных), а также включённых возможностей удалённого управления (WMI, WinRM).

2. **Альтернатива** — если нет времени и прав, можно вызвать `net file /close` прямо на сервере. Но это будет «жёсткий» обрыв соединения, и пользователь увидит ошибку в Excel.

3. **Долгосрочно** — лучше использовать механизмы *автообновления* или *Excel Nadстройку (.xlam)*, чтобы отпала необходимость всех выгонять из файла. Но если заказчик настаивает именно на «скрипте, который в любой момент закрывает все открытые экземпляры», то описанный выше подход — наиболее «гладкий» (через COM-автоматизацию) из «силовых» решений.

---

## Коротко

> **Лучше всего**:  
> 1) Узнать, у кого открыт файл (через `net file` на сервере).  
> 2) Для каждой машины запустить (удалённо) *VBScript* или *PowerShell*, который **найдёт** в открытом Excel нужную книгу и закроет её командой `Workbook.Close`.  
> 3) После чего безопасно заменять файл на новую версию.

Так и решается задача «*I would like a job I can run on the network that would scan the open files and if one of our Excel Macro Workbooks is found to be open that workbook is closed gracefully*».
~~~

## 7. Как правильно решить задачу клиента предложенным тобой способом?
### 7.1.
В 6-й раз я тебя спросил:
~~~
Как правильно решить задачу клиента предложенным тобой способом? (пункт 2 твоего ответа пункта 5.2 выше)
~~~

### 7.2.
Ты ответил:
~~~
Ниже описан **пошаговый план**, как перейти от «одного общего .xlsm-файла» к схеме с **Excel-надстройкой** (Add-in), чтобы не приходилось силовым способом закрывать файлы у пользователей и можно было **централизованно обновлять логику макросов**.

---

# 1. Суть способа №2 (из предыдущего ответа)

Идея в том, чтобы **вынести все макросы, функции, формы и логику** из основной книги в отдельный *файл надстройки* (обычно это формат `.xlam` для современных версий Excel) и хранить его в каком-то **центральном** месте (сеть / облако).

1. **Пользователи** вместо «тяжёлой» книги с макросами получают:
   - Либо небольшую «оболочку» (книгу с минимумом настроек/формул, которая сама *подключается* к надстройке при запуске).
   - Либо вообще не получают «файл», а просто в своей Excel-настройке **добавляют** сетевую надстройку, и макросы/кнопки появляются во вкладке «Надстройки» или «Лента» Excel.

2. **Обновление** надстройки (замена файла `.xlam`) происходит **централизованно**: вы кладёте новую версию в сетевую папку.  
   - Как только пользователь **перезапускает Excel**, та автоматически подхватывает обновлённый `.xlam`.  
   - При этом не нужно «выгонять» никого из файлов, потому что надстройка не блокируется так же, как обычная книга. 

Таким образом, **макросы** всегда загружаются **из одного и того же источника**, а пользователи не хранят у себя «разные копии».  

---

# 2. Основные шаги перехода к надстройке

## 2.1. Создать (или сконвертировать) надстройку

1. **Откройте** исходную рабочую книгу `.xlsm`, которая сейчас содержит все VBA-модули и пользовательские формы.  
2. **Перенесите** или оставьте там весь код, который вы хотите использовать во всех ваших документах (или в «оболочке»).  
3. **Сохраните** этот файл в формате «Excel надстройка» (`.xlam`).  
   - В Excel 2013/2016/2019/Office 365 это делается через «Файл» → «Сохранить как…» → Тип: *Excel надстройка (*.xlam)*.  
   - В результате вы получите файл, который Excel может подключить как надстройку.

4. Убедитесь, что все нужные макросы **общедоступны** (Public), если планируете вызывать их извне.  
5. Проверьте, что всё, что раньше было «ThisWorkbook», теперь работает корректно в контексте надстройки (иногда логику, связанную с *текущей* книгой пользователя, приходится адаптировать).

> **Справка**: внутри надстройки можно хранить *модули*, *пользовательские формы*, *классы* и даже *шаблонные листы*, но обычно надстройка не содержит пользовательских листов (видимых), а лишь код.

---

## 2.2. Разместить надстройку в сетевом/общедоступном месте

- Выберите **сетевую папку** (например, `\\Server\Share\ExcelAddins\MyAddin.xlam`) или **SharePoint**/OneDrive, к которой у всех нужных пользователей есть доступ (чтение).  
- Скопируйте туда файл надстройки `MyAddin.xlam`.  
- Убедитесь, что права выставлены так, чтобы пользователи могли файл *читать* (но не обязательно изменять).

> **Важно**: Желательно, чтобы сетевой ресурс был **доверенным** для Excel (Trust Center), иначе при запуске макросы могут блокироваться настройками безопасности.

---

## 2.3. Подключить надстройку на компьютерах пользователей

### Вариант А: вручную (если пользователей мало)

1. На каждом ПК открыть Excel → «Файл» → «Параметры» → «Надстройки».  
2. В поле «Управление: Надстройки Excel» нажать «Перейти…».  
3. Нажать «Обзор…» → найти по сети вашу надстройку (`MyAddin.xlam`) → **Добавить**.  
4. Убедиться, что рядом стоит «галочка» (включено).

С этого момента **при каждом запуске** Excel автоматически подгружает `MyAddin.xlam`. Все макросы из неё доступны, а при обновлении файла на сервере (замене новой версией) пользователь в следующий запуск Excel получит актуальный код.

### Вариант Б: групповые политики / скрипт

- В корпоративной среде можно **скопировать** надстройку автоматически в какую-то локальную папку пользователей (например, `C:\CompanyAddins`) и **прописать** путь к ней в реестре, чтобы Excel подключал её при старте.  
- Или задействовать **Office Deployment Tool**, который может автоматически управлять надстройками.  

Этот вариант удобен, когда пользователей много и нужно централизованно всем «пропихнуть» надстройку без ручных действий.

---

## 2.4. Организовать «лёгкую оболочку» (если нужно)

В некоторых случаях вы всё-таки хотите, чтобы пользователи **открывали конкретную Excel-книгу** (например, шаблон с листами, которые нужны для ввода данных). Но весь код при этом пусть живёт в надстройке.

Тогда делается так:

1. Создаёте «пустой» `.xlsx` или `.xlsm`, который содержит **минимум**: лист(ы), где пользователь что-то вводит, и кнопки (формы) на ленте/на листе, которые **вызывают** процедуры из надстройки.  
2. В коде этой «оболочки» может быть **очень мало** VBA — фактически только вспомогательные вызовы надстройки. Основная логика — в `MyAddin.xlam`.  
3. При желании саму «оболочку» тоже кладёте на сервер, но её обновлять гораздо реже и проще, чем большой файл с макросами.  

**Плюс** такого подхода:  
- Макросы хранятся в одном месте, а у пользователей может быть **своя копия** «оболочки» (если в ней есть какие-то их личные данные) или один общий «шаблон» для запуска (который не блокируется, так как в большинстве случаев Excel-файл можно открывать в режиме «только чтение» из общего ресурса).

---

# 3. Как происходит обновление в реальной работе

1. Вы исправляете/дополняете код надстройки у себя (локально) — в файле `.xlam`.  
2. Проверяете, что всё работает (например, на тестовом стенде).  
3. **Перезаписываете** (копируете сверху) новую версию `.xlam` в сетевую папку `\\Server\Share\ExcelAddins\MyAddin.xlam`.  

   > Если кто-то из пользователей в этот момент **уже** открыл Excel и надстройка загружена, у них она продолжает работать **старой** версией в памяти. Но как только **Excel будет закрыт и открыт заново**, подтянется **новая** надстройка.

4. Все пользователи при **следующем запуске Excel** автоматически получают новую версию макросов.  

**Важно**: Ни у кого при этом не будет «заблокирован файл», потому что надстройка в режиме «только чтение» и Excel не держит её открытой так, как обычную .xlsm-книгу. 

---

# 4. Дополнительные моменты

## 4.1. Подписание цифровым сертификатом

Чтобы избежать постоянных предупреждений о макросах, вы можете:
- **Подписать** `.xlam` своим **цифровым сертификатом VBA**.  
- Добавить этот сертификат в доверенные издатели.  
- Таким образом, даже при довольно строгих настройках безопасности макросы будут считаться «доверенными».

## 4.2. Создание пользовательской вкладки в ленте

В Excel (с 2007+) можно **добавить** отдельную вкладку в Ленте (Ribbon) для своей надстройки (с иконками, кнопками, выпадающими списками). Делается это:
- Либо через XML-код ленты в самом `.xlam` (раздел «CustomUI»).
- Либо при помощи встроенных инструментов «Настроить ленту» — но для надстроек часто удобнее редактировать XML руками (или использовать сторонние редакторы).

Таким образом, пользователь при открытии Excel будет видеть, к примеру, вкладку «Company Tools» со всеми кнопками макросов, и ничего дополнительно нажимать не придётся.

## 4.3. Если нужны пользовательские формы (UserForm)

UserForm-ы (VBA) тоже **прекрасно живут** внутри Add-in. При вызове `UserFormName.Show` из надстройки форма отображается так же, как из обычного .xlsm. Если нужен доступ к данным *в текущей активной книге*, используйте объекты `ActiveWorkbook`, `ActiveSheet`, и т.д. — код надстройки «видит» контекст Excel, в котором он работает.

## 4.4. Сложные зависимости (базы данных, внешние DLL)

Если в ваших макросах есть связь с внешней БД, запросами, ODBC и т.д., обычно это не проблема — код в надстройке продолжит работать, важно лишь, чтобы **путь/подключение** был доступен с компьютеров пользователей (учётные данные, драйверы, и т.п.).

---

# 5. Итог

1. **Переводим VBA-код** из `.xlsm` в **.xlam** (надстройку).  
2. **Кладём** надстройку на общий сетевой ресурс.  
3. **Подключаем** её у пользователей (через «Надстройки Excel» или скрипт).  
4. При **обновлении** (замене) `.xlam` в общей папке у всех автоматически появляется **новая версия** макросов (без принудительного закрытия файлов).  

### Это решает основную задачу
- **Не нужно** «сканировать, у кого открыт файл, и насильно его закрывать», поскольку больше **не существует** «единого блокируемого .xlsm».  
- Все могут быть уверены, что при открытии Excel у них всегда **одна и та же актуальная** логика макросов.  

> **P. S.** Если вам нужно всё-таки распространять и сам «шаблон» с листами (для ввода данных), он будет лёгким `.xlsx` (или `.xlsm`, но почти пустым), а **вся VBA-начинка** — в надстройке. Обновлять «шаблон» придётся реже, а даже если обновлять — он не будет долго блокироваться, так как «основной» код всё равно вынесен.
~~~

## 8. В чём преимущество твоего подхода?
### 8.1.
В 7-й раз я тебя спросил:
~~~
Итак, в своёи прошлом ответе ты написал:
```
Как только пользователь **перезапускает Excel**, та автоматически подхватывает обновлённый `.xlam`. 
```
Получается, при твоём способе клиенту всё равно нужно дистанционно перезапускать Excel у всех пользователей для применения у пользователей своих изменений в «Excel Macro Workbook»?
Непонятно: в чём тогда преимущество твоего подхода?
~~~

### 8.2.
Ты ответил:
~~~
Ниже — развёрнутый ответ на вопрос, почему при использовании **надстройки** (Add-in) обновления **всё равно** применяются *лишь при* следующем запуске Excel и в чём **преимущество** данного подхода **по сравнению** с «обычной» .xlsm‑книгой, которую приходится закрывать у пользователей *силовым* методом.

---

## 1. Действительно ли нужен «дистанционный перезапуск» Excel?

При классическом (прямолинейном) использовании надстройки `.xlam` **новая версия** будет **подхвачена только тогда**, когда Excel **запускается заново** или когда пользователь вручную **отключит и снова подключит** надстройку. Другими словами:

- Если у кого-то Excel открыт **всю неделю** без перезапуска (и не уходит в перерывах в «выход из Excel»), то он продолжит пользоваться **старой версией** кода из надстройки (которая загружена в память при старте).  
- Как только Excel будет закрыт и открыт заново — макросы подгрузятся из актуального файла `.xlam` на сетевом ресурсе.

Тут нет автоматической «горячей перезагрузки» надстройки из сети (по умолчанию Excel не следит за изменением файла). **Но это, как правило, не проблема**, если обновления выходят не так часто — или если сотрудники периодически перезапускают компьютеры.

### Нужно ли «дистанционно убивать» Excel?

При **обычной надстройке** обычно **нет необходимости** «насильно» закрывать Excel у всех, даже если файл `.xlam` обновлён. Старая версия продолжит функционировать у тех, кто уже её загрузил, **не блокируя** новую версию на сервере. Заменить `.xlam` в сетевой папке можно спокойно и **без конфликтов**:

1. Файл надстройки не «захватывается» на запись (или, во всяком случае, Excel обычно не держит блокировку на файл надстройки так жёстко, как при работе с «живой» .xlsm).  
2. Пользователи, у которых Excel уже был запущен, *продолжают работать* в старой версии (в памяти).  
3. Все **новые** запуски Excel берут **новый** файл `.xlam`.

Таким образом, не нужно устраивать «массовые обрывы», чтобы **заменить** файл на сервере. Поэтому — **зачастую неважно**, что кто-то работает на предыдущей версии в течение дня; как только человек выйдет-зайдёт в Excel, у него станет новая. 

Если вдруг администратору **критически** нужно заставить всех перейти на свежую версию *прямо сейчас*, всегда остаётся вариант **вежливо оповестить** через корпоративный чат или почту: «Коллеги, для корректной работы вышла новая версия надстройки, перезапустите Excel». Но при этом **не нужно** насильно «убивать» их процессы Excel.

---

## 2. В чём реальное преимущество надстройки?

### 2.1. Главное отличие: отсутствует блокировка «основного файла»

С *.xlsm*-книгой (когда у каждого пользователя **одна и та же** рабочая книга с макросами на сетевом диске) происходят вот какие проблемы:

1. Excel **держит блокировку** (вплоть до «файл уже открыт в режиме только чтения/записи»).  
2. Если нужно **заменить** `.xlsm` файлом «новой версии», **нельзя** просто перезаписать — система «ругнётся», что файл занят (locked).  
3. Администратору приходится находить, **кто** держит файл открытым, и **закрывать** ему Excel (или отключать файл через `net file /close`), чтобы освободить для перезаписи.

При схеме с **надстройкой** (`.xlam`) таких «жёстких» блокировок, как правило, нет (или они **мгновенно** снимаются при копировании). Следовательно, **обновлять** файл надстройки можно «на лету», **не дожидаясь**, когда все его закроют. То есть **никого** не нужно «выгонять» из Excel, чтобы **разместить** свежий код.

### 2.2. Безопасность для пользовательских данных

Обычно «Excel Macro Workbook» бывает не только «движком макросов», но и содержит какие-то листы, в которых пользователь может (или мог бы) что-то вводить или временно хранить.  
- Если «убить» процесс Excel, пользователь может потерять какие-то **несохранённые** данные, даже если «основной» документ задуман как «только для чтения».  
- При надстройке же, всё, что делается **в рабочих книгах** пользователя, в `.xlsx`-файлах и т.д., не блокирует **сам** `.xlam`. И если требуется обновление кода, нет риска порушить пользовательские данные.

### 2.3. Плавный переход на новую версию

- Когда вы выкладываете **новую** версию надстройки, **уже открытые** экземпляры Excel продолжают работать на старом коде **до** следующего перезапуска Excel — **но** при этом **не мешают** вам перезаписать файл на сервере.  
- Новые (или повторно запущенные) сеансы Excel получают **новейшую** версию макросов.

Это сильно упрощает жизнь в том плане, что **все новые** подключения видят обновления, при этом **нет срочного** требования разрывать сессию у каждого пользователя, кто «залип» с Excel.

### 2.4. Возможность «горячего» обновления (при желании)

Сама надстройка **по умолчанию** не перезагружается «на лету», но это **технически возможно** сделать, если вы захотите:

- В коде надстройки `.xlam` вы можете реализовать **механизм автообновления** — периодически (или по событию) проверять версию `.xlam` на сервере и, если она изменилась, **автоматически** «перечитывать» надстройку.  
- Или попросить пользователя нажать специальную кнопку «Update Add-in» (которая выгружает текущую надстройку и тут же заново её подключает), тем самым загружая свежий код *без* полного перезапуска Excel.

Это уже детали реализации и часто бывает «избыточно», но **в принципе** решаемо — главное, что в этом случае код в памяти может сам себя «переобновить», не ломая логику работы пользователя с другими файлами.

---

## 3. Ситуация: «Нужно критично и мгновенно обновить код для всех»

Если когда-либо возникает **критическая** ситуация (например, «в старой версии надстройки обнаружен баг, который ломает отчёты, нужно срочно остановить его использование»), есть несколько вариантов:

1. **Попросить** всех **просто закрыть и открыть** Excel (самый мягкий). В большинстве компаний люди реагируют на такие срочные уведомления.  
2. Если кто-то «не выходит на связь», **силой** (админским скриптом) **закрыть** Excel. Но это нужно значительно реже, чем в случае, когда код живёт в `.xlsm`, потому что **обычно** достаточно «мягкого» уведомления и добровольного перезапуска.  

Как правило, в реальной практике **единичные** сотрудники, которые «не прочитали рассылку», не успеют нанести компании большой урон, пока работают на старом коде.  Тогда **уже** можно точечно закрывать их Excel (если это действительно надо). Но это **в сотни раз реже**, чем при постоянной необходимости обновлять `.xlsm`, который держит блокировку.

---

## 4. Итоговые тезисы

1. **Да**, если человек **держит Excel открытым сутками** и не перезапускает, то новый код надстройки он не увидит «моментально».  
2. **Однако** при этом **нет** проблемы «файл заблокирован, заменить нельзя» — администратор спокойно **заливает** новую версию `.xlam` на сервер.  
3. Все остальные, кто **закроет и откроет** Excel (даже завтра с утра), получат обновлённую надстройку, **не вызывая** конфликтов и дополнительных действий.  
4. В случае **критического** обновления (когда ошибка в старом коде может «поломать» данные) — всё равно **легче** попросить пользователей перезапустить Excel, чем «выбивать» у них `.xlsm`, потому что файл надстройки **не остаётся» под эксклюзивной блокировкой**.  

**Вот почему** надстройка (Add-in) всё равно **выигрывает**:  
- Нет необходимости «сканировать» все открытые копии и закрывать «живые» файлы, чтобы **заменить** версию на сервере.  
- Внедрение обновлений становится **естественным**: люди постепенно получают новую версию при следующем запуске, а вы не рискуете потерять их данные принудительным закрытием.  

Это куда **меньше трений** и драматических ситуаций, чем «один общий .xlsm‑файл», блокируемый на уровне ОС, который невозможно перезаписать, пока хотя бы один человек его не закрыл.

---

### Ответ на главный вопрос:

- **«Нужно ли дистанционно перезапускать Excel у всех, чтобы все сразу же получили новую версию надстройки?»**  
  Формально — *нет*. Если обновление **не критическое**, то пользователи сами перейдут на новую версию при ближайшем закрытии/открытии Excel.  

- **«В чём преимущество?»**  
  При использовании `.xlsm`-файла приходится *принудительно* закрывать, чтобы освободить сам файл для перезаписи. При надстройке `.xlam` можно обновлять **без** «убийства» открытых сессий Excel и без рисков потери несохранённых данных, так как надстройка **не держится** в блокировке на запись.  

**Именно** в этом главное упрощение и преимущество.
~~~

## 9.
Я хочу ответить клиенту так:
~~~
1) У вашей проблемы есть более сильное альтернативное решение: надо вынести все макросы, функции, формы и логику из основной книги в отдельный файл надстройки (обычно это формат `.xlam` для современных версий Excel) и хранить его в каком-то центральном месте (сеть / облако).
1.1) Пользователи вместо «тяжёлой» книги с макросами получают:
1.1.1) Либо небольшую «оболочку» (книгу с минимумом настроек/формул, которая сама подключается к надстройке при запуске).
1.1.2) Либо вообще не получают «файл», а просто в своей Excel-настройке добавляют сетевую надстройку, и макросы/кнопки появляются во вкладке «Надстройки» или «Лента» Excel.
1.2) Обновление надстройки (замена файла `.xlam`) происходит централизованно: вы кладёте новую версию в сетевую папку.  
1.2.1) Как только пользователь перезапускает Excel, та автоматически подхватывает обновлённый `.xlam`.  
1.2.2) При этом не нужно «выгонять» никого из файлов, потому что надстройка не блокируется так же, как обычная книга. 
1.3) Таким образом, макросы всегда загружаются из одного и того же источника, а пользователи не хранят у себя «разные копии». 
1.4) У моего решения есть главное преимущество: отсутствует блокировка «основного файла».
1.4.1) С `.xlsm`-книгой (когда у каждого пользователя одна и та же рабочая книга с макросами на сетевом диске)  Excel держит блокировку (вплоть до «файл уже открыт в режиме только чтения/записи»).  
Если нужно заменить `.xlsm` файлом «новой версии», нельзя просто перезаписать — система «ругнётся», что файл занят (locked).  
И вот поэтому вам приходится находить, кто держит файл открытым, и закрывать ему Excel, чтобы освободить для перезаписи.
1.4.2) При моём решении пользователи с открытым Excel не будут блокировать новую вашу новую версию файла надстройки (`.xlam`) на сервере. 
1.5) Я могу опционально запрограммровать возможность «горячего» обновления надстройки у ваших сотрудников.
Для этого в коде надстройки `.xlam` я могу реализовать механизм автообновления — периодически (или по событию) проверять версию `.xlam` на сервере и, если она изменилась, автоматически «перечитывать» надстройку, без полного перезапуска Excel у пользователей.  
2) Тем не менее, я могу решить вашу проблему и вашим способом. 
Например, это можно сделать через PowerShell.
Допустим, у вас включён PowerShell Remoting (WinRM) и у вас есть права на удалённую сессию. Тогда вы можете запустить скрипт на конкретном удалённом компьютере что-то вроде:
```
$computers = @("UserPC1","UserPC2","UserPC3")
foreach($c in $computers) {
    Invoke-Command -ComputerName $c -FilePath "C:\Scripts\CloseExcelWorkbook.ps1" `
        -ArgumentList "MyExcelMacroWorkbook.xlsm", $false
}
```
~~~

## 10.
Переведи ответ на английский.

## 11. Правила перевода
### 11.1.
Переводи именно в той стилистике, как написано на русском языке.
Не делай перевод более вежливым, чем оригинал.
### 11.2.
Не используй Markdown: только plain text.
При этом можно и нужно использовать то форматирование, которое уже есть в оригинале: его не убирай.
### 11.3.
Форматируй перевод в точности как оригинал. 
В частности:
*каждый абзац должен содержать ровно одно предложение
*) между абзацами не должно оставаться пустых строк.
*) кавычки используй те же, что и в оригинале: «» и ``
### 11.4.
Не используй сокращения типа «don't». Все подобные фразы пиши полностью: «do not».