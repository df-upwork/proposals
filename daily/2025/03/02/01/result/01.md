Ниже — 2 главные причины: техническая и стратегическая.
Первой напишу техническую, потому что стратегическая вам вряд ли понравится, хотя она намного важнее и правильнее.
1) Главная техническая причина: ваши скрипт на PHP (SP) и скрипт на Node.js (SJ) подключаются к БД в принципе по-разному, через разные сокеты. 
1.1) SP подключается через `localhost`.
Обычно это Unix-сокет, но на самом деле не всегда и может быть переопределено в операционной системе.
1.2) SJ подключается через TCP-сокет (`127.0.0.1`).
1.3) У меня 25 лет опыта программирования, и я многократно видел, когда простая смена сокета `localhost` на `127.0.0.1` (или наоборот) в разы меняет скорость работы программы с БД.
1.4) В синтетических тестах вроде вашего подключение через Unix socket обычно быстрее.
1.4.1) Так происходит потому, что Unix сокеты — это механизм межпроцессного взаимодействия (IPC) в пределах одного хост-системы. 
Данные передаются напрямую в пространстве ядра, минуя несколько уровней сетевого стека.
1.4.2) А вот TCP-сокеты задействуют:
- Уровень IP (пусть и через loopback-интерфейс).
- Уровень TCP (управление окнами, подтверждениями, порядком доставки).
- Дополнительные структуры данных в ядре (таблица маршрутизации, таблицы состояний TCP-соединений, порты и т.д.).
Для локальной передачи данных столько слоёв избыточны, ведь на самом деле мы просто шлём байты от одного процесса к другому в пределах одного компьютера.
1.4.3) Даже если речь идёт о loopback (адрес `127.0.0.1`), TCP/IP реализация включает:
- Формирование IP-пакета: добавление IP-заголовка (20 байт для IPv4 или больше для IPv6).  
- Формирование TCP-сегмента: добавление TCP-заголовка (20 байт минимум).  
- Подсчёт контрольных сумм (checksums) для TCP и IP.  
- Обработку ACK-пакетов (подтверждение получения данных).  
- Управление окнами TCP (window size, congestion control).  
1.5) В моей 25-летней практике многократно встречались и обратные случаи: когда `127.0.0.1` быстрее, чем `localhost`.
Например, если Unix socket использует файловую систему с высокой нагрузкой или медленным доступом (например, из-за конкуренции за файловые дескрипторы), это может замедлить соединение через `localhost` по сравнению с `127.0.0.1`.
2) Стратегическая причина: при работе с MySQL PHP — намного более зрелая система, чем Node.js.
2.1) Программный код подключения PHP к MySQL почти полностью реализован на языке C: в его разработку за последние 25 лет вложены гигантские усилия сообщества PHP.
До версии 5.4 (2012 код) PHP по умолчанию использовал написанную на С библиотеку `libmysqlclient`, разработанную создателями MySQL.
Однако сообщество PHP на этом не остановилось, и к 2009 году (PHP 5.3) разработало на языке С свою, ещё более мощную библиотеку: `mysqlnd`, сверхоптимизированную именно для PHP, и с PHP 5.4 (2012 год) сделало `mysqlnd` библиотекой по умолчанию.
Не забывайте, что на PHP работает множество крупных и денежных eCommerce систем: у них реально было много ресурсов и мотивации, чтобы сделать работу с MySQL enterprise-grade.
2.2) Node.js же только появился в 2009 году, и к 2012 году только входил в моду: в те годы ниша eCommerce и работы с реляционными БД была уже занята. 
В те годы проекты на Node.js обычно делали с появившейся в том же 2009 году MongoDB: Node.js и MongoDB зародились и входили в моду практически одновременно, и их использовали одни и те же люди.
Поэтому реализация работы с MySQL в Node.js откровенно посредственная: все перечисленные вами модули (`mysql2`, `mysql`, `promise-mysql`, `mariadb`) реализованы почти полностью на языке JavaScript, без особых ухищрений и оптимизаций.
Разница в 2 раза в скорости одного и того же алгоритма на C и JavaScript — это ещё хорошо для JavaScript, обычно намного хуже бывает.
2.3) Надежд на исправление этой ситуации для Node.js практически нет: у хипстеров Node.js уже вышел из моды, у них теперь моден Python, вот там при работе с MySQL вообще треш и угар (например, в библиотеке SQLAlchemy).
2.4) Разница в скорости в 2 раза в примитивном тесте — это далеко не главная проблема Node.js при работе с MySQL.
Если разработать на Node.js крупную систему, работающую с MySQL (а таких систем в мире реально очень мало: поищите, например, успешный движок eCommerce на Node.js и MySQL), то небольшие задежки на запросах к БД могут быть нивелированы другими сильными сторонами Node.js (такими как приципиально другая реализация асинхронности, которая в современном PHP тоже есть (например, в PHP-FPM), но реализована по другому).
Главная проблема в другом: интеграция Node.js и MySQL в принципе незрелая, примитивная.
3) Добавлю, кстати, что даже более быстрый код SP в принципе плох: при правильной реализации разрыв в производидельности с SJ может быть ещё больше.
3.1) Сейчас в коде SP используется бессмысслица: `$db->prepare()` вызывается внутри цикла `for`.
3.2) При качественной реализации prepared statements должны быть вне цикла: именно в этом их смысл.
Statements должны быть prepared 1 раз, и затем повторно использоваться в цикле.
Правильная реализация должна быть такой:
```php
$s = $db->prepare("UPDATE test SET f=? WHERE id=?"); 
for ($i = 0; $i < 10; $i++) {
    <…>
    $s->bind_param("ii", 1, 1);
    $s->execute();
    <…>
}
```
3.3) При повторных вызовах prepared statements уменьшается объём пересылаемой информации, и клиент/сервер могут использовать более эффективный бинарный формат (если включены server‐side prepared statements).
3.4) Также, при первом prepare сервер тратит время на парсинг SQL и создание плана выполнения. 
Это разовая операция, а далее повторные вызовы `execute` проходят быстрее.





  