https://gemini.google.com/share/f86af4fbbcef

## 1. Выявленные проблемы, беспокоящие `ꆜ`

Основная проблема клиента (`P†`) определена в `O.md` (§9) и детально описана в `PD` (`O.md` §2.3).

### 1.1. Основная техническая проблема (`P†`): Ошибка аутентификации (401) при отправке боевых ордеров

Клиент разработал Python-бота для маркет-мейкинга на Polymarket. Бот успешно функционирует в тестовом режиме (paper mode), но при переключении на исполнение реальных ордеров (live order execution) возникает критическая ошибка.

**Симптом:** При попытке отправить ордер через REST API бот получает ответ:

```
REAL_EXEC- Failed to submit BUY order: PolyApiException[status_code=401, error_message='error': 'Unauthorized/Invalid api key'
```

**Контекст:**

  * Ошибка возникает только на эндпоинте отправки ордера (REST order-submit endpoint).
  * WebSocket-соединения и получение данных работают корректно.
  * Клиент обладает всеми необходимыми учётными данными (API Key, API Secret, API Passphrase, private key).
  * Бот использует подписание EIP-712 для ордеров CLOB (Central Limit Order Book) и подключён через MetaMask.

### 1.2. Сопутствующие опасения и неопределённости

Исходя из `PD`, клиент также обеспокоен следующими аспектами:

1.  **Корректность использования учётных данных:** Неопределённость в том, правильно ли бот применяет имеющиеся ключи для аутентификации POST-запросов.
2.  **Логика деривации ключей:** Опасение, что логика получения (деривации) учётных данных может некорректно перезаписывать или использовать ключи («Verify nothing is being overwritten by the credential derivation logic»).
3.  **Различия в потоках аутентификации:** Необходимость чёткого понимания разницы между аутентификацией на основе приватного ключа и API-ключей в контексте Polymarket.

## 2. Анализ обоснованности проблем

Проблема `P†` является полностью обоснованной и критичной для функционирования бота. Код состояния HTTP 401 (Unauthorized) указывает на то, что запрос не был принят из-за недействительных учётных данных аутентификации.

Анализ сложности аутентификации Polymarket API подтверждает, что существует множество потенциальных точек отказа при переходе из тестового режима в боевой.

### 2.1. Двухуровневая аутентификация Polymarket CLOB

Для понимания проблемы критически важно разобрать модель аутентификации Polymarket CLOB, которая состоит из двух уровней (L1 и L2).

#### 2.1.1. L1: Аутентификация приватным ключом (EIP-712)

Этот уровень использует приватный ключ кошелька Polygon для подписания структурированных данных ордера в соответствии со стандартом EIP-712. Это криптографически подтверждает намерение владельца средств совершить сделку. L1 также используется для генерации ключей L2.

#### 2.1.2. L2: Аутентификация API-ключом (HMAC)

Этот уровень использует API Key, Secret и Passphrase для аутентификации самого HTTP-запроса к серверу CLOB. Он подтверждает право пользователя отправлять команды API. Реализуется через генерацию HMAC-подписи запроса.

#### 2.1.3. Интерпретация ошибки

Сообщение `'Unauthorized/Invalid api key'` и код 401 указывают на сбой именно на уровне **L2**. Сервер отклоняет запрос до того, как приступает к валидации ордера (L1), потому что не может верифицировать подпись самого запроса (L2).

### 2.2. Вероятные причины возникновения ошибки 401 (`T1⁎`)

Анализ документации и публичных репозиториев выявил несколько высоковероятных причин сбоя L2-аутентификации в Python-боте.

#### 2.2.1. Критическая проблема: Форматирование (сериализация) JSON

Наиболее вероятной причиной является специфическое требование бэкенда Polymarket к формату JSON при расчёте HMAC-подписи (L2). HMAC-подпись генерируется на основе точного строкового представления тела запроса. Если строка, подписанная клиентом, отличается от строки, которую ожидает сервер (даже на один пробел), подписи не совпадут.

В официальном репозитории Python-клиента (`Polymarket/py-clob-client`) зафиксирована проблема (Issue #164), точно соответствующая симптомам клиента:

> "Some endpoints don't accept (valid) JSON that doesn't have extra spaces, and will instead return `{"error":"Unauthorized/Invalid api key"}`"

Стандартные библиотеки Python могут сериализовать JSON с пробелами для читаемости (например, `{"key": "value"}`). Если сервер Polymarket ожидает компактный формат (например, `{"key":"value"}`) и рассчитывает HMAC на его основе, а клиент отправляет форматированный JSON, возникнет ошибка 401.

**Обоснованность:** Высокая. Это подтверждённая проблема, специфичная для Python-реализации и API Polymarket.

#### 2.2.2. Некорректная генерация HMAC-подписи (L2)

Если бот реализует логику подписания вручную или использует устаревшую версию библиотеки, ошибка может быть в самом алгоритме генерации HMAC. Это включает:

  * Неправильный порядок конкатенации элементов для подписи (Timestamp, Method, Request Path, Body).
  * Использование неверного API Secret.

**Обоснованность:** Средняя. Стандартные библиотеки обычно реализуют это корректно, но ошибки в интеграции возможны.

#### 2.2.3. Ошибки в логике деривации или использования ключей

Клиент явно указал на необходимость проверки логики деривации. Если бот использует ключи от тестовой среды в боевой, или если логика деривации L2-ключей из L1-подписи содержит ошибки (например, используется неверный nonce или приватный ключ), это приведёт к использованию недействительных L2-ключей.

**Обоснованность:** Средняя. Это обоснованное опасение, учитывая явное упоминание этой логики клиентом.

#### 2.2.4. Рассинхронизация времени

Аутентификация L2 включает временную метку (`POLY_TIMESTAMP`). Если часы на сервере бота значительно отличаются от времени сервера Polymarket, запрос будет отклонён как просроченный. Это распространённая проблема в API криптобирж.

**Обоснованность:** Низкая, но возможная. Требует проверки синхронизации времени на VPS клиента.

## Заключение

Проблемы клиента (`ꆜ`) обоснованы и связаны со сложностями и неочевидными требованиями аутентификации Polymarket API при переходе в режим реальной торговли. Ошибка 401 указывает на сбой L2-аутентификации.

Наиболее вероятной причиной является специфическая проблема с форматированием JSON-тел запросов (Issue #164 в `py-clob-client`), что приводит к неверному расчёту HMAC-подписи. Другие возможные причины включают ошибки в логике генерации HMAC или некорректное управление/деривацию API-ключей.