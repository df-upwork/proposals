1) Stripe initialization may be in `useEffect`, which is triggered on every render (e.g., due to broken dependencies).
If an array of dependencies is specified in `useEffect`, React compares the values of those dependencies on each render of the component with their values on the previous render.
If at least one value in the array of dependencies has changed, `useEffect` is re-run.
E.g., a component creates a new object or function on each render, which (without memoization) will always have a new value in memory.
React sees that the old and new dependency values do not match (even though the contents of the object or function are logically the same).
It works as follows:
- The render calls `useEffect`.
- `useEffect` sees that the dependency has changed and calls the effect.
- The effect changes the state (for example, reinitializes the Stripe form).
- This results in a new render.
This results in an infinite loop.
2) If the component passes props or state to the nested (child) component that is recalculated on each render (e.g., a new function or object), this can cause the child component to be constantly rebuilt, resulting in repeated renders.
This results in an infinite re-rendering loop.
After creating the element, developers could call `setState` in the React code to store the reference to the Stripe object (or element) in the local state (or pass it on through context or props).
If this `setState` is called on every render (without checking whether the element has already been created), the result will be: «Create a new element» → `setState` → render → «Create a new element again» → `setState`… and so on endlessly.