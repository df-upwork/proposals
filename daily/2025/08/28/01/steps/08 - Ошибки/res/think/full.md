3. (Критическая фактическая ошибка) В примечании к п. 5.3.2.1 утверждается: «При запуске `Data Flow` в режиме «Debug Mode» данные по умолчанию не записываются в `Sink` transform». Это неверно и опасно в контексте запуска конвейера (Pipeline Debug Run), описанного в Разделе 6. При отладочном запуске конвейера действие `Data Flow` **будет** выполнять запись в приемники (Sinks). Утверждение справедливо только для «Data Preview» внутри редактора `Data Flow`.
4. (Критическое упущение) В п. 3.6 анализ использования параметров ограничен только действиями (Activities). Упущена необходимость анализа того, как параметры конвейера передаются в параметры наборов данных (Dataset Parameters) и связанных служб (Linked Service Parameters) для динамической конфигурации ресурсов (пути, имена таблиц, строки подключения).
5. (Логическая ошибка / Структура) Неверная последовательность действий. Определение конфигурации Source Control (п. 3.1) расположено слишком поздно. Понимание режима работы (Git vs Live Mode) критически важно до начала анализа (Раздел 1), так как это определяет интерпретацию версий кода (Author vs Monitor Snapshot).
6. (Фактическая ошибка) Описание `Live Mode` в п. 3.1.3.1 неточно. Утверждается, что изменения не сохраняются до момента публикации через «Publish All». В `Live Mode` изменения сохраняются непосредственно в службу Data Factory. Описанный механизм публикации характерен для `Git Mode`.
7. (Упущение) В Разделе 1 анализ исторических проблем сфокусирован только на сбойных запусках («Failed»). Упущена возможность того, что конвейер «не работал», потому что он не запускался вообще. Необходимо включить анализ «Trigger Runs» на вкладке «Monitor» для проверки статуса и истории срабатывания триггеров.
8. (Упущение) В Разделе 1 упущен анализ *успешных* исторических запусков. Изучение параметров и поведения во время корректной работы необходимо для понимания назначения конвейера и установления базовой линии.
9. (Упущение) В п. 1.4.4 не указано критическое ограничение: значения параметров типа `SecureString` и секреты, получаемые из Azure Key Vault, маскируются в журналах мониторинга и недоступны для просмотра в исторических запусках.
10. (Упущение) В Разделе 2 отсутствует конкретная методика диагностики проблем с Azure Key Vault (AKV). Если Linked Services используют AKV, необходимо явно указать на проверку политик доступа (Access Policies) или RBAC на ресурсе AKV (разрешения Get/List secrets), а также проверку брандмауэра AKV.
11. (Упущение) В Разделах 3 и 4 не рассмотрено использование Глобальных параметров (Global Parameters) как возможного источника конфигурации конвейера.
12. (Упущение) В Разделе 3 не описана методика определения ожидаемой структуры (схемы) для сложных типов параметров (`Object`, `Array`) при отсутствии документации. Необходимо упомянуть обратный инжиниринг выражений внутри конвейера, которые потребляют эти параметры (например, анализ `@pipeline().parameters.configObject.propertyName`).
13. (Упущение) В п. 2.2.3 не учитывается контекст Integration Runtime (IR) при «Test connection». Если Linked Service использует AutoResolve-IR, а Activity в конвейере принудительно использует другой IR (например, VNet IR), успешный тест может ввести в заблуждение, так как сетевой контекст выполнения будет отличаться.
14. (Упущение) В п. 5.3.1.2 рекомендация временного изменения конфигурации без сохранения несет риски, особенно в `Git Mode`. Следует упомянуть более безопасную альтернативу: клонирование (Clone) конвейера и/или наборов данных для тестирования.
15. (Упущение) В п. 5.3 не упомянуты альтернативные стратегии безопасного запуска для `Data Flow`, такие как использование преобразования `Conditional Split` перед `Sink` для временной блокировки потока данных или использование `Cache Sink`.
16. (Упущение) В п. 6.5 не указано, что при наличии `Data Flow activities` необходимо использовать детальный мониторинг выполнения `Data Flow` (иконка в виде очков), а не только общую вкладку «Output», для анализа плана выполнения и производительности трансформаций.
17. (Фактическая неточность) Утверждение в п. 2.2.5.2 о том, что Azure RBAC не управляет доступом к объектам внутри Azure SQL/Synapse, устаревает. Azure AD RBAC теперь может использоваться для авторизации доступа к данным (Data Plane) в этих службах наряду с традиционными SQL разрешениями.