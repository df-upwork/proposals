## 1. `Def`
### 1.1.
```
Def(A, B)
```
будет обозначать, что для понятия `B` я использую обозначение `A`.

### 1.2.
~~~
Def(A):
```
B
```
~~~
имеет то же значение, что и `Def(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 2. `Def_P`
### 2.1.
```
Def_P(A)
```
будет обозначать, что `A` является для меня проблемой.

### 2.2.
```
Def_P(A, B)
```
будет обозначать, что `B` является для меня проблемой, и для этой проблемы я использую обозначение `A`.

### 2.3.
~~~
Def_P(A):
```
B
```
~~~
имеет то же значение, что и `Def_P(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 3. `Def_C`
### 3.1.
```
Def_C(P, A, B)
```
будет обозначать `Def(A, B)` в контексте пункта `P`.
Вне пункта `P` это правило не применяется.
Если до пункта `P` обозначение `A` имело другой смысл, то после пункта `P` обозначение `A` снова будет иметь этот смысл.
По сути, `Def_C` объявляет локальную переменную `A` с областью действия `P`.
В отличие от него, `Def` объявляет глобальную переменную `A` (значение которой действует для всех пунктов, кроме `P`).

### 3.2.
~~~
Def_C(P, A):
```
B
```
~~~
имеет то же значение, что и `Def_C(P, A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 3.3.
```
Def_C([P1, P2, …, Pn], A, B)
```
имеет значение, аналогичное `Def_C(P, A, B)`, только в этом случае обозначение `A` имеет значение `B` в контексте не одного пункта `P`, а всех пунктов [`P1`, `P2`, …, `Pn`], перечисленных в квадратных скобках.

### 3.4.
```
Def_C([P1-Pn], A, B)
```
имеет значение, аналогичное `Def_C([P1, P2, …, Pn], A, B)`: в этом случае обозначение `A` имеет значение `B` в контексте множества всех пунктов между `P1` и `Pn`, включая сами эти пункты.

### 3.5.
~~~
Def_C([P1, P2, …, Pn], A):
```
B
```
~~~
имеет то же значение, что и `Def_C([P1, P2, …, Pn], A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 3.6.
~~~
Def_C([P1-Pn], A):
```
B
```
~~~
имеет то же значение, что и `Def_C([P1-Pn], A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 4. `Def_F`
### 4.1.
Def_C(4-5, `F`):
```
Факт: некое событие, которое случилось в описываем мной случае.
```

### 4.2.
```
Def_F(B)
```
будет обозначать, что `B` — это `F`.

### 4.3.
~~~
Def_F:
```
B
```
~~~
имеет то же значение, что и `Def_F(B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 4.4.
```
Def_F(A, B)
```
будет обозначать, что `B` — это `F`, и для него я использую обозначение `A`.

### 4.5.
~~~
Def_F(A):
```
B
```
~~~
имеет то же значение, что и `Def_F(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 5. `Def_Ph`
### 5.1.
Def_C(5, `Ph`):
```
Феномен: `F`, который вызывает у меня удивление.
```

### 5.2.
```
Def_Ph(B)
```
будет обозначать, что `B` — это `Ph`.

### 5.3.
~~~
Def_Ph:
```
B
```
~~~
имеет то же значение, что и `Def_Ph(B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 5.4.
```
Def_Ph(A, B)
```
будет обозначать, что `B` — это `Ph`, и для него я использую обозначение `A`.

### 5.5.
~~~
Def_Ph(A):
```
B
```
~~~
имеет то же значение, что и `Def_Ph(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 6. `Def_H`
### 6.1.
Def_C(6, `H`):
```
Гипотеза: некое предположение, требующее проверки.
```

### 6.2.
```
Def_H(B)
```
будет обозначать, что `B` — это `H`.

### 6.3.
~~~
Def_H:
```
B
```
~~~
имеет то же значение, что и `Def_H(B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 6.4.
```
Def_H(A, B)
```
будет обозначать, что `B` — это `H`, и для него я использую обозначение `A`.

### 6.5.
~~~
Def_H(A):
```
B
```
~~~
имеет то же значение, что и `Def_H(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 7. `Def_Set`
```
Def_Set(S, I)
```
будет обозначать, что `S` — множество всех возможных `I`.

## 8. `Def_I`
```
Def_I(I, S)
```
будет обозначать, что `I` — элемент множества `S`.

## 9. `Use`
```
Use(A)
```
будет обозначать, что в описываемой мной ситуации я использую `A`.

## 10.
Потенциальный клиент опубликовал на Upwork следующий проект:
### 10.1. Title
FileMaker EXPERT for consultancy on migrating data to other DB

### 10.2. Description
```text
I need consultancy, advices on migrating a lot of FileMaker files into an other DB (postgresql).
I'm not familiar with FileMaker, I need to handle a large number of Filemaker files.
I need to cope with the difficulty that the files are not yet "Allowed for ODBC connection" and due to the large number it would be difficult to manualy open each of them and allow the connection. 
Rights on files have been set as well, so might need to "Re-login" with a user-password.
I also need to understand what are my export options, how to select info the tables export,..
I can't share the files, so I expect an 1 hour or less video meeting for discussion about all that.
Tell me briefly how you would do it in your response and what is your experience on it.
```

### 10.3. Tags
Claris FileMaker
Migration

## 11. Информация о клиенте
### 11.1. Местоположение
Switzerland
Daillon

## 11.2. Характеристики компании
### 11.2.1. Сектор экономики
неизвестно
### 11.2.2. Количество сотрудников
неизвестно

## 11.3. Характеристики учётной записи на Upwork
### 11.3.1. Member since
Apr 26, 2017
#### 11.3.2. Hire rate (%)
100
#### 11.3.3. Количество опубликованных проектов (jobs posted)
45 
#### 11.3.4. Total spent
$39K
#### 11.3.5. Количество оплаченных часов в почасовых проектах
1005

## 12.
Def(`C`):
```
клиент пункта 10
```

## 13.
Def(`P`):
```
проект пункта 10
```

## 14.
Def(`Ps`):
```
множество подобных `P` проектов 
```

## 15.
Def(`D`):
```
Описание `P` (пункт 10.2 выше)
```

## 16.
Def(`FM`):
```
FileMaker (о котором `C` пишет в `D`)
```

## 17.
Def(`PG`):
```
PostgreSQL (о котором `C` пишет в `D`)
```

## 18.
Def_P(`P1`):
```
Проблема, о которой `C` пишет в `D`:
~~~
I need to cope with the difficulty that the files are not yet "Allowed for ODBC connection" and due to the large number it would be difficult to manualy open each of them and allow the connection. 
~~~
```

## 19.
Def(`T1`):
```
Одна из задач, о которой `C` пишет в `D`:
~~~
what are my export options
~~~
```

## 20.
Def(`T2`):
```
Одна из задач, о которой `C` пишет в `D`:
~~~
how to select info the tables export
~~~
```

## 21.
Def(`D`, «мой ответ `C`»).

## 22.
Содержание `D`:
~~~markdown
Правильное решение вашей задачи:
1) Разработать главную программу (`P1`), которая будет управлять всем процессом миграции.
Я рекомендую сделать её на языке Python.
2) Разработать набор низкоуровневых программ (`P2s`) на языке сценариев FileMaker.
3) `P1` будет взаимодействовать с `P2s` посредством стандартной для FileMaker технологии `fmurlscript` (через URL вида `fmp://`).
Вызов `P2s` из `P1` на Python:
3.1) в Windows:
```python
subprocess.run(['start', '', fmp_url])
``` 
3.2) В macOS:
```python
subprocess.run(['open', fmp_url])
``` 
4) `P1` будет читать cхему (структуру) базы данных из FileMaker посредством библиотеки `pyfilemaker2`:  https://github.com/jeremie-borel/pyfilemaker2
5) Основные скрипты `P2s` будут экспортировать данные из FileMaker:
5.1) В CSV (для простых схем).
5.2) В XML (для сложных схем).
6) `P1` будет загружать данные в PostgreSQL посредством библиотеки `psycopg`: https://github.com/psycopg/psycopg
~~~

## 23.
Def(`D2`, «начальная часть `D`, переведённая с Russian на English»).

## 24.
Содержание `D2`:
~~~markdown
~~~

## 25.
Def(`F`, «фрагмент `D`»).

## 26.
Содержание `F`:
~~~markdown
6) `P1` будет загружать данные в PostgreSQL посредством библиотеки `psycopg`
~~~

## 27.
Переведи `F` на English, с учётом:
- контекста `D`
- `D2`: уже переведённой части `D`
- всех предыдущих пунктов моего запроса

## 28. Правила перевода
### 28.1.
Переводи именно в той стилистике, как написано на Russian.
Не делай перевод более вежливым, чем оригинал.

### 28.2.
Те предложения, которые сейчас полностью на English — оставь без изменения.

### 28.3.
#### 28.3.1.
Не используй Markdown: только plain text.
#### 28.3.2.
При этом можно и нужно использовать то форматирование, которое уже есть в оригинале: его не убирай.
#### 28.3.3.
Не форматируй веб-ссылки посредством Markdown, если они не отформатированы так в оригинале. 
Например, не пиши так:
```
[https://www.eca.web.tr/eca-nita-esnek-uclu-eviye-bataryasi-beyaz-102118110-308](https://www.eca.web.tr/eca-nita-esnek-uclu-eviye-bataryasi-beyaz-102118110-308)
```
если в оригинале скобок `[]()` нет.

### 28.4.
Форматируй перевод в точности как оригинал. 
В частности:
*) каждый абзац должен содержать ровно одно предложение
*) между абзацами не должно оставаться пустых строк.
*) кавычки используй те же, что и в оригинале: «» и ``.

### 28.5.
Не используй сокращения типа «don't». Все подобные фразы пиши полностью: «do not».

### 28.6.
Не используй жаргон.
Вместо этого используй официальные термины.
#### 28.6.1.
В частности, фразы в кавычках используй только в том случае, когда они являются точными цитатами.
Не используй фразы в кавычках для применения жаргонных фраз.
Например, следующий фрагмент текста недопустим, потому что там используется жаргонная фраза «пролетел»: 
```
Например, код, который пушит данные о покупке, подключён асинхронно и загружается с небольшой задержкой, а триггер уже «пролетел».
```

### 28.7.
При обсуждении программного обеспечения используй точные официальные термины на английском языке: именно в том виде, как они указаны в официальной англоязычной документации к этому программному обеспечению.

### 28.8.
Не используй «you need» и другие подобные обращённые к клиенту фразы, перекладывающие действия на него.
Помни: я пишу клиенту или потенциальному клиенту.
Делать в любом случае буду я, а не клиент.
Вместо «you need» используй 2 альтернативы:
#### 28.8.1.
Нейтральные фразы типа «it is necessary».
#### 28.8.2.
Глаголы в неопределённой форме.
Например, во фрагменте ниже использованы подобные глаголы «set up», «create»:
```
1.2) Set up the transfer of login events from WordPress to Power BI using Fabric / OneLake.
1.2.1) Set up a «Data Pipeline» from the WordPress database table that stores login events (see point 1.1) to Fabric / OneLake.
1.2.2) Set up a connection from Power BI to Fabric / OneLake to pass login events.
1.3) Create the data model in Power BI.
```
Обрати внимание, в этом фрагменте не говорится, кто именно будет выполнять описанные действия: ответственность не перекладывается на клиента, в отличие от «you need».

### 28.9.
Никогда не переводи понятие «сайт» / «веб-сайт» как «site». 
Вместо этого используй форму «website»: это является более профессиональным.

### 28.10.
Никогда не переводи понятие «пункт нумерованного списка» как «item».
Всегда переводи это как «point».