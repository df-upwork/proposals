Благодаря вашему подробному описанию проблемы я выделил 2 наиболее вероятные причины, которые могут вызывать эту проблему независимо друг от друга или в сочетании.
Я излагаю их в пунктах 1 и 2 ниже.
Причина «WordPress sessions», на которую вам указала поддержка LearnDash — гораздо менее вероятна.
Я разбираю её в пункте 3.

1) Причина #1: Некорректная конфигурация кэширования или промежуточных слоев (Proxy/CDN).
1.1) Суть:
Эта причина наиболее вероятно проявляется по сценарию 1.1.1.
Сценарий 1.1.2 является гораздо менее вероятным по причине 1.2.3.
1.1.1) Неправильная работа Page Caching и Redirect Caching
Это наиболее распространенный механизм.
Аутентификация в WordPress основана на cookies (имена начинаются с `wordpress_logged_in_`).
Системы Page Caching (e.g., на уровне веб-сервера Apache, Proxy, CDN или плагины кэширования) должны быть настроены так, чтобы пропускать запрос к WordPress (Bypass Cache) при наличии этих cookies.
Использование механизма Vary Cache (варьирование кэша) в данном случае некорректно.
Значение аутентификационных cookies уникально для каждой сессии пользователя.
Варьирование кэша по уникальному значению приведет к созданию отдельной записи в кэше для каждой сессии.
Это полностью нивелирует эффективность Page Caching (Cache Hit Rate).
Если конфигурация некорректна, система кэширования игнорирует эти cookies и обрабатывает запрос как анонимный.
Когда авторизованный пользователь запрашивает защищенный URL (e.g., курс или урок), система кэширования может вернуть ответ, ранее сохраненный для гостя (Cache HIT).
Если для этого URL был закэширован ответ перенаправления (HTTP 302 на страницу входа, который генерируется для гостей), пользователь немедленно перенаправляется обратно на страницу входа.
В этом сценарии запрос обслуживается системой кэширования.
PHP может не выполняться вовсе (если кэш обслуживается веб-сервером Apache, Proxy или CDN).
Альтернативно, выполнение PHP может прерываться на ранней стадии (e.g., через механизм Drop-in `advanced-cache.php` при использовании плагинов кэширования WordPress).

1.1.2) Неправильная работа Cookie Stripping
Промежуточный слой (e.g., CDN, Proxy, Load Balancer или конфигурация веб-сервера Apache) может быть некорректно настроен на удаление (Stripping) аутентификационных cookies перед тем, как запрос достигнет приложения WordPress.
В этом сценарии запрос достигает ядра WordPress.
Однако, поскольку аутентификационные cookies отсутствуют, функция `is_user_logged_in()` возвращает `false`.
Чтобы защитить контент, WordPress (часто через функцию `auth_redirect()`) или LearnDash немедленно инициирует перенаправление на страницу входа.

1.2) Обоснование:
1.2.1) Вы пишете, очистка кэша или вход через режим инкогнито/приватный браузер часто «исправляет» проблему временно.
1.2.2) Это указывает на то, что пользователь получает некорректное состояние (Stale State).
Это является сильным индикатором получения закэшированного перенаправления (Сценарий 1.1.1).
Действия на стороне клиента (Client-Side Actions) не могут исправить конфигурацию сервера, но они могут временно обойти проблему за счет изменения состояния запроса или локального кэша.
Это происходит через 2 механизма:

1.2.2.1) Взаимодействие с Browser Cache.
В Сценарии 1.1.1 система Server-Side Caching некорректно возвращает закэшированный ответ перенаправления (e.g., HTTP 302).
Если этот ответ содержит заголовки управления кэшем (e.g., `Cache-Control` или `Expires`), добавленные caching layer, браузер может сохранить его локально.
В этом случае браузер выполняет перенаправление локально, не обращаясь к серверу повторно.
Очистка кэша браузера или режим инкогнито заставляют браузер отбросить локально сохраненный ответ и отправить новый запрос на сервер.

1.2.2.2) Временный обход Server-Side Cache.
Режим инкогнито или очистка cookies требуют повторного входа в систему.
Процесс входа (Login Process) изменяет характеристики сессии.
E.g., ответ `wp-login.php` содержит заголовок `Set-Cookie`.
Некоторые системы кэширования могут интерпретировать это как сигнал для временного отключения кэша для этой сессии (e.g., механизм Hit-for-Pass).
Также запрос, следующий сразу после входа, может содержать специфический заголовок `Referer`.
Эти факторы могут позволить первому запросу после входа успешно достичь WordPress, минуя некорректный закэшированный ответ.
Однако при последующих запросах, когда эти условия больше не выполняются, проблема возвращается.

1.2.3) Симптом 1.2.1 делает Сценарий 1.1.2 гораздо менее вероятным, чем Сценарий 1.1.1.
Если бы конфигурация инфраструктуры была однородной, постоянное правило удаления cookies применялось бы к каждому запросу, и действия на стороне клиента не приводили бы к временному решению.
Однако в неоднородной среде с несколькими серверами (e.g., за балансировщиком нагрузки), где конфигурация может быть неидентичной, возможно, что только часть узлов некорректно удаляет cookies.
В таком случае начало новой сессии может направить пользователя на корректно работающий узел, что создаст видимость временного исправления проблемы.

2) Причина #2: Неправильная работа Object Caching.
2.1) Суть:
В тегах проекта вы указали Redis и Memcached.
Если ваша система использует эти технологии для Object Caching, критически важные данные для аутентификации (Authentication) кэшируются в памяти.
WordPress использует Session Tokens (хранящиеся в `wp_usermeta`) для отслеживания состояния входа пользователя.
При высокой нагрузке состояние этих токенов в Object Cache может перестать соответствовать актуальному состоянию базы данных MariaDB (Inconsistent State).
Когда пользователь переходит на защищенную страницу, WordPress выполняет Authentication Check с помощью функции `wp_validate_auth_cookie()`.
При наличии Persistent Object Cache эта функция использует его как первичный источник данных (Primary Data Source) для получения Session Tokens (e.g., через `get_user_meta()`).
Если WordPress читает некорректный (устаревший или поврежденный) Session Token из кэша (Cache HIT), проверка завершается неудачей.
В результате WordPress считает пользователя неаутентифицированным (функция `is_user_logged_in()` возвращает `false`) и инициирует перенаправление на страницу входа.
Это может происходить по двум сценариям.

2.1.1) Stale Cache
Когда Session Tokens обновляются в базе данных (e.g., при входе, выходе или автоматическом продлении сессии), соответствующие данные в Object Cache должны быть инвалидированы (Invalidated) или обновлены.
Если механизм инвалидации работает некорректно (e.g., из-за ошибки в конфигурации, конфликта плагинов или проблем с репликацией базы данных), последующие запросы могут получить устаревшие данные (Stale Data) из кэша.
Использование устаревшего токена приводит к сбою Authentication.

2.1.2) Race Condition
При высокой нагрузке и параллельных запросах (e.g., AJAX) может возникнуть Race Condition при обновлении Session Tokens в кэше.
Хотя базовые операции (e.g., GET, SET) в Redis и Memcached являются атомарными (atomic), Race Condition возникает на уровне прикладной логики (Application Logic) в цикле Read-Modify-Write.
Этот цикл (приложение читает массив токенов из кэша, изменяет его в PHP и записывает обратно) не является атомарным.
Если несколько процессов одновременно изменяют этот массив, это может привести к потере обновления (Lost Update) и несогласованности состояния (Inconsistent State) в кэше.
Чтение некорректного состояния Session Tokens приводит к сбою Authentication.

2.2) Обоснование:
2.2.1) Сочетание высокой активности пользователей (которая есть на production, но нет на staging) и использования внешнего Object Cache создает условия для возникновения Stale Cache и Race Condition.
2.2.2) Этот механизм объясняет, почему пользователи перенаправляются, «even though they are already logged in».
Authentication cookie присутствует в браузере, но Authentication Check завершается неудачей из-за временной несогласованности Session Tokens в Object Cache во время конкретного запроса.

3) Причина #3: Проблемы с нативными PHP-сессиями (PHP Native Sessions).
3.1) Суть:
Эта причина гораздо менее вероятна (обоснование в пункте 3.2), но её следует рассмотреть, так как есть признаки использования PHP Native Sessions (`$_SESSION`) в вашей системе.
Хотя WordPress Core не использует `$_SESSION` для Authentication, некоторые плагины (e.g., BuddyBoss, указанный в тегах) могут их активировать.
Ваши действия по удалению файлов в `/tmp` (deleting /tmp session files) также предполагают их использование.
Если `$_SESSION` активны, это создает Concurrency Challenges при высокой нагрузке (которая есть на production, но нет на staging).
Конкретные проблемы зависят от конфигурации PHP `session.save_handler` и проявляются в двух основных сценариях:
3.1.1) Session Locking.
Если используется стандартный обработчик (`session.save_handler = files`), параллельные запросы (e.g., AJAX) блокируют друг друга при вызове `session_start()`.
Это приводит к Resource Contention и значительным задержкам.
3.1.2) Race Conditions.
Если используется внешний обработчик (e.g., Redis или Memcached, указанные в тегах) с отключенной или неэффективной блокировкой, параллельные запросы могут повреждать данные сессии (Data Corruption).

3.2) Обоснование низкой вероятности.
Эти сценарии вряд ли являются прямой причиной цикла перенаправлений из-за несоответствия симптомов (Symptom Mismatch).
3.2.1) Session Locking (пункт 3.1.1) приводит к Performance Bottlenecks.
Симптомы обычно включают ошибки сервера (e.g., HTTP `504 Gateway Timeout` или HTTP `500 Internal Server Error`), а не чистое перенаправление (HTTP `302`) на страницу входа.
3.2.2) Race Conditions (пункт 3.1.2) вызывают Data Corruption в `$_SESSION`.
Это может повлиять на логику плагинов (LearnDash/BuddyBoss), но не влияет на стандартный механизм Authentication WordPress Core.
WordPress Core Authentication основан на cookies и Session Tokens, а не на `$_SESSION`.
3.2.3) В целом, эти механизмы способствуют общей нестабильности системы под нагрузкой, а не конкретно этой проблеме с циклом входа.

4) «How would you approach debugging this issue without disrupting live students?»
4.1) Passive Diagnostics
Цель этапа  — идентифицировать слой, генерирующий перенаправление (CDN, Proxy, Apache или WordPress/PHP), без внесения изменений в код или конфигурацию Production.

4.1.1) Анализ конфигурации и HTTP Headers (Диагностика Причины #1).
4.1.1.1) Проанализировать конфигурацию всех слоев Page Caching (CDN, Proxy, модули Apache, плагины WordPress) на предмет правил обработки аутентификационных cookies.
4.2.2.2) Проанализировать HTTP Response Headers (e.g., `X-Cache`, `Cache-Control`, `Age`) для запросов к защищенным URL.
Наличие заголовков, указывающих на Cache HIT в ответе HTTP 302, подтвердит Сценарий 1.1.1.

4.1.2) Анализ Object Cache (Диагностика Причины #2).
4.1.2.1) Проанализировать конфигурацию интеграции Redis/Memcached.
4.1.2.2) Проанализировать операции кэша (GET/SET/DELETE), связанные с Session Tokens, во время тестовых попыток входа, используя инструменты Real-Time Monitoring (e.g., `redis-cli monitor`).
Это позволяет наблюдать за потенциальными несоответствиями (Stale Cache или Race Conditions) без сброса глобального кэша, который привел бы к принудительному выходу из системы всех студентов.

4.1.3) Анализ существующих логов.
Провести корреляционный анализ Apache `domlogs`, `login-audit.log` и логов вашего MU plugin для выявления паттернов перенаправлений.

4.2) Conditional Debugging
 Если пассивная диагностика не дала окончательного ответа — перейти к активным методам отладки.
4.2.1) Расширенное логирование (Enhanced Logging).
Модифицировать MU plugin для детального логирования процесса Authentication (e.g., результат `wp_validate_auth_cookie()`) и состояния cookies.
Это логирование будет активироваться только при наличии специального отладочного cookie или для конкретного тестового `user_id`.
4.2.2) Контролируемый обход кэша (Controlled Cache Bypass).
Временно настроить правила для принудительного обхода Page Cache только для тестовых запросов.
Использовать фильтр `wp_using_ext_object_cache`, чтобы временно отключить Object Cache только для моей тестовой сессии.

4.3) Staging Reproduction
Поскольку проблема зависит от нагрузки — провести Load Testing на Staging среде.
Используя инструменты (e.g., Apache JMeter или k6), симулировать параллельные аутентифицированные сессии для искусственного создания Race Conditions (Причина 2.1.2).
Это позволит безопасно воспроизвести проблему и протестировать исправления перед развертыванием на Production.

5) «What’s your process for isolating a plugin conflict vs. WordPress core issue?»
5.1) Общий принцип: Systematic Isolation.
Cистематически упрощать Runtime Environment до минимальной конфигурации (Vanilla WordPress).
Это позволяет определить, вызван ли сбой кодом сторонних компонентов (плагины или тема) или базовой платформой (WordPress Core или инфраструктура).

5.2) Процедура изоляции на Production.
5.2.1) Создание Clean Environment.
Использовать технику Conditional Deactivation.
Это реализуется через Must-Use Plugin (`mu-plugin`) или специализированные инструменты (e.g., плагин «Health Check & Troubleshooting»).
Этот метод создает Clean Environment (деактивирует плагины и переключает тему на стандартную, e.g., Twenty Twenty-Five) только для моей сессии администратора (Admin Session).
Другие пользователи продолжают работу с сайтом без изменений.

5.2.2) Baseline Check.
Попытаться воспроизвести проблему в изолированном Clean Environment (пункт 5.2.1).
5.2.2.1) Если проблема воспроизводится — это указывает на проблему в WordPress Core, Must-Use Plugins (включая ваш Custom MU plugin для логирования) или конфигурации инфраструктуры (Server Configuration, Caching Layers).
В этом случае перейти к анализу инфраструктуры и WordPress Core (пункт 5.2.4).
5.3.2.2) Если проблема не воспроизводится - это подтверждает Plugin Conflict или Theme Conflict.
В этом случае перейти к изоляции конфликтующего компонента (пункт 5.2.3).

5.2.3) Изоляция конфликтующего компонента.
5.2.3.1) Сохраняя изолированную сессию,активировать компоненты.
5.2.3.2) Сначала активировать текущую Theme.
Если проблема возвращается — источник конфликта находится в теме.
5.2.3.3) Если нет — активировать критически важные плагины (LearnDash, BuddyBoss).
Затем использовать Binary Search Method: активировать половину оставшихся плагинов и проверить воспроизведение проблемы.
Повторять процесс, сужая поиск до идентификации конкретного плагина или комбинации плагинов, вызывающих конфликт.

5.2.4) Дифференциация WordPress Core и инфраструктуры.
5.2.4.1) Проверить целостность файлов WordPress Core (File Integrity Check) на предмет модификаций.
5.2.4.2) Проанализировать конфигурацию инфраструктуры (Apache, PHP-FPM, Redis/Memcached, правила Caching), так как это наиболее вероятные причины для Production-Only проблем (как описано в пунктах 1-3).
5.3.4.3) Если предыдущие шаги не выявляют причину — рассмотреть вероятность ошибки в WordPress Core.
В этом случае провести глубокую отладку (Deep Debugging) с использованием Xdebug для анализа Authentication Flow и искать известные проблемы (Known Issues) в WordPress Trac.
