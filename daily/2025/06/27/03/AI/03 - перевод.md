## 1. `Def`
### 1.1.
```
Def(A, B)
```
будет обозначать, что для понятия `B` я использую обозначение `A`.

### 1.2.
~~~
Def(A):
```
B
```
~~~
имеет то же значение, что и `Def(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 2. `Def_P`
### 2.1.
```
Def_P(A)
```
будет обозначать, что `A` является для меня проблемой.

### 2.2.
```
Def_P(A, B)
```
будет обозначать, что `B` является для меня проблемой, и для этой проблемы я использую обозначение `A`.

### 2.3.
~~~
Def_P(A):
```
B
```
~~~
имеет то же значение, что и `Def_P(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 3. `Def_C`
### 3.1.
```
Def_C(P, A, B)
```
будет обозначать `Def(A, B)` в контексте пункта `P`.
Вне пункта `P` это правило не применяется.
Если до пункта `P` обозначение `A` имело другой смысл, то после пункта `P` обозначение `A` снова будет иметь этот смысл.
По сути, `Def_C` объявляет локальную переменную `A` с областью действия `P`.
В отличие от него, `Def` объявляет глобальную переменную `A` (значение которой действует для всех пунктов, кроме `P`).

### 3.2.
~~~
Def_C(P, A):
```
B
```
~~~
имеет то же значение, что и `Def_C(P, A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 3.3.
```
Def_C([P1, P2, …, Pn], A, B)
```
имеет значение, аналогичное `Def_C(P, A, B)`, только в этом случае обозначение `A` имеет значение `B` в контексте не одного пункта `P`, а всех пунктов [`P1`, `P2`, …, `Pn`], перечисленных в квадратных скобках.

### 3.4.
```
Def_C([P1-Pn], A, B)
```
имеет значение, аналогичное `Def_C([P1, P2, …, Pn], A, B)`: в этом случае обозначение `A` имеет значение `B` в контексте множества всех пунктов между `P1` и `Pn`, включая сами эти пункты.

### 3.5.
~~~
Def_C([P1, P2, …, Pn], A):
```
B
```
~~~
имеет то же значение, что и `Def_C([P1, P2, …, Pn], A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 3.6.
~~~
Def_C([P1-Pn], A):
```
B
```
~~~
имеет то же значение, что и `Def_C([P1-Pn], A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 4. `Def_F`
### 4.1.
Def_C(4-5, `F`):
```
Факт: некое событие, которое случилось в описываем мной случае.
```

### 4.2.
```
Def_F(B)
```
будет обозначать, что `B` — это `F`.

### 4.3.
~~~
Def_F:
```
B
```
~~~
имеет то же значение, что и `Def_F(B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 4.4.
```
Def_F(A, B)
```
будет обозначать, что `B` — это `F`, и для него я использую обозначение `A`.

### 4.5.
~~~
Def_F(A):
```
B
```
~~~
имеет то же значение, что и `Def_F(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 5. `Def_Ph`
### 5.1.
Def_C(5, `Ph`):
```
Феномен: `F`, который вызывает у меня удивление.
```

### 5.2.
```
Def_Ph(B)
```
будет обозначать, что `B` — это `Ph`.

### 5.3.
~~~
Def_Ph:
```
B
```
~~~
имеет то же значение, что и `Def_Ph(B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 5.4.
```
Def_Ph(A, B)
```
будет обозначать, что `B` — это `Ph`, и для него я использую обозначение `A`.

### 5.5.
~~~
Def_Ph(A):
```
B
```
~~~
имеет то же значение, что и `Def_Ph(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 6. `Def_H`
### 6.1.
Def_C(6, `H`):
```
Гипотеза: некое предположение, требующее проверки.
```

### 6.2.
```
Def_H(B)
```
будет обозначать, что `B` — это `H`.

### 6.3.
~~~
Def_H:
```
B
```
~~~
имеет то же значение, что и `Def_H(B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 6.4.
```
Def_H(A, B)
```
будет обозначать, что `B` — это `H`, и для него я использую обозначение `A`.

### 6.5.
~~~
Def_H(A):
```
B
```
~~~
имеет то же значение, что и `Def_H(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 7. `Def_Set`
```
Def_Set(S, I)
```
будет обозначать, что `S` — множество всех возможных `I`.

## 8. `Def_I`
```
Def_I(I, S)
```
будет обозначать, что `I` — элемент множества `S`.

## 9. `Use`
```
Use(A)
```
будет обозначать, что в описываемой мной ситуации я использую `A`.

## 10.
Потенциальный клиент опубликовал на Upwork следующий проект:
### 10.1. Title
Azure Specialist Needed for Access-Based Enumeration (ABE) Configuration on SMB File Shares

### 10.2. Description
```text
We are seeking an Azure specialist to implement Access-Based Enumeration (ABE) on our Azure SMB file shares. Currently, we use basic Azure File Share within Azure Storage. Our objective is to restrict visibility so users only see folders and files they have explicit permissions to access.

Currently, all folders are visible to all users, regardless of their permissions. We need someone to configure ABE effectively, ensuring enhanced security and usability.

Tasks:

Implement and test ABE on Azure File Shares.

Configure granular identity-based folder and file permissions.

Provide clear documentation and best practices.

Assist with initial permission setup and troubleshooting.

Requirements:

Expertise in Azure Files and SMB protocol.

Experience implementing Access-Based Enumeration.

Familiarity with Azure Active Directory (Azure AD).

Strong troubleshooting, documentation, and communication skills.

Preferred:

Azure certifications (e.g., Azure Administrator Associate).

Experience with similar projects on Azure File Share.

Knowledge of Azure security best practices.

Application:
In your proposal, please provide:

Your experience with Azure ABE.

Examples of similar completed projects.

Availability and proposed timeline.

Hourly rate or fixed-price bid.
```

### 10.3. Tags
Microsoft Azure
Windows Server
Microsoft Active Directory
Microsoft Azure Administration

## 11. Информация о клиенте
### 11.1. Местоположение
USA
Palm Springs

## 11.2. Характеристики компании
### 11.2.1. Сектор экономики
Finance & Accounting
### 11.2.2. Количество сотрудников
10-99 people

## 11.3. Характеристики учётной записи на Upwork
### 11.3.1. Member since
Mar 13, 2023
#### 11.3.2. Hire rate (%)
13%
#### 11.3.3. Количество опубликованных проектов (jobs posted)
8
#### 11.3.4. Total spent
$250
#### 11.3.5. Количество оплаченных часов в почасовых проектах
0 

## 12.
Def(`C`):
```
клиент пункта 10
```

## 13.
Def(`P`):
```
проект пункта 10
```

## 14.
Def(`Ps`):
```
множество подобных `P` проектов 
```

## 15.
Def(`T`):
```
Стратегическая задача `C`, о которой он пишет в пункте 10.2:
~~~
Our objective is to restrict visibility so users only see folders and files they have explicit permissions to access.
Currently, all folders are visible to all users, regardless of their permissions. 
~~~
```

## 16.
Def(`S1`):
```
способ, которым `C` намерен решить `T`:
~~~
implement Access-Based Enumeration (ABE)
~~~
```

## 17.
Def(`As`):
```
альтернативы `S1` для `T`
```

## 18.
Def(`D`, «мой ответ `C`»).

## 19.
Содержание `D`:
```markdown
1) Предлагаемый вами способ решения вашей задачи в принципе неверен.
В официальной документации Microsoft прямо сказано: «Using ABE with Azure Files isn't currently supported»
https://learn.microsoft.com/en-us/azure/storage/files/storage-files-faq#access-based-enumeration
4 правильных способа решения вашей задачи я описываю ниже в пунктах 2-5.
2) Azure Files с элементами управления на основе удостоверений (в частности, с использованием Windows ACL). 
Для реализации разрешений на уровне пользователей и групп необходимо интегрировать Azure Files с одним из поддерживаемых источников удостоверений. 
Azure поддерживает 3 основных метода:
2.1) Локальные службы доменов Active Directory (AD DS)
2.2) Microsoft Entra Domain Services
2.3) Microsoft Entra Kerberos для гибридных удостоверений
После включения аутентификации на основе удостоверений Azure Files начинает полностью поддерживать стандартные списки контроля доступа (ACL) Windows на уровне каталогов и файлов.
Это и есть механизм, позволяющий имитировать поведение ABE.
3) Azure NetApp Files (ANF): https://learn.microsoft.com/en-us/azure/azure-netapp-files/network-attached-storage-permissions
4) SharePoint Online: вместо создания традиционного файлового сервера в облаке использовать платформу, изначально созданную для совместной работы с документами.
5) Файловый сервер Windows на виртуальной машине Azure.
В Azure развертывается виртуальная машина с ОС Windows Server, к ней подключаются управляемые диски (Managed Disks) для хранения данных, настраивается роль файлового сервера, создаются общие папки и настраиваются разрешения. 
Поскольку это полноценная ОС Windows Server, она имеет полную нативную поддержку ABE, которую можно включить для каждой общей папки через Диспетчер серверов или PowerShell.
```

## 20.
Def(`D2`, «начальная часть `D`, переведённая с Russian на English»).

## 21.
Содержание `D2`:
```markdown
1) The proposed method for solving your task is fundamentally incorrect.
In the official Microsoft documentation, it is explicitly stated: «Using ABE with Azure Files isn't currently supported»
https://learn.microsoft.com/en-us/azure/storage/files/storage-files-faq#access-based-enumeration
I describe 4 correct methods to solve your task below in points 2-5.
2) Azure Files with identity-based controls (specifically, using Windows ACLs).
To implement user and group-level permissions, it is necessary to integrate Azure Files with one of the supported identity sources.
Azure supports 3 main sources:
2.1) On-premises Active Directory Domain Services (AD DS)
2.2) Microsoft Entra Domain Services
2.3) Microsoft Entra Kerberos for hybrid identities
Once identity-based authentication is enabled, Azure Files fully supports standard Windows Access Control Lists (ACLs) at the directory and file level.
This is the mechanism that simulates ABE behavior.
3) Azure NetApp Files (ANF): https://learn.microsoft.com/en-us/azure/azure-netapp-files/network-attached-storage-permissions
```

## 22.
Def(`F`, «фрагмент `D`»).

## 23.
Содержание `F`:
```text
5) Файловый сервер Windows на виртуальной машине Azure.
В Azure развертывается виртуальная машина с ОС Windows Server, к ней подключаются управляемые диски (Managed Disks) для хранения данных, настраивается роль файлового сервера, создаются общие папки и настраиваются разрешения. 
Поскольку это полноценная ОС Windows Server, она имеет полную нативную поддержку ABE, которую можно включить для каждой общей папки через Диспетчер серверов или PowerShell.
```

## 24.
Переведи `F` на English, с учётом:
- контекста `D`
- `D2`: уже переведённой части `D`
- всех предыдущих пунктов моего запроса

## 25. Правила перевода
### 25.1.
Переводи именно в той стилистике, как написано на Russian.
Не делай перевод более вежливым, чем оригинал.

### 25.2.
Те предложения, которые сейчас полностью на English — оставь без изменения.

### 25.3.
#### 25.3.1.
Не используй Markdown: только plain text.
#### 25.3.2.
При этом можно и нужно использовать то форматирование, которое уже есть в оригинале: его не убирай.
#### 25.3.3.
Не форматируй веб-ссылки посредством Markdown, если они не отформатированы так в оригинале. 
Например, не пиши так:
```
[https://www.eca.web.tr/eca-nita-esnek-uclu-eviye-bataryasi-beyaz-102118110-308](https://www.eca.web.tr/eca-nita-esnek-uclu-eviye-bataryasi-beyaz-102118110-308)
```
если в оригинале скобок `[]()` нет.

### 25.4.
Форматируй перевод в точности как оригинал. 
В частности:
*) каждый абзац должен содержать ровно одно предложение
*) между абзацами не должно оставаться пустых строк.
*) кавычки используй те же, что и в оригинале: «» и ``.

### 25.5.
Не используй сокращения типа «don't». Все подобные фразы пиши полностью: «do not».

### 25.6.
Не используй жаргон.
Вместо этого используй официальные термины.
#### 25.6.1.
В частности, фразы в кавычках используй только в том случае, когда они являются точными цитатами.
Не используй фразы в кавычках для применения жаргонных фраз.
Например, следующий фрагмент текста недопустим, потому что там используется жаргонная фраза «пролетел»: 
```
Например, код, который пушит данные о покупке, подключён асинхронно и загружается с небольшой задержкой, а триггер уже «пролетел».
```

### 25.7.
При обсуждении программного обеспечения используй точные официальные термины на английском языке: именно в том виде, как они указаны в официальной англоязычной документации к этому программному обеспечению.

### 25.8.
Не используй «you need» и другие подобные обращённые к клиенту фразы, перекладывающие действия на него.
Помни: я пишу клиенту или потенциальному клиенту.
Делать в любом случае буду я, а не клиент.
Вместо «you need» используй 2 альтернативы:
#### 25.8.1.
Нейтральные фразы типа «it is necessary».
#### 25.8.2.
Глаголы в неопределённой форме.
Например, во фрагменте ниже использованы подобные глаголы «set up», «create»:
```
1.2) Set up the transfer of login events from WordPress to Power BI using Fabric / OneLake.
1.2.1) Set up a «Data Pipeline» from the WordPress database table that stores login events (see point 1.1) to Fabric / OneLake.
1.2.2) Set up a connection from Power BI to Fabric / OneLake to pass login events.
1.3) Create the data model in Power BI.
```
Обрати внимание, в этом фрагменте не говорится, кто именно будет выполнять описанные действия: ответственность не перекладывается на клиента, в отличие от «you need».

### 25.9.
Никогда не переводи понятие «сайт» / «веб-сайт» как «site». 
Вместо этого используй форму «website»: это является более профессиональным.

### 25.10.
Никогда не переводи понятие «пункт нумерованного списка» как «item».
Всегда переводи это как «point».