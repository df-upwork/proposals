1. В пункте 2.2 содержится критическая фактическая ошибка в описании реализации Conditional Outer Join (например, Left Outer Join). Метод, описанный в пунктах 2.2.1–2.2.4 (соединение по ключам с последующим применением условной формулы к выходу «J» и объединением с выходом «L»), не эквивалентен стандартной операции SQL `LEFT OUTER JOIN`, где дополнительные условия включены в предикат `ON` (например, `... ON L.Key = R.Key AND [Condition]`).
Описанный метод реализует логику, эквивалентную использованию выражения `CASE` в списке `SELECT` после стандартного `LEFT OUTER JOIN`. Различие заключается в том, что в предложенном варианте соединение записей происходит всегда, когда совпадают ключи, а условия проверяются постфактум. В SQL Conditional Outer Join условия определяют сам факт успешного соединения. Это может привести к неверному количеству строк или дублированию данных.

2. В пункте 1.2 присутствует логическая ошибка, так как он предписывает использовать метод из пункта 2.2 для реализации Conditional Outer Join на этапе консолидации данных. Поскольку метод в пункте 2.2 фактологически неверен (см. замечание 1), консолидация данных (`Hierarchy_Data`) будет выполнена некорректно, если требуется точная репликация указанной SQL-логики.

3. В разделе 2 отсутствует описание реализации условных соединений, условия которых не содержат операторов равенства (non-equi-joins), например, соединение по диапазонам значений (BETWEEN) или неравенствам (<, >). Для таких случаев стандартный инструмент «Join» неприменим. В Alteryx необходимо использовать альтернативный подход: формирование декартова произведения с помощью инструмента «Append Fields» с последующим применением инструмента «Filter».

4. В описании дизайна итерационного макроса (раздел 3) присутствует критический логический пробел: отсутствует механизм обнаружения и обработки циклических ссылок в данных иерархии (например, A является родителем B, а B является родителем A).

5. Пункт 4.2.3 предлагает использовать «Maximum Number of Iterations» только для предотвращения бесконечных циклов, но это не решает проблему корректности результата при наличии циклических ссылок. Без явной логики отслеживания посещенных узлов внутри каждого пути макрос будет генерировать некорректные данные (избыточные пути, неверные значения уровня иерархии) до достижения лимита итераций.

6. В пунктах 1.2 и 3.3 делается сильное предположение, что логика Conditional Outer Join требуется только на этапе статической консолидации данных (пункт 1.2), и что для рекурсивного обхода достаточно логики Conditional Inner Join (пункт 3.3). Это может быть логической ошибкой в архитектуре решения, если исходная реализация на SQL использует Conditional Outer Join именно в рекурсивной части запроса (например, в Recursive CTE) для динамического определения связей.

7. Структура данных для итерации, определенная в пунктах 1.4 и 3.2.1 (`AncestorID`, `CurrentID`, `Level`), является неполной, если внутри макроса применяется условное соединение (пункт 3.3.4). В итерационный поток необходимо также включить все поля, участвующие в условии (`ConditionFields`), и обеспечить их корректную передачу между итерациями (пункт 3.4.3).

8. В пункте 5.3 допущена логическая неточность. Утверждается, что объединение начальных узлов (`Initial_Nodes`) с результатом работы макроса (`Output_R`) выполняется «При необходимости». В действительности это объединение является обязательным для получения полного набора данных иерархии. Описанная логика макроса накапливает в `Output_R` только связи, найденные в ходе итераций (начиная с уровня 1), но не включает сами начальные узлы (уровень 0).

9. В разделе 4 отсутствуют важные детали конфигурации макроса в «Interface Designer» (раздел «Properties»). Не указаны настройки «Output Mode» и режима сопоставления полей (например, «Auto Configure by Name»). Утверждение в пункте 3.5.1 о том, что выход `Output_R` накапливает результаты всех итераций, зависит от корректной конфигурации этих параметров.

10. В пункте 3.4.2 приведено фактологически неточное обоснование отказа от использования переменной `[Engine.IterationNumber]`. Утверждение, что она «не учитывает начальный уровень», некорректно, так как это можно учесть в формуле расчета (например, `[Начальный_Уровень] + [Engine.IterationNumber] + 1`).