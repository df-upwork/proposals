# 1. `B.md`
~~~~~~markdown
# 1. `᛭MDi`
## 1.1.
Каждый отдельный (произвольный, неопределённый) документ в формате Markdown, прикреплённый мной к этому запросу, буду обозначать `᛭Di`.
## 1.2.
Имя файла `᛭Di` всегда имеет расширение `.md`.
## 1.3.
Множество всех `᛭Di` буду обозначать `᛭Ds`.

# 2. `L.md`
### 2.1.
`L.md` ∈ `᛭Ds`.
## 2.2.
`L.md` описывает полуформальный язык: `᛭L`.
## 2.3.
Большинство `᛭Di` написаны на `᛭L`.
## 2.4.
Множество всех `᛭Di`, написанных на `᛭L`, буду обозначать `᛭DLs`.
Таким образом, `᛭DLs` ⊆ `᛭Ds`. 

# 3. `O.md`
## 3.1.
`O.md` ∈ `᛭DLs`
## 3.2.
`O.md` описывает некую **онтологию** (`᛭O`)  — модель предметной области, в которой тебе предстоит решать задачу.
«An **ontology** encompasses a representation, formal naming, and definitions of the categories, properties, and relations between the concepts, data, or entities»: https://en.wikipedia.org/wiki/Ontology_(information_science)

# 4. `T.md`
## 4.1.
`T.md` ∈ `᛭DLs`
## 4.2.
`T.md` описывает задачу (`᛭T`), которую ты должен решить.

# 5. Порядок твоих действий
Действуй пошагово:
## 5.1.
Сначала внимательно и полностью прочитай `L.md`.
В точности запомни его содержание.

## 5.2.
Затем внимательно и полностью прочитай `O.md`. 
В точности запомни его содержание.

## 5.3.
Затем внимательно и полностью прочитай `T.md`. 
Выполни `᛭T`.

~~~~~~

# 2. `L.md`
~~~~~~markdown
# 1. `≔`
## 1.1.
- `≔` — это бинарный оператор.
## 1.2.
`A ≔ B` means that `A` **denotes** `B`.
## 1.3.
Я использую `≔` для сокращения записи.
В выражении `A ≔ B` `B` обычно — это длинный текст, а `A` — это более короткое обозначение.  
## 1.4.
~~~code
A ≔
```
B
```
~~~
равнозначно `A ≔ B` и используется, когда `B` — многострочный текст.

# 2. `→`
~~~code
A → B
~~~
denotes a material conditional (https://en.wikipedia.org/wiki/Material_conditional)

# 3. `⊢`
~~~code
A ⊢ B
~~~
denotes a logical consequence (https://en.wikipedia.org/wiki/Logical_consequence)

# 4. `⊤`
## 4.1.
~~~code
⊤ B
~~~
means that `B` is true (is a fact).

## 4.2.
~~~code
⊤⟦Rs⟧ B
~~~
means:
```
(⊤ `B`) AND (`Rs` are the reasons why `B` is true)
```

## 4.3.
~~~code
A ≔⊤
```
B
```
~~~
means:
```code
(`A` ≔ `B`) AND (⊤ `B`).
```

## 4.4.
~~~code
A ≔⊤⟦Rs⟧
```
B
```
~~~
means:
```code
(`A` ≔ `B`) AND (⊤⟦Rs⟧ B).
```

# 5. `≔!`
## 5.1.
~~~code
A ≔! B
~~~
means:
```code
(`A` ≔⊤ `B`) AND (`B` is surprising).
```

## 5.2.
~~~code
A ≔!⟦Rs⟧ B
~~~
means:
```code
(`A` ≔⊤⟦Rs⟧ `B`) AND (`B` is surprising).
```

# 6. `?`
## 6.1.
~~~code
? B
~~~
means that `B` is a hypothesis.

## 6.2.
~~~code
?⟦Rs⟧ B
~~~
means:
```code
(? `B`) AND (`Rs` are the reasons for the hypothesis)
```

## 6.3.
~~~code
A ≔? B
~~~
means:
```code
(? `B`) AND (`A` ≔ `B`)
```

## 6.4.
~~~code
A ≔?⟦Rs⟧ B
~~~
means:
```code
(?⟦Rs⟧ `B`) AND (`A` ≔ `B`)
```

# 7.
## 7.1.
~~~code
A : S ≔ B
~~~
means:
```code
(`A` ≔ `B`) AND (`A` ∈ `S`).
```

## 7.2.
~~~code
A : S
~~~
means:
```code
`A` : `S` ≔ (an arbitrary element of `S`)
```

# 8. `⠿{…}`
## 8.1. `⠿{I₁, I₂, …, Iₙ}`
`⠿{I₁, I₂, …, Iₙ}` обозначает множество, заданное точным перечислением всех его элементов: {`I₁`, `I₂`, …, `Iₙ`}.

## 8.2. `⠿{I₁-Iₙ}` 
`⠿{I₁-Iₙ}` обозначает множество, заданное интервалом (диапазоном) его значений.
Это множество, в числе прочего, включает границы указанного интервала: `I₁` и `Iₙ`.

# 9. `⠿~`
## 9.1. `⠿~ (D)`
`⠿~ (D)` обозначает множество, заданное неформальным (словесным) описанием его элементов (`D`).

## 9.2.
~~~code
⠿~
```
D
```	
~~~
равнозначно `⠿~ (D)` и используется, когда `D` — многострочный текст.

## 9.3.
~~~code
S ≔ ⠿~ (D)
```yaml
- I₁
- I₂
- …
- Iₙ
```	
~~~
означает: (`S ≔ ⠿~ (D)`) AND (⠿{`I₁`, `I₂`, …, `Iₙ`} ⊆ `S`) .

# 10.
## 10.1.
`᛭DLi` : `᛭DLs`
## 10.2.
### 10.2.1.
`᛭Dc` — это обозначение `᛭DLi` самого себя.
Другими словами, если текст `᛭DLi` содержит упоминание `᛭Dс` — это значит, что `᛭Di` упоминает сам себя. 
### 10.2.2.
Например: если имя файла `᛭Di` — `sample.md`, и текст `sample.md` использует обозначение `᛭Dc`, это значит, что `᛭Dc` в данном случае обозначает документ `sample.md`.  

# 11. `§`
## 11.1.
~~~code
§P
~~~
означает ссылку на пункт `P` `᛭Dc`.
Например, §8.2.2 означает ссылку на пункт 8.2.2 `᛭Dc`.
## 11.2.
~~~code
`᛭DLi`::§P
~~~
означает ссылку на пункт `P` `᛭DLi`.
  
# 12. Local Definitions
## 12.1.
~~~code
A[§P] ≔ B
~~~
Означает:
- Для понятия `B` я **временно**, **только в рамках** §`P`, использую обозначение `A`.
- Вне §`P` это правило не применяется: в частности, если до §`P` обозначение `A` имело другой смысл, то после §`P` обозначение `A` снова будет иметь этот смысл.
- По сути, `A[§P] ≔ B` объявляет **локальную переменную** `A` с **областью действия** §`P`.
- В отличие от `A[§P] ≔ B`, `A ≔ B` объявляет **глобальную переменную** `A`.

## 12.2.
~~~code
A[§P₁, §P₂, …, §Pₙ] ≔ B
~~~
Означает, что обозначение `A` имеет значение `B` в контексте ⠿{§`P₁`, §`P₂`, …, §`Pₙ`}.
По сути, это правило аналогично §12.1, но область действия локальной переменной `A` ограничивается не одним пунктом, а множеством пунктов.

## 12.3.
~~~code
A[§P₁-§Pₙ] ≔ B
~~~
Означает, что обозначение `A` имеет значение `B` в контексте ⠿{§P₁-§Pₙ}.
По сути, это правило аналогично §12.1 и §12.2.

# 13. `≔†`
~~~code
A ≔† B
~~~
means:
```code
(`A` ≔ `B`) AND (`B` is a **problem** to me).
```

# 14. `▶`
```
▶ A
```
означает, что в описываемой мной ситуации я использую `A`.



~~~~~~

# 3. `O.md`
~~~~~~markdown
# 1.
## 1.1.
`UW` ≔ (Upwork: https://en.wikipedia.org/wiki/Upwork)

## 1.2.
`ꆜ` ≔ (Некий конкретный потенциальный клиент на `UW`)

## 1.3.
`P⁎` ≔ (Некий конкретный потенциальный проект, опубликованный `ꆜ` на `UW`)

# 2. Информация о `P⁎`
## 2.1. URL
https://www.upwork.com/jobs/~021960782395149854631

## 2.2. Title
Azure Data Factory pipelines

## 2.3. Description
`PD` ≔ 
```text
I joined a new company last month in the UK. 
I have been tasked to understand why some Azure Data Factory pipelines have not been working. 
Now why am i here? 
I cannot even test the pipeline. 
I wanted to run the pipeline but because it is a parameterised pipeline, i just don't know how to go about it. 
I want someone to look at the pipeline, tell me what it is doing and then show me how to run it or test it. 
Then your job is done. 
Is that something you are happy or can help with?
Thank you
Charles
```

## 2.4. Tags
STUB

# 3. Информация о `ꆜ`
## 3.1. Местоположение
nited Kingdom

## 3.2. Характеристики компании
### 3.2.1. Сектор экономики
неизвестно

### 3.2.2. Количество сотрудников
неизвестно

## 3.3. Характеристики учётной записи на `UW`
### 3.3.1. Member since
STUB
### 3.3.2. Hire rate (%)
 Aug 27, 2025
### 3.3.3. Количество опубликованных проектов (jobs posted)
1
### 3.3.4. Total spent (USD)
0
### 3.3.5. Количество оплаченных часов в почасовых проектах
0

# 4. Другие проекты `ꆜ` на `UW`
отсутствуют

# 5.
`P†` ≔†
```
Проблема, о которой `ꆜ` пишет в `PD`:
~~~
I wanted to run the pipeline but because it is a parameterised pipeline, i just don't know how to go about it
~~~
```

# 6.
## 6.1.
`Ⰰ⠿` ≔? ⠿~ (Возможные причины `P†`)
 
## 6.2.
`Ⰰᵢ` : `Ⰰ⠿`

# 7.
## 7.1. 
`Ⰰ1` : `Ⰰ⠿` ≔ 
```
# Отсутствие контекста и документации по значениям параметров

## Оценка правдоподобности: 95/100

## Доводы за 
Это критическая проблема при работе с унаследованными системами. 
Даже если клиент знает, *как* технически ввести параметр , он не знает, *какое* значение корректно (например, путь к хранилищу, строка подключения, диапазон дат). 
Его запрос — "tell me what it is doing and then show me how to run it" — прямо указывает на отсутствие понимания логики работы конвейера и, следовательно, его входных требований. 
Кроме того, новый сотрудник может опасаться запускать конвейер с неверными данными, чтобы не повредить производственную среду.

## Доводы против 
Если бы для параметров были установлены значения по умолчанию, он мог бы попытаться запустить конвейер с ними. Его заявление подразумевает отсутствие таких значений или недоверие к ним
``` 

## 7.2. 
`Ⰰ2` : `Ⰰ⠿` ≔ 
```
#  Недостаток фундаментальных знаний и опыта работы с ADF

## Оценка правдоподобности: 80/100

## Доводы за 
Клиент прямо заявляет: "i just don't know how to go about it". 
Будучи новым сотрудником (1 месяц в компании), он может быть не знаком с ADF. 
Он может не понимать разницу между режимами запуска ("Debug" и "Trigger Now"), как параметры используются в выражениях (expressions) или как взаимодействовать с панелью ввода параметров.

## Доводы против
Клиент смог найти конвейеры и корректно идентифицировал их как "parameterised pipeline", что предполагает базовое взаимодействие с интерфейсом ADF Studio и понимание того, что именно параметры являются блокером.
``` 

## 7.3. 
`Ⰰ3` : `Ⰰ⠿` ≔ 
```
#  Сложность эмуляции параметров, автоматически предоставляемых триггерами

## Оценка правдоподобности: 75/100

## Доводы за
Производственные конвейеры часто получают параметры автоматически от триггеров (например, Tumbling Window или Storage Event) через системные переменные (например, `@trigger().outputs.windowStartTime` или `@triggerBody().fileName`). 
При ручном тестировании (Debug) пользователь должен эмулировать эти значения самостоятельно. 
Если клиент не знает об этой зависимости и о том, какие данные обычно предоставляет триггер, он не сможет корректно запустить конвейер вручную.

## Доводы против
Не все параметризованные конвейеры зависят от метаданных триггера; они могут использовать только простые конфигурационные параметры (покрывается `Ⰰ1`).
``` 

## 7.4. 
`Ⰰ4` : `Ⰰ⠿`  ≔ 
```
# Сложность типов входных данных (Object/Array)

## Оценка правдоподобности: 60/100

## Доводы за
Если конвейер ожидает параметры типа `Object` или `Array` (часто используется в сложных, управляемых метаданными конвейерах), пользователь должен ввести синтаксически корректный JSON. 
Ошибки в форматировании сложных структур данных в UI являются рас пространенной проблемой для новичков и могут приводить к ошибкам валидации еще до запуска.

## Доводы против
Мы не знаем типы параметров; они могут быть простыми (String, Int). 
Эта проблема часто является частным случаем `Ⰰ1` (незнание формата и значения).
``` 

# 8.
## 8.1.
`ᛝ⠿` ≔? ⠿~ (Возможные заблуждения `ꆜ` относительно `P†`)
 
## 8.2.
`ᛝᵢ` : `ᛝ⠿`

# 9.
## 9.1. 
`ᛝ1` : `ᛝ⠿` ≔ 
```
# Чтобы диагностировать прошлые сбои, необходимо запустить конвейер сейчас.

##
Фокус на немедленном запуске для диагностики исторических проблем игнорирует основной инструмент анализа сбоев в ADF (Monitor) и различия в режимах выполнения.

##
###
Задача клиента — диагностировать *исторические* сбои. 
Стандартным и наиболее эффективным первым шагом в ADF является просмотр журналов выполнения на вкладке «Monitor» (Источник: Microsoft Learn, *Monitor and manage pipelines*). 
Там хранятся точные сообщения об ошибках, входные параметры и статус каждого действия для прошлых запусков.
###
Повторный запуск может не воспроизвести ошибку, если она была вызвана временными условиями (таймауты сети, блокировки БД) или специфическими данными того времени.
###
Существуют критические различия между режимом отладки (Debug) и запуском по триггеру (Triggered run). Они могут использовать разные версии кода (текущая на холсте против опубликованной) и разные контексты безопасности (учетные данные пользователя против Managed Identity ADF). Диагностика производственных сбоев (Triggered runs) путем запуска в Debug может ввести в заблуждение.

##
###
*Воспроизведение сбоя путем запуска конвейера — распространенная техника отладки для проверки исправлений и наблюдения за поведением системы в реальном времени.
###
Некоторые ошибки (например, проблемы производительности или сложные логические ошибки в потоках данных) лучше диагностировать в режиме отладки (Debug).
```  
 
## 9.2. 
`ᛝ2` : `ᛝ⠿` ≔ 
```
# Проблема внутренняя (логика/параметры), а не внешняя (среда))

##
Игнорирование внешних факторов является критической ошибкой при диагностике сбоев в ADF.

##
###
Конвейеры ADF сильно зависят от внешних систем. 
Значительная часть сбоев связана с инфраструктурой и безопасностью, особенно в унаследованных средах (Источник: Microsoft Learn, *Troubleshoot pipeline orchestration and execution*):

1.  **Аутентификация и Авторизация:** Истекшие учетные данные или ключи в Linked Services, некорректная настройка Managed Identity, отсутствие доступа к Azure Key Vault или целевым хранилищам.
2.  **Сетевые проблемы:** Конфигурация брандмауэров (Azure Storage, SQL DB), VNet, Private Endpoints, блокирующие доступ.
3.  **Integration Runtime (IR):** Проблемы с доступностью, конфигурацией или производительностью Self-Hosted IR.

###
Поскольку клиент является новым сотрудником, вероятность проблем, связанных с конфигурацией среды и доступом, значительно возрастает.

##
Некоторые сбои действительно вызваны ошибками в логике конвейера (например, некорректные выражения или маппинги) или неправильной обработкой параметров.
```   

~~~~~~

# 4. `T.md`
~~~~~~markdown
# 1.
## 1.1.
`Aᨀ` ≔ (мой ответ `ꆜ`)

## 1.2.
Содержание `Aᨀ`:
~~~markdown
1) Стратегическая задача, которую вам поручил работодатель — диагностика проблем прошлых запусков ваших pipelines.
Ваше первое возможное заблуждение: попытка провести эту диагностику новым запуском pipeline.
На самом же деле, новый запуск не является первоочередным способом понять, почему конвейеры не работали в прошлом.
Вместо этого в первую очередь следует изучить журналы выполнения прошлых запусков:
1.1) Перейти в Azure Data Factory Studio.
1.2) Открыть вкладку «Monitor» на левой боковой панели.
1.3) В разделе «Pipeline runs» изучить список предыдущих выполнений целевого конвейера. 
Использовать фильтры по имени конвейера (Pipeline name) и статусу (Status, например, «Failed»), чтобы найти интересующие запуски. 
Убедиться, что анализируются запуски типа «Triggered» (производственные запуски), а не «Debug».
1.4) Проанализировать детали сбойного запуска.
1.4.1) Кликнуть на имя конвейера в списке, чтобы перейти к списку «Activity runs» (выполнения действий).
1.4.2) Идентифицировать действие (activity), которое завершилось сбоем.
1.4.3) Изучить детальное сообщение об ошибке. Для этого кликнуть на иконку в колонке «Error» для этого activity.
1.4.4) Изучить входные параметры, которые были использованы при этом запуске.
Для этого найти колонку «Parameters» (на уровне Pipeline run или в верхней части экрана Activity runs) и посмотреть значения, которые были фактически переданы в конвейер.
2) Ваше второе возможное заблуждение: вы ищете причину сбоя работы pipeline только внутри него.
На самом же деле, значительная часть сбоев pipeline связана с внешниими причинами: инфраструктурой и безопасностью, особенно в унаследованных средах.
В частности:
- Аутентификация и Авторизация: истекшие учетные данные или ключи в Linked Services, некорректная настройка Managed Identity, отсутствие доступа к Azure Key Vault или целевым хранилищам.
- Сетевые проблемы: конфигурация брандмауэров (Azure Storage, SQL DB), VNet, Private Endpoints, блокирующие доступ.
- Integration Runtime (IR): проблемы с доступностью, конфигурацией или производительностью Self-Hosted IR.

Игнорирование внешних факторов является критической ошибкой при диагностике сбоев в ADF.
Поэтому нужно провести диагностику этих внешних факторов:
2.1) Перейти на вкладку «Manage» на левой боковой панели.
2.2) Проверить Linked Services:
2.2.1) Перейти в раздел «Linked services».
2.2.2) Идентифицировать все Linked Services, используемые в целевом конвейере (их можно найти в настройках Datasets или Activities).
2.2.3) Для каждого Linked Service открыть его конфигурацию и использовать функцию «Test connection». 
Убедиться, что аутентификация (например, Managed Identity, Service Principal, ключи в Azure Key Vault) настроена корректно и нет сетевых ограничений (Firewall, VNet).
2.3) Проверить Integration Runtimes:
2.3.1) Перейти в раздел «Integration runtimes».
2.3.2) Проверить статус Integration Runtimes, используемых в Linked Services. Убедиться, что они находятся в состоянии «Running», особенно если используются Self-Hosted Integration Runtimes.
3) Далее, нужно идентифицировать и проанализировать Pipeline Parameters
3.1) Перейти на вкладку «Author» на левой боковой панели.
3.2) Найти и открыть целевой конвейер.
3.3) Кликнуть на пустую область холста (canvas) конвейера, чтобы отобразить его общие настройки.
3.4) Перейти на вкладку «Parameters». 
Составить список всех параметров, зафиксировав их «Name», «Type» (например, `String`, `Int`, `Array`, `Object`, `SecureString`) и «Default value» (значение по умолчанию), если оно указано.
Знание типа данных критично, особенно для сложных типов (`Array`, `Object`).
Источник: Microsoft Learn: Parameters and variables in Azure Data Factory.
3.5) Изучить, как параметры используются внутри конвейера.
3.5.1) Выбрать каждое activity на холсте (например, Copy activity, Lookup, Data Flow).
3.5.2) Проверить вкладки настроек (например, «Settings», «Source», «Sink») на предмет использования динамического содержимого (dynamic content).
3.5.3) Идентифицировать выражения (expressions), которые ссылаются на параметры конвейера, используя синтаксис `@pipeline().parameters.<parameterName>`.

4) Затем нужно определить Parameter Sources
Цель: Определить, как конвейер получает параметры в производственной среде (часто автоматически через триггеры), чтобы эмулировать эти значения при ручном тестировании.
4.1) Проанализировать связанные триггеры (Triggers).
4.1.1) Находясь в редакторе конвейера (вкладка «Author»), нажать кнопку «Trigger» на верхней панели и выбрать «New/Edit».
4.1.2) В открывшейся панели изучить конфигурацию существующих триггеров, связанных с этим конвейером.
4.2) Изучить параметры, передаваемые триггером.
4.2.1) Продвигаясь по конфигурации триггера, обратить внимание на шаг, где заполняются параметры конвейера.
4.2.2) Идентифицировать использование системных переменных (System Variables). 
Это выражения, начинающиеся с `@trigger()` или `@triggerBody()`. 
Примеры:
- `@trigger().outputs.windowStartTime` (для Tumbling Window Trigger).
- `@triggerBody().fileName` (для Storage Event Trigger).

Производственные конвейеры часто получают метаданные (например, временные метки или имена файлов) автоматически от триггеров через System Variables. 
При ручном тестировании (Debug) пользователь должен эмулировать эти значения самостоятельно. 
Незнание этой зависимости является частой причиной проблем с ручным запуском.
4.3) Определить значения для тестирования. 
Использовать комбинацию значений из исторических запусков (пункт 1.4.4 выше), значений по умолчанию (пункт 3.4) и эмулированных значений триггеров (пункт 4.2.2) для формирования набора тестовых входных данных.
5) Выполнить тестовый запуск (Test Run)
Цель: Запустить конвейер с корректными параметрами в контролируемом режиме и проверить его работоспособность.
5.1) Находясь на вкладке «Author» в редакторе целевого конвейера, начать выполнение в режиме отладки, нажав кнопку «Debug» на верхней панели инструментов.
Обоснование: 
Режим «Debug» используется для тестирования текущей версии конвейера на холсте (включая неопубликованные изменения) и позволяет наблюдать за выполнением в реальном времени без необходимости публикации (Publish). 
Он предпочтителен для итеративной разработки и тестирования.
5.2) В открывшейся панели (обычно называется «Pipeline Debug» или «Pipeline run parameters») ввести значения для параметров, определённые на пункте 4.3 выше.
5.3) Соблюдать корректный формат ввода данных:
5.3.1) При эмуляции временных меток триггера использовать формат ISO 8601 (например, `2025-08-27T10:00:00Z`).
5.3.2) Для параметров типа `Array` ввести значение в формате JSON массива. 
Например: `["item1", "item2"]`.
5.3.3. Для параметров типа Object ввести значение в формате JSON объекта. 
Например: `{"key1": "value1", "key2": "value2"}`.
Обоснование: Корректный ввод параметров, особенно сложных типов (`Array`, `Object`), необходим для успешного запуска. 
Неправильный формат JSON приведет к ошибкам валидации еще до начала выполнения.
5.4) Нажать «OK», чтобы начать выполнение.
5.5) Наблюдать за ходом выполнения на вкладке «Output» под холстом конвейера. 
Проверить входные (Input) и выходные (Output) данные для каждого Activity после его завершения, чтобы убедиться, что параметры были интерпретированы корректно.
~~~

# 2. `᛭T`
Проанализируй `Aᨀ`:
1) Есть ли там логические ошибки?
2) Есть ли там фактические ошибки?
3) Упущено ли в `Aᨀ` нечто важное?

# 3. Требования к твоему ответу
## 3.1.
Отвечай на русском языке.
## 3.2.
Мой вопрос не пересказывай.
## 3.3.
Уже сформулированную мной информацию не пересказывай.
## 3.4.
Писать свою версию `Aᨀ` не нужно: просто укажи свои замечания по пунктам.
## 3.5.
До и после списка замечаний ничего не пиши.
## 3.6.
Нумерация замечаний должна быть сквозной.
~~~~~~