# 1.
## 1.1.
`Aᨀ` ≔ (мой ответ `ꆜ`)

## 1.2.
Содержание `Aᨀ`:
~~~markdown
Задача моделирования ragged hierarchy в Alteryx One Platform решается так:
1) Подготовка данных (Основной Workflow)
Перед началом итеративной обработки необходимо консолидировать данные из всех исходных таблиц в единую структуру.
1.1) Импортировать данные.
Использовать инструмент «Input Data» для загрузки всех таблиц Excel, описывающих иерархию.
1.2) Консолидировать и нормализовать структуру.
Объединить данные из разных таблиц в единый поток данных со структурой списка смежности (Adjacency List), то есть в формате Parent-Child.
Этот этап может потребовать сложной логики для соединения таблиц, представляющих разные уровни или суб-иерархии (ragged hierarchy).
Если для связи исходных таблиц требуется логика, аналогичная SQL Conditional Outer Join (как указано в описании проекта), где условия включены в предикат `ON` (e.g., `... ON L.Key = R.Key AND [Condition]`), необходимо реализовать её на этом этапе, используя надежный метод, описанный в пункте 2.2.
Этот метод требует комбинации нескольких инструментов (e.g., «Record ID», «Join», «Filter», «Union») для точной репликации логики SQL и обеспечения корректного количества строк.
Результирующий набор данных (далее `Hierarchy_Data`) должен содержать как минимум поля идентификатора родителя (например, `ParentID`), идентификатора потомка (например, `ChildID`), а также все поля, необходимые для условной логики соединения (далее `ConditionFields`).
Единая структура Parent-Child необходима для универсальной реализации итеративной логики обхода иерархии.
1.3) Определить начальные узлы.
Определить узлы, с которых начнется обход иерархии (например, корневые узлы, где `ParentID` равен `Null`). Использовать инструмент «Filter».
1.4. Подготовить данные для итерации.
Для реализации обхода иерархии (например, для её развертывания в плоский список отношений Предок-Потомок) необходимо добавить служебные поля к начальным узлам. 
Использовать инструмент «Formula» для добавления полей:
- `AncestorID`: Идентификатор предка (изначально равен идентификатору самого узла).
- `CurrentID`: Идентификатор текущего узла (изначально равен идентификатору самого узла).
- `Level`: Уровень иерархии (изначально 0 или 1).
Этот набор данных (далее `Initial_Nodes`) инициирует процесс.
2) Реализация Conditional Join в Alteryx
Инструмент «Join» в Alteryx поддерживает только соединения на основе равенства (equi-joins).
Поэтому для репликации условной логики необходимо использовать комбинацию инструментов после «Join».
2.1) Реализация Conditional Inner Join.
Если требуется включить в результат только те записи, для которых совпали ключи и выполнено условие:
2.1.1) Использовать инструмент «Join» для соединения по ключам.
2.1.2) Подключить инструмент «Filter» к выходу «J» (Joined) инструмента «Join».
2.1.3) Сконфигурировать «Filter» для проверки дополнительных условий (`ConditionFields`).
2.1.4) Выход «T» (True) инструмента «Filter» содержит результат Conditional Inner Join.
2.2) Реализация Conditional Outer Join (например, Left Outer Join).
Если требуется реплицировать логику SQL `LEFT OUTER JOIN`, где дополнительные условия включены в предикат `ON` (e.g., `... ON L.Key = R.Key AND [Condition]`), необходимо использовать подход, который определяет сам факт успешного соединения на основе всех условий.
Этот метод отличается от применения выражения `CASE` в списке `SELECT` после стандартного `LEFT OUTER JOIN` и гарантирует корректность результата даже при отношениях N-to-M.
2.2.1) Обеспечить уникальность записей левой таблицы.
Для однозначной идентификации записей необходимо убедиться, что левый поток данных имеет уникальный идентификатор.
Если его нет, использовать инструмент «Record ID» для создания нового поля (e.g., `L_ID`).
2.2.2) Выполнить Conditional Inner Join.
Реализовать логику, описанную в пункте 2.1, используя подготовленный левый поток (шаг 2.2.1) и правый поток.
Результат (выход «T» инструмента «Filter», далее `Joined_Conditional`) содержит успешно соединенные записи, включая уникальный идентификатор (`L_ID`).
2.2.3) Идентифицировать истинно несоединенные записи (Left Unjoined).
Необходимо найти записи из левого потока, для которых не было найдено ни одного соответствия полному условию соединения.
2.2.3.1) Добавить второй инструмент «Join».
Соединить подготовленный левый поток (шаг 2.2.1, вход «L») и `Joined_Conditional` (шаг 2.2.2, вход «R»).
2.2.3.2) Сконфигурировать соединение по уникальному идентификатору (e.g., `L_ID`).
2.2.3.3) Выход «L» (Left Unjoined) этого инструмента содержит искомые несоединенные записи (далее `Unjoined_L`).
2.2.4) Финальное объединение.
Использовать инструмент «Union» для объединения `Joined_Conditional` (шаг 2.2.2) и `Unjoined_L` (шаг 2.2.3.3).
Инструмент «Union» автоматически согласует схемы данных, заполняя поля из правой таблицы значениями Null для потока `Unjoined_L` (при соответствующей конфигурации, e.g., «Auto Configure by Name»).
2.2.5) Завершение.
При необходимости использовать инструмент «Select» для удаления служебного уникального идентификатора (e.g., `L_ID`) и упорядочивания полей.
3) Создание Iterative Macro
Необходимо создать отдельный Workflow для реализации рекурсивной логики. 
В большинстве случаев для обхода иерархии в рекурсивном шаге используется логика Inner Join (нахождение существующих связей).
3.1) Установить тип Workflow.
В новом Workflow открыть панель «Workflow Configuration». 
На вкладке «Workflow» в разделе «Type» выбрать «Macro», затем «Iterative Macro».
«Iterative Macro» выполняет процесс циклически, передавая результаты одной итерации на вход следующей, что позволяет обрабатывать данные рекурсивно или до выполнения определенного условия. 
3.2) Определить входы макроса.
Добавить два инструмента «Macro Input» из категории «Interface».
3.2.1) Итерационный вход (например, `Input_I`).
Принимает данные для текущей итерации. 
Схема должна соответствовать `Initial_Nodes` (поля `AncestorID`, `CurrentID`, `Level`).
3.2.2) Фиксированный вход (например, `Input_H`).
Принимает полный набор данных иерархии (`Hierarchy_Data`).
3.3) Реализовать логику итерации и условное соединение.
Необходимо найти следующий уровень иерархии.
Для рекурсивного обхода иерархии применяется логика Conditional Inner Join (см. пункт 2.1).
Цель итеративного процесса — обнаружение существующих связей (потомков), удовлетворяющих заданным условиям, для продолжения обхода по этим ветвям.
Логика Conditional Outer Join (упомянутая в описании проблемы) применяется при необходимости сохранения записей, для которых условие не выполнено (например, на этапе консолидации данных в пункте 1.2), но не подходит для механизма рекурсивного обхода внутри «Iterative Macro».
Использование Outer Join приведет к невозможности завершения макроса, так как поток данных, передаваемый на итерационный выход (`Output_I`), никогда не станет пустым (стандартное условие остановки не будет достигнуто).
3.3.1) Добавить инструмент «Join». Соединить `Input_I` (вход «L») и `Input_H` (вход «R»).
3.3.2) Сконфигурировать соединение: `L.CurrentID` = `R.ParentID`.
3.3.3) Добавить инструмент «Filter», подключенный к выходу «J».
3.3.4) Сконфигурировать «Filter» на основе `ConditionFields` из `Input_H` (и, возможно, данных из `Input_I`).
3.4) Подготовить данные для следующей итерации.
Выход «T» инструмента «Filter» содержит успешные соединения. Необходимо обновить данные для следующего шага.
3.4.1) Добавить инструмент «Formula», подключенный к выходу «T».
3.4.2) Обновить поля:
- `AncestorID`: оставить значение из `Input_I` (переносится через итерации).
- `CurrentID`: установить значение `ChildID` из `Input_H` (новый текущий узел).
- `Level`: увеличить значение на 1 (использовать формулу `[Level] + 1`).
Системную переменную `[Engine.IterationNumber]` (которая начинается с 0) также можно использовать для расчета уровня.
Однако это требует учета начального уровня, заданного в пункте 1.4 (e.g., формула `[Начальный_Уровень] + [Engine.IterationNumber] + 1`).
Явная передача и инкрементация поля `Level` обеспечивает большую гибкость, если разные ветви иерархии начинаются с разных уровней.
3.4.3) Использовать инструмент «Select» для обеспечения точного соответствия схемы данных (имена полей, типы, порядок) схеме `Input_I`.
3.5) Определить выходы макроса.
Добавить два инструмента «Macro Output».
3.5.1) Выход результата (например, `Output_R`).
Подключить выход инструмента «Select» (шаг 3.4.3). 
Этот выход накапливает все найденные связи Предок-Потомок на всех итерациях.
3.5.2) Итерационный выход (например, `Output_I`).
Также подключить выход инструмента «Select» (шаг 3.4.3). 
Эти данные передаются обратно на `Input_I`. 
Макрос остановится, когда этот выход будет пуст.
4) Конфигурация параметров макроса
4.1) Открыть Interface Designer.
Перейти в меню «View» → «Interface Designer».
4.2) Настроить свойства итерации.
Перейти в раздел «Properties» (иконка гаечного ключа или шестеренки).
4.2.1) В поле «Iteration Input» выбрать `Input_I`.
4.2.2) В поле «Iteration Output» выбрать `Output_I`.
4.2.3) В поле «Maximum Number of Iterations» установить достаточно большое значение (например, 100) для предотвращения бесконечных циклов из-за циклических ссылок в данных.
Обоснование: Эти настройки определяют, как Alteryx Engine управляет потоком данных между итерациями.
4.3) Сохранить макрос (например, как файл `ProcessHierarchy.yxmc`).
5) Выполнение (Основной Workflow)
5.1) Вставить макрос.
В основном Workflow кликнуть правой кнопкой мыши на холсте → «Insert» → «Macro...» и выбрать файл `ProcessHierarchy.yxmc`.
5.2) Подключить данные.
5.2.1) Соединить `Hierarchy_Data` (шаг 1.2) с входом `Input_H` макроса.
5.2.2) Соединить `Initial_Nodes` (шаг 1.4) с входом `Input_I` макроса.
5.3) Обработать результаты.
Выход `Output_R` макроса содержит развернутую иерархию (все связи Предок-Потомок, начиная с уровня 1).
Описанная логика «Iterative Macro» не включает сами начальные узлы (уровень 0) в этот выходной поток.
Для получения полного набора данных иерархии необходимо использовать инструмент «Union», чтобы объединить начальные узлы (`Initial_Nodes`) с результатом работы макроса (`Output_R`).
~~~

# 2. `᛭T`
Проанализируй `Aᨀ`:
1) Есть ли там логические ошибки?
2) Есть ли там фактические ошибки?

# 3. Требования к твоему ответу
## 3.1.
Отвечай на русском языке.
## 3.2.
Мой вопрос не пересказывай.
## 3.3.
Уже сформулированную мной информацию не пересказывай.
## 3.4.
Писать свою версию `Aᨀ` не нужно: просто укажи свои замечания по пунктам.
## 3.5.
До и после списка замечаний ничего не пиши.
## 3.6.
Нумерация замечаний должна быть сквозной.

# 4. Источники информации
## 4.1.
Используй авторитетные источники информации на английском языке, относящиеся к предметной области `P⁎` и `P†`.

## 4.2.
В первую очередь используй официальные источники: https://alteryx.com