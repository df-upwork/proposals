`T1⁎` описывает проблему дублирования данных в Firestore: гость оставляет RSVP, а затем регистрируется через Google Auth с тем же адресом электронной почты, что приводит к созданию дублирующей записи. Необходимо разработать архитектуру для чистого слияния гостевых и аутентифицированных пользовательских данных.

Контекст задачи: стабилизация MVP с "загрязненным" кодом в течение 2-4 недель для приложения (Hæfen), ориентированного на конфиденциальность (privacy-focused).

# 1. `S⠿` (Способы решения `T1⁎`)

Я идентифицировал пять основных архитектурных подходов (`Sᵢ`) к решению этой проблемы.

## 1.1. `S₁`: Слияние на стороне клиента (Client-Side Merging)
Клиентское приложение (React) после регистрации пользователя самостоятельно ищет гостевые данные по email, перезаписывает их в профиль аутентифицированного пользователя (UID) и удаляет гостевую запись.

## 1.2. `S₂`: Слияние на бэкенде через триггер аутентификации (Auth Trigger Cloud Function)
Облачная функция Firebase автоматически срабатывает при создании нового пользователя (`functions.auth.user().onCreate()`). Функция, используя Admin SDK (с повышенными привилегиями), выполняет поиск и слияние данных на сервере.

## 1.3. `S₃`: Слияние на бэкенде через вызываемую функцию (Callable Cloud Function)
Клиентское приложение явным образом вызывает специальную облачную функцию сразу после завершения регистрации. Функция проверяет токен пользователя и выполняет слияние на сервере с помощью Admin SDK, возвращая результат клиенту.

## 1.4. `S₄`: Анонимная аутентификация и связывание (Anonymous Auth & Account Linking)
Архитектура изменяется: при гостевом RSVP пользователь немедленно аутентифицируется анонимно (Anonymous Auth). Данные привязываются к этому анонимному UID. При регистрации через Google Auth используется метод Firebase `linkWithCredential` для преобразования анонимной учетной записи в постоянную. UID сохраняется, миграция данных не требуется.

## 1.5. `S₅`: Использование Email в качестве ID документа (Email as Primary Key)
Структура базы данных изменяется так, что идентификатором документа пользователя служит email, а не Firebase UID. Слияние происходит автоматически через операцию обновления (upsert).

# 2. Анализ `S⠿`

## 2.1. Анализ `S₁` (Слияние на стороне клиента)

*   **Недостатки**:
    1.  **Критические риски безопасности**: Чтобы клиент мог найти и изменить гостевые данные, требуются ослабленные правила безопасности Firestore (Security Rules), позволяющие запрашивать данные по email, не привязанные к UID пользователя. Это недопустимо для "privacy-focused" приложения, так как позволяет злоумышленникам потенциально извлекать чужие данные RSVP.
    2.  **Ненадежность и атомарность**: Процесс (чтение, запись, удаление) не является атомарным на клиенте. Сбой сети или закрытие приложения во время процесса приведет к несогласованности данных (потере или частичному дублированию).
*   **Достоинства**:
    1.  **Отсутствие бэкенд-кода**: Не требует разработки Cloud Functions.

## 2.2. Анализ `S₂` (Триггер аутентификации)

*   **Недостатки**:
    1.  **Асинхронность и UX**: Слияние происходит в фоновом режиме после создания пользователя. Существует задержка, во время которой пользователь может войти в систему и увидеть свой профиль до того, как данные RSVP будут перенесены. Это ухудшает пользовательский опыт.
    2.  **Сложность отладки и обратной связи**: Сложнее информировать пользователя о статусе или ошибках слияния в реальном времени.
*   **Достоинства**:
    1.  **Безопасность**: Логика выполняется на сервере с использованием Admin SDK, что позволяет сохранять строгие правила безопасности для клиентов.
    2.  **Надежность**: Процесс гарантированно запускается при регистрации (с гарантией доставки at-least-once) и не зависит от стабильности клиентского соединения.
    3.  **Минимальные изменения клиента**: Не требует изменения потока аутентификации на клиенте.

## 2.3. Анализ `S₃` (Вызываемая функция)

*   **Недостатки**:
    1.  **Зависимость от клиента**: Требует явного вызова функции и обработки потенциальных сбоев вызова на клиенте (например, реализация логики повторных попыток).
*   **Достоинства**:
    1.  **Безопасность**: Как и S₂, выполняется на сервере с Admin SDK.
    2.  **Контроль и UX**: Позволяет клиентскому приложению дождаться завершения слияния (показывая индикатор загрузки), прежде чем отображать профиль пользователя. Это обеспечивает "чистое" слияние и отличный UX.
    3.  **Атомарность**: Позволяет использовать транзакции Firestore на сервере для обеспечения целостности данных.

## 2.4. Анализ `S₄` (Анонимная аутентификация и связывание)

*   **Недостатки**:
    1.  **Требует значительного рефакторинга**: Внедрение Anonymous Auth для всех гостей — это изменение архитектуры, а не просто исправление бага. Учитывая, что код MVP "загрязнен", это рискованно для короткого спринта стабилизации.
    2.  **Хрупкость сессии**: Если пользователь очистит кэш браузера или сменит устройство до регистрации, анонимная сессия теряется, и данные становятся "осиротевшими".
    3.  **Обработка конфликтов**: Требует сложной логики для обработки ошибок `auth/credential-already-in-use`.
*   **Достоинства**:
    1.  **Архитектурная чистота**: Это рекомендуемый Firebase подход ("The Firebase Way").
    2.  **Отсутствие миграции данных**: UID пользователя остается неизменным.

## 2.5. Анализ `S₅` (Email как ID)

*   **Недостатки**:
    1.  **Анти-паттерн**: Нарушает лучшие практики Firebase. Архитектура Firebase построена вокруг иммутабельных UID; email может меняться.
    2.  **Сложность поддержки**: Создает проблемы при необходимости смены email пользователем и усложняет написание Security Rules.
    3.  **Раскрытие PII**: Использование персональных данных в путях документов не рекомендуется.
*   **Достоинства**:
    1.  **Концептуальная простота**: Устраняет дублирование по определению.

# 3. Оценка `Sᵢ`

| Si | Название | Оценка (0-100) | Обоснование |
| :--- | :--- | :--- | :--- |
| **S₁** | Слияние на стороне клиента | **20** | Функционально работает, но критически небезопасно и ненадежно. Неприемлемо для privacy-focused app. |
| **S₂** | Триггер аутентификации | **80** | Безопасное и надежное решение, но UX страдает из-за асинхронности: пользователь может увидеть неполные данные при первом входе. |
| **S₃** | **Вызываемая функция** | **95** | Обеспечивает наилучший баланс между безопасностью, надежностью, качеством UX и скоростью внедрения для текущей задачи стабилизации. |
| **S₄** | Анонимная аутентификация | **75** | Идеальное решение для нового проекта, но слишком рискованное (рефакторинг, хрупкость сессии) для стабилизации существующего MVP. |
| **S₅** | Email как ID | **10** | Нарушает фундаментальные принципы архитектуры Firebase и создает долгосрочные проблемы. |

# 4. Вердикт

Задача (`᛭T`) состоит в стабилизации MVP в сжатые сроки. Приоритетами являются безопасность (из-за "privacy-focused" позиционирования) и надежность исправления при минимальном вмешательстве в существующий "загрязненный" код.

Наиболее предпочтительным решением является **`S₃` (Слияние на бэкенде через вызываемую функцию)**.

Обоснование:
1.  **Безопасность и Надежность**: Вся логика слияния выполняется в доверенной среде (Cloud Functions) с использованием Admin SDK. Это позволяет использовать транзакции Firestore для обеспечения атомарности и сохранять строгие правила безопасности для клиента (в отличие от `S₁` и `S₅`).
2.  **Пользовательский опыт (UX)**: В отличие от `S₂` (Триггеры), `S₃` позволяет клиенту контролировать процесс и дождаться завершения слияния. Это гарантирует, что пользователь увидит свои данные сразу после регистрации, избегая путаницы.
3.  **Низкие риски рефакторинга**: В отличие от `S₄`, `S₃` не требует изменения существующей логики гостевого RSVP. Он работает путем очистки данных постфактум, что идеально подходит для спринта стабилизации.