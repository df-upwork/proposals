## 1. Клиент хочет выполнить следующий проект
### 1.1.
Клиент хочет выполнить следующий проект:
#### 1.1.1. Title
B2C Theme Customization for Netsuite and Adobe Commerce Integration
#### 1.1.2. Description
We are looking for an experienced developer to customize a theme for our B2C furniture business and integrate separately while using our existing B2B company and website's inventory from Netsuite. The theme should be user-friendly, easily editable, and integrate seamlessly with Netsuite and Adobe Commerce. The ideal candidate has a strong eCommerce background and a keen eye for design. If you can enhance our online presence, we want to hear from you!
Proposal Summary:
This proposal outlines the integration of Adobe Commerce with NetSuite to create a B2C website for Corp Design, referred to as "the client." The goal is to establish a new drop-shipping entity using Adobe Commerce, integrated with NetSuite, to manage product resales and order fulfillment. The implementer, serving as the Oracle NetSuite partner, will oversee the integration and theme design.
Prerequisites:
This theme or a theme provided by dev
https://clauem2.arrowtheme.com/at/
Upgrade the server to Cloudways to host the new website.
Activate essential NetSuite features: Custom Segments, Promotion Codes, Suite Promotions, and Auto-Apply Promotions.
Deliverables:
Website Theme and Configuration: The client will provide a theme that will be purchased and configured or replicated (https://clauem2.arrowtheme.com/at/) with all necessary sections and dynamic features. Additional customizations will be handled by the implementer. The website will support USD currency and be available in English and Spanish.
Header and Footer: Consistent across all pages, including logos, primary categories, and links like About Us, Help, Contact Us, Terms and Conditions, and social media links.
Homepage: Features a banner slider, top categories, trending products, hot product showcases, and a blog section.
Product List and Detail Pages: These will display product images, prices, SKUs, and quick add-to-cart options. The detail page will provide multiple product images, features, attributes, recommended products, and additional information like dimensions and care instructions.
Cart and Checkout: Includes product summary, quantity management, subtotal, shipping charges, tax, and total amount. The checkout page will integrate shipping and payment options, including Cybersource for credit, debit cards, and Apple Pay.
Thank You Page: Displays order completion messages and encourages further shopping.
My Account Pages: Customers can manage their profiles, view order histories, invoices, and RMAs. Each section provides comprehensive details and options for updating information.
Login/Register and Contact Us Pages: Facilitate user authentication and direct communication with the Sleek furniture team.
About Us, Return Policy, Help, and Terms and Conditions Pages: Static content managed through the Magento backend, providing essential company and policy information.
NetSuite – Adobe Commerce Integration:
Custom Segment Setup: A "Sales Channel" field will be used to categorize items, transactions, and customer records between Sleek and Corp, ensuring clear separation of data and operations.
Customer Sync: Real-time synchronization of customer data, including new registrations, updates, and deletions, between the website and NetSuite. Sleek customers will be classified as "Individual" in NetSuite, with a checkbox to identify guest customers.
Item Sync: Ensures real-time product data synchronization from NetSuite to Adobe Commerce, categorizing items for Sleek and Corp, and handling product updates and deletions.
Sales Order Sync: Two-way real-time synchronization of sales orders between NetSuite and the website, including status updates, payment mapping, and guest user handling.
Promotions and Tax: NetSuite-managed promotions and tax configurations will be automatically applied to sales orders on the website, with real-time syncing to ensure consistency.
Item Fulfillment and Shipping Method Sync: Fulfillment processes and shipping methods will be managed in NetSuite, with updates reflected in Adobe Commerce.
Cash Sale and RMA Sync: One-way synchronization of cash sales and RMAs from NetSuite to Adobe Commerce, ensuring seamless order and return management.
Error Handling:
A custom record will store synchronization failures, with retries scheduled every 15 minutes. Persistent issues will trigger email notifications to the administrator.
Assumptions and Scope Limitations:
The website will operate in USD and support English and Spanish languages.
Customer data access and some advanced NetSuite features (e.g., deposits, cheques) will not be used in this integration.
Risks:
Shared NetSuite account constraints may limit certain customizations, like logo display, and role-based data visibility.
Future changes in NetSuite's concurrency limits could affect real-time syncing scripts.
Post Go-Live Support:
The implementer will provide free bug fixes and issue resolution for the first few months post-launch, with additional services available as required.

#### 1.1.3. The client's questions
1.1.3.1) Provide link to GitHub profile and/or website if applicable
1.1.3.2) Describe your recent experience with similar projects such as Netsuite Development and Adobe Commerce/Magento
1.1.3.3) What frameworks have you worked with?
1.1.3.4) Describe your approach to testing and improving QA
1.1.3.5) Please list any certifications related to this project

#### 1.1.4. Tags
JavaScript
Shopify
HTML
Web Development
CSS
Magento
NetSuite Administration
Ecommerce Website Development
NetSuite Development
adobe commerce

## 2. В чём вообще заключается бизнес клиента сейчас?
### 2.1.
Я начал составлять свой ответ клиенту так:
```
1) Для вашего случая лучший способ интеграции NetSuite и Adobe Commerce — это использование офицального REST API от NetSuite («SuiteTalk REST Web Services Platform»): https://docs.oracle.com/en/cloud/saas/netsuite/ns-online-help/chapter_1540391670.html
1.1) Именно этот способ (в отличие от готовых модулей для Adobe Commerce или NetSuite и готовых интеграционных платформ) позволит правильно реализовать все перечисленные вами в описании проекта требования.
1.2) Ниже в пунктах 2-10 я анализирую каждое требование из вашего описания проекта и детально описываю, как конкретно это требование реализуется посредством «SuiteTalk REST Web Services Platform».
2) Общая архитектура интеграции NetSuite и Adobe Commerce:
2.1) Я разработаю модуль для Adobe Commerce.
2.2) Этот модуль будет взаимодействовать с NetSuite посредством способа пункта 1.
3) В целом для реализации архитектуры пункта 2 надо настроить в NetSuite аутентификацию моего модуля для Adobe Commerce 
3.1) Получение ключей «Consumer Key» и «Consumer Secret»
«Consumer Key» и «Consumer Secret» — это идентификаторы внешнего приложения (в данном случае — моего модуля для Adobe Commerce) в NetSuite.
3.1.1) В NetSuite нужно создать «Integration Record» (Setup → Integration → Manage Integrations → New).
3.1.2) В «Integration Record» настраивается разрешённый способ аутентификации: в вашем случае лучше всего использовать «TBA»: Token Based Authentication.
3.1.3) После создания «Integration Record» вы получите ключи: «Consumer Key» и «Consumer Secret» в случае «TBA».
3.2) Получение ключей «Token ID» и «Token Secret»
«Token ID» и «Token Secret» —  это ключи конкретной учётной записи NetSuite, которую мой модуль будет использовать для взаимодействия с NetSuite.
Эти ключи привязаны к «Integration Record» пункта 3.1.1 выше.
3.2.1) В NetSuite надо настроить «Role», которая будет иметь полномочия для выполнения всех указанных вами в описании проекта требований (например, для «Customer Sync» нужно предоставить этой роли полномочия на чтение/запись Customer Records через REST API).
3.2.2) В NetSuite надо настроить учётную запись («User»), которую будет использовать мой модуль для Adobe Commerce.  
3.2.3) Для учётной записи пункта 3.2.2 надо будет настроить «Access Token» («User» → «Access Tokens» → «New»), где надо будет указать настроенную выше «Integration Record» (пункт 3.1.1).
В результате NetSuite создаст «Token ID» и «Token Secret».
3.3) Все 4 ключа («Consumer Key», «Consumer Secret», «Token ID», «Token Secret») будут предоставлены модулю для Adobe Commerce, который я разработаю (пункт 2.1 выше): конретно указаны в интерфейсе этого модуля в административной части Adobe Commerce.
3.4) Также надо будет указать в настройках моего модуля для Adobe Commerce «Account ID» вашей компании в NetSuite: его можно увидеть в разделе «Setup» → «Company» → «Company Information» интерфейса NetSuite.
Этот идентификатор используется в запросах по REST API к серверам NetSuite, чтобы NetSuite знал, что запросы относятся к вашей компании, а не к другой, например: `https://<ACCOUNT_ID>.suitetalk.api.netsuite.com/services/rest/record/v1/<...>`.
4) «Customer Sync: Real-time synchronization of customer data, including new registrations, updates, and deletions, between the website and NetSuite»
При моём способе пункта 1 это реализуется так:
4.1) Новые регистрации customers в Adobe Commerce
4.1.1) В Adobe Commerce существует событие `customer_register_success`, которое срабатывает при успешной регистрации нового customer. 
4.1.2) Можно написать «Observer» (или «Plugin»), который слушает это событиеи вызывает кастомный код.
4.1.3) При срабатывании события, мой модуль будет формировать JSON с данными customer и далее по протоколу HTTPS выполнять запрос типа `POST` к соответствующему эндпоинту SuiteTalk REST API (`/services/rest/record/v1/customer`), передавая нужные поля в body.
4.1.4) NetSuite будет возвращает `internalId` созданной записи .  
4.1.5) Мой модуль будет сохранять этот `internalId` в Adobe Commerce, например, в кастомном поле customer’а или в связующей таблице, чтобы позднее при обновлениях понимать, к какой записи в NetSuite обращаться.
4.2) Обновление данных customer из Adobe Commerce в NetSuite
Аналогично пунктам 4.1.1-4.1.2, в Adobe Commerce можно слушать соответствующее событие и далее по протоколу HTTPS выполнять запрос типа `PATCH` или `PUT` (зависит от версии REST API NetSuite), передавая обновлённые данные и `internalId` customer'а в NetSuite.
4.3) Обновление данных customer из NetSuite в Adobe Commerce
Если предполагается, что в NetSuite тоже могут менять данные о клиенте (например, менеджер вносит правки), то нужно настроить обратные вызовы.
В NetSuite может быть «SuiteScript» («User Event Script» или «Scheduled Script»), который при обновлении customer вызывет endpoint моего модуля для Adobe Commerce.
5) «Item Sync: Ensures real-time product data synchronization from NetSuite to Adobe Commerce, categorizing items for Sleek and Corp, and handling product updates and deletions»
При моём способе пункта 1 с учётом вашего требования «real-time synchronization» синхронизацию товаров лучше всего реализовать push-стратегией NetSuite → Adobe Commerce:
При создании/редактировании/удалении Item-записи в NetSuite автоматически вызывается скрипт («SuiteScript»), который будет передавать данные моему модулю в Adobe Commerce по REST API.
Есть 2 способа реализации такого «SuiteScript»:
5.1) «User Event Script» («After Submit»)
Запускается сразу после сохранения записи Item в NetSuite.  
Этот способ хорош для единичных обновлений.  
Код на SuiteScript (JavaScript) будет формировать JSON с данными товара и передавать данные моему модулю в Adobe Commerce по REST API для создания/обновления/деактивации товара в Adobe Commerce.
5.2) «Map/Reduce» или «Scheduled Script»
Запускается по расписанию через регулярные интервалы времени.  
Этот способ хорош, если товары меняются очень часто, и вы не хотите нагружать NetSuite вызовами «на каждый Item» в реальном времени (способ 5.1).  
При этом способе скрипт ищет (через «Saved Search») все Items, у которых `lastModifiedDate` больше, чем при прошлом запуске, и синхронизирует их с Adobe Commerce.
5.3) При действительно «огромном» потоке изменений иногда делают гибридный вариант — «User Event Script» ставит запись в очередь (custom record или внешнюю шину сообщений), а отдельный «Map/Reduce» её обрабатывает. 
Но в небольших/средних проектах хватает 5.1 или короткого интервала «Scheduled Script» (5.2).
6) «Sales Order Sync: Two-way real-time synchronization of sales orders between NetSuite and the website, including status updates, payment mapping, and guest user handling»
При моём способе пункта 1 это реализуется так:
6.1) Сценарий «Adobe Commerce → NetSuite» реализуется так:
6.1.1) Покупатель размещает заказ в Adobe Commerce.  
6.1.2) Мой модуль для Adobe Commerce обрабатывает событие сохранения заказа (`sales_order_place_after`, аналогично пунктам 4.1.1-4.1.2) и вызывает NetSuite по REST API  (аналогично пункту 4.1.3), создавая в NetSuite «Sales Order»
6.1.3) NetSuite (аналогично пункту 4.1.4) возвращает `internalId` (Sales Order ID) в ответ.  
6.1.4) Мой модуль сохраняет этот ID в Adobe Commerce, чтобы далее обновления выполнялись по тому же ID.
6.2) Сценарий «NetSuite → Adobe Commerce» реализуется так:   
6.2.1) Менеджер в NetSuite обновляет Sales Order (меняет статус, указывает оплату, формирует частичную отгрузку, и т. д.).  
6.2.2) «User Event Script» (аналогично пункту 5.1) или «Scheduled Script» (аналогично пункту 5.2) в NetSuite отслеживает эти изменения и передаёт их моему модулю в Adobe Commerce через REST-эндпоинт моего модуля.
6.2.3) Мой модуль:
- обновляет статус заказа,  
- добавляет трекинг-номер отгрузки,  
- указывает, что заказ «завершён» (Complete) или «отменён» (Canceled) и т. д.  
7) «Promotions and Tax: NetSuite-managed promotions and tax configurations will be automatically applied to sales orders on the website, with real-time syncing to ensure consistency»
При моём способе пункта 1 это реализуется так:
7/1
7.1) В NetSuite будет настроен «User Event Script» или «Scheduled Script» на «Promotion» («Record Type»: `promotionCode`), «SuitePromotions» и налоговые правила.  
7.2) При создании/изменении/удалении промо-кода NetSuite будет отправлять запрос к моему модулю по REST API модуля.
7.3) Мой модуль будет обрабатывать запросы пункта 7.2 и обновлять в Adobe Commerce налоговые и скидочные правила.
7.4) Таким образом, корзина покупателя в Adobe Commerce будет правильно отражать налоговые и скидочные правила из NetSuite.
8) «Item Fulfillment and Shipping Method Sync: Fulfillment processes and shipping methods will be managed in NetSuite, with updates reflected in Adobe Commerce»
8.1) Сценарий «Item Fulfillment Sync» (NetSuite → Adobe Commerce)
8.1.1) Создание/обновление Fulfillment в NetSuite
Менеджер в NetSuite будет на основе Sales Order создавать «Item Fulfillment» («Record Type»: `itemFulfillment`).
8.1.2) Синхронизация с Adobe Commerce будет выполняться аналогично пунктам 5.1 и 5.2.
8.2) Сценарий «Shipping Method Sync» (NetSuite → Adobe Commerce)
8.2.1) В NetSuite существуют «Shipping Items» («Record Type»: `shipItem`).
8.2.2) При добавлении/изменении/удалении «Shipping Items» в NetSuite эти изменения будут синхронизироваться с Adobe Commerce аналогично пунктам 5.1 и 5.2.
9) «Cash Sale and RMA Sync: One-way synchronization of cash sales and RMAs from NetSuite to Adobe Commerce, ensuring seamless order and return management»
9.1) Cash Sale
9.1.1) Cash Sale — это сделка в NetSuite, при которой оплата происходит сразу, без отдельной процедуры выставления и закрытия Invoice. 
9.1.2) Как только в NetSuite появляется или обновляется запись типа `cashSale` — эти изменения будут синхронизироваться с Adobe Commerce аналогично пунктам 5.1 и 5.2.
9.2) RMA (Return Authorization) 
9.2.1) RMA — это документ, фиксирующий возврат товаров от клиента. 
В дальнейшем в NetSuite могут создаваться «Item Receipt» (принятие товара на склад) и «Credit Memo» (денежный возврат).  
9.2.2) Аналогично 9.1.2: как только в NetSuite появляется или обновляется запись типа `returnAuthorization` — эти изменения будут синхронизироваться с Adobe Commerce аналогично пунктам 5.1 и 5.2.
10) «A custom record will store synchronization failures, with retries scheduled every 15 minutes. Persistent issues will trigger email notifications to the administrator.» 
При моём способе пункта 1 это реализуется так:
10.1) При каждом «событии» (например, создании/редактировании Sales Order, Item, Fulfillment и т. д.), «User Event Script» (пример был описан выше в пункте 5.1) или Scheduled Script (пример был описан выше в пункте 5.2) будет пытаться передавать данные моему модулю в Adobe Commerce по протоколу REST. 
10.2) Если мой модуль (или система более высокого уровня: Adobe Commerce или серверное программное обеспечение) не был в состоянии обработать запрос от NetSuite, то NetSuite будет записывать отчёт о сбое в специальном месте (таблице базы данных) и повторять попытку позже.
10.2.1) Таблица в NetSuite будет иметь следующие поля:
- «Record Type» (какой объект мы пытались синхронизировать: Order, Item, Customer)  
- «Record ID» (какой конкретно идентификатор в NetSuite)  
- «Action» (Create, Update, Delete в Magento)  
- «Error Message» (текст ошибки, код, тело ответа Magento)  
- «Number of Retries» (сколько раз мы уже пытались)  
- «Last Attempt Date» (дата/время последней попытки)  
- «Next Attempt Date» (когда мы планируем снова попробовать)  
- «Status» (Pending, In Progress, Failed, Resolved и т. д.)
10.3) По расписанию (каждые 15 минут) в NetSuite будет запускается «Scheduled Script» или «Map/Reduce Script», который на основе таблицы пункта 10.2.1 будет повторять запросы к Adobe Commerce.
11) Для розничного мебельного бизнеса в США использование указанной вами готовой оформительской темы Claue от Arrow Theme — не самое лучшее и сильно устаревшее решение в 2025 году.
```

## 2.2.
Как ты видишь, текущие пункты 1-10 моего ответа касаются интеграции NetSuite и Adobe Commerce.
Начиная с пункта 11 я начинаю освещать уже другие вопросы, не касающиеся интеграции NetSuite и Adobe Commerce.
Поэтому измени нумерацию в моём ответе следующим образом:
2.2.1) Создай новый пункт 1: «Интеграции NetSuite и Adobe Commerce.
2.2.2) Текущие пункты 1-10 сделай подпунктами нового пункта 1.
Например, текущий пункт 4.1.4 должен стать пунктом 1.4.1.4.
При этом обрати внимание, что в тексте ответа я часто ссылаюсь на тот или иной пункт.
При изменении нумерации все эти ссылки надо обновить.
2.2.3) Кроме изменения нумерации больше ничего в моем тексте не меняй.
2.2.4) Результатом должен стать артефакт.
