Ниже приведён пример более детализированного подхода к тому, как именно «считывать содержимое файла (CSV, XML и т. д.), распарсить данные и сопоставить каждую запись с нужным заказом (Sales Order) в NetSuite». Для наглядности рассмотрим сценарий с CSV-файлом. Принципы будут схожи и для XML/JSON, но там потребуются другие парсеры.

---

## Общая структура кода

Предположим, у нас есть Scheduled (или Map/Reduce) SuiteScript 2.x с названием `Import3PLConfirmations.js`. В нём:

1. **Загружаем файл**, лежащий либо в File Cabinet (уже скачанный с SFTP), либо сразу получаем его в ходе скрипта (через `N/sftp`).  
2. **Извлекаем содержимое** (метод `fileObj.getContents()`), которое представляет собой текст.  
3. **Парсим** этот текст в зависимости от формата (CSV, XML, JSON).  
4. **Для каждой записи** (строки в CSV, элемент в XML и т. д.):  
   - Определяем номер заказа (Sales Order Number) или другой идентификатор, по которому «сопоставим» запись с конкретным заказом в NetSuite.  
   - **Ищем нужный заказ** через Saved Search или загрузку записи (чаще всего — поиск по `tranid`, `externalid`, или пользовательскому полю).  
   - **Обновляем** нужные поля в заказе (например, подтверждение отправки, трекинг-номер, статус).  
5. Сохраняем изменения и логируем результат.

---

## Пример кода (CSV) — упрощённый вариант для SuiteScript 2.x

Ниже код-«скелет», который можно адаптировать под ваш реальный проект. Предполагаем, что файл CSV уже лежит в NetSuite File Cabinet по известному `fileId`, либо вы его только что скачали с SFTP и сохранили через `file.create()`.

```js
/**
 * @NApiVersion 2.x
 * @NScriptType ScheduledScript
 */
define([
    'N/file',
    'N/search',
    'N/record',
    'N/log'
], function(file, search, record, log) {

    function execute(context) {
        try {
            // 1. Получаем файл из File Cabinet по ID (или ID можно передать в параметры Script Deployment).
            var fileId = 12345; // <-- подставьте реальный ID
            var fileObj = file.load({ id: fileId });
            
            // 2. Считываем содержимое
            var fileContent = fileObj.getContents();
            if (!fileContent) {
                log.error('File Error', 'Файл пустой или недоступен');
                return;
            }
            
            // 3. Разбиваем содержимое на строки (по переносам)
            var lines = fileContent.split(/\r?\n/); // учтём и \r\n, и \n
            // Предположим, первая строка — заголовки (header).
            // Поэтому начнём разбор с i=1.

            for (var i = 1; i < lines.length; i++) {
                var line = lines[i].trim();
                if (!line) {
                    continue; // пропускаем пустые строки
                }

                // 4. Разбиваем строку по запятым (или учитываем другой разделитель)
                var columns = line.split(',');

                // Предположим, что CSV содержит:
                // [0] - SalesOrderNumber
                // [1] - ShippingStatus
                // [2] - TrackingNumber
                // [3] - Дата подтверждения
                // и т.д. — подставьте нужные поля
                var soNumber       = columns[0];
                var shippingStatus = columns[1];
                var trackingNumber = columns[2];

                // 5. Ищем нужный Sales Order в NetSuite
                // Обычно ищут по 'tranid' (это внутреннее поле NetSuite, в интерфейсе видимое как "Document Number" или "Transaction Number").
                // Но иногда нужно искать по Custom Field или по External ID — зависит от того, как настроен процесс.
                
                var soInternalId = findSalesOrderByTranId(soNumber);
                if (!soInternalId) {
                    log.error('Not Found', 'Sales Order с номером ' + soNumber + ' не найден');
                    continue;
                }

                // 6. Загружаем запись Sales Order и обновляем нужные поля
                var soRecord = record.load({
                    type: record.Type.SALES_ORDER,
                    id: soInternalId
                });

                // Например, запишем значения в пользовательские поля:
                //   custbody_shipping_status
                //   custbody_tracking_number
                soRecord.setValue({
                    fieldId: 'custbody_shipping_status',
                    value: shippingStatus
                });
                soRecord.setValue({
                    fieldId: 'custbody_tracking_number',
                    value: trackingNumber
                });

                // При необходимости можно также менять статус заказа (но аккуратно — не всегда это делается прямым setValue).
                // Если нужно создать Item Fulfillment, то создаём новый Fulfillment, ссылающийся на этот Sales Order.
                
                soRecord.save();
            }

        } catch (e) {
            log.error('Execution Error', e.toString());
        }
    }

    /**
     * Поиск Sales Order по номеру (tranid).
     * Возвращает Internal ID или null.
     */
    function findSalesOrderByTranId(tranId) {
        if (!tranId) return null;

        var soSearch = search.create({
            type: search.Type.SALES_ORDER,
            filters: [
                ['mainline', 'is', 'T'],
                'AND',
                ['tranid', 'is', tranId]
            ],
            columns: ['internalid']
        });

        var resultSet = soSearch.run().getRange({
            start: 0,
            end: 1
        });

        if (resultSet && resultSet.length > 0) {
            return resultSet[0].getValue({ name: 'internalid' });
        }
        return null;
    }

    return {
        execute: execute
    };
});
```

### Ключевые моменты в примере:

1. **Разделитель**: в примере используется `split(',')`, но в реальных CSV-файлах часто встречаются ситуации с кавычками, экранированием запятых и т. д. Для более сложных случаев можно использовать готовые библиотеки парсинга CSV или написать собственную логику.  
2. **Поиск Sales Order**:  
   - В примере сделан поиск по полю `tranid`. Оно отображается в интерфейсе NetSuite как «Document Number». Убедитесь, что CSV-файл содержит именно то же значение, что и в поле `tranid`.  
   - Если у вас в файле хранится другой идентификатор (например, `externalId`), придётся менять логику поиска, например:  
     ```js
     filters: [
       ['externalidstring', 'is', externalIdValue]
     ]
     ```  
   - Если ваш Sales Order имеет пользовательское поле (например, `custbody_3pl_orderid`), по которому нужно искать, то можно сделать:  
     ```js
     filters: [
       ['custbody_3pl_orderid', 'is', orderIdFromFile]
     ]
     ```  
3. **Обновление статуса или создание Fulfillment**:  
   - Если нужно не просто обновить поля, а изменить статус (например, «Pending Fulfillment» → «Fulfilled»), то часто правильнее создавать запись типа `Item Fulfillment`. В NetSuite нельзя напрямую проставить произвольный статус Sales Order через `setValue` — это делается системой автоматически при сохранении Item Fulfillment.  
   - Если 3PL передаёт ещё и информацию о каждой позиции в заказе (SKU, количество), то может потребоваться построчная обработка для создания Line Items в Item Fulfillment.  

---

## Пример (XML)

Если 3PL присылает **XML**, логика поиска и обновления Sales Order такая же. Разница в шаге парсинга:

```js
var fileContent = fileObj.getContents();
// Допустим, fileContent — это строка с XML-структурой

// 1. Преобразуем в DOM-объект
var parser = new DOMParser(); 
var xmlDoc = parser.parseFromString(fileContent, 'text/xml');

// 2. Предположим, документ содержит элементы <order> … </order>
var orderNodes = xmlDoc.getElementsByTagName('order');
for (var i = 0; i < orderNodes.length; i++) {
    var orderNode = orderNodes[i];

    // 3. Извлекаем данные, например, <salesOrderNumber>...</salesOrderNumber>
    var soNumber = orderNode.getElementsByTagName('salesOrderNumber')[0].textContent;
    var trackingNumber = orderNode.getElementsByTagName('trackingNumber')[0].textContent;
    // и т. д.

    // 4. Поиск и обновление Sales Order — та же логика, что и в CSV-примере.
}
```

> В SuiteScript 2.x нативного `DOMParser` может не быть, поэтому зачастую применяют `N/xml` или внешние библиотеки XML (или парсят «вручную», если формат относительно простой). Но общая идея остаётся прежней: «достать нужные поля и искать заказ».

---

## Пример (JSON)

Если файл в формате **JSON**, можно сделать:

```js
var fileContent = fileObj.getContents();
var jsonData = JSON.parse(fileContent);

// Допустим, jsonData — это массив объектов [{orderNumber: 'SO1001', status: 'Shipped', ...}, ...]
for (var i = 0; i < jsonData.length; i++) {
    var orderObj = jsonData[i];
    var soNumber = orderObj.orderNumber;
    var shippingStatus = orderObj.status;

    // Поиск в NetSuite:
    var soInternalId = findSalesOrderByTranId(soNumber);
    if (!soInternalId) {
        log.error('Not Found', 'Sales Order ' + soNumber + ' не найден');
        continue;
    }

    // Загрузка и обновление заказа — аналогично CSV-примерам.
}
```

---

## Важные дополнительные замечания

1. **Код выше — упрощённый**. В реальных проектах может потребоваться Map/Reduce-скрипт, если объём данных большой (чтобы избежать превышения лимитов по памяти и времени).  
2. **Обработка ошибок**: Если в файле возникают некорректные данные или не удаётся найти соответствующий заказ, нужно либо логировать ошибку, либо добавлять в отдельный отчёт.  
3. **Идентификаторы полей**: Поля вроде `custbody_shipping_status` и `custbody_tracking_number` могут отличаться от примера. Нужно проверять актуальные Script IDs в вашей учётной записи NetSuite.  
4. **Управление статусами**: Если требуется менять статус Sales Order на «Fulfilled», обычно создаётся запись `Item Fulfillment`. Это отдельный процесс (загружаем Item Fulfillment, указываем ссылки на Sales Order и на линии заказа). Прямая установка поля `orderstatus` чаще всего не рекомендуется.  
5. **Large file**: Если файл CSV огромный, есть риск, что `split('\n')` и полный цикл прервутся лимитами исполнения. Тогда лучше использовать **Map/Reduce Script**:  
   - В стадии `getInputData` парсим файл, разбиваем на блоки (или строки), возвращаем массив/объекты.  
   - В стадии `map` или `reduce` обрабатываем каждую строку, чтобы ровно один Sales Order обновлялся в одном потоке.  
6. **Безопасность**: Учитывать, что доступ к SFTP может быть защищён ключами SSH или логином/паролем. В NetSuite есть специальный раздел «Certificates» в File Cabinet, где можно хранить ключи. В коде модуля `N/sftp` вы настраиваете аутентификацию.

---

### Итог

- **«Считать содержимое файла, распарсить данные и сопоставить с нужным заказом»** сводится к тому, что в SuiteScript 2.x мы:  
  1. Загружаем текст (CSV/XML/JSON) из `fileObj.getContents()`.  
  2. Парсим в необходимую структуру (разбиваем построчно, используем `N/xml`, или `JSON.parse` и т. д.).  
  3. По каждому элементу/строке выполняем Saved Search (или прямую загрузку) для нахождения Sales Order.  
  4. `record.load()` → `setValue()` → `save()`.  
- В более сложных сценариях (добавление Item Fulfillment, частичные отгрузки и т. п.) шаг обновления заказа расширяется созданием/редактированием соответствующих записей.  

Таким образом, главное — знать **формат входящих данных**, иметь **уникальный идентификатор** для поиска заказа (чаще всего `tranid`, `externalId` или `custbody…`), и аккуратно обрабатывать все ошибки/исключения.