1) You may be bundling too much code on the client side.
Overuse of the `use client` directive in components turns them into client-side components. 
As a result, their code is fully loaded and executed in the browser, which can negatively impact performance.
2) In the Pages Router, data fetching was often done via `getStaticProps`/`getServerSideProps`, which clearly separated the data fetching logic from the component.
In the App Router, data loading can be done directly in a server component using `fetch()`.
If you are not careful about how and when requests are sent, you may end up with duplicate requests or a suboptimal caching strategy.
Missing or incorrect configuration of `revalidate` (ISR) can also cause SSR requests to occur too frequently.
3) The App Router provides more options for fine-tuning the caching process (HTTP headers, automatic invalidation, etc.), but it is important to configure these options correctly. 
If caching is not enabled or configured incorrectly, the server components will be rebuilt on every request, which will significantly increase the server load.
4) The App Router encourages a more flexible structure: nested layouts, parallel routes, etc.
However, if this hierarchy is too complex, or if there are heavy operations in the layouts, it can affect the overall render time and therefore performance.
With parallel routes, there can be multiple route branches at the same time, which can increase data preparation time if the logic is not optimized.
5) Sometimes misconfigured imports and lack of optimization (such as tree shaking or code splitting) cause unnecessary code to be included in the bundle.
6) The App Router uses React 18 features by default (such as streaming and concurrent rendering).
Using these features incorrectly can result in increased time to first byte (TTFB) or hydration issues, especially if the server and client are rendering different versions of data or making repeated requests.
7) Using external code in server components that is not optimized to run in the Node environment (for example, browser-specific APIs) can cause a fallback to client-side rendering. 
Sometimes logic that should only be used on the client side (events, handlers, animations) ends up in server components, complicating the build and rendering process.
8) Often, during a phased migration, some routes remain in the Pages Router while others are migrated to the App Router.
If the overall configuration (webpack, ESLint, TypeScript, and environment settings) is not consistent, there may be additional overhead (repeated builds, configuration collisions, increased switching between routers).
9) When migrating to the new router, the location of the API endpoints may have changed (previously they were located in `/api/*` within the `pages` folder, and now separate route handlers may have been created in the `app` folder).
If there are errors or misconfigurations in the caching, request logic, or request handling, the server side may become slower.
10) Sometimes it may appear that performance has dropped after migration, but in fact different metrics are being measured. 
10.1) For example, you may be comparing TTFB alone in one scenario to TTFB combined with streaming in another, which may give different results.
10.2) Another possibility is that the bundle was smaller before the migration due to a different build process, so certain performance metrics (e.g. load time) may appear higher now.
10.3) Errors in Lighthouse, Web Vitals, or other tools can be misleading, especially if «App Router» uses more intensive server-side rendering.
10.4) React 18 (with concurrent rendering and streaming SSR) changes how TTFB, Time to Hydrate, and Time to Interactive are measured and interpreted.
10.5) For streaming, TTFB can often be slightly higher, but the user will see some of the content faster.
10.6) Lighthouse, WebPageTest, and other tools may show different results depending on how the rendering process and sending of HTML in chunks is done.
10.7) Some of the degradation in metrics (especially TTFB) can sometimes be explained by the peculiarities of streaming. 
Where previously the user received a fully rendered HTML page all at once, now the content may arrive in chunks (streaming SSR), and the metrics in tools like Lighthouse may be different.
11) If you do not consider the nuances when using «Server Actions» (for example, which data is sent in the form and how it is serialized or deserialized), these oversights can also affect the application's performance and behavior.
12) You may need to revise your image optimization settings (loader configuration, caching, etc.).
13) If you previously relied on SSR via a Node server but have now switched to the «Edge Runtime» (Vercel Edge Functions, etc.), you might notice changes in latency, caching behavior, and rendering approaches.