Наиболее вероятные причины вашей проблемы:
1) Исчерпание вашими PHP applications оперативной памяти.
В этом случае и ядро Linux запускает программу OOM Killer (Out Of Memory Killer).
OOM Killer выбирает процессы для завершения (kill), чтобы освободить системные ресурсы. 
OOM Killer использует «OOM score», который зависит от текущего объёма потребления памяти процессом, приоритетов процесса, времени жизни процесса, настроек `oom_adj` и так далее.
2) Неправильная настройка параметров `pm.max_children`, `pm.start_servers`, `pm.min_spare_servers` в PHP-FPM. 
Обычно это приводит к причине 1.
3) Ограничения по CPU.
Сервера Linode — виртуальные.
Это значит, что Linode обслуживает на одном физическом сервере сразу несколько клиентов вроде вас.
По этой причине, Linode не заинтересован предоставлять вам много ресурсов процессора: им выгоднее ограничивать потребление ресурсов процессора клиентами, чтобы напихать на один физический сервер побольше клиентов.
Если ваш виртуальный CPU сильно загружен, ваши PHP applications будут обрабатывать запросы пользователей слишком медленно.
В этом случае в PHP либо в одном из middleware (например, веб-сервер или Cloudflare) срабатывает timeout, и этот middleware обрывает обслуживание клиента. 
4) Вообще, слишком короткие таймауты PHP-FPM или веб-сервера могут не только make your PHP applications «timing out», но и также make them «going down».
Например, это может происходить так:
4.1) Запросы пользователей, на обработку которых нужно чуть больше времени, будут прерываться до завершения.
Пользователи начинают получать 500/504 ошибки (запросы прерываются по таймауту)
4.2) При этом некоторые процессы PHP-FPM могут зависать в момент убийства, оставляя за собой выделенные ресурсы (память, открытые соединения к БД). 
4.3) Постепенно число подвисших или убитых процессов растёт, конфигурация PHP-FPM может выйти из строя (например, перестаёт порождать новые воркеры или уходит в ошибку). 
5) Слишком длинные таймауты PHP-FPM или веб-сервера тоже могут не только make your PHP applications «going down».
Сценарий будет выглядеть так:
5.1) Если `max_execution_time` или `request_terminate_timeout` чрезмерно велики (например, несколько минут), скрипты могут висеть очень долго, даже если они попали в тупиковое состояние (блокировка в БД, бесконечный цикл и т.д.).  
5.2) Такие зависшие процессы продолжают удерживать системные ресурсы (CPU, RAM, соединения к БД) в течение всего срока длинного таймаута.
5.3) При высокой нагрузке (много одновременно зависших процессов) общее потребление оперативной памяти растёт, и это приводит к причине 1. 
6) Если в программном коде ваших PHP applications есть неэффективные или длительно выполняющиеся запросы к базе данных, это может приводить не только к таймаутам, но и к полной недоступности приложения.
Один из возможных сценариев:
6.1) Пользователь что-то запрашивает у вашего application.
6.2) Ваш application отправляет к базе тяжёлый запрос.
6.3) Пока application ждет результат, соответствующий процесс (воркер) PHP-FPM находится в режиме ожидания (blocking I/O).
6.4) Чем дольше выполняется запрос 6.2, тем дольше воркер PHP-FPM захвачен этим соединением и не может обслужить другие запросы.
6.5) Когда несколько пользователей одновременно делают 6.1, число занятых PHP-процессов начинает быстро расти.  
6.6) Длительные запросы с модификацией данных (INSERT/UPDATE/DELETE) или даже SELECT-операции в определённых режимах изоляции транзакций могут удерживать блокировки на таблицах или строках базы данных.
6.7) Из-за блокировок и конкурентного доступа даже небольшие запросы к БД начинают дольше выполняться.  
6.8) Если MySQL настроен на ограниченное число соединений (`max_connections`), под большим валом запросов оно может быстро исчерпаться.  
При превышении лимита подключения к БД новые запросы получают ошибку вроде «Too many connections». Это уже само по себе может приводить к падению вашего приложения.
6.9) Если PHP-процессы висят долго, то их память, выделенная под выполнение скриптов, продолжает быть занята.
6.10) Под нагрузкой суммарное потребление RAM растёт и может достичь критических значений, и это приводит к причине пункта 1.
7) Неправильная конфигурация веб-сервера (Apache, Nginx).
7.1) Если в конфигурации Apache (через MPM-параметры вроде `MaxRequestWorkers`, `ServerLimit` и т.д.) или в Nginx (`worker_processes`, `worker_connections`) установлено слишком маленькое количество рабочих процессов/воркеров, сервер при пике нагрузки просто захлёбывается.
7.2) Обратная ситуация: если лимиты выставлены слишком высоко (особенно в сочетании с PHP-FPM, где тоже может быть завышенный `pm.max_children`), то при одновременных запросах каждый воркер запускает PHP-процесс, и общее потребление CPU и памяти может резко возрасти.  
Это приводит к причине 1.  
7.3) Важна согласованность между числом дочерних процессов в  PHP-FPM и соответствующими параметрами Apache/Nginx (число воркеров, очереди). 
Любой дисбаланс (например, веб-сервер принимает больше одновременных соединений, чем способен обработать пул PHP-FPM) приводит к накоплению запросов и сбоям.
7.4) Важна согласованность таймаутов PHP-FPM и Apache/Nginx.
Если, к примеру, Apache имеет `ProxyReadTimeout` в 1 минуту (или, аналогично, Nginx имеет `fastcgi_read_timeout` в 1 минуту), а PHP-FPM использует большее время выполнения (или наоборот), то при интенсивной нагрузке веб-сервер может прекращать соединения раньше, чем скрипт успеет завершиться.  
Это вызывает частые 504/502 ошибки, которые при накоплении и повторных запросах нагружают систему ещё сильнее.
7.4.1) Также, при несоответствующих таймаутах (особенно если веб-сервер ждёт ответа дольше, чем реально настроен PHP-FPM) часть рабочих процессов зависает в режиме ожидания.  
Со временем все воркеры становятся занятыми зависшими запросами, а новые соединения не могут быть приняты — фактически сайт не отвечает.
7.5) Если `ProxyBuffer` Apache (или аналогичных буферов Nginx) недостаточно (особенно при больших ответах), могут возникать ситуации, когда соединение разрывается при передаче данных от PHP-FPM.  
В результате — частые ошибки, «таймауты» и затем полная недоступность (если служба забита зависшими коннектами).
7.6) При неправильной конфигурации (например, слишком агрессивные `KeepAlive`-настройки в Apache) соединения могут удерживаться долго, и число доступных воркеров сокращается.  
Когда все воркеры заняты, новые входящие запросы получают мгновенный отказ (5xx) или уходят в бесконечное ожидание.
8) Cloudflare имеет собственные лимиты времени ожидания ответа от сервера.
Может быть, вашим applications реально нужно долго выполнять некоторые запросы пользователей, но Cloudflare этого не знает, и при неправильной настройке Cloudflare может обрывать обслуживание этих пользователей и показывать им сообщения о сбоях: «504» / «Gateway Timeout», «522» / «Connection timed out», «524» / «A Timeout Occurred».  
9) Когда в конфигурации PHP (php.ini или настройках PHP-FPM pool) установлены определённые лимиты на загрузку файлов (например, `upload_max_filesize`, `post_max_size`) и при этом пользователи или процессы приложения пытаются загружать большие файлы, может возникнуть цепочка проблем, которые в итоге приводят к падению приложения. 
10) Если какой-то PHP extension неправильно освобождает память, то со временем это приводит к причине 1.
В отличие от классического `mod_php` (когда процесс Apache может перезапускаться чаще), PHP-FPM-пулы могут работать достаточно долго (или фактически постоянно) — пока не достигнут лимита по числу обработанных запросов (`pm.max_requests`) или не будут перезапущены вручную. 
Если процессы работают часами или сутками, утечки памяти накапливаются внутри каждого воркера.
11) Бывает, что в результате автоматических обновлений cPanel/WHM настройки PHP или Apache сбиваются, и это приводит к причинам 2, 5, 7.
12) MultiPHP Manager в cPanel генерирует пул-конфиги (`/opt/cpanel/ea-phpXX/root/etc/php-fpm.d/*.conf`), которые перезаписывают друг друга.