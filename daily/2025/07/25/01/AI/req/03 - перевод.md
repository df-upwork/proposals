## 1. `Def`
~~~
Def(A):
```
B
```
~~~
будет обозначать, что для понятия `B` я использую обозначение `A`.

## 2. `Def_P`
~~~
Def_P(A):
```
B
```
~~~
будет обозначать, что `B` является для меня проблемой, и для этой проблемы я использую обозначение `A`.

## 3. `Def_C`
### 3.1.
```
Def_C(P, A, B)
```
будет обозначать `Def(A, B)` в контексте пункта `P`.
Вне пункта `P` это правило не применяется.
Если до пункта `P` обозначение `A` имело другой смысл, то после пункта `P` обозначение `A` снова будет иметь этот смысл.
По сути, `Def_C` объявляет локальную переменную `A` с областью действия `P`.
В отличие от него, `Def` объявляет глобальную переменную `A` (значение которой действует для всех пунктов, кроме `P`).

### 3.2.
~~~
Def_C(P, A):
```
B
```
~~~
имеет то же значение, что и `Def_C(P, A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 3.3.
```
Def_C([P1, P2, …, Pn], A, B)
```
имеет значение, аналогичное `Def_C(P, A, B)`, только в этом случае обозначение `A` имеет значение `B` в контексте не одного пункта `P`, а всех пунктов [`P1`, `P2`, …, `Pn`], перечисленных в квадратных скобках.

### 3.4.
```
Def_C([P1-Pn], A, B)
```
имеет значение, аналогичное `Def_C([P1, P2, …, Pn], A, B)`: в этом случае обозначение `A` имеет значение `B` в контексте множества всех пунктов между `P1` и `Pn`, включая сами эти пункты.

### 3.5.
~~~
Def_C([P1, P2, …, Pn], A):
```
B
```
~~~
имеет то же значение, что и `Def_C([P1, P2, …, Pn], A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 3.6.
~~~
Def_C([P1-Pn], A):
```
B
```
~~~
имеет то же значение, что и `Def_C([P1-Pn], A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 4. `Def_F`
### 4.1.
Def_C(4-5, `F`):
```
Факт: некое событие, которое случилось в описываем мной случае.
```

### 4.2.
~~~
Def_F:
```
B
```
~~~
будет обозначать, что `B` — это `F`.

### 4.3.
~~~
Def_F(A):
```
B
```
~~~
будет обозначать, что `B` — это `F`, и для него я использую обозначение `A`.

## 5. `Def_Ph`
### 5.1.
Def_C(5, `Ph`):
```
Феномен: `F`, который вызывает у меня удивление.
```

### 5.2.
~~~
Def_Ph(A):
```
B
```
~~~
будет обозначать, что `B` — это `Ph`, и для него я использую обозначение `A`.

## 6. `Def_H`
### 6.1.
Def_C(6, `H`):
```
Гипотеза: некое предположение, требующее проверки.
```

### 6.2.
~~~
Def_H(A):
```
B
```
~~~
будет обозначать, что `B` — это `H`, и для него я использую обозначение `A`.

## 7. `Def_Set`
### 7.1.
```
Def_Set(S, I)
```
будет обозначать, что `S` — множество всех возможных `I`.

### 7.2.
```
Def_Set(S, {I1, I2, …, In})
```
будет обозначать, что `S` — множество, заданное точным перечислением всех его элементов: {`I1`, `I2`, …, `In`}.

## 8. `Def_I`
### 8.1.
```
Def_I(I, S)
```
будет обозначать, что `I` ∈ `S` (`I` — элемент множества `S`).

### 8.2.
~~~
Def_I(I, S):
```
B
```
~~~
будет обозначать, что `I` ∈ `S` и `B` — определение `I`.

## 9. `Use`
```
Use(A)
```
будет обозначать, что в описываемой мной ситуации я использую `A`.

## 10.
Потенциальный клиент опубликовал на Upwork следующий проект:
### 10.1. Title
EntraId and Keycloak Configuration Expert Needed

### 10.2. Description
```text
We are seeking an EntraId expert to assist in configuring Authorization using Keycloak. 
The ideal candidate should possess a strong understanding of both EntraId and Keycloak platforms to effectively manage user authentication and authorization processes. 
Your expertise will be crucial in ensuring seamless integration and optimal functionality. 
If you have experience in identity management systems and a passion for delivering high-quality results, we would love to hear from you!
```

### 10.3. Tags
Java
JavaScript
PHP
Amazon Web Services
Network Administration

## 11. Информация о клиенте
### 11.1. Местоположение
United States

## 11.2. Характеристики компании
### 11.2.1. Сектор экономики
Tech & IT
### 11.2.2. Количество сотрудников
10-99

## 11.3. Характеристики учётной записи на Upwork
### 11.3.1. Member since
Aug 31, 2022
#### 11.3.2. Hire rate (%)
0
#### 11.3.3. Количество опубликованных проектов (jobs posted)
3
#### 11.3.4. Total spent (USD)
0
#### 11.3.5. Количество оплаченных часов в почасовых проектах
0

## 12.
Def(`C`):
```
клиент пункта 10
```

## 13.
Def(`P`):
```
проект пункта 10
```

## 14.
Def(`PD`):
```
Описание `P` (пункт 10.2 выше)
```

## 15.
Def(`T`):
```
Задача, о которой `C` пишет в `PD`:
~~~
configuring Authorization using Keycloak
~~~
```

## 16.
Def(`D`, «мой ответ `C`»).

## 17.
Содержание `D`:
~~~markdown
1) Я рекомендую следующий авторизации с использованием Microsoft Entra ID (`EI`) и Keycloak (`K`):
1.1) В основе предлагаемого решения лежит архитектурный паттерн «Identity Brokering», также известный как «Identity Federation». 
`K` обладает встроенной поддержкой данного паттерна, позволяя делегировать процесс аутентификации внешнему, доверенному поставщику удостоверений, который в данном контексте именуется «Identity Provider» (`IP`).
1.2) `EI` выступает в роли авторитетного `IP`.
Это означает, что именно `EI` отвечает за хранение учётных данных пользователей, проверку их подлинности (аутентификацию) и предоставление информации об этих пользователях.
1.3) `K`, в свою очередь, конфигурируется как «Identity Broker»: промежуточный сервис, который устанавливает доверительные отношения с `EI`. 
Конечное клиентское приложение (`A`) не взаимодействует с `EI` напрямую. 
Вместо этого оно полностью доверяет `K`, который предоставляет ему унифицированный интерфейс для аутентификации и авторизации.
2) Мой подход (пункт 1) создаёт важный слой абстракции, который даёт следующие преимущества: 
2.1) Централизация управления `IP`. 
Если в будущем потребуется добавить других поставщиков удостоверений (например, Google, Facebook или другой корпоративный SAML `IP`), все изменения будут производиться централизованно в `K`. 
`A` останется неизменным, так как оно по-прежнему будет взаимодействовать только с `K`. 
2.2) Упрощение `A`. 
Разработчикам `A` не нужно реализовывать логику для взаимодействия с различными протоколами и API множества `IP`. 
Им достаточно интегрироваться с одним сервисом (`K`) по одному стандартизированному протоколу.
2.3) Обогащение и трансформация токенов. 
`K` может получать информацию от внешнего `IP`, а затем обогащать или преобразовывать её перед передачей `A`. 
Например, он может сопоставлять группы из `EI` с внутренними ролями `K`.
3) В моём подходе `K` выполняет двойную роль:
3.1) С точки зрения `A`, `K` является его `IP`. 
`A` обращается к `K` за аутентификацией и получает от него токены. 
3.2) С точки зрения `EI`, `K` — это клиентское приложение, которое запрашивает аутентификацию. 
В терминологии протоколов он выступает как «Service Provider» (`SP`) или «Relying Party» (`RP`). 
4) Двойственность пункта 3 имеет критическое значение при диагностике проблем. 
Например, сбой аутентификации может быть связан либо с токеном, который `K` получает от `EI` (его роль как `SP`/`RP`), либо с токеном, который он выдаёт конечному приложению (его роль как `IP`).
Чёткое разграничение этих ролей позволяет точно локализовать источник проблемы.
5) `K` поддерживает два основных протокола для федерации удостоверений: Security Assertion Markup Language 2.0 (SAML) и OpenID Connect 1.0 (`OIDC`).
Я рекомендую в вашем случае `OIDC` по следующим причинам:
5.1) Учитывая технологический стек проекта, указанный вами в тегах (Java, JavaScript, PHP, Amazon Web Services), который явно ориентирован на современные веб-технологии и облачные сервисы
5.2) `OIDC` — это более современный стандарт, построенный как простой слой идентификации поверх протокола авторизации OAuth 2.0. 
Для передачи данных `OIDC` использует формат JSON и токены JWT («JSON Web Tokens»). 
Он изначально проектировался с учётом потребностей современных веб-приложений, мобильных клиентов и RESTful API.
6) Общая схема взаимодействия:
6.1) Пользователь (`U`) пытается получить доступ к защищённому ресурсу в `A`.
6.2) `A`, обнаружив отсутствие активной сессии, перенаправляет `U` на страницу входа `K`.
6.3) `K`, в свою очередь, видит, что `U` не аутентифицирован, и перенаправляет его на сконфигурированный внешний `IP`: `EI`.
6.4) `U` вводит свои корпоративные учётные данные на странице входа `EI` и успешно проходит аутентификацию.
6.5) `EI` генерирует «ID Token» (`T`), содержащий claims о `U`, включая его идентификаторы групп, и перенаправляет браузер `U` обратно на специальный «Redirect URI» в `K`.
6.6) `K` получает `T` от `EI`, проверяет его цифровую подпись и валидность.
6.7) `K` извлекает из `T` claims. 
6.8) На основе claims `K` либо создаёт в своей БД новую учётную запись для `U`, либо обновляет  существующую. 
На этом же этапе происходит ключевой процесс — сопоставление (маппинг) идентификаторов групп из claim «groups» на внутренние роли `K`. 
6.9) `K` создаёт собственную сессию для `U`.
6.10) `K` генерирует собственные токены (`K-TT`) для `A`:
- Собственный «ID Token» (не путать с `T`) 
- «Access Token». 

`K-TT` содержат роли, которые были назначены `U` внутри `K`. 
6.11) `K` перенаправляет браузер `U` обратно на «Redirect URI» `A`.
6.12) `A` получает `K-TT` от `K`, валидирует их и извлекает из них информацию о ролях `U`. 
6.13) `A` принимает решение о предоставлении или запрете доступа `U` к запрошенному ресурсу.
~~~

## 18.
Def(`D2`, «начальная часть `D`, переведённая с Russian на English»).

## 19.
Содержание `D2`:
~~~markdown
1) I recommend the following authorization approach using Microsoft Entra ID (`EI`) and Keycloak (`K`):
1.1) The proposed solution is based on the architectural pattern «Identity Brokering», also known as «Identity Federation».
`K` has built-in support for this pattern, allowing the delegation of the authentication process to an external, trusted identity provider, which in this context is referred to as an «Identity Provider» (`IP`).
1.2) `EI` acts as the authoritative `IP`.
This means that it is `EI` that is responsible for storing user credentials, verifying their authenticity (authentication), and providing information about these users.
1.3) `K`, in turn, is configured as an «Identity Broker»: an intermediary service that establishes a trust relationship with `EI`.
The end-client application (`A`) does not interact with `EI` directly.
Instead, it fully trusts `K`, which provides it with a unified interface for authentication and authorization.
2) My approach (point 1) creates an important abstraction layer, which provides the following advantages:
2.1) Centralized `IP` management.
If in the future it becomes necessary to add other identity providers (e.g., Google, Facebook, or another corporate SAML `IP`), all changes will be made centrally in `K`.
`A` will remain unchanged, as it will still interact only with `K`.
2.2) Simplification of `A`.
`A` developers do not need to implement the logic for interacting with the various protocols and APIs of multiple `IP`s.
They only need to integrate with a single service (`K`) using a single standardized protocol.
2.3) Token enrichment and transformation.
K can receive information from the external `IP` and then enrich or transform it before passing it to A.
E.g., it can map groups from `EI` to `K`'s internal roles.
3) In my approach, `K` performs a dual role:
3.1) From the perspective of `A`, `K` is its `IP`.
`A` contacts `K` for authentication and receives tokens from it.
3.2) From the perspective of `EI`, `K` is a client application that requests authentication. 
In protocol terminology, it acts as «Service Provider» (`SP`) or «Relying Party» (`RP`).
4) The duality described in point 3 is of critical importance for troubleshooting. e.g., an authentication failure can be related to either the token that `K` receives from `EI` (its role as `SP`/`RP`) or the token that it issues to the end application (its role as `IP`). 
A clear distinction between these roles makes it possible to precisely localize the source of the problem.
~~~

## 20.
Def(`F`, «фрагмент `D`»).

## 21.
Содержание `F`:
~~~markdown
6.11) `K` перенаправляет браузер `U` обратно на «Redirect URI» `A`.
6.12) `A` получает `K-TT` от `K`, валидирует их и извлекает из них информацию о ролях `U`. 
6.13) `A` принимает решение о предоставлении или запрете доступа `U` к запрошенному ресурсу.
~~~

## 22.
Переведи `F` на English, с учётом:
- контекста `D`
- `D2`: уже переведённой части `D`
- всех предыдущих пунктов моего запроса

## 23. Правила перевода
### 23.1.
Переводи именно в той стилистике, как написано на Russian.
Не делай перевод более вежливым, чем оригинал.

### 23.2.
Те предложения, которые сейчас полностью на English — оставь без изменения.

### 23.3.
#### 23.3.1.
Не используй Markdown: только plain text.
#### 23.3.2.
При этом можно и нужно использовать то форматирование, которое уже есть в оригинале: его не убирай.
#### 23.3.3.
Не форматируй веб-ссылки посредством Markdown, если они не отформатированы так в оригинале. 
Например, не пиши так:
```
[https://www.eca.web.tr/eca-nita-esnek-uclu-eviye-bataryasi-beyaz-102118110-308](https://www.eca.web.tr/eca-nita-esnek-uclu-eviye-bataryasi-beyaz-102118110-308)
```
если в оригинале скобок `[]()` нет.

### 23.4.
Форматируй перевод в точности как оригинал. 
В частности:
*) каждый абзац должен содержать ровно одно предложение
*) между абзацами не должно оставаться пустых строк.
*) кавычки используй те же, что и в оригинале: «» и ``.

### 23.5.
Не используй сокращения типа «don't». Все подобные фразы пиши полностью: «do not».

### 23.6.
Не используй жаргон.
Вместо этого используй официальные термины.
#### 23.6.1.
В частности, фразы в кавычках используй только в том случае, когда они являются точными цитатами.
Не используй фразы в кавычках для применения жаргонных фраз.
Например, следующий фрагмент текста недопустим, потому что там используется жаргонная фраза «пролетел»: 
```
Например, код, который пушит данные о покупке, подключён асинхронно и загружается с небольшой задержкой, а триггер уже «пролетел».
```

### 23.7.
При обсуждении программного обеспечения используй точные официальные термины на английском языке: именно в том виде, как они указаны в официальной англоязычной документации к этому программному обеспечению.

### 23.8.
Не используй «you need» и другие подобные обращённые к клиенту фразы, перекладывающие действия на него.
Помни: я пишу клиенту или потенциальному клиенту.
Делать в любом случае буду я, а не клиент.
Вместо «you need» используй 2 альтернативы:
#### 23.8.1.
Нейтральные фразы типа «it is necessary».
#### 23.8.2.
Глаголы в неопределённой форме.
Например, во фрагменте ниже использованы подобные глаголы «set up», «create»:
```
1.2) Set up the transfer of login events from WordPress to Power BI using Fabric / OneLake.
1.2.1) Set up a «Data Pipeline» from the WordPress database table that stores login events (see point 1.1) to Fabric / OneLake.
1.2.2) Set up a connection from Power BI to Fabric / OneLake to pass login events.
1.3) Create the data model in Power BI.
```
Обрати внимание, в этом фрагменте не говорится, кто именно будет выполнять описанные действия: ответственность не перекладывается на клиента, в отличие от «you need».

### 23.9.
Никогда не переводи понятие «сайт» / «веб-сайт» как «site». 
Вместо этого используй форму «website»: это является более профессиональным.

### 23.10.
Никогда не переводи понятие «пункт нумерованного списка» как «item».
Всегда переводи это как «point».

### 23.11.
Вместо «for example» используй «e.g.».
