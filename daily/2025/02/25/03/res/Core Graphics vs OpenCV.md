Ниже приведена сравнительная таблица основных аспектов **масштабирования изображений** (image resizing) в **Core Graphics (Quartz)** и **OpenCV**.

| **Критерий**                                            | **Core Graphics (Quartz)**                                                                                                                                                                                                                                                             | **OpenCV**                                                                                                                                                                                                                                                                                |
|:--------------------------------------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Уровень / Назначение**                                | • **Низкоуровневый** фреймворк для 2D-графики (отрисовка, трансформации, работа с PDF и т. д.).<br/>• Масштабирование выполняется при отрисовке в контекст (`CGContext`), выбор качества интерполяции — через `CGInterpolationQuality`.                                                                                 | • **Компьютерное зрение** и обработка изображений (C++/Python).<br/>• Широкий набор алгоритмов и функций: от простого ресайза до сложных CV-задач (поиск особенностей, классификация, ML-модули).                                                                                      |
| **Основной механизм масштабирования**                   | • Масштабирование идёт путём «отрисовки» исходного `CGImage` в новом размере с учётом `CGInterpolationQuality`.<br/>• Степени качества: `None`, `Low`, `Medium`, `High` (поведение может меняться между версиями macOS).                                                                                                  | • Функция `cv2.resize()` (Python) или `resize()` (C++), в которой можно явно указать флаг интерполяции (например, `INTER_LINEAR`, `INTER_CUBIC`, `INTER_LANCZOS4` и т. д.).<br/>• Поддерживает несколько чётко определённых алгоритмов (Nearest, Linear, Cubic, Lanczos4, Area и т. д.).   |
| **Выбор конкретного алгоритма интерполяции**            | • **Ограниченное** явное управление: 4 уровня качества.<br/>• Типичные соответствия: <br/> &nbsp;&nbsp;• `kCGInterpolationNone` ≈ Nearest Neighbor<br/> &nbsp;&nbsp;• `kCGInterpolationLow/Medium` ≈ Bilinear<br/> &nbsp;&nbsp;• `kCGInterpolationHigh` ≈ Bicubic/Lanczos (но гарантии нет).                   | • **Чёткий** выбор через параметр `interpolation`: <br/> &nbsp;&nbsp;• `INTER_NEAREST`, `INTER_LINEAR`, `INTER_CUBIC`, `INTER_LANCZOS4`, `INTER_AREA` и др. <br/>• Каждый флаг явно соответствует конкретному алгоритму (nearest, bilinear, bicubic, lanczos и т. п.).                                   |
| **Дополнительные методы**                               | • Суперразрешение «из коробки» отсутствует.<br/>• Если нужен явно Lanczos, можно попасть в ситуацию, когда «High» даёт бикубику или другой метод — Apple не раскрывает деталей.<br/>• Для более продвинутых фильтров следует использовать **Core Image** или другие фреймворки.                                                  | • `INTER_AREA` (усреднение по области) особенно хорошо для **уменьшения** (сводит к минимуму aliasing).<br/>• GPU-ускорение возможно через модули CUDA/OpenCL (не всегда «по умолчанию»).<br/>• Есть модули *super resolution* (dnn_superres) с использованием ML-моделей (ESRGAN и т. д.).         |
| **Сценарии использования**                              | • «Классический» рендеринг (GUI, PDF, графика).<br/>• Быстрая перерисовка изображений при изменении масштаба — например, для отображения на экране или экспорта.                                                                                                                           | • Широко используется в **компьютерном зрении**, машинном обучении, обработке фотографий/видео (детекция, трекинг, классификация).<br/>• Часто вызывается на CPU, но может работать и на GPU.                                                                                            |
| **Производительность**                                  | • Традиционно **CPU-центричный** подход (Quartz).<br/>• На современных системах часть операций может выполняться с GPU-ускорением (Metal), но официально Apple позиционирует Core Graphics именно как 2D-API для CPU (в отличие от Core Image).                                                                                | • Реализован на C++ с широкими SIMD-оптимизациями. При необходимости — **GPU-ускорение** (CUDA/OpenCL) в некоторых модулях.<br/>• Для крупных изображений и высокочастотных операций может быть быстрее, чем Core Graphics, особенно при грамотном использовании аппаратных ресурсов.        |
| **Простота / Гибкость**                                 | • Очень простая модель: нужно создать `CGContext`, задать `interpolationQuality`, «нарисовать» изображение в нужном размере. <br/>• Гибкость при выборе **конкретного** фильтра ограничена (всего 4 уровня качества).                                                                                                           | • Более «технический» и подробный контроль: можно явно выбрать «Linear», «Cubic», «Lanczos4», «Area» и т. д.<br/>• Поддержка очень многих алгоритмов, в том числе кастомных (через самописные функции и плагины).                                                                                                               |
| **Интеграция с другими фреймворками**                   | • Глубоко интегрирован в macOS/iOS (отрисовка UI, векторная графика, PDF).<br/>• Для чтения/записи форматов изображений, как правило, используется **Image I/O**.                                                                                                                          | • OpenCV может работать в Windows, Linux, macOS, Android и iOS. <br/>• Широко интегрируется с Python (NumPy, SciPy), C++-библиотеками, ML-фреймворками (TensorFlow, PyTorch).                                                                                                               |
| **Типичные соответствия методов**                       | • `kCGInterpolationNone` ≈ `INTER_NEAREST` <br/>• `kCGInterpolationLow/Medium` ≈ `INTER_LINEAR` <br/>• `kCGInterpolationHigh` ≈ может быть **ближе** к `INTER_CUBIC` или `INTER_LANCZOS4` (зависит от macOS).                                                                                                                    | • `INTER_NEAREST`, `INTER_LINEAR`, `INTER_CUBIC`, `INTER_LANCZOS4` и `INTER_AREA` — каждый метод определяется чётко. <br/>• Lanczos в OpenCV = `INTER_LANCZOS4` (апертура 4).                                                                                                                                                |

### Ключевые отличия и выводы

1. **Способ указания алгоритма**  
   - **Core Graphics**: всего 4 «уровня качества» через `CGInterpolationQuality`, без точной гарантии, что «High» всегда соответствует именно Lanczos.  
   - **OpenCV**: чёткое перечисление (`INTER_NEAREST`, `INTER_LINEAR`, `INTER_CUBIC`, `INTER_LANCZOS4`, `INTER_AREA`) с предсказуемым поведением.

2. **Назначение и экосистема**  
   - **Core Graphics (Quartz)** — родной 2D-фреймворк Apple, тесно связан с отрисовкой UI, PDF, иконок, текстом.  
   - **OpenCV** — универсальная библиотека для компьютерного зрения и image processing, доступная на всех популярных платформах.

3. **Производительность**  
   - **Quartz** традиционно CPU-ориентирован; хорошо подходит для типовых задач отрисовки.  
   - **OpenCV** ориентирован на высокую скорость в CV-задачах, можно подключить SIMD/GPU.  

В итоге, если вам нужно просто «отрисовать изображение в новом размере в macOS/iOS с минимальными усилиями», Core Graphics проще. Если же требуется гибкий и точный выбор алгоритмов (например, сравнение Bicubic vs Lanczos vs Area) или более продвинутые методы компьютерного зрения, **OpenCV** даст большую свободу и масштабируемость.