1) Firebaseは、ブロードキャストメッセージングを実装するためのネイティブなメカニズムとして、FCM Topic Messagingを提供しています。
2) 私が提案するアーキテクチャ：
2.1) サーバーサイド（`S`）は、Firebase Admin SDKを使用して、トピックへのデバイスのサブスクリプション管理や、それらへのメッセージ送信などの特権的な操作を実行します。
`S`は、すべてのサーバーサイドロジックを担当します。
2.2) クライアントサイド (`C`):
- ユーザー (`U`) から通知を受信するための許可を要求する
- FCMから一意のデバイス登録トークン (`T`) を受信し、その後のサブスクリプションのために `T` を `S` に送信する
3) 高レベルなインタラクションフロー：
3.1) `C`が`T`を取得し、`S`に送信する
3.2) `S`は、この`T`を使用してデバイスを共通のトピックにサブスクライブする
3.3) その後、ブロードキャスト通知を送信するために、承認された管理者（`A`）は、安全なAPIエンドポイント`/api/broadcast`（`E1`）を介してFCMに単一のメッセージを送信し、この共通トピックを受信者として指定します。
3.4) FCMは、今度は、このメッセージをすべてのサブスクライブしているデバイスに配信します。
4) ウェブクライアント向けのFCMのアーキテクチャ上の重要な制約は、独立してトピックにサブスクライブできないことです。
この操作は`S`によって実行される必要があります。
したがって、`C`から登録`T`を受け取り、その代理でサブスクリプションを実行するサーバーサイドAPIエンドポイント `/api/subscribe` (`E2`) を作成する必要があります。
5) `E1`および`E2`へのアクセスは厳密に制限されなければなりません。
保護されていないブロードキャストメッセージング用のエンドポイントは、スパムや攻撃に対して脆弱です。
この保護を2つのステップで実装することをお勧めします：
5.1) 認証：リクエストが、既知のログイン済み`A`（`E1`の場合）および`U`（`E2`の場合）からのものであることを確認する必要があります。
`E1`については、`A`が各リクエストと共に送信する`Firebase ID`トークン（`AT`）を使用することを推奨します。
5.2) 認可: `A` / `U` がこのアクションを実行するために必要な権限を持っていることを確認します。
5.2.1) `A` にカスタムクレーム (`AC`)、例えば `{admin: true}` を追加し、`S` でそれを検証することをお勧めします。
5.2.2) `AC` の割り当ては、既存の `A` のみが利用可能な Cloud Function や、サーバーサイドのスクриプトなど、別の非常に安全なメカニズムを介して実行する必要があります。
6) `C`でFCMを扱うためには、クライアントSDKをインストールし、Service Workerを設定する必要があります。
7) `U`がウェブサイトに通知を表示する許可を明示的に与えるまで、ブラウザは`T`を提供しません。したがって、通知を受信するためには`U`から許可を要求する必要があります。
8) `T`は変更される可能性があるという点を覚えておくことが極めて重要です。
`C`の各ロード時に`T`を取得し、以前に保存されたものと異なる場合は`S`に送信することをお勧めします。
9) `S`がFirebase APIコールを認証して実行するためには、IDが必要です。
この役割は、サーバー間通信など、人間以外のインタラクションを目的とした特別な種類のGoogleアカウントであるサービスアカウント（`SA`）によって実行されます。
`SA`のキーファイルをDockerイメージに含めることは、深刻なセキュリティ違反です。
実行時にコンテナに認証情報を注入することをお勧めします。
10) 完全な`U`のサブスクリプションプロセス:
10.1) `U`がブラウザで`C`を開く。
10.2) `C`が通知表示の許可をリクエストする。
10.3) `U`が«許可»をクリックする。
10.4) `C`がFCMから`T`を要求する。
10.5) `C`がトークンを`S`の`E2`に送信する。
10.6) `S`が`T`を共通トピック`all_users`にサブスクライブする。
10.7) `U`のデバイスがブロードキャスト通知を受信できる状態になる。
11) ブロードキャスト通知を開始するための手順:
11.1) `A`は、特別な管理パネルで自身のアカウントにログインします。
11.2) `A`は、`AC`を含むATをFirebaseから取得します。
11.3) `A`はメッセージ（タイトルと本文）を作成し、「Send」をクリックします。
11.4) 管理アプリケーションは、`Authorization: Bearer <AT>`ヘッダーに`AT`を添付して、`E1`に`POST`リクエストを送信します。
11.5) `E1`はトークンの有効性と`AC`の存在を検証します。検証に合格すると、`S`はFCM用のメッセージオブジェクトを構築し、送信メソッドを呼び出します。
11.6) FCMはリクエストを受信し、`all_users`トピックにサブスクライブしているすべてのデバイスに通知を配信します。