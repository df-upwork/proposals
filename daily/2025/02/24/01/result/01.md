Наиболее вероятные причины вашей проблемы:
1) Неверные пути к статическим файлам (или даже базовый URL):
1.1) В development mode (`npm run dev` или `vite dev`) файлы отдаются напрямую из памяти дев-сервера. 
Он понимает, что всё лежит, например, по `localhost:5173`, а ваши относительные пути часто работают даже без дополнительной настройки (поскольку всё находится в условном корне).  
Более того, в режиме разработки Vite часто «подсовывает» пути на лету, игнорируя `base`, или добавляет HMR-модули.
1.2) В production mode (`npm run build` или `vite preview`) файлы минифицируются и рассыпаются в папку `dist` (по умолчанию).  
Vite подменяет ссылки внутри бандла на те, что указаны в конфигурации `base`. 
Если `base` не соответствует реальному пути деплоя, браузер будет запрашивать файлы по неверным URL.
1.3) В итоге, если главный JS-бандл (или CSS) не загрузился, все фреймворки и компоненты не смогут отрисоваться.  
2) В production mode код минифицируется, и при возникновении ошибки в рантайме (например, при вызове метода контракта) приложение может просто упасть без явного сообщения. 
В итоге пользователь видит серый/пустой экран. 
3) Ваше приложение Vite может использовать разные настроечные файлы `.env` в режимах development и production, и поэтому поведение приложения в этих режимах может отличаться.
4) В режимах development и production очень часто используются отличные друг от друга провайдеры Web3, потому что написание и отладку смарт-контрактов требует быстрого, бесплатного и контролируемого окружения, а в production используется уже реальная сеть Ethereum.  
4.1) В режиме разработки (dev) контракт обычно деплоится на локальный блокчейн (Hardhat, Ganache). Здесь транзакции проходят моментально, баланс есть по умолчанию, и всё контролируется на одной машине.  
Адреса контрактов, RPC-URL, приватные ключи — все игрушечные.
4.2) В production-режиме (или при реальном деплое) приложение подключается к настоящей сети (mainnet) или к публичному тестнету (Goerli, Sepolia и т. д.).  
Здесь уже требуются реальные средства (ETH на mainnet или тестовые в testnet), транзакции занимают время, и адреса контрактов могут отличаться от локальных. 
4.3) Если в production mode вы подставляете неверные RPC-URL и адреса контрактов — Web3.js не сможет подключиться к сети и может давать серый экран.
5) В режимах development и production могут использоваться разные адреса смарт-контрактов.
6) В локальном Hardhat допустимо деплоить контракт с любой логикой. 
В реальной сети этот контракт может вообще не существовать, либо иметь иную ABI (если деплой делался когда-то в другой версии). 
При попытке вызвать несуществующий метод всё ломается.
7) В dev-сети (Hardhat/Ganache) транзакции бесплатные или газ условный. 
В реальной сети требуется оплачивать газ, и если кошелёк пользователя пуст, отправка транзакции вызовет ошибку, которая без корректной обработки в коде может сломать UI.
8) В dev-среде нередко используют локальный узел, а в prod — Infura или Alchemy.  
Если при prod-сборке токен Infura/Alchemy неправильный (просрочен, отсутствует), запросы к RPC вернут ошибку, например, `403 Forbidden` или `invalid project id`.  
Без обработки эта ошибка в коде может упасть и оставить интерфейс неотрисованным.
9) Неправильная (слишком ранняя или некорректная) инициализация MetaMask или любого другого Ethereum-кошелька в браузере может привести к тому, что приложение падает и показывает серый экран (или просто пустую страницу) без явной ошибки. 
9.1) В development mode MetaMask в браузере может успевать инициализировать `window.ethereum`, и код приложения, хоть и с ошибками, всё равно срабатывает.  
9.2) В production mode, когда код минифицирован, разбит по бандлам и загружается асинхронно, время инициализации MetaMask может сдвинуться. 
Если код приложения просит `window.ethereum` до того, как он появился, приложение может упасть.