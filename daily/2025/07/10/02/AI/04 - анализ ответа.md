## 1. `Def`
### 1.1.
```
Def(A, B)
```
будет обозначать, что для понятия `B` я использую обозначение `A`.

### 1.2.
~~~
Def(A):
```
B
```
~~~
имеет то же значение, что и `Def(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 2. `Def_P`
### 2.1.
```
Def_P(A)
```
будет обозначать, что `A` является для меня проблемой.

### 2.2.
```
Def_P(A, B)
```
будет обозначать, что `B` является для меня проблемой, и для этой проблемы я использую обозначение `A`.

### 2.3.
~~~
Def_P(A):
```
B
```
~~~
имеет то же значение, что и `Def_P(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 3. `Def_C`
### 3.1.
```
Def_C(P, A, B)
```
будет обозначать `Def(A, B)` в контексте пункта `P`.
Вне пункта `P` это правило не применяется.
Если до пункта `P` обозначение `A` имело другой смысл, то после пункта `P` обозначение `A` снова будет иметь этот смысл.
По сути, `Def_C` объявляет локальную переменную `A` с областью действия `P`.
В отличие от него, `Def` объявляет глобальную переменную `A` (значение которой действует для всех пунктов, кроме `P`).

### 3.2.
~~~
Def_C(P, A):
```
B
```
~~~
имеет то же значение, что и `Def_C(P, A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 3.3.
```
Def_C([P1, P2, …, Pn], A, B)
```
имеет значение, аналогичное `Def_C(P, A, B)`, только в этом случае обозначение `A` имеет значение `B` в контексте не одного пункта `P`, а всех пунктов [`P1`, `P2`, …, `Pn`], перечисленных в квадратных скобках.

### 3.4.
```
Def_C([P1-Pn], A, B)
```
имеет значение, аналогичное `Def_C([P1, P2, …, Pn], A, B)`: в этом случае обозначение `A` имеет значение `B` в контексте множества всех пунктов между `P1` и `Pn`, включая сами эти пункты.

### 3.5.
~~~
Def_C([P1, P2, …, Pn], A):
```
B
```
~~~
имеет то же значение, что и `Def_C([P1, P2, …, Pn], A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 3.6.
~~~
Def_C([P1-Pn], A):
```
B
```
~~~
имеет то же значение, что и `Def_C([P1-Pn], A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 4. `Def_F`
### 4.1.
Def_C(4-5, `F`):
```
Факт: некое событие, которое случилось в описываем мной случае.
```

### 4.2.
```
Def_F(B)
```
будет обозначать, что `B` — это `F`.

### 4.3.
~~~
Def_F:
```
B
```
~~~
имеет то же значение, что и `Def_F(B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 4.4.
```
Def_F(A, B)
```
будет обозначать, что `B` — это `F`, и для него я использую обозначение `A`.

### 4.5.
~~~
Def_F(A):
```
B
```
~~~
имеет то же значение, что и `Def_F(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 5. `Def_Ph`
### 5.1.
Def_C(5, `Ph`):
```
Феномен: `F`, который вызывает у меня удивление.
```

### 5.2.
```
Def_Ph(B)
```
будет обозначать, что `B` — это `Ph`.

### 5.3.
~~~
Def_Ph:
```
B
```
~~~
имеет то же значение, что и `Def_Ph(B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 5.4.
```
Def_Ph(A, B)
```
будет обозначать, что `B` — это `Ph`, и для него я использую обозначение `A`.

### 5.5.
~~~
Def_Ph(A):
```
B
```
~~~
имеет то же значение, что и `Def_Ph(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 6. `Def_H`
### 6.1.
Def_C(6, `H`):
```
Гипотеза: некое предположение, требующее проверки.
```

### 6.2.
```
Def_H(B)
```
будет обозначать, что `B` — это `H`.

### 6.3.
~~~
Def_H:
```
B
```
~~~
имеет то же значение, что и `Def_H(B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 6.4.
```
Def_H(A, B)
```
будет обозначать, что `B` — это `H`, и для него я использую обозначение `A`.

### 6.5.
~~~
Def_H(A):
```
B
```
~~~
имеет то же значение, что и `Def_H(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 7. `Def_Set`
```
Def_Set(S, I)
```
будет обозначать, что `S` — множество всех возможных `I`.

## 8. `Def_I`
```
Def_I(I, S)
```
будет обозначать, что `I` — элемент множества `S`.

## 9. `Use`
```
Use(A)
```
будет обозначать, что в описываемой мной ситуации я использую `A`.

## 10.
Потенциальный клиент опубликовал на Upwork следующий проект:
### 10.1. Title
Ardupilot: Implement Positition Hold in GUIDED_NOGPS mode using SET_ATTITUDE_TARGET

### 10.2. Description
```text
The goal is to implement position hold in GUIDED_NOGPS flight mode.
There is a ROS2 topic that publish current position and orientation to the target point (will be provided). The data is available only in a radios of 1m from the target. 
Based on that data, we need to implement position hold. 
Since the data is not continuously, we VISION_POSITION_ESTIMATE.
In addition, we don't have any GPS, therefore, we have to use SET_ATTITUDE_TARGET.

Environment:
Companion computer: Jetson Orin NX (Ubuntu 22.04)
Sensor: Realsense D455
Simulator: Gazebo harmonic
ROS2 humble
C++ or Python (preferred)

step 1: Implement it in gazebo simulator
step 2: support/debug real flight
```

### 10.3. Tags
Python
C++
arudpilot
Control Engineering
Robotics

## 11. Информация о клиенте
### 11.1. Местоположение
Israel
Ramat Gan

## 11.2. Характеристики компании
### 11.2.1. Сектор экономики
неизвестно
### 11.2.2. Количество сотрудников
10-99 people

## 11.3. Характеристики учётной записи на Upwork
### 11.3.1. Member since
Apr 5, 2020
#### 11.3.2. Hire rate (%)
25
#### 11.3.3. Количество опубликованных проектов (jobs posted)
8
#### 11.3.4. Total spent
250
#### 11.3.5. Количество оплаченных часов в почасовых проектах
0

## 12.
Def(`C`):
```
клиент пункта 10
```

## 13.
Def(`P`):
```
проект пункта 10
```

## 14.
Def(`Ps`):
```
множество подобных `P` проектов 
```

## 15.
Def(`D`):
```
Описание `P` (пункт 10.2 выше)
```

## 16.
Def(`T`):
```
Конкретная подзадача, о которой `C` пишет в `D`:
~~~
implement position hold in GUIDED_NOGPS flight mode
~~~
Эта подзадача не включает следующие этапы общей задачи:
- Конфигурация Системы и Подготовка Окружения
- Разработка и Настройка Симуляционной Среды
- Интеграционное Тестирование и Отладка в Симуляторе
- Перенос Системы на Реальное Оборудование и Летные Испытания
```

## 17.
Def(`S1`):
```
Моё решение `T`:
~~~
1) Отправка сообщений `VISION_POSITION_ESTIMATE` в расширенный фильтр Калмана (EKF) во время нахождения в режиме `GUIDED_NOGPS` является архитектурно некорректной и не окажет никакого влияния на удержание позиции аппаратом:
1.1) Сообщение MAVLink `VISION_POSITION_ESTIMATE` по своему определению предназначено для передачи данных о положении от внешней системы (например, системы визуальной одометрии) напрямую в EKF полетного контроллера.
В этой парадигме EKF объединяет (fuses) эти внешние данные с показаниями инерциальных датчиков (IMU) для формирования точной оценки состояния (положения и скорости) аппарата. 
Затем полетный контроллер использует эту оценку для автономного удержания позиции в таких режимах, как `Loiter` или `Guided`. 
Для работы в таком сценарии без физического GPS-модуля необходимо соответствующим образом сконфигурировать параметры EKF, чтобы он использовал внешний источник навигации.
1.2) Полетный режим `GUIDED_NOGPS` не использует данные о положении или скорости для стабилизации и принимает исключительно команды на установку углов ориентации (`SET_ATTITUDE_TARGET`).
Он был разработан специально для того, чтобы предоставить бортовым компьютерам возможность низкоуровневого управления ориентацией аппарата, аналогично тому, как пилот управляет им в режимах `Stabilize` или `AltHold`.
Исходный код режима в файле `mode_guided_nogps.cpp` подтверждает его простоту: его основная функция заключается в вызове обработчика управления по углам (`ModeGuided::angle_control_run()`), что фактически делает его «прозрачным» каналом для команд ориентации: https://github.com/ArduPilot/ardupilot/blob/master/ArduCopter/mode_guided_nogps.cpp
2) Для задачи удержания позиции применение простого одноконтурного ПИД-регулятора, выход которого напрямую связан с углами наклона, часто приводит к нестабильности, осцилляциям и перерегулированию.
Более надежным и широко распространенным в робототехнике подходом является использование каскадной (многоконтурной) архитектуры управления:
2.1) Внешний контур (контроллер положения). 
Его задача — преобразовать ошибку положения (разницу между целевой и текущей позицией) в целевую скорость. 
Если аппарат находится справа от цели, контроллер генерирует команду на движение влево с определенной скоростью. 
Величина этой скорости пропорциональна удалению от цели. Входом для этого контура является ошибка положения `[error_x, error_y]`, а выходом — вектор целевой скорости `[target_vx, target_vy]`.
2) Внутренний контур (контроллер скорости). 
Его задача — минимизировать ошибку скорости (разницу между целевой и текущей скоростью). 
Для изменения скорости необходимо приложить ускорение. 
Таким образом, входом для этого контура является ошибка скорости, а выходом — вектор целевого ускорения `[target_ax, target_ay]`.
3) Для конкретной задачи удержания позиции в одной точке (где целевая скорость равна нулю), ахитектуру пункта 2 можно математически упростить и представить в виде единого ПИД-регулятора, работающего с ошибкой положения:
3.1) Пропорциональный член (`P`) реагирует на текущую ошибку положения: `Output_P = Kp * error`. 
Он обеспечивает основную возвращающую силу к цели.
3.2) Производный член (`D`) реагирует на скорость изменения ошибки, что эквивалентно противодействию текущей скорости аппарата: `Output_D = Kd * d(error)/dt`. 
Он выполняет функцию демпфирования, предотвращая перерегулирование и затухая колебания.
3.3) Интегральный член (`I`) накапливает ошибку с течением времени: `Output_I = Ki * integral(error)`. 
Его задача — компенсировать постоянные внешние возмущения (например, ветер) или систематические ошибки (например, неидеальную калибровку), которые приводят к статической ошибке (когда аппарат зависает не точно в цели, а с небольшим смещением).
3.4) Итоговый выход ПИД-регуляторов для каждой из горизонтальных осей (`X` и `Y`) будет представлять собой желаемое ускорение `[ax, ay]`, которое необходимо сообщить аппарату для возвращения в целевую точку.
4) ПИД-регулятор пункта 3 выдает абстрактную команду на ускорение, но квадрокоптер управляется путем изменения своей ориентации в пространстве. 
Следовательно, необходим этап преобразования, основанный на законах динамики.
Квадрокоптер создает подъемную силу, направленную в основном вдоль своей вертикальной оси (оси `Z`).
Чтобы создать горизонтальное ускорение, аппарат должен наклониться (создать крен или тангаж), направляя часть вектора тяги в горизонтальную плоскость. 
Целевые углы крена и тангажа можно рассчитать напрямую из желаемых ускорений ё[ax, ay]ё, полученных от ПИД-регуляторов:
``````
target_roll_angle = asin(ay / total_thrust_acceleration)
target_pitch_angle = -asin(ax / total_thrust_acceleration)
``````
Полученные углы Эйлера (крен, тангаж) вместе с желаемым углом рыскания (который для задачи удержания позиции можно считать постоянным, например, 0, для сохранения направления) необходимо преобразовать в кватернион. 
Сообщение `SET_ATTITUDE_TARGET` требует представления ориентации именно в этом формате.
5) Так как в вашем случае данные о положении поступают не непрерывно, наивная реализация пунктов 2-4 выше, не учитывающая возможные перерывы в поступлении данных, может привести к катастрофическим последствиям:
5.1) При прекращении поступления данных значение error в ПИД-регуляторе «замерзает». 
Интегральный член может начать бесконтрольно расти (так называемое «насыщение интегратора»), если в момент потери данных существовала статическая ошибка. 
5.2) При возобновлении поступления данных после паузы ошибка может измениться скачкообразно. 
Это вызовет огромный всплеск в производной составляющей (`d(error)/dt`), что приведет к резкой, неконтролируемой команде и рывку аппарата.
6) Правильное решение проблемы пункта 5 — постоянный мониторинг времени поступления последнего сообщения о положении. 
Управляющий цикл должен проверять разницу между текущим временем и временной меткой последнего полученного сообщения. 
Если эта разница превышает заданный порог (например, 200-500 мс), контроллер должен перейти в безопасный режим. 
~~~
```

## 18. Твоя задача
Есть ли в `S1` ошибки?