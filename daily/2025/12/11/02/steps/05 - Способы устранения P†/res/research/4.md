https://gemini.google.com/share/d0a87219fcbd

## **1. Введение и контекст проблемы**

В четвертом квартале 2024 года и начале 2025 года глобальное сообщество DevOps-инженеров и системных архитекторов столкнулось с критическим сбоем в работе инструментов управления облачной инфраструктурой Microsoft Azure. Обновление **Azure Command-Line Interface (CLI)** до версии **2.77.0** привело к массовой недоступности сервисов аутентификации и управления ресурсами в корпоративных сетях, защищенных технологиями глубокой инспекции трафика (SSL Inspection/Interception).

Проблема, классифицируемая в данном отчете как P†, проявляется в невозможности установить защищенное соединение с конечными точками управления Azure (такими как management.azure.com или login.microsoftonline.com). Пользователи получают сообщения об ошибках вида ``, часто сопровождаемые специфическими диагностическими данными: *“Basic Constraints of CA cert not marked critical”* (Основные ограничения сертификата CA не помечены как критические) или *“Missing Authority Key Identifier”* (Отсутствует идентификатор ключа центра сертификации). Эти ошибки указывают на фундаментальный конфликт между обновленными стандартами безопасности, внедренными в среду исполнения Python 3.13, и устоявшимися конфигурациями корпоративных систем защиты (Middleboxes), таких как Zscaler Internet Access (ZIA) и межсетевые экраны Palo Alto Networks (PAN-OS).1

Данный отчет ставит своей целью выполнить задачу ᛭T: провести исчерпывающий анализ причин возникновения проблемы, рассмотреть криптографические и стандартизирующие документы (в частности, RFC 5280), лежащие в основе конфликта, и систематизировать методы устранения (Mᚖ⠿). Особое внимание уделяется оценке долгосрочных последствий перехода на строгую валидацию X.509 сертификатов и выработке рекомендаций для адаптации корпоративных инфраструктур открытых ключей (PKI) к новым реалиям информационной безопасности.

## ---

**2. Архитектурный анализ изменений в Azure CLI и среде Python**

Для понимания глубины проблемы необходимо рассмотреть архитектуру Azure CLI и эволюцию его зависимостей. Azure CLI не является монолитным бинарным приложением в традиционном смысле; это сложный программный комплекс, написанный на языке Python и поставляемый вместе с интерпретатором и набором библиотек. Именно изменения в этой "подкапотной" составляющей стали триггером для рассматриваемого инцидента.

### **2.1 Эволюция среды исполнения: Переход на Python 3.13**

До версии 2.77.0 Azure CLI использовал версии интерпретатора Python 3.11 или 3.12 (в зависимости от операционной системы). Эти версии, базируясь на более старых ветках библиотеки OpenSSL, придерживались стратегии "допустимой совместимости" (permissive compatibility). Это означало, что механизмы валидации сертификатов были настроены таким образом, чтобы принимать сертификаты, имеющие незначительные отклонения от стандартов, при условии, что криптографическая подпись верна и цепочка доверия прослеживается до корневого центра сертификации (Root CA).4

Выпуск Azure CLI 2.77.0 ознаменовался переходом на **Python 3.13**. Данный релиз языка программирования включил в себя ряд существенных улучшений безопасности, направленных на устранение векторов атак, связанных с некорректной интерпретацией полей сертификатов X.509. Ключевым изменением стала модификация функции ssl.create_default_context(), которая создает контекст SSL/TLS для сетевых соединений в стандартной библиотеке.

В Python 3.13 этот контекст по умолчанию устанавливает флаг **VERIFY_X509_STRICT**. Это изменение, задокументированное в примечаниях к выпуску и документации модуля ssl, фундаментально меняет логику проверки. Если ранее приоритетом было установление соединения при наличии доверия, то теперь приоритетом является строгое соответствие структуры сертификата формальным требованиям стандарта RFC 5280.1

### **2.2 Роль библиотеки OpenSSL и флага Strict**

Python делегирует низкоуровневые криптографические операции библиотеке OpenSSL. Флаг VERIFY_X509_STRICT в Python напрямую транслируется во флаг X509_V_FLAG_X509_STRICT в OpenSSL. Активация этого режима отключает все встроенные механизмы обхода ошибок (workarounds) для устаревших или некорректно сформированных сертификатов.

В режиме строгой валидации OpenSSL проводит проверку следующих расширений сертификата:

* **Basic Constraints (Основные ограничения):** Проверяется наличие расширения в сертификатах CA и, что критически важно, наличие флага Critical.  
* **Key Usage (Использование ключа):** Проверяется соответствие заявленного назначения ключа (например, подпись сертификатов) фактическому использованию в цепочке.  
* **Authority Key Identifier (AKI):** Проверяется наличие идентификатора ключа, которым был подписан сертификат, для однозначного построения цепочки доверия.

Именно жесткость этих проверок в сочетании с широко распространенными практиками генерации сертификатов на корпоративных прокси-серверах привела к массовым отказам в обслуживании.3

### **2.3 Сравнительная характеристика версий**

| Характеристика | Azure CLI 2.76.0 | Azure CLI 2.77.0 |
| :---- | :---- | :---- |
| **Версия Python** | 3.11 / 3.12 | 3.13.x |
| **Режим SSL Context** | Permissive (Допускающий) | Strict (Строгий, RFC 5280) |
| **Флаги OpenSSL** | Стандартные | VERIFY_X509_STRICT, VERIFY_X509_PARTIAL_CHAIN |
| **Реакция на BasicConstraints: Non-Critical** | Игнорирование (Warning) | Фатальная ошибка (Fatal Error) |
| **Требование AKI** | Опционально (при наличии цепочки) | Обязательно |

Данная таблица наглядно демонстрирует, что обновление не было минорным исправлением ошибок, а представляло собой сдвиг парадигмы безопасности, к которому инфраструктура многих предприятий оказалась не готова.

## ---

**3. Теоретический базис: RFC 5280 и анатомия конфликта**

Чтобы понять, почему сертификаты, генерируемые корпоративными системами безопасности, внезапно стали считаться "нелегитимными", необходимо обратиться к первоисточнику — стандарту **RFC 5280** "Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile". Этот документ определяет структуру сертификатов версии 3 (X.509 v3) и правила их обработки.

### **3.1 Расширение Basic Constraints (OID 2.5.29.19)**

Расширение "Основные ограничения" (Basic Constraints) играет фундаментальную роль в иерархии доверия PKI. Оно выполняет две функции: определяет, является ли данный субъект центром сертификации (CA), и ограничивает глубину цепочки сертификации, которая может следовать за данным сертификатом.

Текст стандарта RFC 5280 в разделе 4.2.1.9 содержит императивное требование:

"Conforming CAs **MUST** include this extension in all CA certificates that contain public keys used to validate digital signatures on certificates and **MUST mark the extension as critical** in such certificates."

*(Перевод: Соответствующие стандарту CA **ОБЯЗАНЫ** включать это расширение во все сертификаты CA, содержащие открытые ключи, используемые для проверки цифровых подписей на сертификатах, и **ОБЯЗАНЫ помечать это расширение как критическое** в таких сертификатах.)*.7

Смысл требования критичности (Critical: TRUE) заключается в предотвращении ошибочной интерпретации. Если программное обеспечение не умеет обрабатывать расширение Basic Constraints, но видит флаг Critical, оно обязано отвергнуть сертификат. Это защитный механизм: если ПО не понимает, что перед ним CA, оно не должно доверять этому сертификату право подписывать другие сертификаты. Если же флаг не установлен (Critical: FALSE), старое или некорректно написанное ПО могло проигнорировать расширение и ошибочно принять сертификат конечного пользователя за CA, что открывает вектор атаки для повышения привилегий в системе доверия.

Проблема P† возникает именно здесь: многие системы SSL-инспекции (Zscaler, Palo Alto) генерируют промежуточные сертификаты CA с параметром CA:TRUE, но помечают само расширение как Critical:FALSE.3 Для Python 3.13 в строгом режиме это является нарушением императива "MUST mark... as critical", что ведет к немедленному разрыву соединения.

### **3.2 Расширение Key Usage (OID 2.5.29.15)**

Расширение "Использование ключа" (Key Usage) определяет криптографические операции, для которых предназначен открытый ключ в сертификате. Для центров сертификации, которые подписывают другие сертификаты (как это делают прокси-серверы при генерации поддельных сертификатов для инспекции), должен быть установлен бит keyCertSign.

RFC 5280 раздел 4.2.1.3 гласит:

"Conforming CAs **MUST** include this extension in certificates that contain public keys that are used to validate digital signatures on other public key certificates or CRLs."

*(Перевод: Соответствующие стандарту CA **ОБЯЗАНЫ** включать это расширение в сертификаты... используемые для проверки подписей на других сертификатах.)*.7

Более того, существует прямая связь между Key Usage и Basic Constraints:

"If the keyCertSign bit is asserted, then the cA bit in the basic constraints extension (Section 4.2.1.9) **MUST** also be asserted."

*(Перевод: Если установлен бит keyCertSign, то бит cA в расширении основных ограничений **ОБЯЗАН** быть также установлен.)*.9

В контексте проблемы P† часто наблюдается ситуация, когда корпоративный прокси либо не включает расширение Key Usage вовсе (полагаясь на старое поведение "по умолчанию можно всё"), либо включает его без соответствующего корректного оформления Basic Constraints. Ошибка "Missing Key Usage" или несоответствие битов использования ключа в строгом режиме также приводит к сбою валидации.

### **3.3 Authority Key Identifier (OID 2.5.29.35)**

Третьим элементом пазла является идентификатор ключа центра сертификации (AKI). Python 3.13 ввел проверку на наличие этого расширения для построения цепочек. AKI помогает клиенту быстро найти родительский сертификат в хранилище. Если промежуточный сертификат, сгенерированный прокси, не содержит AKI, или использует ссылку на имя издателя (DirName) в формате, который OpenSSL не может однозначно разрешить, возникает ошибка *“Missing Authority Key Identifier”*.10

Это требование также опирается на RFC 5280, который рекомендует ("SHOULD") использовать AKI для облегчения построения пути сертификации, но в реалиях строгого режима рекомендация де-факто превращается в обязательное условие для успешной валидации библиотекой OpenSSL 3.0+.

## ---

**4. Механика сбоя в корпоративной среде**

Рассмотрим детально, как именно происходит сбой при взаимодействии Azure CLI 2.77.0 с типичным корпоративным шлюзом безопасности (Secure Web Gateway).

### **4.1 Сценарий "Человек посередине" (MITM)**

В корпоративных сетях для защиты от утечек данных и угроз нулевого дня применяется технология SSL Inspection (или TLS Interception). Устройства таких вендоров, как Zscaler, Palo Alto Networks, Fortinet или Check Point, перехватывают исходящие TLS-соединения.

1. **Инициация:** Пользователь вводит команду az login. Клиент Azure CLI инициирует TLS-рукопожатие (Client Hello) с сервером login.microsoftonline.com.  
2. **Перехват:** Корпоративный шлюз перехватывает этот запрос. Он устанавливает собственное защищенное соединение с реальным сервером Microsoft.  
3. **Генерация подделки:** Шлюз динамически генерирует сертификат X.509 для домена login.microsoftonline.com. Этот сертификат подписывается закрытым ключом внутреннего "Промежуточного CA" (Intermediate CA), который установлен на шлюзе.  
4. **Презентация:** Шлюз отправляет этот сгенерированный сертификат (и цепочку, ведущую к Промежуточному CA) обратно клиенту Azure CLI.

### **4.2 Точка отказа**

Именно в момент получения цепочки сертификатов от шлюза происходит сбой в Azure CLI 2.77.0.

* **Доверие (Trust):** Корневой сертификат организации (Root CA), который подписал Промежуточный CA шлюза, обычно распространен на рабочие станции через групповые политики (GPO). Следовательно, с точки зрения *доверия*, цепочка легитимна.  
* **Соответствие (Compliance):** Python 3.13 запускает процедуру проверки VERIFY_X509_STRICT для Промежуточного CA, полученного от шлюза.  
  * Проверка видит расширение Basic Constraints.  
  * Она считывает флаг Critical.  
  * В конфигурациях Zscaler/Palo Alto по умолчанию этот флаг часто установлен в FALSE (для совместимости с устаревшими клиентами, которые могли падать при виде критических расширений).  
  * **Вердикт:** Сертификат признается *некорректным* (malformed). Рукопожатие прерывается.

Пользователь видит ошибку SSL, несмотря на то, что корневой сертификат установлен и доверен. Это ключевое отличие от классических ошибок SSL, связанных с отсутствием доверия. Здесь проблема не в том, "кем" подписан сертификат, а в том, "как" он составлен.3

## ---

**5. Анализ методов устранения (Mᚖ⠿)**

Основываясь на проведенном исследовании, можно выделить три основные категории методов решения проблемы: тактические (откат версий), стратегические (исправление инфраструктуры) и клиентские (модификация среды доверия).

### **Метод 1: Откат версии Azure CLI (Тактический)**

Этот метод, обозначенный как приоритетный для оперативного восстановления работоспособности, заключается в возврате к версии Azure CLI 2.76.0.

Анализ эффективности:  
Версия 2.76.0 использует Python 3.11/3.12, который не применяет флаг VERIFY_X509_STRICT по умолчанию. Следовательно, валидация сертификатов происходит в "разрешительном" режиме, и некорректные сертификаты корпоративных прокси принимаются, как и раньше.  
Процедура реализации (Windows):  
Использование диспетчера пакетов winget позволяет точно зафиксировать версию, избегая случайных обновлений.

1. Удаление текущей версии: winget uninstall --id Microsoft.AzureCLI. Это критически важно для корректной очистки библиотек Python 3.13.11  
2. Установка версии 2.76.0: winget install --exact --id Microsoft.AzureCLI --version 2.76.0.11  
3. Альтернативно, использование MSI установщика: Ссылка на архивный дистрибутив https://azcliprod.blob.core.windows.net/msi/azure-cli-2.76.0-x64.msi.12

Процедура реализации (macOS/Linux):  
Для macOS через Homebrew откат затруднен из-за архитектуры репозитория, требующей извлечения конкретного коммита формулы (formula).13 Для Linux, использующего pip, команда pip install azure-cli==2.76.0 является стандартным решением.  
**Достоинства:**

* Мгновенное восстановление работы бизнес-процессов.  
* Не требует вмешательства в глобальные настройки безопасности сети (нет необходимости привлекать отдел ИБ).  
* Предсказуемое поведение инструмента.

**Недостатки:**

* Накопление технического долга: фиксация на старой версии лишает доступа к новым функциям Azure.  
* Угроза безопасности: со временем версия 2.76.0 станет уязвимой для новых эксплойтов.  
* Необходимость отключения автообновлений (az config set auto-upgrade.enable=no).14

### ---

**Метод 2: Модернизация PKI Инфраструктуры (Стратегический)**

Это единственное фундаментальное решение проблемы, устраняющее первопричину — несоответствие сертификатов стандарту RFC 5280. Оно требует переконфигурации систем инспекции трафика.

**Сценарий А: Zscaler Internet Access (ZIA)**

В Zscaler проблема часто кроется в использовании "Default Intermediate Certificate", который генерируется системой автоматически с устаревшими параметрами. Решением является генерация собственного Промежуточного CA и его загрузка в Zscaler.

1. **Генерация CSR и ключа:** Необходимо создать запрос на сертификат (CSR) для Промежуточного CA.  
2. **Конфигурация OpenSSL:** Критически важно использовать конфигурационный файл, явно задающий критичность расширений. Пример секции конфигурации:  
   Ini, TOML  
   [ v3_intermediate_ca ]  
   basicConstraints = critical, CA:true  
   keyUsage = critical, digitalSignature, cRLSign, keyCertSign  
   subjectKeyIdentifier = hash  
   authorityKeyIdentifier = keyid:always,issuer

   Здесь явно указано critical для Basic Constraints и Key Usage, что удовлетворяет требованиям Python 3.13.15  
3. **Импорт в Zscaler:** Загрузка подписанного сертификата через консоль администратора: **Policy > SSL Inspection > Intermediate CA Certificates**. Необходимо убедиться, что выбран режим использования "Custom Certificate".16

**Сценарий Б: Palo Alto Networks (PAN-OS)**

В PAN-OS за инспекцию отвечает сертификат "Forward Trust".

1. **Аудит сертификата:** В разделе **Device > Certificate Management > Certificates** необходимо проверить свойства текущего сертификата Forward Trust. Если он был сгенерирован средствами самого Firewall на старых версиях OS, он может не иметь критических флагов.  
2. **Настройка Decryption Profile:** В профиле дешифрования (SSL Forward Proxy) существует настройка **"Restrict certificate extensions"** (Ограничить расширения сертификата). Эта опция принудительно оставляет только Key Usage и Extended Key Usage в поддельных сертификатах. Однако, если исходный CA (Forward Trust) сам по себе некорректен (нет Critical Basic Constraints), эта настройка не спасет.  
3. **Импорт корректного CA:** Рекомендуется сгенерировать CA на внешней, полноценной PKI (например, Microsoft CA или OpenSSL) с соблюдением всех требований RFC 5280, и импортировать его в PAN-OS как Forward Trust Certificate, вместо использования самоподписанных сертификатов, сгенерированных на устройстве.17

**Достоинства:**

* Решает проблему не только для Azure CLI, но и для любых будущих инструментов, использующих современные стеки (Python 3.13+, Go, Rust, OpenSSL 3.0).  
* Повышает общий уровень безопасности и соответствия стандартам.

**Недостатки:**

* Высокая сложность реализации: требует прав администратора безопасности и доступа к корневым CA.  
* Риск простоя: ошибка при ротации сертификата инспекции может привести к глобальному сбою доступа в интернет для всей организации.

### ---

**Метод 3: Клиентские модификации доверия (Ограниченная эффективность)**

Попытки решить проблему через модификацию клиентского хранилища доверия, такие как использование пакета pip-system-certs или переменных окружения, показывают смешанные результаты.

Анализ pip-system-certs:  
Этот пакет предназначен для того, чтобы заставить Python доверять системному хранилищу сертификатов Windows (где корпоративный Root CA уже есть), вместо встроенного хранилища certifi.  
Однако, в случае с Azure CLI 2.77.0 этот метод часто оказывается неэффективным. Причина кроется в механике проверки: pip-system-certs решает проблему доверия (Trust), но не проблему валидации структуры (Validation/Compliance). Даже если Python "видит" доверенный корень через системное хранилище, библиотека OpenSSL, работающая в строгом режиме, отвергает промежуточный сертификат из-за отсутствия флага Critical в Basic Constraints еще до того, как проверка доверия завершится успехом. Строгая проверка синтаксиса сертификата в OpenSSL 3.0 имеет приоритет.3  
Новый пакет truststore:  
Начиная с Python 3.10, доступен пакет truststore, который использует нативные API операционной системы (CryptoAPI для Windows, Security framework для macOS) для проверки сертификатов, вместо OpenSSL. Теоретически, это могло бы решить проблему, так как Windows CryptoAPI более лоялен к старым сертификатам, чем OpenSSL в строгом режиме. Однако внедрение truststore в скомпилированный бинарный пакет Azure CLI требует модификации исходного кода точки входа приложения (az.cmd или python скриптов запуска), что сложно автоматизировать и ненадежно при обновлениях.19  
**Достоинства:**

* Не требует прав администратора сети.  
* Позволяет использовать новые версии ПО (теоретически).

**Недостатки:**

* Низкая надежность в контексте ошибки Basic Constraints.  
* Сложность внедрения в "замороженные" среды, такие как MSI-инсталляции Azure CLI.

## ---

**6. Стратегические выводы и рекомендации**

Инцидент с Azure CLI 2.77.0 является симптомом более масштабного процесса, происходящего в индустрии программного обеспечения — так называемого "затвердевания" протоколов (protocol ossification) в сторону безопасности по умолчанию. Разработчики языков программирования и криптографических библиотек (Python, OpenSSL, Go) больше не готовы мириться с техническим долгом, накопленным в корпоративных PKI за десятилетия использования "достаточно хороших", но не соответствующих стандартам сертификатов.

### **Рекомендации**

1. Оперативное реагирование (SLA < 24 часов):  
   Всем пользователям Azure CLI в корпоративных сетях Zscaler/Palo Alto рекомендуется выполнить даунгрейд до версии 2.76.0. Это единственное гарантированное решение для немедленного восстановления работоспособности. Необходимо заблокировать автообновление на рабочих станциях разработчиков и CI/CD агентах.  
2. Плановое исправление (SLA 1-3 месяца):  
   Департаментам информационной безопасности необходимо инициировать аудит всех внутренних выпускающих центров сертификации (Issuing CAs), используемых для SSL-инспекции. Используя команду openssl verify -x509_strict, следует проверить текущие сертификаты на соответствие RFC 5280.  
   Необходимо запланировать перевыпуск сертификатов инспекции с обязательным включением расширения Basic Constraints: Critical, CA:TRUE и Key Usage: Critical, keyCertSign.  
3. Мониторинг зависимостей:  
   DevOps-инженерам следует рассматривать Azure CLI не просто как утилиту, а как сложный программный стек. Отслеживание версий встроенного интерпретатора Python в инструментах (AWS CLI, gcloud, Azure CLI) должно стать частью процесса управления уязвимостями, так как изменения в runtime (как переход 3.12 -> 3.13) могут иметь непропорционально большое влияние на доступность сервисов.

В заключение, проблема P† демонстрирует, что в современном ландшафте безопасности строгое соблюдение стандартов IETF перестает быть теоретической рекомендацией и становится жестким требованием для функционирования базовых инструментов разработки. Игнорирование требований RFC 5280 в настройках прокси-серверов более недопустимо.

---

Используемые источники:  
В отчете использованы данные из технических бюллетеней и документации, идентифицированные как.1

#### **Works cited**

1. What's New In Python 3.13 — Python 3.14.2 documentation, accessed December 14, 2025, [https://docs.python.org/3/whatsnew/3.13.html](https://docs.python.org/3/whatsnew/3.13.html)  
2. Python v3.13 has broken Email delivery due to an SSL change - Stack Overflow, accessed December 14, 2025, [https://stackoverflow.com/questions/79358216/python-v3-13-has-broken-email-delivery-due-to-an-ssl-change](https://stackoverflow.com/questions/79358216/python-v3-13-has-broken-email-delivery-due-to-an-ssl-change)  
3. Change in python 3.13 that breaks certificate trust - Zscaler Community, accessed December 14, 2025, [https://community.zscaler.com/s/question/0D54u0000AfJDtECQW/change-in-python-313-that-breaks-certificate-trust](https://community.zscaler.com/s/question/0D54u0000AfJDtECQW/change-in-python-313-that-breaks-certificate-trust)  
4. Does Python 3.13 ignore SSL_CERT_FILE environment variable by design?, accessed December 14, 2025, [https://stackoverflow.com/questions/79123649/does-python-3-13-ignore-ssl-cert-file-environment-variable-by-design](https://stackoverflow.com/questions/79123649/does-python-3-13-ignore-ssl-cert-file-environment-variable-by-design)  
5. Login to Azure Devops Server - Failed to authenticate using the supplied token #32378, accessed December 14, 2025, [https://github.com/Azure/azure-cli/issues/32378](https://github.com/Azure/azure-cli/issues/32378)  
6. ssl — TLS/SSL wrapper for socket objects — Python 3.14.2 documentation, accessed December 14, 2025, [https://docs.python.org/3/library/ssl.html](https://docs.python.org/3/library/ssl.html)  
7. RFC 5280 - Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile - IETF Datatracker, accessed December 14, 2025, [https://datatracker.ietf.org/doc/html/rfc5280](https://datatracker.ietf.org/doc/html/rfc5280)  
8. cRLSign key usage enforcement · strongswan strongswan · Discussion #1548 - GitHub, accessed December 14, 2025, [https://github.com/strongswan/strongswan/discussions/1548](https://github.com/strongswan/strongswan/discussions/1548)  
9. Can someone explain the "Section 4.2.1.3. Key Usage" extension in RFC 5280 as it relates to TLS 1.2 RFC 5246 - Information Security Stack Exchange, accessed December 14, 2025, [https://security.stackexchange.com/questions/224736/can-someone-explain-the-section-4-2-1-3-key-usage-extension-in-rfc-5280-as-it](https://security.stackexchange.com/questions/224736/can-someone-explain-the-section-4-2-1-3-key-usage-extension-in-rfc-5280-as-it)  
10. 2.77.0 raises error: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: Missing Authority Key Identifier (_ssl.c:1032) #32083 - GitHub, accessed December 14, 2025, [https://github.com/Azure/azure-cli/issues/32083](https://github.com/Azure/azure-cli/issues/32083)  
11. Azure CLI fails after updating from 2.67.0 to 2.77.0 on Azure DevOps ubuntu-latest #32041, accessed December 14, 2025, [https://github.com/Azure/azure-cli/issues/32041](https://github.com/Azure/azure-cli/issues/32041)  
12. Install the Azure CLI on Windows - Microsoft Learn, accessed December 14, 2025, [https://learn.microsoft.com/en-us/cli/azure/install-azure-cli-windows?view=azure-cli-latest](https://learn.microsoft.com/en-us/cli/azure/install-azure-cli-windows?view=azure-cli-latest)  
13. Upgrade to 2.77.0 from 2.76.0 broke installation leaving it in an unusable state · Issue #32064 · Azure/azure-cli - GitHub, accessed December 14, 2025, [https://github.com/Azure/azure-cli/issues/32064](https://github.com/Azure/azure-cli/issues/32064)  
14. How to update the Azure CLI | Microsoft Learn, accessed December 14, 2025, [https://learn.microsoft.com/en-us/cli/azure/update-azure-cli?view=azure-cli-latest](https://learn.microsoft.com/en-us/cli/azure/update-azure-cli?view=azure-cli-latest)  
15. Software Developer TLS Solution | ZIA Integration Guide - Zscaler, accessed December 14, 2025, [https://www.zscaler.com/resources/white-papers/software-developer-tls-guide.pdf](https://www.zscaler.com/resources/white-papers/software-developer-tls-guide.pdf)  
16. Configuring Software Protection Intermediate CA Certificate - Zscaler Help, accessed December 14, 2025, [https://help.zscaler.com/zia/configuring-software-protection-intermediate-ca-certificate](https://help.zscaler.com/zia/configuring-software-protection-intermediate-ca-certificate)  
17. Palo Alto Guide | PDF | Firewall (Computing) | Port (Computer Networking) - Scribd, accessed December 14, 2025, [https://www.scribd.com/document/587288394/Palo-Alto-Guide](https://www.scribd.com/document/587288394/Palo-Alto-Guide)  
18. SSL Forward Proxy Decryption Profile - Palo Alto Networks, accessed December 14, 2025, [https://docs.paloaltonetworks.com/pan-os/11-0/pan-os-admin/decryption/decryption-concepts/ssl-forward-proxy-decryption-profile](https://docs.paloaltonetworks.com/pan-os/11-0/pan-os-admin/decryption/decryption-concepts/ssl-forward-proxy-decryption-profile)  
19. Unable to get local issuer certificate when using requests - Stack Overflow, accessed December 14, 2025, [https://stackoverflow.com/questions/51925384/unable-to-get-local-issuer-certificate-when-using-requests](https://stackoverflow.com/questions/51925384/unable-to-get-local-issuer-certificate-when-using-requests)  
20. User guide | Red Hat OpenShift Dev Spaces | 3.13, accessed December 14, 2025, [https://docs.redhat.com/en/documentation/red_hat_openshift_dev_spaces/3.13/html-single/user_guide/index](https://docs.redhat.com/en/documentation/red_hat_openshift_dev_spaces/3.13/html-single/user_guide/index)