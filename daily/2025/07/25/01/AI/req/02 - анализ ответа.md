## 1. `Def`
~~~
Def(A):
```
B
```
~~~
будет обозначать, что для понятия `B` я использую обозначение `A`.

## 2. `Def_P`
~~~
Def_P(A):
```
B
```
~~~
будет обозначать, что `B` является для меня проблемой, и для этой проблемы я использую обозначение `A`.

## 3. `Def_C`
### 3.1.
```
Def_C(P, A, B)
```
будет обозначать `Def(A, B)` в контексте пункта `P`.
Вне пункта `P` это правило не применяется.
Если до пункта `P` обозначение `A` имело другой смысл, то после пункта `P` обозначение `A` снова будет иметь этот смысл.
По сути, `Def_C` объявляет локальную переменную `A` с областью действия `P`.
В отличие от него, `Def` объявляет глобальную переменную `A` (значение которой действует для всех пунктов, кроме `P`).

### 3.2.
~~~
Def_C(P, A):
```
B
```
~~~
имеет то же значение, что и `Def_C(P, A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 3.3.
```
Def_C([P1, P2, …, Pn], A, B)
```
имеет значение, аналогичное `Def_C(P, A, B)`, только в этом случае обозначение `A` имеет значение `B` в контексте не одного пункта `P`, а всех пунктов [`P1`, `P2`, …, `Pn`], перечисленных в квадратных скобках.

### 3.4.
```
Def_C([P1-Pn], A, B)
```
имеет значение, аналогичное `Def_C([P1, P2, …, Pn], A, B)`: в этом случае обозначение `A` имеет значение `B` в контексте множества всех пунктов между `P1` и `Pn`, включая сами эти пункты.

### 3.5.
~~~
Def_C([P1, P2, …, Pn], A):
```
B
```
~~~
имеет то же значение, что и `Def_C([P1, P2, …, Pn], A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 3.6.
~~~
Def_C([P1-Pn], A):
```
B
```
~~~
имеет то же значение, что и `Def_C([P1-Pn], A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 4. `Def_F`
### 4.1.
Def_C(4-5, `F`):
```
Факт: некое событие, которое случилось в описываем мной случае.
```

### 4.2.
~~~
Def_F:
```
B
```
~~~
будет обозначать, что `B` — это `F`.

### 4.3.
~~~
Def_F(A):
```
B
```
~~~
будет обозначать, что `B` — это `F`, и для него я использую обозначение `A`.

## 5. `Def_Ph`
### 5.1.
Def_C(5, `Ph`):
```
Феномен: `F`, который вызывает у меня удивление.
```

### 5.2.
~~~
Def_Ph(A):
```
B
```
~~~
будет обозначать, что `B` — это `Ph`, и для него я использую обозначение `A`.

## 6. `Def_H`
### 6.1.
Def_C(6, `H`):
```
Гипотеза: некое предположение, требующее проверки.
```

### 6.2.
~~~
Def_H(A):
```
B
```
~~~
будет обозначать, что `B` — это `H`, и для него я использую обозначение `A`.

## 7. `Def_Set`
### 7.1.
```
Def_Set(S, I)
```
будет обозначать, что `S` — множество всех возможных `I`.

### 7.2.
```
Def_Set(S, {I1, I2, …, In})
```
будет обозначать, что `S` — множество, заданное точным перечислением всех его элементов: {`I1`, `I2`, …, `In`}.

## 8. `Def_I`
### 8.1.
```
Def_I(I, S)
```
будет обозначать, что `I` ∈ `S` (`I` — элемент множества `S`).

### 8.2.
~~~
Def_I(I, S):
```
B
```
~~~
будет обозначать, что `I` ∈ `S` и `B` — определение `I`.

## 9. `Use`
```
Use(A)
```
будет обозначать, что в описываемой мной ситуации я использую `A`.

## 10.
Потенциальный клиент опубликовал на Upwork следующий проект:
### 10.1. Title
EntraId and Keycloak Configuration Expert Needed

### 10.2. Description
```text
We are seeking an EntraId expert to assist in configuring Authorization using Keycloak. 
The ideal candidate should possess a strong understanding of both EntraId and Keycloak platforms to effectively manage user authentication and authorization processes. 
Your expertise will be crucial in ensuring seamless integration and optimal functionality. 
If you have experience in identity management systems and a passion for delivering high-quality results, we would love to hear from you!
```

### 10.3. Tags
Java
JavaScript
PHP
Amazon Web Services
Network Administration

## 11. Информация о клиенте
### 11.1. Местоположение
United States

## 11.2. Характеристики компании
### 11.2.1. Сектор экономики
Tech & IT
### 11.2.2. Количество сотрудников
10-99

## 11.3. Характеристики учётной записи на Upwork
### 11.3.1. Member since
Aug 31, 2022
#### 11.3.2. Hire rate (%)
0
#### 11.3.3. Количество опубликованных проектов (jobs posted)
3
#### 11.3.4. Total spent (USD)
0
#### 11.3.5. Количество оплаченных часов в почасовых проектах
0

## 12.
Def(`C`):
```
клиент пункта 10
```

## 13.
Def(`P`):
```
проект пункта 10
```

## 14.
Def(`PD`):
```
Описание `P` (пункт 10.2 выше)
```

## 15.
Def(`T`):
```
Задача, о которой `C` пишет в `PD`:
~~~
configuring Authorization using Keycloak
~~~
```

## 16.
Def(`D`, «мой ответ `C`»).

## 17.
Содержание `D`:
~~~markdown
1) Я рекомендую следующий авторизации с использованием Microsoft Entra ID (`EI`) и Keycloak (`K`):
1.1) В основе предлагаемого решения лежит архитектурный паттерн «Identity Brokering», также известный как «Identity Federation». 
`K` обладает встроенной поддержкой данного паттерна, позволяя делегировать процесс аутентификации внешнему, доверенному поставщику удостоверений, который в данном контексте именуется «Identity Provider» (`IP`).
1.2) `EI` выступает в роли авторитетного `IP`.
Это означает, что именно `EI` отвечает за хранение учётных данных пользователей, проверку их подлинности (аутентификацию) и предоставление информации об этих пользователях.
1.3) `K`, в свою очередь, конфигурируется как «Identity Broker»: промежуточный сервис, который устанавливает доверительные отношения с `EI`. 
Конечное клиентское приложение (`A`) не взаимодействует с `EI` напрямую. 
Вместо этого оно полностью доверяет `K`, который предоставляет ему унифицированный интерфейс для аутентификации и авторизации.
2) Мой подход (пункт 1) создаёт важный слой абстракции, который даёт следующие преимущества: 
2.1) Централизация управления `IP`. 
Если в будущем потребуется добавить других поставщиков удостоверений (например, Google, Facebook или другой корпоративный SAML `IP`), все изменения будут производиться централизованно в `K`. 
`A` останется неизменным, так как оно по-прежнему будет взаимодействовать только с `K`. 
2.2) Упрощение `A`. 
Разработчикам `A` не нужно реализовывать логику для взаимодействия с различными протоколами и API множества `IP`. 
Им достаточно интегрироваться с одним сервисом (`K`) по одному стандартизированному протоколу.
2.3) Обогащение и трансформация токенов. 
`K` может получать информацию от внешнего `IP`, а затем обогащать или преобразовывать её перед передачей `A`. 
Например, он может сопоставлять группы из `EI` с внутренними ролями `K`.
3) В моём подходе `K` выполняет двойную роль:
3.1) С точки зрения `A`, `K` является его `IP`. 
`A` обращается к `K` за аутентификацией и получает от него токены. 
3.2) С точки зрения `EI`, `K` — это клиентское приложение, которое запрашивает аутентификацию. 
В терминологии протоколов он выступает как «Service Provider» (`SP`) или «Relying Party» (`RP`). 
4) Двойственность пункта 3 имеет критическое значение при диагностике проблем. 
Например, сбой аутентификации может быть связан либо с токеном, который `K` получает от `EI` (его роль как `SP`/`RP`), либо с токеном, который он выдаёт конечному приложению (его роль как `IP`).
Чёткое разграничение этих ролей позволяет точно локализовать источник проблемы.
5) `K` поддерживает два основных протокола для федерации удостоверений: Security Assertion Markup Language 2.0 (SAML) и OpenID Connect 1.0 (`OIDC`).
Я рекомендую в вашем случае `OIDC` по следующим причинам:
5.1) Учитывая технологический стек проекта, указанный вами в тегах (Java, JavaScript, PHP, Amazon Web Services), который явно ориентирован на современные веб-технологии и облачные сервисы
5.2) `OIDC` — это более современный стандарт, построенный как простой слой идентификации поверх протокола авторизации OAuth 2.0. 
Для передачи данных `OIDC` использует формат JSON и токены JWT («JSON Web Tokens»). 
Он изначально проектировался с учётом потребностей современных веб-приложений, мобильных клиентов и RESTful API.
6) Общая схема взаимодействия:
6.1) Пользователь (`U`) пытается получить доступ к защищённому ресурсу в `A`.
6.2) `A`, обнаружив отсутствие активной сессии, перенаправляет `U` на страницу входа `K`.
6.3) `K`, в свою очередь, видит, что `U` не аутентифицирован, и перенаправляет его на сконфигурированный внешний `IP`: `EI`.
6.4) `U` вводит свои корпоративные учётные данные на странице входа `EI` и успешно проходит аутентификацию.
6.5) `EI` генерирует «ID Token» (`T`), содержащий claims о `U`, включая его идентификаторы групп, и перенаправляет браузер `U` обратно на специальный «Redirect URI» в `K`.
6.6) `K` получает `T` от `EI`, проверяет его цифровую подпись и валидность.
6.7) `K` извлекает из `T` claims. 
6.8) На основе claims `K` либо создаёт в своей БД новую учётную запись для `U`, либо обновляет  существующую. 
На этом же этапе происходит ключевой процесс — сопоставление (маппинг) идентификаторов групп из claim «groups» на внутренние роли `K`. 
6.9) `K` создаёт собственную сессию для `U`.
6.10) `K` генерирует собственные токены (`K-TT`) для `A`:
- Собственный «ID Token» (не путать с `T`) 
- «Access Token». 

`K-TT` содержат роли, которые были назначены `U` внутри `K`. 
6.11) `K` перенаправляет браузер `U` обратно на «Redirect URI» `A`.
6.12) `A` получает `K-TT` от `K`, валидирует их и извлекает из них информацию о ролях `U`. 
6.13) `A` принимает решение о предоставлении или запрете доступа `U` к запрошенному ресурсу.
~~~

## 18.
Есть ли в `D` ошибки?