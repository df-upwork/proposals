https://gemini.google.com/share/1908ca458abf


## **1. Введение: Смена парадигмы безопасности и наследие технического долга**

Выпуск версии Azure CLI 2.77.0, в которую был интегрирован интерпретатор Python 3.13, стал переломным моментом в управлении безопасными соединениями в средах DevOps. Данное событие спровоцировало масштабный сбой в корпоративных инфраструктурах по всему миру, проявившийся в невозможности аутентификации и взаимодействия с облачными сервисами Azure при работе через прокси-серверы с перехватом SSL (SSL inspection) или при использовании частных центров сертификации (Private CA). Корень проблемы кроется не в дефекте кода самого Azure CLI, а в фундаментальном изменении в политике безопасности среды выполнения Python 3.13, которая по умолчанию активировала строгое соблюдение стандарта RFC 5280.1

Этот инцидент представляет собой не просто программную ошибку, а структурное столкновение между современными стандартами программной безопасности и инерцией корпоративных инфраструктур открытых ключей (PKI). В течение десятилетий реализации SSL/TLS в скриптовых языках и утилитах командной строки сохраняли определенную степень толерантности к отклонениям от стандартов X.509. Эта снисходительность позволяла существовать и функционировать технически некорректным, но операционно работоспособным сертификатам. Такие сертификаты, генерируемые устройствами глубокого анализа трафика (DPI) и "Man-in-the-Middle" (MITM) шлюзами, часто игнорировали критические расширения X.509 v3, требуемые Инженерным советом Интернета (IETF).4

Переход на Python 3.13 ознаменовал конец эры "молчаливого согласия" с нарушениями стандартов. Ошибки, с которыми столкнулись инженеры — certificate verify failed: CA cert does not include key usage extension и Missing Authority Key Identifier, — свидетельствуют о категорическом отказе клиента принимать цепочки доверия, не прошедшие строгую валидацию. Этот отчет ставит своей целью предоставить исчерпывающий технический анализ механизмов сбоя, исследовать криптографические причины конфликта между OpenSSL и устаревшими PKI, а также предложить детализированные стратегии восстановления работоспособности критически важных бизнес-процессов.5

### **1.1 Масштаб и векторы воздействия**

Проблема носит системный характер и затрагивает широкий спектр операционных сред, где Azure CLI 2.77.0 был установлен через MSI-пакеты (Windows), Homebrew (macOS) или стандартные менеджеры пакетов Linux, обновившие встроенную версию Python. В зону риска попадают инфраструктуры, обладающие следующими характеристиками:

1. **Активная SSL-инспекция:** Весь исходящий HTTPS-трафик перехватывается, дешифруется и заново шифруется пограничным шлюзом (например, Zscaler, Palo Alto Networks, Blue Coat), который динамически генерирует поддельные сертификаты для целевых ресурсов.  
2. **Частная PKI:** Использование самоподписанных корневых или промежуточных сертификатов для защиты внутренних сервисов, сгенерированных без строгого соблюдения профилей расширений X.509 v3.  
3. **Среда выполнения Python 3.13:** Использование версий инструментов, жестко привязанных к новому рантайму Python, который внедрил критические изменения в логику верификации сертификатов.7

## ---

**2. Архитектура доверия: Стандарты X.509 и императивы RFC 5280**

Для глубокого понимания природы ошибки "CA cert does not include key usage extension" необходимо погрузиться в технические детали стандартов, регулирующих инфраструктуру открытых ключей. Ошибка указывает на несоответствие сертификата требованиям RFC 5280, который определяет профиль использования сертификатов X.509 v3 в интернете.

### **2.1 Расширение Key Usage (Секция 4.2.1.3)**

Расширение Key Usage (использование ключа) является одним из фундаментальных элементов безопасности в сертификатах X.509. Оно определяет криптографические операции, для которых может быть использован открытый ключ, содержащийся в сертификате. Согласно RFC 5280, секция 4.2.1.3, для того чтобы сертификат мог функционировать как сертификат Удостоверяющего Центра (Certificate Authority — CA), то есть иметь право подписывать другие сертификаты, он должен соответствовать строгим критериям.9

Во-первых, бит keyCertSign (бит 5) в битовой строке Key Usage должен быть установлен в значение 1. Это явное разрешение на использование приватного ключа для проверки подписей на других сертификатах открытых ключей. Без этого бита любой сертификат, даже если он технически способен создать подпись, юридически и криптографически не имеет права выступать в роли эмитента.11

Во-вторых, существует жесткая зависимость между расширениями. Если бит keyCertSign установлен, то в сертификате также должно присутствовать расширение Basic Constraints (Основные ограничения), описанное в секции 4.2.1.9, и в этом расширении булево значение cA должно быть установлено в TRUE. Эта связка гарантирует, что сущность не только имеет техническую возможность подписывать (через Key Usage), но и обладает административным статусом CA (через Basic Constraints). Python 3.13 в режиме строгой проверки рассматривает отсутствие keyCertSign у сертификата, который пытается валидировать следующий сертификат в цепочке, как фатальное нарушение протокола.12

### **2.2 Authority Key Identifier (AKI) (Секция 4.2.1.1)**

Вторым распространенным вектором сбоя является отсутствие расширения Authority Key Identifier (Идентификатор ключа центра сертификации). Это расширение, описанное в секции 4.2.1.1 RFC 5280, предоставляет механизм для идентификации открытого ключа, соответствующего закрытому ключу, который был использован для подписи сертификата. AKI критически важен для построения правильной цепочки сертификации (certification path construction), особенно в сложных PKI-иерархиях, где у одного CA может быть несколько пар ключей или когда происходят перевыпуски сертификатов.9

Стандарт RFC 5280 однозначно гласит, что расширение AKI "ДОЛЖНО присутствовать во всех сертификатах, генерируемых соответствующими стандартам CA, для облегчения построения пути сертификации", за единственным исключением — корневого самоподписанного сертификата, где эмитентом является сама сущность. Ошибка certificate verify failed: Missing Authority Key Identifier, зафиксированная в многочисленных отчетах пользователей Azure CLI, указывает на то, что промежуточные сертификаты, генерируемые прокси-серверами, не содержат этого обязательного поля.3 В предыдущих версиях OpenSSL и Python отсутствие AKI часто игнорировалось, если цепочку можно было построить другими методами (например, по имени эмитента), но в строгом режиме это считается недопустимым.

### **2.3 Сравнительный анализ профилей сертификатов**

Чтобы наглядно продемонстрировать разрыв между требованиями и реальностью, ниже приведена сравнительная таблица профилей сертификатов:

| Компонент сертификата | Требования RFC 5280 (CA) | Типичный сертификат Прокси/Legacy CA | Поведение Python 3.12 (OpenSSL Legacy) | Поведение Python 3.13 (OpenSSL Strict) |
| :---- | :---- | :---- | :---- | :---- |
| **Basic Constraints** | CA:TRUE, часто Critical | CA:TRUE (часто не Critical) | Принимается | Принимается (с оговорками) |
| **Key Usage** | Присутствует, бит keyCertSign установлен | Отсутствует или только digitalSignature | **Игнорируется / Предупреждение** | **Фатальная ошибка** |
| **Authority Key ID (AKI)** | Присутствует (KeyIdentifier) | Отсутствует | **Игнорируется** | **Фатальная ошибка** |
| **Режим валидации** | Стандартный или Строгий | Стандартный ("расслабленный") | Пермиссивный | **Строгий (по умолчанию)** |

Как видно из таблицы, сертификаты, которые годами использовались в корпоративных сетях, фактически нарушают фундаментальные требования стандарта. Их работоспособность обеспечивалась исключительно снисходительностью программного обеспечения, которое ставило функциональность выше безопасности. С обновлением Python до версии 3.13 этот "технический кредит" был внезапно предъявлен к оплате.1

## ---

**3. Python 3.13: Анатомия изменений в модуле SSL**

В основе проблемы лежит не код Azure CLI, а изменения в стандартной библиотеке Python, на которую опирается CLI. Версия 3.13 привнесла радикальные изменения в модуль ssl и urllib, направленные на повышение безопасности по умолчанию, но нарушившие обратную совместимость с устаревшими системами.

### **3.1 Флаг VERIFY_X509_STRICT**

Ключевым изменением в Python 3.13 стала модификация метода ssl.create_default_context(). Теперь этот метод по умолчанию устанавливает флаг VERIFY_X509_STRICT (в терминологии OpenSSL — X509_V_FLAG_X509_STRICT).14 Этот флаг кардинально меняет поведение библиотеки OpenSSL, используемой Python для криптографических операций.

Когда флаг VERIFY_X509_STRICT активен, OpenSSL отключает все встроенные механизмы обхода ошибок ("workarounds") для сломанных или нестандартных сертификатов. Валидатор начинает требовать буквального соблюдения правил X.509. Это означает, что любые отклонения в структуре сертификата, которые ранее могли считаться несущественными (например, отсутствие расширения Key Usage у промежуточного CA), теперь классифицируются как критические уязвимости, приводящие к разрыву соединения.5

Официальная документация Python предупреждает, что этот контекст "может отвергать сертификаты до RFC 5280 или некорректно сформированные сертификаты, которые базовая реализация OpenSSL в противном случае приняла бы".14 Для разработчиков Azure CLI это означало, что обновление встроенного интерпретатора автоматически включило этот режим для всех пользователей, не предоставив (на уровне конфигурации CLI) простого способа его отключения.

### **3.2 Рефакторинг urllib и проблема SSL_CERT_FILE**

Ситуация усугубляется изменениями в модуле urllib.request. В Python 3.13 из функции urllib.request.urlopen были удалены параметры cafile, capath и cadefault.17 Исторически, наличие и обработка этих параметров инициировали цепочку вызовов, которая неявно учитывала переменную окружения SSL_CERT_FILE при создании контекста SSL.

Удаление этих параметров привело к побочному эффекту: стандартный механизм создания контекста перестал автоматически подхватывать путь к сертификатам из переменной SSL_CERT_FILE в некоторых сценариях использования, если они не были явно переписаны с использованием SSLContext.load_verify_locations. Это создало путаницу среди инженеров, пытающихся исправить ошибку валидации путем явного указания пути к корректному бандлу сертификатов через переменную окружения — переменная игнорировалась, и приложение продолжало использовать встроенное хранилище или системные настройки, не содержащие нужного корневого сертификата.17

### **3.3 Дивергенция доверия: ОС против Приложения**

Важным аспектом является то, как Python (и Azure CLI) управляет доверием. В отличие от браузеров (Chrome, Edge), которые используют системное хранилище сертификатов Windows (CAPI) или macOS Keychain, Python по умолчанию использует библиотеку certifi — статический файл cacert.pem, содержащий набор корневых сертификатов Mozilla.18

Это создает ситуацию "двойного стандарта":

1. **Уровень ОС:** Корпоративный корневой сертификат установлен в доверенные корневые центры Windows через групповые политики (GPO). Браузеры и системные службы доверяют прокси-серверу.  
2. **Уровень Python/Azure CLI:** Встроенный Python использует свой изолированный файл cacert.pem, который ничего не знает о корпоративном CA. Ранее это решалось переменными окружения, но с ужесточением проверок в Python 3.13 простого добавления сертификата стало недостаточно — сертификат должен быть *структурно безупречным*, чего нельзя сказать о большинстве сертификатов прокси-серверов.20

## ---

**4. Инцидент Azure CLI 2.77.0: Каскадный отказ аутентификации**

Внедрение Python 3.13 в Azure CLI версии 2.77.0 привело к каскадному отказу функциональности, наиболее критичным из которых стала невозможность выполнения команды az login.

### **4.1 Роль библиотеки MSAL**

Аутентификация в Azure CLI осуществляется через библиотеку Microsoft Authentication Library (MSAL). Анализ отладочных логов (az login --debug) показал, что MSAL в версии 2.77.0 (зависимость msal 1.34.0b1) демонстрирует несогласованное поведение при обработке пользовательских настроек SSL.22

В то время как другие компоненты CLI, использующие библиотеку requests напрямую (например, az vm list), корректно подхватывают переменную REQUESTS_CA_BUNDLE и используют указанный пользователем файл сертификатов (что видно по логу DEBUG: Using CA bundle file at...), модуль аутентификации игнорирует эту настройку. В результате, при попытке соединения с login.microsoftonline.com через прокси, MSAL использует стандартный, строгий контекст SSL, который отвергает сертификат прокси из-за отсутствия AKI или Key Usage, даже если пользователь предоставил корректный CA бандл.3

### **4.2 Проблема встроенного Python на Windows**

На платформе Windows Azure CLI устанавливается как самодостаточный пакет, включающий собственный интерпретатор Python (обычно по пути C:Program FilesMicrosoft SDKsAzureCLI2). Эта архитектура, призванная изолировать CLI от системных зависимостей ("dependency hell"), в данном случае сыграла злую шутку.23

Пользователи оказались заложниками встроенной версии Python 3.13. Они не могут просто "понизить" версию Python внутри CLI, не нарушив целостность пакета. Поскольку pip внутри этой установки также часто оказывается сломанным или урезанным, стандартные методы установки патчей или дополнительных библиотек (таких как pip-system-certs) требуют нетривиальных манипуляций с правами администратора и прямым вызовом исполняемого файла python.21

## ---

**5. Корпоративные прокси и кризис "Man-in-the-Middle"**

Масштаб проблемы обусловлен повсеместным использованием технологий глубокой инспекции пакетов (DPI) и SSL Visibility. Вендоры, такие как Zscaler, Broadcom (Blue Coat), Palo Alto Networks и Netskope, предоставляют критически важные функции безопасности, расшифровывая SSL-трафик для проверки на наличие вредоносного ПО и утечек данных.

### **5.1 Механизм перехвата и генерации сертификатов**

Процесс SSL-инспекции работает следующим образом:

1. **Инициация:** Клиент (Azure CLI) инициирует рукопожатие (Handshake) с сервером (например, management.azure.com).  
2. **Перехват:** Прокси-устройство перехватывает соединение.  
3. **Upstream:** Прокси устанавливает легитимное защищенное соединение с реальным сервером Microsoft.  
4. **Фальсификация:** Прокси динамически генерирует (подписывает) новый сертификат для management.azure.com, используя свой внутренний закрытый ключ CA.  
5. **Downstream:** Этот сгенерированный сертификат отправляется клиенту.

Для успешной работы клиент должен доверять корневому сертификату прокси. Однако, проблема Azure CLI 2.77.0 кроется не в доверии к корню, а в *структуре* сгенерированного сертификата.

### **5.2 Проблема "Застывшего времени"**

Многие конфигурации прокси-серверов и внутренних PKI были созданы 5-10 лет назад. В то время библиотеки SSL были пермиссивными. Администраторы создавали корневые и промежуточные сертификаты с настройками, которые были "достаточно хороши" для работы с браузерами и Java 7/8.

* **Zscaler:** Многочисленные отчеты указывают, что корневые сертификаты Zscaler и генерируемые ими промежуточные сертификаты часто не имеют расширения Key Usage с битом keyCertSign или не помечают расширение Basic Constraints как критическое.4  
* **OpsManager:** Аналогичные проблемы задокументированы с внутренними CA сервисов OpsManager.1  
* **Локальная разработка:** Разработчики, использующие microk8s или самоподписанные сертификаты для локальных кластеров, часто используют упрощенные команды OpenSSL, которые не добавляют необходимые расширения v3, если не использовать специальный конфигурационный файл.27

Поскольку обновление корневого сертификата прокси требует его распространения на тысячи конечных устройств, организации крайне неохотно идут на этот шаг. Строгость Python 3.13 мгновенно выявила этот накопленный технический долг, превратив его в операционный кризис.

## ---

**6. Стратегии исправления и технические решения**

Восстановление работоспособности Azure CLI 2.77.0 требует действий на одном из трех уровней: инфраструктура сертификатов, конфигурация клиента или код приложения. Ниже представлены детальные стратегии, ранжированные от наиболее фундаментальных к временным обходным путям.

### **6.1 Стратегия А: Инфраструктурное исправление (Рекомендуемое)**

Единственным решением, полностью соответствующим стандартам безопасности и гарантирующим долгосрочную стабильность, является перевыпуск некорректных сертификатов. Это устраняет первопричину конфликта с RFC 5280.

* **Действие:** Администраторы безопасности должны перевыпустить внутренние корневые и промежуточные сертификаты CA, используемые на устройствах SSL-инспекции.  
* **Технические требования к новым сертификатам:**  
  * **Basic Constraints:** Расширение должно присутствовать, быть помечено как Critical, и значение CA должно быть TRUE (basicConstraints=critical,CA:TRUE).  
  * **Key Usage:** Расширение должно присутствовать, быть помечено как Critical, и должны быть установлены биты keyCertSign и cRLSign (keyUsage=critical,keyCertSign,cRLSign).  
  * **Authority Key Identifier (AKI):** Должно присутствовать во всех несамоподписанных сертификатах.  
* **Реализация:** Для администраторов, использующих OpenSSL для генерации CA, необходимо использовать конфигурационный файл с секцией v3_ca. Пример корректной конфигурации:  
  Ini, TOML  
  [ v3_ca ]  
  basicConstraints = critical, CA:true  
  keyUsage = critical, digitalSignature, cRLSign, keyCertSign  
  subjectKeyIdentifier = hash  
  authorityKeyIdentifier = keyid:always,issuer

* **Влияние:** Высокое. Требует обновления доверенных корней на всех клиентских машинах. Однако это решает проблему для *всех* будущих строгих клиентов, включая uv, poetry и новые версии языков программирования.

### **6.2 Стратегия Б: Патчинг через pip-system-certs (Windows Workaround)**

Для пользователей Windows наиболее эффективным техническим обходным путем является принуждение встроенного в Azure CLI Python использовать системное хранилище сертификатов Windows (CAPI) вместо внутреннего хранилища OpenSSL. Это позволяет обойти строгие проверки OpenSSL, так как CAPI имеет свою логику валидации, которая, как правило, доверяет корпоративным прокси, уже установленным в систему.

* **Механизм:** Пакет pip-system-certs патчит библиотеку requests и urllib3 во время выполнения, перенаправляя вызовы верификации SSL в Windows CryptoAPI.20  
* **Алгоритм реализации:**  
  1. Запустите PowerShell от имени Администратора.  
  2. Обратитесь к *встроенному* интерпретатору Python внутри директории Azure CLI. Стандартный путь: C:Program Files (x86)Microsoft SDKsAzureCLI2python.exe (для 32-бит) или C:Program FilesMicrosoft SDKsAzureCLI2python.exe (для 64-бит).  
  3. Выполните установку пакета:  
     PowerShell  
     & "C:Program FilesMicrosoft SDKsAzureCLI2python.exe" -m pip install pip-system-certs

  4. После установки Azure CLI начнет использовать системные сертификаты, и если сертификат прокси доверен на уровне ОС, ошибка исчезнет.21  
* **Преимущества:** Решение работает прозрачно для пользователя после установки, не требует перегенерации сертификатов.

### **6.3 Стратегия В: Переопределение бандла (Linux/macOS)**

Поскольку pip-system-certs работает только на Windows, пользователи Linux и macOS вынуждены использовать переменные окружения для указания корректного файла сертификатов.

* **Механизм:** Создание комбинированного файла (PEM bundle), содержащего стандартные сертификаты certifi и корпоративный сертификат прокси, с последующим принудительным указанием CLI использовать этот файл.  
* **Алгоритм реализации:**  
  1. Экспортируйте сертификат прокси (например, proxy-ca.pem) в формате Base-64.  
  2. Найдите путь к стандартному бандлу Python: python3 -m certifi.  
  3. Создайте новый файл, объединив оба: cat proxy-ca.pem $(python3 -m certifi) > ~/combined-ca-bundle.pem.  
  4. Установите переменные окружения в профиле оболочки (.bashrc / .zshrc):  
     Bash  
     export REQUESTS_CA_BUNDLE=~/combined-ca-bundle.pem  
     export SSL_CERT_FILE=~/combined-ca-bundle.pem

*Важное замечание:* Из-за бага в MSAL (см. раздел 4.1), этот метод может не сработать для команды az login в версии 2.77.0. В таком случае, более надежным методом является физическая дозапись сертификата прокси в файл cacert.pem, находящийся внутри установки Azure CLI (site-packages/certifi/cacert.pem).3

### **6.4 Стратегия Г: Откат версии (Downgrade)**

Если операционная непрерывность критична, а изменение инфраструктуры невозможно, откат Azure CLI до версии 2.76.0 является валидным временным решением. Версия 2.76.0 использует более старую версию Python (обычно 3.11 или 3.12), где строгая проверка отключена по умолчанию.

* **Команда для Windows (через Winget):**  
  PowerShell  
  winget install --exact --id Microsoft.AzureCLI --version 2.76.0

* **Команда для Linux (APT):**  
  Bash  
  sudo apt-get install --allow-downgrades -y azure-cli=2.76.0-1~<distro>

* **Риски:** Это временная мера. Будущие версии CLI неизбежно потребуют функционала новых версий Python, и проблема вернется. Кроме того, использование устаревшего ПО несет риски безопасности.22

### **6.5 Стратегия Д: Отключение верификации (Высокий риск)**

Существует возможность полностью отключить проверку SSL-сертификатов через переменную окружения.

* **Переменная:** AZURE_CLI_DISABLE_CONNECTION_VERIFICATION=1.2  
* **Оценка безопасности:** Это решение **категорически не рекомендуется** для продуктивных сред. Оно делает соединение уязвимым для злонамеренных MITM-атак, полностью нивелируя защиту TLS. Использование допустимо только в изолированных тестовых средах ("песочницах") для диагностики.

## ---

**7. Долгосрочные последствия для экосистемы DevSecOps**

Инцидент с Azure CLI 2.77.0 является предвестником более широких изменений в экосистеме разработки программного обеспечения.

### **7.1 Влияние на инструменты нового поколения (uv, poetry)**

Наблюдается конвергенция в подходах к безопасности. Современные инструменты управления пакетами, такие как uv (написанный на Rust), также сталкиваются с проблемами при работе за прокси. Пользователи сообщают об ошибках UnknownIssuer при использовании uv за MITM-прокси, даже если системное хранилище обновлено.29 Это указывает на то, что реализация Native TLS в Rust и строгие хуки в Python движутся к единому стандарту жесткой валидации, исключая возможность использования "грязных хаков" и устаревших сертификатов в будущем.

### **7.2 Дефицит документации по SSL_CERT_FILE**

Путаница вокруг переменной SSL_CERT_FILE в Python 3.13 подсветила серьезный пробел в коммуникации изменений. Удаление аргументов cafile из urllib сломало *неявную* поддержку этой переменной, на которую полагались тысячи разработчиков, даже не подозревая, что это был побочный эффект реализации, а не документированная функция.17 Это требует от индустрии пересмотра внутренних скриптов и инструментов: переход от полагания на глобальные переменные к явному конфигурированию SSL-контекстов в коде (использование SSLContext.load_verify_locations).

### **7.3 Заключение**

Эра пермиссивной SSL-валидации подошла к концу. Организации, игнорирующие требования RFC 5280, будут сталкиваться с нарастающим числом сбоев по мере того, как все больше инструментов (CI/CD агенты, CLI облачных провайдеров, SDK) будут переходить на современные рантаймы (Python 3.13+, Go 1.20+, OpenSSL 3.0+).

Для IT-руководителей этот инцидент должен стать сигналом к немедленному аудиту внутренней PKI. Технический долг в виде некорректных сертификатов больше нельзя игнорировать — теперь это критический фактор доступности сервисов. Microsoft и сообщество Python четко обозначили курс: безопасность по умолчанию, без компромиссов для устаревших конфигураций. Единственный путь вперед — привести инфраструктуру в соответствие со стандартами, которые были приняты более 15 лет назад, но начали принудительно исполняться только сейчас.

#### **Works cited**

1. Opsmanager internal service TLS_CA certificate does not include "key usage extension", accessed December 11, 2025, [https://knowledge.broadcom.com/external/article/409321/opsmanager-internal-service-tlsca-certif.html](https://knowledge.broadcom.com/external/article/409321/opsmanager-internal-service-tlsca-certif.html)  
2. az cli pipelines build list errors with Internal/VPN CA Certs - Developer Community, accessed December 11, 2025, [https://developercommunity.visualstudio.com/t/az-cli-pipelines-build-list-errors-with/10993415?sort=active&topics=ide2](https://developercommunity.visualstudio.com/t/az-cli-pipelines-build-list-errors-with/10993415?sort=active&topics=ide2)  
3. AZ Login fails with SSL intercept for 2.77.0 · Issue #32206 · Azure/azure-cli - GitHub, accessed December 11, 2025, [https://github.com/Azure/azure-cli/issues/32206](https://github.com/Azure/azure-cli/issues/32206)  
4. Python 3.13 Zscaler certificate non-conform, accessed December 11, 2025, [https://community.zscaler.com/s/question/0D5PJ00000Yzt5r0AB/python-313-zscaler-certificate-nonconform](https://community.zscaler.com/s/question/0D5PJ00000Yzt5r0AB/python-313-zscaler-certificate-nonconform)  
5. Elasticsearch CA certificates are rejected by Python 3.13 · Issue #117769 - GitHub, accessed December 11, 2025, [https://github.com/elastic/elasticsearch/issues/117769](https://github.com/elastic/elasticsearch/issues/117769)  
6. Az CLI 2.77.0 ssl issues #32108 - GitHub, accessed December 11, 2025, [https://github.com/Azure/azure-cli/issues/32108](https://github.com/Azure/azure-cli/issues/32108)  
7. Release notes & updates – Azure CLI - Microsoft Learn, accessed December 11, 2025, [https://learn.microsoft.com/en-us/cli/azure/release-notes-azure-cli?view=azure-cli-latest](https://learn.microsoft.com/en-us/cli/azure/release-notes-azure-cli?view=azure-cli-latest)  
8. Azure/azure-cli: Azure Command-Line Interface - GitHub, accessed December 11, 2025, [https://github.com/Azure/azure-cli](https://github.com/Azure/azure-cli)  
9. RFC compliance | Certificate Authority Service - Google Cloud Documentation, accessed December 11, 2025, [https://docs.cloud.google.com/certificate-authority-service/docs/rfc-compliance](https://docs.cloud.google.com/certificate-authority-service/docs/rfc-compliance)  
10. Can someone explain the "Section 4.2.1.3. Key Usage" extension in RFC 5280 as it relates to TLS 1.2 RFC 5246 - Information Security Stack Exchange, accessed December 11, 2025, [https://security.stackexchange.com/questions/224736/can-someone-explain-the-section-4-2-1-3-key-usage-extension-in-rfc-5280-as-it](https://security.stackexchange.com/questions/224736/can-someone-explain-the-section-4-2-1-3-key-usage-extension-in-rfc-5280-as-it)  
11. openssl-verification-options, accessed December 11, 2025, [https://docs.openssl.org/3.1/man1/openssl-verification-options/](https://docs.openssl.org/3.1/man1/openssl-verification-options/)  
12. Self-signed certificate with CA:TRUE and Key Usage not set to sign certificates - is it safe?, accessed December 11, 2025, [https://stackoverflow.com/questions/36999138/self-signed-certificate-with-catrue-and-key-usage-not-set-to-sign-certificates](https://stackoverflow.com/questions/36999138/self-signed-certificate-with-catrue-and-key-usage-not-set-to-sign-certificates)  
13. OpenSSL CA keyUsage extension - Super User, accessed December 11, 2025, [https://superuser.com/questions/738612/openssl-ca-keyusage-extension](https://superuser.com/questions/738612/openssl-ca-keyusage-extension)  
14. ssl — TLS/SSL wrapper for socket objects — Python 3.14.2 documentation, accessed December 11, 2025, [https://docs.python.org/3/library/ssl.html](https://docs.python.org/3/library/ssl.html)  
15. Python v3.13 has broken Email delivery due to an SSL change - Stack Overflow, accessed December 11, 2025, [https://stackoverflow.com/questions/79358216/python-v3-13-has-broken-email-delivery-due-to-an-ssl-change](https://stackoverflow.com/questions/79358216/python-v3-13-has-broken-email-delivery-due-to-an-ssl-change)  
16. Python 3.13.x SSL security changes, accessed December 11, 2025, [https://discuss.python.org/t/python-3-13-x-ssl-security-changes/91266](https://discuss.python.org/t/python-3-13-x-ssl-security-changes/91266)  
17. Does Python 3.13 ignore SSL_CERT_FILE environment variable by design?, accessed December 11, 2025, [https://stackoverflow.com/questions/79123649/does-python-3-13-ignore-ssl-cert-file-environment-variable-by-design](https://stackoverflow.com/questions/79123649/does-python-3-13-ignore-ssl-cert-file-environment-variable-by-design)  
18. Adding Custom Certificate to an Application-Specific Trust Store - Zscaler Help, accessed December 11, 2025, [https://help.zscaler.com/zia/adding-custom-certificate-application-specific-trust-store](https://help.zscaler.com/zia/adding-custom-certificate-application-specific-trust-store)  
19. certificate verify failed: unable to get local issuer certificate - Stack Overflow, accessed December 11, 2025, [https://stackoverflow.com/questions/52805115/certificate-verify-failed-unable-to-get-local-issuer-certificate](https://stackoverflow.com/questions/52805115/certificate-verify-failed-unable-to-get-local-issuer-certificate)  
20. Login to Azure Devops Server - Failed to authenticate using the supplied token #32378, accessed December 11, 2025, [https://github.com/Azure/azure-cli/issues/32378](https://github.com/Azure/azure-cli/issues/32378)  
21. 2.77.0 raises error: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: Missing Authority Key Identifier (_ssl.c:1032) · Issue #32083 · Azure/azure-cli - GitHub, accessed December 11, 2025, [https://github.com/Azure/azure-cli/issues/32083](https://github.com/Azure/azure-cli/issues/32083)  
22. MSAL authentication doesn't respect REQUESTS_CA_BUNDLE for proxy certificates · Issue #32207 · Azure/azure-cli - GitHub, accessed December 11, 2025, [https://github.com/Azure/azure-cli/issues/32207](https://github.com/Azure/azure-cli/issues/32207)  
23. Version 2.77 introduced a python error on upgrade, using az upgrade or MSI · Issue #32221 · Azure/azure-cli - GitHub, accessed December 11, 2025, [https://github.com/Azure/azure-cli/issues/32221](https://github.com/Azure/azure-cli/issues/32221)  
24. Install the Azure CLI on Windows | Microsoft Learn, accessed December 11, 2025, [https://learn.microsoft.com/en-us/cli/azure/install-azure-cli-windows?view=azure-cli-latest](https://learn.microsoft.com/en-us/cli/azure/install-azure-cli-windows?view=azure-cli-latest)  
25. Installed AzureCLI.msi but pip is showing Fatal error in launcher - Microsoft Learn, accessed December 11, 2025, [https://learn.microsoft.com/en-gb/answers/questions/4373649/installed-azurecli-msi-but-pip-is-showing-fatal-er](https://learn.microsoft.com/en-gb/answers/questions/4373649/installed-azurecli-msi-but-pip-is-showing-fatal-er)  
26. Change in python 3.13 that breaks certificate trust - Zscaler Community, accessed December 11, 2025, [https://community.zscaler.com/s/question/0D54u0000AfJDtECQW/change-in-python-313-that-breaks-certificate-trust](https://community.zscaler.com/s/question/0D54u0000AfJDtECQW/change-in-python-313-that-breaks-certificate-trust)  
27. root CA certificate does not include key usage extension · Issue #4864 · canonical/microk8s, accessed December 11, 2025, [https://github.com/canonical/microk8s/issues/4864](https://github.com/canonical/microk8s/issues/4864)  
28. Pip Install Fails With "Connection Error: [Ssl: Certificate_verify_failed] Certificate Verify Failed (_ssl.c:598)" | Better Stack Community, accessed December 11, 2025, [https://betterstack.com/community/questions/pip-install-fails-with-ssl-certificate-verify-failed/](https://betterstack.com/community/questions/pip-install-fails-with-ssl-certificate-verify-failed/)  
29. Certificate passed via `SSL_CERT_FILE` not trusted · Issue #16474 · astral-sh/uv - GitHub, accessed December 11, 2025, [https://github.com/astral-sh/uv/issues/16474](https://github.com/astral-sh/uv/issues/16474)