0) По моему опыту, ваша cookies error скорее всего вызвана тем, что обратный прокси-сервер изменяет контекст взаимодействия между клиентом и бэкенд-приложением.
Cookie, установленные бэкендом для внутреннего контекста (домен, путь, протокол), становятся невалидными для браузера клиента.
Я считаю 5 гипотез наиболее вероятными в вашей ситуации.
Я излагаю их в пунктах 1-5 ниже.
1) Гипотеза №1: Несоответствие домена Cookie (атрибут `Domain`).
1.1) Суть гипотезы
Бэкенд-приложение устанавливает Cookie с атрибутом `Domain`, соответствующим его внутреннему адресу (например, `internal.local`). 
Браузер клиента, обратившегося по внешнему адресу (например, `proxy.com`), отклоняет этот Cookie из-за несоответствия доменов.
1.2) Доводы за правдоподобность
1.2.1)  Вы в описании проекта указали на доступ к сайту в «restricted network». 
Это с высокой вероятностью подразумевает использование внутренних доменных имен, отличающихся от внешних.
1.2.2) По умолчанию Nginx не изменяет атрибут `Domain` в заголовке `Set-Cookie`, передаваемом от бэкенда. 
Для коррекции требуется директива `proxy_cookie_domain`.
2) Гипотеза №2: Проблемы с терминацией SSL/TLS и флагом `Secure`.
2.1) Суть гипотезы
Nginx терминирует SSL/TLS (принимает HTTPS от клиента), но взаимодействует с бэкендом по незащищенному HTTP.
Бэкенд не осведомлен об исходном защищенном соединении и воспринимает запрос как HTTP.
Это приводит к ошибкам аутентификации, поскольку бэкенд генерирует некорректные абсолютные URL для перенаправления (используя `http://` вместо `https://`) или отказывается устанавливать сессию, считая транспорт небезопасным.
2.2) Доводы за правдоподобность
2.2.1) Ваша фраза «Ensure secure access» подразумевает использование HTTPS. 
Терминация SSL на обратном прокси является стандартной архитектурой.
2.2.2) Если Nginx не передает информацию об исходном протоколе (e.g., через заголовок `X-Forwarded-Proto: https`), бэкенд считает соединение небезопасным.
Это приводит к сбоям при генерации redirect URL или к отказу логики приложения устанавливать сессию.
Кроме того, современные браузеры требуют обязательного наличия флага `Secure`, если Cookie используется в cross-site контексте и имеет атрибут `SameSite=None`.
3) Гипотеза №3: Некорректная передача заголовка `Host`
3.1) Суть гипотезы
Nginx передает бэкенду некорректный заголовок `Host` (e.g., имя upstream-сервера или его IP-адрес вместо внешнего доменного имени, использованного клиентом).
Бэкенд использует это значение для генерации абсолютных URL перенаправления после входа.
Кроме того, это значение используется как target origin в механизмах защиты от CSRF (Cross-Site Request Forgery).
3.2) Доводы за правдоподобность
Многие веб-фреймворки сверяют значение заголовка `Host` (target origin) со значениями заголовков `Origin` и/или `Referer` (source origin) для защиты от CSRF.
Несоответствие, вызванное некорректной настройкой `proxy_set_header Host`, приводит к провалу этой проверки (e.g., ошибка 403 Forbidden) и отказу в аутентификации.
Если приложение также использует `Host` для установки атрибута `Domain` в Cookie, этот сценарий является первопричиной Гипотезы №1.
4) Гипотеза №4: Несоответствие пути Cookie (атрибут `Path`).
4.1) Суть гипотезы
Бэкенд-приложение устанавливает Cookie с атрибутом `Path`, соответствующим его внутреннему пути (e.g., `/internal-app/`).
Клиент обращается через прокси по другому пути (e.g., `/`).
Браузер не отправляет Cookie при последующих запросах, так как текущий путь запроса не соответствует значению атрибута `Path` в Cookie.
4.2) Доводы за правдоподобность
4.2.1) При публикации внутреннего приложения через reverse proxy часто используется изменение структуры URL.
4.2.2) По умолчанию Nginx не изменяет атрибут `Path` в заголовке `Set-Cookie`.
Для коррекции требуется директива `proxy_cookie_path`.
5) Гипотеза №5: Блокировка Cookie из-за атрибута `SameSite`.
5.1) Суть гипотезы
В результате проксирования (изменения домена) контекст взаимодействия изменяется с точки зрения браузера с same-site на cross-site.
Браузер блокирует отправку аутентификационных Cookie, так как они не соответствуют требованиям для cross-site контекста.
5.2) Доводы за правдоподобность
Современные браузеры по умолчанию применяют политику `SameSite=Lax`, если атрибут `SameSite` не указан явно.
Политики `Lax` или `Strict` ограничивают отправку Cookie в cross-site запросах (e.g., `POST` запросы после перенаправления).
Для использования Cookie в cross-site контексте требуется явная установка `SameSite=None` вместе с флагом `Secure`.
Если бэкенд не устанавливает эти атрибуты корректно, или если они не скорректированы Nginx (e.g., с помощью директивы `proxy_cookie_flags`), аутентификация может завершиться ошибкой.