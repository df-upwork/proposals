1) Заменить пункт 1.2 на следующий текст:
1.2) Консолидировать и нормализовать структуру.
Объединить данные из разных таблиц в единый поток данных со структурой списка смежности (Adjacency List), то есть в формате Parent-Child.
Этот этап может потребовать сложной логики для соединения таблиц, представляющих разные уровни или суб-иерархии (ragged hierarchy).
Если для связи исходных таблиц требуется логика, аналогичная SQL Conditional Outer Join (как указано в описании проекта), где условия включены в предикат `ON` (e.g., `... ON L.Key = R.Key AND [Condition]`), необходимо реализовать её на этом этапе, используя надежный метод, описанный в пункте 2.2.
Этот метод требует комбинации нескольких инструментов (e.g., «Record ID», «Join», «Filter», «Union») для точной репликации логики SQL и обеспечения корректного количества строк.
Результирующий набор данных (далее `Hierarchy_Data`) должен содержать как минимум поля идентификатора родителя (например, `ParentID`), идентификатора потомка (например, `ChildID`), а также все поля, необходимые для условной логики соединения (далее `ConditionFields`).
Единая структура Parent-Child необходима для универсальной реализации итеративной логики обхода иерархии.

2) Заменить пункт 2.2 (включая подпункты 2.2.1–2.2.4) на следующий текст:
2.2) Реализация Conditional Outer Join (например, Left Outer Join).
Если требуется реплицировать логику SQL `LEFT OUTER JOIN`, где дополнительные условия включены в предикат `ON` (e.g., `... ON L.Key = R.Key AND [Condition]`), необходимо использовать подход, который определяет сам факт успешного соединения на основе всех условий.
Этот метод отличается от применения выражения `CASE` в списке `SELECT` после стандартного `LEFT OUTER JOIN` и гарантирует корректность результата даже при отношениях N-to-M.
2.2.1) Обеспечить уникальность записей левой таблицы.
Для однозначной идентификации записей необходимо убедиться, что левый поток данных имеет уникальный идентификатор.
Если его нет, использовать инструмент «Record ID» для создания нового поля (e.g., `L_ID`).
2.2.2) Выполнить Conditional Inner Join.
Реализовать логику, описанную в пункте 2.1, используя подготовленный левый поток (шаг 2.2.1) и правый поток.
Результат (выход «T» инструмента «Filter», далее `Joined_Conditional`) содержит успешно соединенные записи, включая уникальный идентификатор (`L_ID`).
2.2.3) Идентифицировать истинно несоединенные записи (Left Unjoined).
Необходимо найти записи из левого потока, для которых не было найдено ни одного соответствия полному условию соединения.
2.2.3.1) Добавить второй инструмент «Join».
Соединить подготовленный левый поток (шаг 2.2.1, вход «L») и `Joined_Conditional` (шаг 2.2.2, вход «R»).
2.2.3.2) Сконфигурировать соединение по уникальному идентификатору (e.g., `L_ID`).
2.2.3.3) Выход «L» (Left Unjoined) этого инструмента содержит искомые несоединенные записи (далее `Unjoined_L`).
2.2.4) Финальное объединение.
Использовать инструмент «Union» для объединения `Joined_Conditional` (шаг 2.2.2) и `Unjoined_L` (шаг 2.2.3.3).
Инструмент «Union» автоматически согласует схемы данных, заполняя поля из правой таблицы значениями Null для потока `Unjoined_L` (при соответствующей конфигурации, e.g., «Auto Configure by Name»).
2.2.5) Завершение.
При необходимости использовать инструмент «Select» для удаления служебного уникального идентификатора (e.g., `L_ID`) и упорядочивания полей.

3) Заменить пункт 3.4.2 на следующий текст:
3.4.2) Обновить поля:
- `AncestorID`: оставить значение из `Input_I` (переносится через итерации).
- `CurrentID`: установить значение `ChildID` из `Input_H` (новый текущий узел).
- `Level`: увеличить значение на 1 (использовать формулу `[Level] + 1`).
Системную переменную `[Engine.IterationNumber]` (которая начинается с 0) также можно использовать для расчета уровня.
Однако это требует учета начального уровня, заданного в пункте 1.4 (e.g., формула `[Начальный_Уровень] + [Engine.IterationNumber] + 1`).
Явная передача и инкрементация поля `Level` обеспечивает большую гибкость, если разные ветви иерархии начинаются с разных уровней.

4) Заменить пункт 5.3 на следующий текст:
5.3) Обработать результаты.
Выход `Output_R` макроса содержит развернутую иерархию (все связи Предок-Потомок, начиная с уровня 1).
Описанная логика «Iterative Macro» не включает сами начальные узлы (уровень 0) в этот выходной поток.
Для получения полного набора данных иерархии необходимо использовать инструмент «Union», чтобы объединить начальные узлы (`Initial_Nodes`) с результатом работы макроса (`Output_R`).