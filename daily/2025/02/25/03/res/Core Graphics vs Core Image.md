Ниже приведена сравнительная таблица, в которой основные аспекты **масштабирования изображений** (image resizing) сопоставляются между **Core Graphics (Quartz)** и **Core Image**.  

| **Критерий**                                                                                   | **Core Graphics (Quartz)**                                                                                                                                                                                                                                       | **Core Image**                                                                                                                                                                                                                                                                                                                                                                                                   |
|:------------------------------------------------------------------------------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Уровень API**                                                                                 | • **Низкоуровневый** фреймворк для 2D-графики (отрисовка, контекст).<br/>• Доступ к настройкам интерполяции через `CGInterpolationQuality`.<br/>• Управление пикселями и контекстом (CPU-ориентированная модель), хотя в macOS может использоваться аппаратное ускорение. | • **Высокоуровневый** фреймворк для обработки изображений с помощью «цепочек» фильтров (`CIFilter`).<br/>• В основном ориентирован на **GPU** (или Metal/OpenGL) при работе с фильтрами.<br/>• Более гибок в плане возможностей (шумоподавление, цветокоррекция, compositing и пр.).                                                                                    |
| **Основной механизм масштабирования**                                                           | • Установка качества интерполяции (`kCGInterpolationQuality`) при рисовании изображения в CGContext.<br/>• Значения: `None`, `Low`, `Medium`, `High`, (иногда `Default`).                                                                                          | • Применение специализированных фильтров, например:<br/> &nbsp;&nbsp;• `CILanczosScaleTransform` (Lanczos)<br/> &nbsp;&nbsp;• `CIBicubicScaleTransform` (Бикубическая)<br/> &nbsp;&nbsp;• `CIAffineTransform` (обычно билинейная «по умолчанию»)<br/>• Возможность создавать **кастомные** шейдеры (CIKernel) для своих алгоритмов ресемплинга.                                |
| **Выбор конкретного алгоритма**                                                                 | • Существует 4 уровня качества, но **Apple не гарантирует**, что «High» всегда = именно Lanczos или Bicubic; реализация может меняться от версии системы.<br/>• Типичные соответствия:<br/> &nbsp;&nbsp;• `kCGInterpolationNone` ≈ Nearest Neighbor<br/> &nbsp;&nbsp;• `kCGInterpolationLow/Medium` ≈ Bilinear<br/> &nbsp;&nbsp;• `kCGInterpolationHigh` ≈ Bicubic/Lanczos (зависит от системы). | • Можно **явно** выбрать фильтр (Lanczos, Bicubic, Bilinear) через подходящий `CIFilter` (напр. `CILanczosScaleTransform`).<br/>• При желании можно реализовать **Nearest Neighbor** или любой другой метод через **пользовательский** `CIKernel`.<br/>• В итоге, контроль над алгоритмом **тоньше** за счёт конкретного набора фильтров и возможности кастомизации. |
| **Типичные сценарии**                                                                           | • Быстрое и простое масштабирование при рендере (рисовании) в CGContext.<br/>• Управление качеством при выводе в PDF, при отображении на экран или при сохранении (через `CGImageDestination`).<br/>• Подходит для случаев, где «1–2» операции ресайза и нужны базовые настройки. | • Полноценный «процессор изображений» с множеством фильтров, где ресайз — лишь один из этапов цепочки (можно комбинировать с поворотами, наложением эффектов и т. д.).<br/>• Подходит для более «сложных» или «массовых» сценариев — ретушь, пакетная обработка, реализация сложных графических пайплайнов на GPU.                                                                              |
| **Производительность**                                                                          | • **CPU-ориентированная** модель (хотя в современных macOS используется Metal / GPU-ускорение для части операций), но традиционно Core Graphics = CPU-подход.<br/>• Быстро для простых задач, но при очень больших изображениях может проигрывать Core Image (особенно на GPU).          | • Ориентирован на **GPU** (Core Image использует Metal / OpenGL для фильтров).<br/>• Часто даёт **высокую производительность** при работе с серией изображений или при сложных преобразованиях, если есть доступ к мощному GPU.<br/>• При мелких задачах overhead может быть чуть выше, чем у простого CGContext.                                                                           |
| **Управление цветопрофилями и другим метаданными**                                              | • Поддержка цветопрофилей (ColorSync) через `CGColorSpace`.<br/>• Метаданные обычно обрабатываются через Image I/O или дополнительные API.                                                                                                                           | • Также учитывает цветопрофили (CIImage может неявно содержать `CGColorSpace`).<br/>• Может получать/сохранять метаданные совместно с Image I/O (при создании `CIImage` из `CGImageSource` и т. д.).                                                                                                                                    |
| **Гибкость и расширяемость**                                                                    | • Доступ к интерполяции ограничен enum `CGInterpolationQuality`.<br/>• Нет готовых API для «суперразрешения», ML-фильтров и т. п. (нужно подключать другие фреймворки).                                                                                              | • **Очень гибкий**: стандартная библиотека фильтров (Lanczos, Bicubic, Gaussian Blur, и т. д.) + возможность писать пользовательские шейдеры на языке CIKernel / Metal Shading Language.<br/>• Имеются (через дополнительные фреймворки) методы, позволяющие делать суперразрешение (Core ML + Core Image).                                                             |
| **Простота использования**                                                                      | • Относительно простой вызов: создать CGContext → `CGContextSetInterpolationQuality` → отрисовать изображение в нужном масштабе.<br/>• Подходит для классической 2D-графики, векторной отрисовки и т. д.                                                           | • Нужно создавать `CIImage`, конфигурировать `CIFilter`, а затем рендерить через `CIContext`.<br/>• Чуть более «объектно-ориентированный» и «цепочечный» подход, с возможностью настраивать параметры и комбинировать фильтры.                                                                                                          |
| **Дополнительные комментарии**                                                                   | • Исторически основной API для отрисовки интерфейсов, PDF, контента в macOS/iOS. Масштабирование — лишь одна из функций.                                                                                                                                            | • Создан для **неразрушающей** обработки изображений (filter chain), где можно динамически менять параметры и использовать GPU.                                                                                                                                                                                                                                        |

### Ключевые отличия

1. **Стиль API**: Core Graphics — «рисование» в контексте, выбор одной из 4 степеней качества; Core Image — «цепочка фильтров», позволяющая выбрать конкретный метод (Bicubic, Lanczos и т. д.) или написать собственный.  
2. **Управление алгоритмами**: в Core Graphics вы можете лишь указать «None / Low / Medium / High», тогда как в Core Image возможно явно вызвать `CILanczosScaleTransform`, `CIBicubicScaleTransform` или написать свой `CIKernel`.  
3. **Производительность**: Core Graphics исторически CPU-ориентирован, Core Image — GPU-ориентирован (при сложных операциях может быть значительно быстрее).  
4. **Простота**: для разовых операций (например, быстро изменить размер изображения при отрисовке) Core Graphics проще; если нужна детальная настройка качества или цепочка из нескольких эффектов (blur, resize, color correction и т. д.) — Core Image удобнее и мощнее.  

Таким образом, **Core Graphics** — это базовый инструмент для 2D-рисования (с поддержкой простого выбора качества интерполяции), а **Core Image** — полноценный фреймворк для продвинутой GPU-обработки изображений, позволяющий точнее контролировать процесс ресемплинга (включая Lanczos, Bicubic и кастомные шейдеры).