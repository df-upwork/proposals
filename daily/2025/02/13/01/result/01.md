При переходе с «Pages router» на «App router» производительность приложения может упасть по следующим причинам:
1) При неправильной конфигурации можно случайно затащить в клиентский бандл слишком много кода.
Избыточное количество `use client` в компонентах приводит к тому, что они становятся клиентскими, и их код полностью загружается и исполняется на стороне браузера.
2) В «Pages router» работу с данными часто организовывали через `getStaticProps`/`getServerSideProps`, которые чётко отделяли логику получения данных от компонента.
В «App Router» загрузку данных можно делать прямо в серверном компоненте через `fetch()`. 
Если не следить за тем, как и когда вызываются запросы, может возникнуть дублирование запросов или неоптимальная схема кеширования.
Отсутствие или неправильная настройка `revalidate` (ISR) может вызывать слишком частые SSR-запросы.
3) «App Router» предоставляет больше возможностей для тонкой настройки кеширования (HTTP-заголовки, автоматическая инвалидация и т.д.), но их нужно уметь грамотно использовать. 
Если не включить или неверно настроить кеширование, серверные компоненты будут пересобираться при каждом запросе, что повышает нагрузку на сервер.
4) «App Router» поощряет более гибкую структуру: вложенные layout’ы, параллельные маршруты и т.д. 
Но если эта иерархия слишком сложна или в layout’ах выполняются «тяжёлые» операции, это влияет на общее время рендера и, следовательно, производительность.
При параллельных маршрутах может быть несколько цепочек одновременно, что увеличивает время подготовки данных, если логика не оптимизирована.
5) Иногда некорректно настроенные импорты и отсутствующая оптимизация (tree-shaking, code-splitting) приводят к тому, что в бандл попадают ненужные части кода.
6) «App Router» по умолчанию использует механизмы React 18 (streaming, concurrent mode). 
При неправильном использовании это может привести к увеличению времени first byte или проблемам в процессе гидрации, особенно если сервер и клиент рендерят разные версии данных или делают повторные запросы.
Если из-за «стартового» стриминга клиенту приходится дольше получать данные, пользователь может заметить задержку отображения.
7) Если в серверных компонентах используется сторонний код, который не оптимизирован для работы в Node-среде (например, специфичные для браузера API), то может происходить аварийная ситуация или деградация (fallback) на клиентский рендер. 
Иногда логика, требующаяся только на клиенте (события, хендлеры, анимации), остаётся в серверных компонентах, что усложняет сборку и рендер.
8) Часто при поэтапной миграции часть маршрутов остаётся на «Pages Router», а часть переходит на «App Router». 
Если при этом общая конфигурация (webpack, ESLint, TypeScript, окружения) не согласована, могут возникнуть дополнительные накладные расходы (двойные сборки, коллизии настроек, увеличенные «переходы» между маршрутизаторами).
Также возможно наличие дубликатов конфигурации Next.js (например, неверно прописанные настройки `next.config.js` или некорректные маршруты в старом и новом роутере).
9) При переходе на новый роутер могло измениться расположение API-эндпоинтов (ранее были в `/api/*` внутри папки `pages`, теперь же могут быть созданы отдельные «route handlers» в папке `app`). 
Если здесь допущены ошибки в кэше, логике запросов или обработке, серверная часть может работать медленнее.
Если hosting-провайдер (например, Vercel или другой) был настроен под Pages Router и требует отдельных корректировок под «App Router» (например, edge-функции или middleware), неправильная настройка может влиять на задержки ответа.
10) Иногда кажется, что производительность упала после миграции, но на самом деле изменились метрики (например, сравнивают TTFB вместо TTFB+streaming). 
Или же до миграции бандл был меньше из-за другого способа сборки, а теперь метрика выросла.
Ошибки в Lighthouse, Web Vitals или других инструментах могут вводить в заблуждение, особенно если в «App Router» используется более интенсивный server-side рендеринг.
React 18 (concurrent rendering, streaming SSR) меняет понятия TTFB, Time to Hydrate, Time to Interactive и т.д.
Для стриминга зачастую TTFB может быть чуть выше, зато пользователь быстрее видит часть контента.  
Lighthouse, WebPageTest и другие инструменты могут показывать разные результаты в зависимости от того, как именно происходит процесс рендера и отправки HTML «по кускам». 
10.1) Часть «деградации» в метриках (особенно TTFB) иногда объясняется особенностями стриминга: если раньше пользователь сразу получал готовый HTML «целиком», то теперь контент может приходить частями (streaming SSR), и метрики в инструментах вроде Lighthouse могут выглядеть иначе. 
11) В Next.js 13.4 появились «Server Actions».  
Если при использовании «Server Actions» вы не учитываете нюансы (например, какие данные уходят в форму, как сериализуются/десериализуются), это тоже может влиять на производительность и поведение приложения. 
12) С приходом «App Router»  и новых версий Next.js могут измениться настройки оптимизации изображений (конфигурация loader’а, кеширования и т.п.).
13) Если вы раньше полагались на SSR через Node-сервер (например, на custom server), а теперь используете «Edge Runtime» (Vercel Edge Functions и т.п.), это может изменить характеристики задержек (latency), особенности кэширования и способы рендера.