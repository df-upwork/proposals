1) Your applications may be killed by OOM Killer (Out Of Memory Killer, a Linux component) if they overconsume memory.
2) Incorrect configuration of the `pm.max_children`, `pm.start_servers`, `pm.min_spare_servers` in PHP-FPM usually leads to 1.
3) Linode's servers are virtual and typically do not provide many CPU resources per client; it is more profitable for Linode to limit CPU usage in order to host more clients on the same physical server.
If your virtual CPU is heavily loaded, your applications will process user requests too slowly, and either PHP or one of the middleware components (such as a web server or Cloudflare) will stop serving the user.
4) Timeouts that are too short in PHP-FPM or a web server can cause your applications not only to time out (point 3) but also to «go down».
For example:
4.1) A user request is aborted before completion.
4.2) The PHP-FPM process may hang on termination, leaving allocated resources (e.g. memory) behind.
4.3) The number of hung or killed processes gradually increases, and PHP-FPM may fail.
5) Excessively long timeouts in PHP-FPM or a web server can also cause your applications to «go down»:
5.1) Processes can remain active for a very long time, even if locked by a database lock, an infinite loop, or a similar issue.
5.2) Such hung processes keep CPU, RAM, and database connections.
Under high load, it leads to 1.
6) If your applications use inefficient or long-running database queries, this can cause not only timeouts but also complete unavailability of the application.
For example:
6.1) A user requests something.
6.2) The application sends a resource-intensive query to the database.
6.3) While the application waits for the result, the corresponding PHP-FPM worker process remains locked and cannot serve other requests.
6.4) If multiple users perform 6.1 at the same time, the number of busy PHP processes will grow rapidly.
6.5) Long queries can hold locks on database tables or rows.
6.6) Due to locks and concurrent access, even small queries to the database start to take longer.
6.7) When `max_connections` is exceeded in MySQL, new queries will get an error, which in itself can cause your application to crash.
6.8) If PHP processes remain active for a long time, the memory allocated for script execution remains in use.
Under load, it leads to 1.
7) Incorrect web server configuration (Apache, Nginx).
7.1) If MPM limits of Apache (`MaxRequestWorkers`, `ServerLimit`,  etc.) or similar limits of Nginx (`worker_processes`, `worker_connections`) are too low, the server will be overloaded during peak load.
7.2) The opposite situation: if the limits are too high (especially together with PHP-FPM, where `pm.max_children` can also be overestimated), then under concurrent requests each worker starts a PHP process, and the overall CPU and memory usage can increase sharply, leading to 1.
7.3) Any imbalance between the number of child processes in PHP-FPM and the corresponding Apache/Nginx parameters (the number of workers, queues) may cause the web server to accept more concurrent connections than the PHP-FPM pool can handle, leading to failures.
7.4) It is important to have consistent timeouts for PHP-FPM and Apache/Nginx.
If Apache has `ProxyReadTimeout` set to 1 minute (or similarly, Nginx has `fastcgi_read_timeout` set to 1 minute), while PHP-FPM uses a longer execution time (or vice versa), under heavy load the web server may close connections under heavy load before the script has finished.
7.4.1) If the web server waits longer than the PHP-FPM setting, some workers will be stuck in a wait state.
Over time, all workers become occupied by stuck requests, and new connections cannot be accepted, so the application is effectively not responding.
7.5) If the `ProxyBuffer` in Apache (or similar buffers in Nginx) is insufficient (especially for large responses), the connection may break during data transfer from PHP-FPM.
7.6) Overly aggressive `KeepAlive` in Apache will keep connections open too long, reducing the number of available workers.
If all workers are busy, new incoming requests will receive an error (5xx) or enter an infinite wait
8) Cloudflare has its own server response time limits.
Your applications may need more time to process some user requests, but Cloudflare may abort them.
9) If a PHP extension does not free memory properly, it will eventually lead to 1.
Unlike `mod_php` (where the Apache process can be restarted more often), PHP-FPM pools can run indefinitely until `pm.max_requests` or a manual restart occurs.
When processes run for hours or days, memory leaks accumulate in each worker.
10) Sometimes, automatic cPanel/WHM updates change PHP or Apache settings, resulting in 2, 5, 7.
---
I have completed 534 projects here on Upwork.
My GitHub profile: https://github.com/dmitrii-fediuk
My websites: https://df.tips?order=views, https://dmitry.ai?order=views, https://mage2.pro?order=views 