1.  Заменить текст пункта 1:

<!-- end list -->

```markdown
1) По моему опыту, ваша проблема скорее всего вызвана причиной пункта 2 ниже.
Также, по моему опыту, одновременно с ней может присутствовать причина пункта 3 ниже, однако эта причина вряд ли является единственной, в то время как причина пункта 2 может быть единственной.
```

На текст:

```markdown
1) По моему опыту, ваша проблема с высокой вероятностью вызвана причинами, описанными в пунктах 2 и 3 ниже.
Обе гипотезы хорошо объясняют наблюдаемые симптомы, и они могут присутствовать одновременно.
```

2.  Заменить текст пункта 2.4:

<!-- end list -->

```markdown
2.4) Согласно документации OCI, лимит по умолчанию на размер HTTP-заголовков (HTTP header buffer size) составляет 8KB.
Превышение этого лимита приводит к 502, даже если бэкенд ответил 200 OK.
Этот лимит не является жестким; его можно увеличить до 64KB с помощью OCI LB Rule Sets.
```

На текст:

```markdown
2.4) OCI Load Balancers имеют фиксированный лимит на максимальный размер HTTP-заголовков ответа (Response Headers) от бэкенда.
Согласно документу поддержки Oracle (Doc ID 2603461.1), этот лимит составляет 8KB.
Превышение этого лимита приводит к ошибке 502, даже если бэкенд ответил 200 OK.
Документация OCI описывает настройку HTTP Header Rules в OCI LB Rule Sets, но она позволяет увеличить лимит только для заголовков запроса (Request Headers, превышение которого вызывает ошибку 400), и не влияет на лимит заголовков ответа.
Следовательно, для решения этой проблемы необходимо уменьшить размер заголовков, генерируемых SvelteKit во время SSR (e.g., оптимизация `Link` preload заголовков или `Set-Cookie`).
```

3.  Заменить текст пункта 3.1:

<!-- end list -->

```markdown
3.1) Ошибка 502 может возникать из-за race condition при повторном использовании постоянных соединений (Keep-Alive). 
OCI LB поддерживает пул соединений с бэкендом (Nginx). 
Если Nginx закрывает соединение (по достижении своего `keepalive_timeout`) раньше, чем истекает LB-to-Backend Keep-Alive Timeout на балансировщике, LB может попытаться отправить новый запрос через уже закрытое соединение, что приводит к ошибке 502.
```

На текст:

```markdown
3.1) Ошибка 502 может возникать из-за race condition при повторном использовании постоянных соединений (Keep-Alive).
OCI LB поддерживает пул соединений с бэкендом (Nginx).
Если Nginx закрывает соединение (по достижении своего `keepalive_timeout`) раньше, чем истекает LB-to-Backend Idle Timeout на балансировщике, LB может попытаться отправить новый запрос через уже закрытое соединение, что приводит к ошибке 502.
```

4.  Заменить текст пункта 3.4:

<!-- end list -->

```markdown
3.4) Критически важно, чтобы таймаут Keep-Alive на бэкенде был больше, чем LB-to-Backend Keep-Alive Timeout на OCI LB.
Согласно документации OCI, LB-to-Backend Keep-Alive Timeout является фиксированным значением в 300 секунд.
Если `keepalive_timeout` в Nginx меньше 300 секунд (e.g., стандартное значение 75s), это создает идеальные условия для возникновения проблемы.
Увеличение Listener Idle Timeout (который определяет время простоя во время фазы HTTP-запроса/ответа), которое вы предприняли, не влияет на этот механизм.
```

На текст:

```markdown
3.4) Критически важно, чтобы таймаут Keep-Alive на бэкенде (Nginx `keepalive_timeout`) был больше, чем LB-to-Backend Idle Timeout на OCI LB.
Согласно документации OCI («Load Balancer Timeout Connection Settings»), OCI LB закрывает соединения с бэкендом, которые простаивают более 300 секунд (фиксированное значение LB-to-Backend Idle Timeout).
Если `keepalive_timeout` в Nginx меньше этого значения (e.g., стандартное значение 75s), это создает идеальные условия для возникновения проблемы.
Документация OCI рекомендует установить таймаут на бэкенде не менее 310 секунд для предотвращения ошибок 502.
Увеличение Listener Idle Timeout (который определяет время простоя во время фазы HTTP-запроса/ответа, а не между запросами), которое вы предприняли, не влияет на этот механизм.
```

5.  Заменить текст пункта 3.5:

<!-- end list -->

```markdown
3.5) Однако эта гипотеза не полностью объясняет, почему проблема возникает исключительно при SSR и не проявляется при SPA-навигации, так как Keep-Alive соединения переиспользуются для обоих типов запросов.
Поэтому, как я уже написал в пункте 1, причина пункта 3 вряд ли является единственной.
```

На текст:

```markdown
3.5) Эта гипотеза хорошо объясняет, почему проблема возникает преимущественно при SSR (обновление страницы).
SSR-запросы часто происходят после периода бездействия пользователя.
Если время простоя превышает `keepalive_timeout` Nginx, но меньше LB-to-Backend Idle Timeout (300s), возникает описанное состояние гонки.
SPA-навигация, напротив, генерирует частые запросы, которые поддерживают соединение в активном состоянии и предотвращают достижение idle-таймаутов.
```