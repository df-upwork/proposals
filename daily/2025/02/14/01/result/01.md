1) Сначала нужно выбрать удостоверяющий центр (CA):
1.1) Если вы использете внутренний корпоративный CA (например, Microsoft Active Directory Certificate Services), необходимо убедиться, что он настроен корректно для выдачи сертификатов как для серверов, так и для клиентов.
1.2) Можно также испльзовать внешний коммерческий CA (например, GlobalSign, DigiCert и т.д.).
2) Затем надо сформировать запрос (Certificate Signing Request, CSR) на серверном узле (IIS) либо с помощью отдельного инструмента (например, `certreq.exe` или OpenSSL).
3) Затем надо создать клиентские сертификаты.
На стороне клиента ключ обычно хранится в личном хранилище (Personal) пользователя или в приложении/программе, которая взаимодействует с сервером.  
Важно правильно настроить «Key Usage» и «Extended Key Usage», чтобы сертификат подходил для клиентской аутентификации.  
При использовании Windows-клиента или .NET-клиента сертификат устанавливается в личное хранилище пользователя («Current User» → «Personal») или машины.
4) Затем, надо убедиться, что корневой (Root CA) и при необходимости промежуточный (Intermediate CA) сертификаты установлены в «Trusted Root Certification Authorities» как на стороне сервера, так и на стороне клиента.  
Без корректной цепочки доверия двухсторонняя аутентификация работать не будет (сертификаты не пройдут проверку валидности).
5) В IIS Manager → раздел «Server Certificates» убедитесь, что ваш серверный сертификат (выданный CA) корректно установлен.  
6) Для нужного сайта в IIS создайте/обновите HTTPS-биндинг, выбрав нужный сертификат в поле «SSL certificate».  
7) В свойствах сайта или конкретного виртуального каталога/приложения в IIS найдите вкладку «SSL Settings».  
7.1) В параметрах «Client certificates» выберите «Require» (требовать) или «Accept» (принять), в зависимости от логики:  
- «Require» — будет разрывать соединение, если клиент не представит действительный сертификат.  
- «Accept» — позволяет принимать соединение без сертификата, но использовать его, если он всё же предоставлен; обычно используется для гибких сценариев, но для полноценной mutual-аутентификации чаще выставляют «Require».  
8) В ASP.NET (или .NET Framework) сервер может получить объект `HttpRequest.ClientCertificate`. Через него можно получить информацию о клиентском сертификате, цепочке, валидности и т. п. 
Пример (C#) в контроллере или HTTP-модуле:
```
var cert = Request.ClientCertificate;
if (cert.IsPresent) {
	var subject = cert.Subject;
	var issuer = cert.Issuer;
}
```
9) В ASP.NET Core аналогичные сведения доступны через `HttpContext.Connection.ClientCertificate`.
10) Дополнительная валидация клиентского сертификата  
10.1) При необходимости можно проверять:  
- Серийный номер: Сверяется со списком разрешённых номеров.  
- Issuer (кто выдал сертификат): Должен совпадать с доверенным CA.  
- Дата и время действия: Сертификат не должен быть просрочен.  
- Подпись: Как правило, если цепочка доверия верна, подпись тоже валидна.  
10.1) Можно реализовать гибкую логику (например, хранить в базе список серийных номеров сертификатов, привязанных к конкретным пользователям или клиентским приложениям).
11) IIS умеет маппить сертификаты на Windows-учётные записи (cert-mapping), если это требуется политикой безопасности.  
Однако в современных .NET-приложениях чаще делают собственную логику аутентификации/авторизации на базе данных, проверяя поля сертификата или сопоставляя его с токеном.
12) Важно иметь процедуру ротации сертификатов и следить за сроком их действия.  
Если используется автоматизация (например, PowerShell-скрипты или DevOps-пайплайны), полезно настраивать механизмы «холодной» (безостановочной) замены сертификата в IIS.