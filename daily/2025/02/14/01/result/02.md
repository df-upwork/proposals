1) First, you must select a Certification Authority (CA).
1.1) If you are using an internal corporate CA (for example, Microsoft Active Directory Certificate Services), you must ensure that it is correctly configured to issue certificates for both servers and clients.
1.2) You can also use an external commercial CA (for example, GlobalSign, DigiCert, etc.).
2) Then you need to create a Certificate Signing Request (CSR) on the server (IIS) or use a separate tool (for example, `certreq.exe` or OpenSSL).
3) Then you need to create client certificates.
On the client side, the key is usually stored in the user's Personal store or in the application that interacts with the server.
It is important to properly configure «Key Usage» and «Extended Key Usage» so that the certificate is suitable for client authentication.
When you use a Windows client or .NET client, the certificate is installed in the user's Personal store («Current User» → «Personal») or the machine store.
4) Then, you need to ensure that the root (Root CA) and, if necessary, the intermediate (Intermediate CA) certificates are installed in «Trusted Root Certification Authorities» on both the server side and the client side.
Without a correct trust chain, mutual authentication will not work (the certificates will not pass validation).
5) In IIS Manager → «Server Certificates» section, ensure that your server certificate (issued by the CA) has been correctly added to the server's certificate store.
6) Create or update the HTTPS binding for the required site in IIS by selecting the required certificate in the «SSL certificate» field.
7) In the site properties or in a specific virtual directory/application in IIS, find the «SSL Settings» tab.
7.1) In the «Client certificates» settings, select «Require» or «Accept», depending on the logic:
- «Require» — will break the connection if the client does not present a valid certificate.
- «Accept» — allows the connection without a certificate but uses it if it is still provided; it is usually used for flexible scenarios, but for a full-fledged mutual authentication, «Require» is more common.
8) In ASP.NET (or .NET Framework), the server can get the `HttpRequest.ClientCertificate` object.
You can use it to get information about the client certificate, its chain, validity, etc.
Example (C#) in a controller or HTTP module:
```
var cert = Request.ClientCertificate;
if (cert.IsPresent) {
	var subject = cert.Subject;
	var issuer = cert.Issuer;
}
```
9) In ASP.NET Core, the same information is available through `HttpContext.Connection.ClientCertificate`.
10) Additional validation of the client certificate
10.1) If necessary, you can check the following:
- Serial number: It is compared against the list of allowed numbers.
- Issuer (who issued the certificate): Must match the trusted CA.
- Date and time of validity: The certificate must not be expired.
- Signature: If the trust chain is correct, the signature is usually valid.
10.1) You can implement flexible logic (for example, store a list of certificate serial numbers in the database, tied to specific users or client applications).
11) IIS can map certificates to Windows accounts (cert-mapping) if this is required by the security policy.
However, in modern .NET applications, it is more common to use custom authentication or authorization logic based on a database that validates certificate fields or maps them to a token.
12) It is important to have a process for rotating certificates and monitoring their expiration dates.
When using automation (e.g. PowerShell scripts or DevOps pipelines), it is helpful to configure mechanisms for «cold» (zero downtime) certificate replacement in IIS.
---
I have completed 534 projects here on Upwork.
My GitHub profile: https://github.com/dmitrii-fediuk
My websites: https://df.tips?order=views, https://dmitry.ai?order=views, https://mage2.pro?order=views 