## 1.
Клиент хочет выполнить следующий проект:
### 1.1. Title
Amazon SP-API - JSON_LISTINGS_FEED Update Bug Fix

### 1.2. Description
We have migrated our Amazon SP-API PHP stock level Script from XML to JSON submission using JSON_LISTINGS_FEED, however no values are been updated from what we can see a successful upload. Need help with the JSON structure, error catching and migration

### 1.3. Местоположение клиента
United Kingdom
Hitchin

### 1.4. Tags
MySQL
SQL
PHP
API
Amazon Web Services
JSON

## 2. «no values are been updated»
### 2.1.
Я тебя спросил:
~~~
В пункте 1.2 клиент пишет:
```
no values are been updated
```
В чём причина проблемы клиента?
~~~

### 2.2.
Ты ответил:
~~~
Судя по описанию «no values are been updated» при вроде бы «успешной» загрузке, ключевая причина в том, что Amazon просто не обрабатывает или отбрасывает предоставленные данные (другими словами, «успешная загрузка» здесь не означает «успешное обновление значений»). Чаще всего это происходит из-за неправильного формата JSON (не соответствует требованиям JSON_LISTINGS_FEED) либо из-за пропущенных/неверных обязательных полей в самом фиде.  

Основные пункты, которые чаще всего приводят к подобным проблемам:

1. **Неправильная структура JSON**  
   - Amazon ожидает определённое дерево объектов и полей, соответствующее JSON_LISTINGS_FEED. Если хотя бы одно поле не совпадает с ожидаемой схемой или структура не соблюдена, Amazon не обновит данные.  
   - Нужно убедиться, что поля SKU, идентификатор товара (ASIN) или аналогичные ключевые поля присутствуют и имеют корректный формат.

2. **Неполный набор данных**  
   - Для обновления определённых атрибутов (например, цены, наличия, описания) Amazon требует обязательные поля. При отсутствии даже одного из таких полей обновление просто не произойдёт.  
   - Иногда требуется указывать MarketplaceId, ConditionType или другие важные поля (в зависимости от типа обновления).

3. **Отсутствие или некорректное чтение Feed Processing Report**  
   - После отправки JSON-фида Amazon генерирует отчёт, который показывает, были ли данные приняты или отклонены. Если этот отчёт не проверяется или неправильно интерпретируется, можно неверно заключить, что «загрузка успешна», тогда как на деле обновления могли быть отвергнуты.  
   - Из лога/отчёта обычно понятно, почему конкретные поля не были обновлены.

4. **Ошибки при формировании заголовков (headers) в запросе**  
   - В SP-API достаточно строгие требования к заголовкам авторизации, датам, подписям (Signature). Если что-то некорректно, Amazon может принять запрос «без ошибок» на этапе соединения, но не применить обновление.  

Таким образом, суть проблемы сводится к неправильному или неполно сформированному JSON-фиду и отсутствию корректной проверки отчёта о его обработке. Чтобы устранить эту проблему, нужно:

1. Свериться со **спецификацией JSON_LISTINGS_FEED**, особенно с обязательными полями.  
2. **Логировать** и **анализировать** Feed Processing Report.  
3. Проверить, что **заголовки** при запросе к SP-API корректны и соответствуют требованиям (особенно если используется собственная библиотека для подписи/формирования запроса).  
4. При необходимости пересмотреть **права** (auth/roles/permissions) в IAM/Developer Console, чтобы убедиться, что у скрипта достаточно прав на внесение нужных изменений в листинги.
~~~

## 3. «we can see a successful upload»
### 3.1.
Я тебя спросил:
~~~
В пункте 1.2 клиент пишет:
```
we can see a successful upload
```
Что клиент имеет в виду фразой «we can see a successful upload?
Feed Processing Report или что-то другое?
~~~

### 3.2.
Ты ответил:
~~~
Чаще всего под «successful upload» имеют в виду именно то, что **запрос на подачу фида был успешно принят Amazon** (то есть сервер не вернул никаких ошибок при отправке). Это означает, что **технически** фид был «загружен» и Amazon присвоил ему некий Feed ID. Однако **это не обязательно означает, что изменения действительно применены к листингу**.

Обычно механизм работы Feeds API такой:

1. **Отправка фида (submitFeed)**  
   - При этом вы получаете подтверждение: *«Фид принят сервером, ошибок на этапе загрузки нет»*.  
   - Часто это и называют «successful upload».

2. **Обработка фида (processing)**  
   - Amazon в фоновом режиме обрабатывает полученные данные, и по завершении вы можете получить «Feed Processing Report». Именно в нём отображается, *были ли фактически приняты изменения по каждому SKU* или какие-то записи отклонены с указанием причин.  

В вашей цитате «we can see a successful upload» скорее всего говорит о том, что **фид загрузился и не выдал явной ошибки на этапе отправки** (ошибок сетевого уровня, 4xx/5xx, валидации на уровне запроса и т.п.). Но это не означает, что **сам контент фида** соответствует требованиям и что **эти данные были применены** к листингам.

Таким образом, клиент, видимо, ещё *не* смотрит (или не до конца смотрит) **Feed Processing Report** и воспринимает саму успешную передачу данных через API как гарантию, что обновления должны произойти. Но на самом деле, чтобы подтвердить, что значения обновились, нужно смотреть именно в итоговый отчёт и проверять статус/детальную информацию там.
~~~

## 4. Напиши инструкцию, как посмотреть Feed Processing Report
### 4.1.
Я тебя спросил:
~~~
Напиши пошаговую инструкцию, как посмотреть Feed Processing Report.
~~~

### 4.2.
Ты ответил:
~~~
Ниже приведён пример пошаговой инструкции, как проверить результат обработки фида (Feed Processing Report) с помощью Amazon SP-API. Предполагается, что есть доступ к Amazon Seller Central и настроены необходимые учетные данные в AWS для работы с Amazon SP-API.

1. Создать документ фида с помощью операции createFeedDocument.  
   1.1. Отправить запрос POST на ресурс /feeds/2021-06-30/documents согласно официальной документации Amazon SP-API (раздел «Feeds» → «createFeedDocument»).  
   1.2. В ответ придёт объект JSON, в котором будет поле feedDocumentId и ссылку preSignedUrl.  
   1.3. Сохранить значение feedDocumentId для дальнейшего использования.

2. Загрузить содержимое фида (JSON_LISTINGS_FEED) в preSignedUrl.  
   2.1. Использовать любой HTTP-клиент, который поддерживает PUT-запросы.  
   2.2. В заголовке Content-Type указать application/json.  
   2.3. Отправить подготовленный JSON-фид на указанный в поле preSignedUrl адрес.  
   2.4. Убедиться, что HTTP-статус ответа от сервера 200 (OK).

3. Создать фид с помощью операции createFeed.  
   3.1. Отправить запрос POST на ресурс /feeds/2021-06-30/feeds.  
   3.2. В теле запроса указать:  
       • feedType (например, "JSON_LISTINGS_FEED"),  
       • marketPlaceIds (список идентификаторов маркетплейсов),  
       • inputFeedDocumentId (значение feedDocumentId из шага 1.3).  
   3.3. Запомнить значение feedId из ответа.

4. Проверить статус обработки фида с помощью операции getFeed.  
   4.1. Отправить запрос GET на ресурс /feeds/2021-06-30/feeds/{feedId}.  
   4.2. В ответе будет указано поле processingStatus.  
   4.3. При необходимости повторять вызов getFeed через интервалы времени, чтобы дождаться завершения обработки (значение processingStatus может быть IN_PROGRESS, DONE, CANCELLED, FATAL и т.д.).

5. После завершения обработки (processingStatus = DONE, CANCELLED или FATAL), получить идентификатор документа результата.  
   5.1. В ответе getFeed, кроме прочего, будет указано поле resultFeedDocumentId (если доступен отчет, то в поле resultFeedDocumentId будет содержаться идентификатор).  
   5.2. Сохранить значение resultFeedDocumentId.

6. Получить содержимое Feed Processing Report с помощью операции getFeedDocument.  
   6.1. Отправить запрос GET на ресурс /feeds/2021-06-30/documents/{resultFeedDocumentId}.  
   6.2. Из ответа извлечь поле url (в отличие от preSignedUrl, этот URL ведёт к отчету об обработке фида).  
   6.3. Скачать файл отчета по указанному URL (обычно это JSON или XML).  

7. Изучить детали Feed Processing Report.  
   7.1. Открыть скачанный файл (например, в текстовом редакторе или анализировать программно).  
   7.2. Проверить, какие SKU или ASIN были успешно обновлены, а какие отклонены.  
   7.3. При наличии ошибок изучить коды ошибок и сообщения, чтобы исправить структуру фида или данные (например, при отсутствии обязательных полей).

8. Для удобства можно дополнительно проверить обновление листинга в интерфейсе Amazon Seller Central.  
   8.1. Перейти в «Seller Central» → «Inventory» → «Manage All Inventory».  
   8.2. Убедиться, что внесённые данные (например, новые уровни наличия, цена, атрибуты) отражаются корректно.  

Если в Feed Processing Report указаны ошибки, целесообразно скорректировать JSON-фид и повторить процесс с учётом замечаний из отчёта. Это стандартная практика при работе с Amazon SP-API: отсутствие ошибок в момент отправки ещё не гарантирует, что все данные приняты и обновлены на стороне Amazon.
~~~

## 5. «запрос на подачу фида был успешно принят Amazon»
### 5.1.
Я тебя спросил:
~~~
В пункте 3.2 ты писал:
```
Чаще всего под «successful upload» имеют в виду именно то, что **запрос на подачу фида был успешно принят Amazon** (то есть сервер не вернул никаких ошибок при отправке). Это означает, что **технически** фид был «загружен» и Amazon присвоил ему некий Feed ID. 
```
Что конкретно при этом пишет Amazon пользователю?
Приведи точную цитату на английском языке.
~~~

### 5.2.
Ты ответил:
~~~
Ни в SP-API, ни в старом MWS нет буквально зашитой «человеческой» строки вроде *«Your feed has been accepted successfully!»* В случае SP-API Amazon просто возвращает стандартный HTTP-код и объект с `feedId`. 

### Как это выглядит в SP-API (пример из официальной документации)

При вызове `createFeed` в ответ вы обычно получаете статус **`HTTP/1.1 201 Created`** и тело:

```json
{
  "feedId": "5193140167"
}
```

В официальной документации это кратко описывается фразой (на английском):
> **"The feed was successfully created."**  

Но в реальности *никакой* дополнительной текстовой строки об «успешной загрузке» (в стиле «We have accepted your feed») не придёт. Сам факт, что вернулся код **201 Created** и объект с `feedId`, трактуется как успешная подача (upload) фида.

### Как это выглядело в MWS (устаревшая API)

В старом Amazon MWS при вызове `SubmitFeed` тоже не было «фразы» вроде *«Feed submission successful»*. Сервер возвращал XML-ответ со структурой:

```xml
<SubmitFeedResponse xmlns="http://mws.amazonaws.com/doc/2009-01-01/">
  <SubmitFeedResult>
    <FeedSubmissionInfo>
      <FeedSubmissionId>1234567890</FeedSubmissionId>
      <FeedType>_POST_PRODUCT_DATA_</FeedType>
      <SubmittedDate>2012-09-20T02:10:33+00:00</SubmittedDate>
      <FeedProcessingStatus>_SUBMITTED_</FeedProcessingStatus>
    </FeedSubmissionInfo>
  </SubmitFeedResult>
  <ResponseMetadata>
    <RequestId>...</RequestId>
  </ResponseMetadata>
</SubmitFeedResponse>
```

В документации могли кратко писать (на английском) что-то вроде:
> **“Your request has been submitted successfully and a FeedSubmissionId was returned.”**  

Но это уже пояснение в документации, а не буквальный текст от сервера.

### Что видит пользователь в Seller Central

Если грузить файлы через веб-интерфейс (вкладка «Add Products via Upload» или аналогичные инструменты), после отправки файла часто появляется фраза:

> **“Your file has been submitted successfully. We will notify you when the processing is complete.”**

Но это сообщение **интерфейса** Seller Central, а не прямой ответ API.

---

## Итого

1. **Официальный ответ SP-API** — это **HTTP-код** и, в случае успеха, **JSON** с `feedId`.  
2. В документации Amazon для ответа с кодом `201 Created` обычно пишут комментарий:  
   > **"The feed was successfully created."**  
3. В старом MWS — XML с `FeedSubmissionId` и `FeedProcessingStatus=_SUBMITTED_`.  
4. В интерфейсе Seller Central может быть надпись в стиле:  
   > **“Your file has been submitted successfully…”**  

Но точной развернутой фразы «we can see a successful upload» в теле ответа от Amazon не существует. Это скорее пользовательское (или интерфейсное) описание того, что *«фид был принят без ошибок и получил свой ID»*.
~~~

## 6. Как клиенту программно получить и обработать Feed Processing Report, относящийся к его конкретной загрузке?
### 6.1.
Я тебя спросил:
~~~
В пункте 1.2 клиент пишет, что использует «PHP stock level Script».
Как же ему в программно получить и обработать Feed Processing Report, относящийся к его конкретной загрузке?
~~~

### 6.2.
Ты ответил:
~~~
Ниже приведён упрощённый алгоритм (и примерная схема кода на PHP), показывающий, как **программно** (через Amazon SP-API) получить и обработать *Feed Processing Report* именно для того фида, который вы только что загрузили (submit). Предполагается, что у вас уже есть:

1. **Доступ** к SP-API (учётные данные, роли, авторизация).
2. **Скрипт на PHP**, который умеет формировать/подписывать запросы к SP-API.
3. **Создан и отправлен** фид (JSON_LISTINGS_FEED) через `createFeedDocument` + `createFeed`.

---

## Общая схема (шаги SP-API)

1. **Создание документа фида** (createFeedDocument)  
2. **Загрузка контента фида** (PUT на preSignedUrl)  
3. **Создание самого фида** (createFeed)  
4. **Ожидание завершения обработки** (poll getFeed → проверка `processingStatus`)  
5. **Получение `resultFeedDocumentId`** из ответа getFeed  
6. **Скачивание отчёта** (getFeedDocument → GET на URL из ответа)  
7. **Разбор отчёта** и анализ ошибок/предупреждений.

При этом `feedId` и `resultFeedDocumentId` будут уникальны для каждого фида, поэтому вы точно будете получать отчёт именно по *своему* конкретному файлу.

---

## Как программно «подождать» и получить отчёт

### 1. Отправляем запрос `createFeed`

После того как вы **уже** загрузили сам JSON-файл на `preSignedUrl` (из `createFeedDocument`), вы вызываете `createFeed`. Пример тела запроса (в JSON) для createFeed может выглядеть так:

```jsonc
{
  "feedType": "JSON_LISTINGS_FEED",
  "marketplaceIds": ["A1F83G8C2ARO7P"], // UK marketplaceId
  "inputFeedDocumentId": "amzn1.spdoc.XXXXXX", // ваш feedDocumentId из createFeedDocument
  "region": "EU"
}
```

В ответ придёт **`feedId`**:

```json
{
  "feedId": "5193140167"
}
```

Сохраняйте `feedId`: оно понадобится, чтобы получить статус и потом результат.

---

### 2. Периодически запрашиваем статус обработки (getFeed)

Пример запроса на получение статуса:  
```
GET /feeds/2021-06-30/feeds/{feedId}
```

Вместо `{feedId}` — подставьте реальный `feedId`, полученный на шаге выше.  
В ответ вы получите JSON с полем `processingStatus`. Например:

```json
{
  "feedId": "5193140167",
  "feedType": "JSON_LISTINGS_FEED",
  "processingStatus": "IN_PROGRESS",
  "createdTime": "2025-02-22T10:00:00Z",
  "processingStartTime": "2025-02-22T10:01:00Z"
  // ...
}
```

Возможные значения `processingStatus`:

- `IN_QUEUE`  
- `IN_PROGRESS`  
- `DONE`  
- `CANCELLED`  
- `FATAL`  
- и т.д.

Пока статус не стал `DONE` (либо `CANCELLED` или `FATAL`), отчёт либо не готов, либо фид прерван.  
Обычно проверяют раз в 1–2 минуты (или реже) до тех пор, пока `processingStatus` не изменится на `DONE` (или ошибочный).

---

### 3. Получаем `resultFeedDocumentId`

Когда `processingStatus` = `DONE` (или хотя бы `CANCELLED/FATAL`), в объекте ответа (из `getFeed`) появится поле `resultFeedDocumentId`. Пример:

```json
{
  "feedId": "5193140167",
  "feedType": "JSON_LISTINGS_FEED",
  "processingStatus": "DONE",
  "createdTime": "2025-02-22T10:00:00Z",
  "processingStartTime": "2025-02-22T10:01:00Z",
  "processingEndTime": "2025-02-22T10:02:30Z",
  "resultFeedDocumentId": "amzn1.spdoc.abc1234-5678" 
}
```

Если `resultFeedDocumentId` отсутствует, значит отчет недоступен (например, при `FATAL` или другой аномалии).

---

### 4. Забираем ссылку на отчёт (`getFeedDocument`)

Теперь делаем запрос:  
```
GET /feeds/2021-06-30/documents/{resultFeedDocumentId}
```

Пример ответа:

```json
{
  "feedDocumentId": "amzn1.spdoc.abc1234-5678",
  "url": "https://d28xxxxx.cloudfront.net/FeedDocuments/...",
  "encryptionDetails": { 
    "standard": "AES",
    "initializationVector": "...", 
    "key": "..."
  }
}
```

- Поле `url` содержит **pre-signed URL**, откуда можно скачать сам *Feed Processing Report*.  
- Также может быть указан блок `encryptionDetails`, если Amazon хранит отчёт в зашифрованном виде (в таком случае его нужно расшифровывать вручную). Для JSON_LISTINGS_FEED бывает и незашифрованный вариант.  

---

### 5. Скачиваем Feed Processing Report

Чаще всего это делается обычным HTTP GET-запросом по `url`:

```php
$reportUrl = $feedDocument['url']; 
// затем GET-запрос любым методом — cURL, Guzzle и т.п.
```

Если используется **шифрование** (см. `encryptionDetails`), придётся расшифровать файл по схеме AES (Amazon подробно описывает это в документации SP-API, раздел «Decrypting feed document contents»). 

---

### 6. Анализируем содержимое отчёта

- Формат отчёта может быть JSON или XML (зависит от типа фида). Для `JSON_LISTINGS_FEED` Amazon зачастую выдаёт JSON-структуру.
- Внутри отчёта перечислены **строки** (SKU, ASIN и т.п.) с указанием, принято обновление или нет, а также коды ошибок/предупреждений.
- Вот здесь вы и увидите, *почему* какие-то значения не обновились. Например, может быть отсутствует обязательное поле, неверная цена или статус.

---

## Примерный PHP-код (упрощённый)

Ниже *очень упрощённая* иллюстрация, как может выглядеть проверка статуса фида и скачивание отчёта. Предположим, что вы уже имеете функцию `callSpApi($method, $endpoint, $body=null)` для отправки подписанных запросов к SP-API (на базе Guzzle или cURL).

```php
function waitForFeedProcessingAndGetReport($feedId, $maxRetries = 10, $sleepSeconds = 60) {
    $reportContent = null;

    for ($i = 0; $i < $maxRetries; $i++) {
        // 1) Запрашиваем информацию о фиде
        $response = callSpApi('GET', "/feeds/2021-06-30/feeds/$feedId");
        $feedInfo = json_decode($response, true);

        $status = $feedInfo['processingStatus'] ?? 'UNKNOWN';

        // 2) Проверяем статус
        if ($status === 'DONE' || $status === 'CANCELLED' || $status === 'FATAL') {
            // Пытаемся получить resultFeedDocumentId
            if (!empty($feedInfo['resultFeedDocumentId'])) {
                // 3) Получаем URL для скачивания
                $docId = $feedInfo['resultFeedDocumentId'];
                $docResponse = callSpApi('GET', "/feeds/2021-06-30/documents/$docId");
                $docInfo = json_decode($docResponse, true);

                $downloadUrl = $docInfo['url'] ?? null;
                // 4) Скачиваем файл
                if ($downloadUrl) {
                    $reportContent = file_get_contents($downloadUrl);

                    // Если зашифровано (encryptionDetails), нужно расшифровать вручную
                    // Пример:
                    //   $decryptedReport = decryptAes($reportContent, $docInfo['encryptionDetails']);
                    //   return $decryptedReport; 
                    
                    return $reportContent;
                }
            }
            // Если `resultFeedDocumentId` нет, значит отчёт не формировался.
            // Можно выйти или вернуть null/false.
            return null;
        } else {
            // Если не DONE, подождать и повторить
            sleep($sleepSeconds);
        }
    }

    // Если цикл закончился, фид не успел завершиться
    return null;
}
```

Далее вы анализируете `$reportContent`. Если отчёт — JSON, делаете `json_decode($reportContent, true)` и ищете ошибки/предупреждения:

```php
$reportData = json_decode($reportContent, true);
if (isset($reportData['errors'])) {
    // смотрим, что именно
    // ...
}
```

---

## Важные замечания

1. **Обратите внимание на шифрование**:  
   - В некоторых случаях Amazon хранит фид и отчёт в зашифрованном виде (AES). Тогда нужно использовать `encryptionDetails` из ответа `getFeedDocument`. Алгоритм расшифровки описан в [официальной документации SP-API](https://github.com/amzn/selling-partner-api-docs/tree/main/guides/feed_guide) (раздел «Decrypting the feed document contents»).  

2. **Проверяйте ошибки авторизации** и права IAM:  
   - Если в вашем скрипте неверно подписаны запросы или у приложения нет нужных разрешений, вы можете получить 403/401 при попытке вызвать `getFeed` или `getFeedDocument`.

3. **Учитывайте MarketplaceId**:  
   - При работе с конкретным европейским маркетплейсом (Великобритания: `A1F83G8C2ARO7P`) не забудьте корректно указывать `marketplaceIds`.  
   - Если нужно обновлять несколько marketplaces, указывайте их массивом.

4. **Изучайте содержимое Feed Processing Report**:  
   - Именно из него вы поймёте, *почему* «no values are updated». Возможно, у вас неверная структура JSON или пропущен `SKU`, `ASIN` и т.д.

---

# Итог

Чтобы **программно получить и обработать Feed Processing Report** для «конкретной загрузки» (фида), нужно:

1. **Сохранить** `feedId`, который вернулся в ответ на `createFeed`.  
2. **Периодически** вызывать `getFeed(feedId)` и ждать, пока `processingStatus` не станет `DONE` (или ошибка).  
3. Как только статус = `DONE`, извлечь `resultFeedDocumentId` из ответа.  
4. Вызвать `getFeedDocument(resultFeedDocumentId)`, взять `url` и скачать файл (при необходимости расшифровать).  
5. **Разобрать** (JSON/XML) содержимое отчёта и посмотреть, какие изменения Amazon применил и какие — отклонил.  

Так вы сможете автоматизировать полный цикл: от подачи фида до анализа детальных результатов обработки.
~~~

## 7. Мой ответ клиенту
Я хочу ответить клиенту так:
~~~
1) Probably, the developer of your PHP script has carelessly assumed that «successful upload» means calling `POST /feeds/2021-06-30/feeds` (`createFeed`) and receiving `feedId` in response.
https://developer-docs.amazon.com/sp-api/docs/feeds-api-v2021-06-30-reference#createfeed
2) However, Amazon processes feeds asynchronously: after a certain amount of time after the upload, Amazon creates a «Feed Processing Report» which informs you whether Amazon accepts your feed or not. 
3) Accordingly, after `createFeed` it is necessary to wait for the «Feed Processing Report», retrieve it, and then interpret it correctly:
3.1) It is necessary to request the processing status periodically: `GET /feeds/2021-06-30/feeds/{feedId}`
https://developer-docs.amazon.com/sp-api/docs/feeds-api-v2021-06-30-reference#get-feeds2021-06-30feedsfeedid 
3.2) In the response, Amazon returns a `Feed` object.  
For this object, it is necessary to track the value of the `processingStatus` field: https://developer-docs.amazon.com/sp-api/docs/feeds-api-v2021-06-30-reference#processingstatus  
3.2.1) As long as the value is `IN_PROGRESS` or `IN_QUEUE`, it is necessary to repeat point 3.1 periodically.
3.2.2) The other 3 possible values are: `DONE`, `CANCELLED`, and `FATAL`.
Even here `DONE` does not mean that the feed is a «successful upload»: this status only means that Amazon has finished processing the feed.
4) To diagnose `DONE`, `CANCELLED`, and `FATAL`, it is necessary to use another field of the `Feed` object from point 3.2: `resultFeedDocumentId`.
4.1) Using the value of this field, it is necessary to request `GET /feeds/2021-06-30/documents/{resultFeedDocumentId}`:
https://developer-docs.amazon.com/sp-api/docs/feeds-api-v2021-06-30-reference#get-feeds2021-06-30documentsfeeddocumentid
4.2) The response will be a `FeedDocument` object: https://developer-docs.amazon.com/sp-api/docs/feeds-api-v2021-06-30-reference#feeddocument
For it, it is necessary to use the `url` field — this is the «Feed Processing Report» address.  
This report will list all the errors of your feed. 
5) I can implement the proper feed submission to Amazon in your PHP script.  
I have been working on eCommerce programming for the last 15 years (usually Magento — the largest in size and functionality eCommerce program in PHP) and I know all the proper eCommerce processes.  
~~~

## 8. Твоя задача
Проанализируй следующий фрагмент моего ответа клиенту (пункт 7) на наличие языковых ошибок/недостатков:
<фрагмент>
STUB
</фрагмент>

## 9. Требования к твоему ответу
### 9.1.
Анализируй только тот фрагмент текста, который указан в пункте 8.

### 9.2.
Используй полный текст моего ответа клиенту (пункт 7) для понимания контекста анализируемого фрагмента (пункт 8).

### 9.3.
Используй все предыдущие пункты моего запроса для понимания обсуждаемой в моём ответе клиенту (пункт 7) предметной области.

### 9.4. 
Анализ языковых ошибок (пункт 8) веди на русском языке.

### 9.5.
К уловым кавычкам `«»` не придирайся.

### 9.6.
Каждую языковую ошибку нумеруй.

### 9.7. Итоговый вариант
#### 9.7.1
После своего анализа каждой из языковых ошибок предложи итоговый вариант улучшения анализируемого фрагмента (пункт 8). 
#### 9.7.2
Назови этот раздел своего ответа «Итоговый вариант».
Сделай это заголовком 2-го уровня (используй `##`).
#### 9.7.3
Свой итоговый вариант помести внутрь backticks таким образом:
```
Текст итогового варианта
```
Мне это нужно, чтобы я мог одним кликом скопировать твой итоговый вариант.
#### 9.7.4
Не добавляй новую разметку Markdown к итоговому варианту.
Используй только ту разметку Markdown, которая имелась в исходном варианте.
#### 9.7.5
Форматируй итоговый вариант в точности как исходный фрагмент. 
В частности:
*) каждый абзац должен содержать ровно одно предложение
*) между абзацами не должно оставаться пустых строк.
*) кавычки используй те же, что и в оригинале: «» и ``.
### 9.7.6
Не используй в итоговом варианте сокращения типа «don't». 
Все подобные фразы пиши полностью: «do not».

### 9.8.
Не используй «you need» и другие подобные обращённые к клиенту фразы, перекладывающие действия на него.
Помни: я пишу клиенту или потенциальному клиенту.
Делать в любом случае буду я, а не клиент.
Вместо «you need» используй 2 альтернативы:
#### 9.8.1.
Нейтральные фразы типа «it is necessary».
#### 9.8.2.
Глаголы в неопределённой форме.
Например, во фрагменте ниже использованы подобные глаголы «set up», «create»:
```
1.2) Set up the transfer of login events from WordPress to Power BI using Fabric / OneLake.
1.2.1) Set up a «Data Pipeline» from the WordPress database table that stores login events (see point 1.1) to Fabric / OneLake.
1.2.2) Set up a connection from Power BI to Fabric / OneLake to pass login events.
1.3) Create the data model in Power BI.
```
Обрати внимание, в этом фрагменте не говорится, кто именно будет выполнять описанные действия: ответственность не перекладывается на клиента, в отличие от «you need».

### 9.9.
Никогда не переводи понятие «сайт» / «веб-сайт» как «site». 
Вместо этого используй форму «website»: это является более профессиональным.

### 9.10.
Никогда не переводи понятие «пункт нумерованного списка» как «item».
Всегда переводи это как «point»