https://g.co/gemini/share/26cf16dba77e

1. (К пункту 3.4.2) Описана логика обновления полей `CurrentID` и `PathHistory` в рамках одного инструмента «Formula». При этом формула для `PathHistory` (`[PathHistory] + ToString([CurrentID]) + "|"`) ссылается на поле `CurrentID`, которое обновляется в этом же инструменте. Фактически, инструмент «Formula» выполняет выражения последовательно. Корректность работы этой логики зависит от строгого соблюдения порядка выражений (обновление `CurrentID` должно предшествовать обновлению `PathHistory`). Зависимость от порядка выполнения внутри одного инструмента делает реализацию хрупкой (fragile design). Изменение порядка приведет к логической ошибке. Рекомендуется рассчитывать `PathHistory`, используя исходные поля, доступные после соединения (например, идентификатор потомка из потока `Input_H`), чтобы устранить эту зависимость.

2. (К пункту 2.2) Описан паттерн «Double Join» для реализации Conditional Outer Join. Этот метод является корректным, но не оптимальным во всех случаях. Если условные предикаты зависят только от полей одной (правой) таблицы (логика SQL: `LEFT JOIN ON L.Key = R.Key AND [R.Condition]`), существует более производительная альтернатива: предварительная фильтрация правого потока перед инструментом «Join» с последующим стандартным объединением выходов L и J. Отсутствие упоминания этой оптимизации является упущением.

3. (К пунктам 1.4 и 3.4) В описании подготовки и обновления итерационных полей (`Level`, `PathHistory`) отсутствует указание на необходимость строгого управления типами и размерами данных. Итеративные макросы требуют абсолютного совпадения схемы данных (metadata) между итерациями. Необходимо явно определять типы данных с помощью инструмента «Select» или в конфигурации «Macro Input».

4. (К пункту 3.3.6) Не рассмотрен риск усечения (Truncation) данных в поле `PathHistory`. Это поле увеличивается на каждой итерации. Если размер строкового поля недостаточен для хранения полного пути в глубокой иерархии, данные будут автоматически усечены. Это приведет к некорректной работе механизма обнаружения циклических ссылок и, как следствие, к ошибкам в результирующих данных. Необходимо гарантировать достаточный размер поля (например, используя тип V_String или V_WString с большим размером).

5. (К пункту 4.2.3) Рекомендация установить «Maximum Number of Iterations» в значение «например, 100» является потенциально опасной. Если фактическая глубина иерархии превысит это значение, макрос остановится, и результаты будут неполными (обработка иерархии завершится преждевременно). Следует рекомендовать значение, заведомо превышающее максимально ожидаемую глубину иерархии.

6. (К пункту 5.3) Не упомянута фактическая особенность работы Alteryx Engine: порядок записей на выходе итеративного макроса и последующего инструмента «Union» не гарантирован. Если для дальнейшей обработки требуется детерминированный порядок (например, сортировка по предку и уровню), необходимо явное добавление инструмента «Sort».

7. (К разделу 5) В пункте 3.5.3 определен выход для циклических данных (`Output_C`), однако в разделе 5 (Выполнение) отсутствуют инструкции по его обработке. Для обеспечения качества данных необходимо предусмотреть анализ этого выходного потока с целью идентификации и устранения циклических ссылок в исходных данных.