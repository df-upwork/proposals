## 1. `Def`
~~~
Def(A):
```
B
```
~~~
будет обозначать, что для понятия `B` я использую обозначение `A`.

## 2. `Def_P`
~~~
Def_P(A):
```
B
```
~~~
будет обозначать, что `B` является для меня проблемой, и для этой проблемы я использую обозначение `A`.

## 3. `Def_C`
### 3.1.
```
Def_C(P, A, B)
```
будет обозначать `Def(A, B)` в контексте пункта `P`.
Вне пункта `P` это правило не применяется.
Если до пункта `P` обозначение `A` имело другой смысл, то после пункта `P` обозначение `A` снова будет иметь этот смысл.
По сути, `Def_C` объявляет локальную переменную `A` с областью действия `P`.
В отличие от него, `Def` объявляет глобальную переменную `A` (значение которой действует для всех пунктов, кроме `P`).

### 3.2.
~~~
Def_C(P, A):
```
B
```
~~~
имеет то же значение, что и `Def_C(P, A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 3.3.
```
Def_C([P1, P2, …, Pn], A, B)
```
имеет значение, аналогичное `Def_C(P, A, B)`, только в этом случае обозначение `A` имеет значение `B` в контексте не одного пункта `P`, а всех пунктов [`P1`, `P2`, …, `Pn`], перечисленных в квадратных скобках.

### 3.4.
```
Def_C([P1-Pn], A, B)
```
имеет значение, аналогичное `Def_C([P1, P2, …, Pn], A, B)`: в этом случае обозначение `A` имеет значение `B` в контексте множества всех пунктов между `P1` и `Pn`, включая сами эти пункты.

### 3.5.
~~~
Def_C([P1, P2, …, Pn], A):
```
B
```
~~~
имеет то же значение, что и `Def_C([P1, P2, …, Pn], A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 3.6.
~~~
Def_C([P1-Pn], A):
```
B
```
~~~
имеет то же значение, что и `Def_C([P1-Pn], A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 4. `Def_F`
### 4.1.
Def_C(4-5, `F`):
```
Факт: некое событие, которое случилось в описываем мной случае.
```

### 4.2.
~~~
Def_F:
```
B
```
~~~
будет обозначать, что `B` — это `F`.

### 4.3.
~~~
Def_F(A):
```
B
```
~~~
будет обозначать, что `B` — это `F`, и для него я использую обозначение `A`.

## 5. `Def_Ph`
### 5.1.
Def_C(5, `Ph`):
```
Феномен: `F`, который вызывает у меня удивление.
```

### 5.2.
~~~
Def_Ph(A):
```
B
```
~~~
будет обозначать, что `B` — это `Ph`, и для него я использую обозначение `A`.

## 6. `Def_H`
### 6.1.
Def_C(6, `H`):
```
Гипотеза: некое предположение, требующее проверки.
```

### 6.2.
~~~
Def_H(A):
```
B
```
~~~
будет обозначать, что `B` — это `H`, и для него я использую обозначение `A`.

## 7. `Def_Set`
### 7.1.
```
Def_Set(S, I)
```
будет обозначать, что `S` — множество всех возможных `I`.

### 7.2.
```
Def_Set(S, {I1, I2, …, In})
```
будет обозначать, что `S` — множество, заданное точным перечислением всех его элементов: {`I1`, `I2`, …, `In`}.

## 8. `Def_I`
### 8.1.
```
Def_I(I, S)
```
будет обозначать, что `I` ∈ `S` (`I` — элемент множества `S`).

### 8.2.
~~~
Def_I(I, S):
```
B
```
~~~
будет обозначать, что `I` ∈ `S` и `B` — определение `I`.

## 9. `Use`
```
Use(A)
```
будет обозначать, что в описываемой мной ситуации я использую `A`.

## 10.
Потенциальный клиент опубликовал на Upwork следующий проект:
### 10.1. Title
Sending broadcast push notification at the server

### 10.2. Description
```text
This could be full-time or contract-basis position.
Most important thing is we should add sending broadcast push notification feature right now.
So agency or beginners please do not apply.
We were currently using Firebase push notification.
After adding the broadcast push notification feature, we will think about converting it into OneSignal if that's the way to do.
The guys who have node.js, typescript and docker experience must apply to this job.
If you don't know all of them, please do not waste our time.
```

### 10.3. Tags
Docker
React
Node.js
TypeScript
JavaScript
Firebase Cloud Firestore

## 11. Информация о клиенте
### 11.1. Местоположение
Japan
Kitakyushu

## 11.2. Характеристики компании
### 11.2.1. Сектор экономики
неизвестно
### 11.2.2. Количество сотрудников
неизвестно

## 11.3. Характеристики учётной записи на Upwork
### 11.3.1. Member since
Jul 7, 2025
#### 11.3.2. Hire rate (%)
58
#### 11.3.3. Количество опубликованных проектов (jobs posted)
7
#### 11.3.4. Total spent (USD)
110
#### 11.3.5. Количество оплаченных часов в почасовых проектах
0

## 12.
Def(`C`):
```
клиент пункта 10
```

## 13.
Def(`P`):
```
проект пункта 10
```

## 14.
Def(`PD`):
```
Описание `P` (пункт 10.2 выше)
```

## 15.
Def_F(`POs`):
```
Другие проекты `C` на Upwork:
~~~
1) https://www.upwork.com/jobs/~021945144932981572678
2) https://www.upwork.com/jobs/~021946198340312798764
3) https://www.upwork.com/jobs/~021944577886773602001
4) https://www.upwork.com/jobs/~021942043569245879475
~~~
```

## 16.
Def(`T`):
```
Задача, о которой `C` пишет в `PD`:
~~~
sending broadcast push notification feature
~~~
```

## 17.
N/A

## 18.
Def(`PN-F`):
```
Термин «Firebase push notification» в `PD`
```

## 19.
Def(`PN-B`):
```
Термин «broadcast push notification» в `PD`
```

## 20.
Def(`PNs`):
```
Разница `PN-F` и `PN-B` в понимании `C`.
Обрати внимание, что:
- в отношении `PN-F` `C` пишет: «We were currently using»
- в отношении `PN-B` `C` пишет: «we should add»
```

## 21.
N/A

## 22.
Def(`TM`):
```
FCM Topic Messaging (в контексте `P`)
```

## 23.
Def(`S`):
```
Решение `P` посредством `TM`
```

## 24.
Def(`D`, «мой ответ `C`»).

## 25.
Содержание `D`:
~~~markdown
1) Firebase предоставляет нативный механизм для реализации широковещательных рассылок: FCM Topic Messaging.
2) Предлагаемая мной архитектура:
2.1) Серверная часть (`S`) использует Firebase Admin SDK для выполнения привилегированных операций, таких как управление подписками устройств на темы и отправка сообщений по этим темам. 
`S` отвечает за всю серверную логику.  
2.2) Клиентская часть (`C`):
- запрашивает у пользователя (`U`) разрешение на получение уведомлений
- получает от FCM уникальный регистрационный токен (`T`) устройства и передаёт `T` на `S` для последующей подписки.
3) Высокоуровневая схема взаимодействия:
3.1) `C` получает `T` и отправляет его на `S`. 
3.2) `S` подписывает устройство с этим `T` на общую тему. 
3.3) В дальнейшем, для отправки широковещательного уведомления, авторизованный администратор (`A`) через защищённый API-эндпоинт `/api/broadcast` (`E1`) отправляет одно сообщение в FCM, указывая в качестве адресата эту общую тему. 
3.4) FCM, в свою очередь, доставляет это сообщение всем подписанным устройствам.
4) Ключевое архитектурное ограничение FCM для веб-клиентов заключается в том, что они не могут самостоятельно подписываться на темы. 
Эта операция должна выполняться `S`. 
Следовательно, необходимо создать серверный API-эндпоинт `/api/subscribe` (`E2`), который будет принимать регистрационный `T` от `C` и выполнять подписку от его имени.
5) Доступ к `E1` и `E2` должен быть строго ограничен. 
Незащищённые endpoints для широковещательной рассылки — это открытая дверь для спама и атак. 
 Я рекомендую реализовать эту защиту из 2 этапов:
5.1) Аутентификация: убедиться, что запрос исходит от известного, вошедшего в систему `A` (в случае `E1`) и `U` (в случае `E2`).
Для `E1` я рекомендую использовать ID-токены Firebase (`AT`), которые `A` будет отправлять с каждым запросом.
5.2) Авторизация: убедиться, что у `A` / `U` есть права на выполнение этого действия. 
5.2.1) Я рекомендую добавить `A` a custom claim (`AC`), например `{admin: true}`, и проверять его на `S`.
5.2.2) Назначение `AC` должно производиться через отдельный, высокозащищенный механизм, например, через Cloud Function, доступную только существующим `A`, или через серверный скрипт.
6) Для работы с FCM в `C` необходимо установить клиентский SDK и настроить Service Worker.
7) Браузер не предоставит `T`, пока `U` явно не разрешит сайту показывать уведомления.
Поэтому нужно запросить у `U` разрешение на получение уведомлений.
8) Крайне важно помнить, что `T` может меняться.
Лучшая практика — получать `T` при каждой загрузке `C` и отправлять на `S`, если он отличается от ранее сохранённого.
9) Для того чтобы `S` могло аутентифицироваться и выполнять вызовы API Firebase, ему необходима идентификация.
Эту роль выполняет сервисный аккаунт (`SA`): специальный тип учётной записи Google, предназначенный для не-человеческих взаимодействий, таких как взаимодействие между серверами.
Включение файла ключа `SA` в Docker-образ является грубым нарушением безопасности.
Правильный подход — инъекция учётных данных в контейнер во время его запуска.
10) Полный процесс подписки `U`:
10.1) `U` открывает `C` в браузере.
10.2) `C` инициирует запрос разрешения на показ уведомлений.
10.3) `U` нажимает «Разрешить».
10.4) `C` запрашивает у FCM `T`.
10.5) `C` отправляет токен в `S` на `E2`.
10.6) `S` подписывает `T` на общую тему `all_users`.
10.7) Устройство `U` готово к приёму широковещательных уведомлений.
11) Процедура инициирования широковещательного уведомления:
11.1) `А` входит в свою учётную запись в специальной административной панели.
11.2) `А` получает от Firebase `AT`, содержащий `AC`.
11.3) `А` формирует сообщение (заголовок и текст) и нажимает «Отправить».
11.4) Приложение администратора делает POST-запрос на `E1`, прикрепляя `AT` в заголовок `Authorization: Bearer <AT>`.
11.5) `E1` проверяет валидность токена и наличие `AC`.
Если проверка пройдена, `S` конструирует объект сообщения для FCM и вызывает метод `send`.
11.6) FCM получает запрос и доставляет уведомление на все устройства, подписанные на тему `all_users`.

~~~

## 26.
Def(`D2`, «начальная часть `D`, переведённая с Russian на English»).

## 27.
Содержание `D2`:
~~~markdown
1) Firebase provides a native mechanism for implementing broadcast messaging: FCM Topic Messaging.
2) My proposed architecture:
2.1) The server-side (`S`) uses the Firebase Admin SDK to perform privileged operations, such as managing device subscriptions to topics and sending messages to these topics. 
`S` is responsible for all the server-side logic.
2.2) Client-side (`C`):
- requests permission from the user (`U`) to receive notifications
- receives a unique device registration token (`T`) from FCM and sends `T` to `S` for subsequent subscription.
3) High-level interaction flow:
3.1) `C` obtains `T` and sends it to `S`.
3.2) `S` subscribes the device with this `T` to a common topic.
3.3) Subsequently, to send a broadcast notification, an authorized administrator (`A`) sends a single message to FCM via the secure API endpoint `/api/broadcast` (`E1`), specifying this common topic as the recipient.
3.4) FCM, in turn, delivers this message to all subscribed devices.
4) A key architectural limitation of FCM for web clients is that they cannot independently subscribe to topics.
This operation must be performed by `S`.
Consequently, it is necessary to create a server-side API endpoint `/api/subscribe` (`E2`) that will accept the registration `T` from `C` and perform the subscription on its behalf.
5) Access to `E1` and `E2` must be strictly restricted.
Unprotected endpoints for broadcast messaging are an open door for spam and attacks.
I recommend implementing this protection in 2 stages:
5.1) Authentication: to ensure that the request comes from a known, logged-in `A` (in the case of `E1`) and `U` (in the case of `E2`).
For `E1` I recommend using Firebase ID tokens (`AT`), which `A` will send with each request.
5.2) Authorization: to ensure that `A` / `U` has the permissions to perform this action.
5.2.1) I recommend adding a custom claim (`AC`) to `A`, e.g. `{admin: true}`, and verifying it on `S`.
5.2.2) The assignment of `AC` must be performed via a separate, highly secure mechanism, e.g., via a Cloud Function available only to existing `A`s, or via a server-side script.
6) To work with FCM in `C`, it is necessary to install the client SDK and configure a Service Worker.
7) The browser will not provide `T` until `U` explicitly grants the website permission to display notifications. Therefore, it is necessary to request permission from `U` to receive notifications.
8) It is crucial to remember that `T` can change.
The best practice is to obtain `T` on each load of `C` and send it to `S` if it differs from the one previously saved.
9) For `S` to authenticate and execute Firebase API calls, it requires an identity.
This role is performed by a service account (`SA`): a special type of Google account intended for non-human interactions, such as server-to-server communication.
Including the `SA` key file in the Docker image is a serious security violation.
The correct approach is to inject the credentials into the container at runtime.
~~~

## 28.
Def(`F`, «фрагмент `D`»).

## 29.
Содержание `F`:
~~~markdown
11.4) Приложение администратора делает POST-запрос на `E1`, прикрепляя `AT` в заголовок `Authorization: Bearer <AT>`.
11.5) `E1` проверяет валидность токена и наличие `AC`.
Если проверка пройдена, `S` конструирует объект сообщения для FCM и вызывает метод `send`.
11.6) FCM получает запрос и доставляет уведомление на все устройства, подписанные на тему `all_users`.
~~~

## 30.
Переведи `F` на English, с учётом:
- контекста `D`
- `D2`: уже переведённой части `D`
- всех предыдущих пунктов моего запроса

## 31. Правила перевода
### 31.1.
Переводи именно в той стилистике, как написано на Russian.
Не делай перевод более вежливым, чем оригинал.

### 31.2.
Те предложения, которые сейчас полностью на English — оставь без изменения.

### 31.3.
#### 31.3.1.
Не используй Markdown: только plain text.
#### 31.3.2.
При этом можно и нужно использовать то форматирование, которое уже есть в оригинале: его не убирай.
#### 31.3.3.
Не форматируй веб-ссылки посредством Markdown, если они не отформатированы так в оригинале. 
Например, не пиши так:
```
[https://www.eca.web.tr/eca-nita-esnek-uclu-eviye-bataryasi-beyaz-102118110-308](https://www.eca.web.tr/eca-nita-esnek-uclu-eviye-bataryasi-beyaz-102118110-308)
```
если в оригинале скобок `[]()` нет.

### 31.4.
Форматируй перевод в точности как оригинал. 
В частности:
*) каждый абзац должен содержать ровно одно предложение
*) между абзацами не должно оставаться пустых строк.
*) кавычки используй те же, что и в оригинале: «» и ``.

### 31.5.
Не используй сокращения типа «don't». Все подобные фразы пиши полностью: «do not».

### 31.6.
Не используй жаргон.
Вместо этого используй официальные термины.
#### 31.6.1.
В частности, фразы в кавычках используй только в том случае, когда они являются точными цитатами.
Не используй фразы в кавычках для применения жаргонных фраз.
Например, следующий фрагмент текста недопустим, потому что там используется жаргонная фраза «пролетел»: 
```
Например, код, который пушит данные о покупке, подключён асинхронно и загружается с небольшой задержкой, а триггер уже «пролетел».
```

### 31.7.
При обсуждении программного обеспечения используй точные официальные термины на английском языке: именно в том виде, как они указаны в официальной англоязычной документации к этому программному обеспечению.

### 31.8.
Не используй «you need» и другие подобные обращённые к клиенту фразы, перекладывающие действия на него.
Помни: я пишу клиенту или потенциальному клиенту.
Делать в любом случае буду я, а не клиент.
Вместо «you need» используй 2 альтернативы:
#### 31.8.1.
Нейтральные фразы типа «it is necessary».
#### 31.8.2.
Глаголы в неопределённой форме.
Например, во фрагменте ниже использованы подобные глаголы «set up», «create»:
```
1.2) Set up the transfer of login events from WordPress to Power BI using Fabric / OneLake.
1.2.1) Set up a «Data Pipeline» from the WordPress database table that stores login events (see point 1.1) to Fabric / OneLake.
1.2.2) Set up a connection from Power BI to Fabric / OneLake to pass login events.
1.3) Create the data model in Power BI.
```
Обрати внимание, в этом фрагменте не говорится, кто именно будет выполнять описанные действия: ответственность не перекладывается на клиента, в отличие от «you need».

### 31.9.
Никогда не переводи понятие «сайт» / «веб-сайт» как «site». 
Вместо этого используй форму «website»: это является более профессиональным.

### 31.10.
Никогда не переводи понятие «пункт нумерованного списка» как «item».
Всегда переводи это как «point».

### 31.11.
Вместо «for example» используй «e.g.».