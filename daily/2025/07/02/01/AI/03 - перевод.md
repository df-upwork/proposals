## 1. `Def`
### 1.1.
```
Def(A, B)
```
будет обозначать, что для понятия `B` я использую обозначение `A`.

### 1.2.
~~~
Def(A):
```
B
```
~~~
имеет то же значение, что и `Def(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 2. `Def_P`
### 2.1.
```
Def_P(A)
```
будет обозначать, что `A` является для меня проблемой.

### 2.2.
```
Def_P(A, B)
```
будет обозначать, что `B` является для меня проблемой, и для этой проблемы я использую обозначение `A`.

### 2.3.
~~~
Def_P(A):
```
B
```
~~~
имеет то же значение, что и `Def_P(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 3. `Def_C`
### 3.1.
```
Def_C(P, A, B)
```
будет обозначать `Def(A, B)` в контексте пункта `P`.
Вне пункта `P` это правило не применяется.
Если до пункта `P` обозначение `A` имело другой смысл, то после пункта `P` обозначение `A` снова будет иметь этот смысл.
По сути, `Def_C` объявляет локальную переменную `A` с областью действия `P`.
В отличие от него, `Def` объявляет глобальную переменную `A` (значение которой действует для всех пунктов, кроме `P`).

### 3.2.
~~~
Def_C(P, A):
```
B
```
~~~
имеет то же значение, что и `Def_C(P, A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 3.3.
```
Def_C([P1, P2, …, Pn], A, B)
```
имеет значение, аналогичное `Def_C(P, A, B)`, только в этом случае обозначение `A` имеет значение `B` в контексте не одного пункта `P`, а всех пунктов [`P1`, `P2`, …, `Pn`], перечисленных в квадратных скобках.

### 3.4.
```
Def_C([P1-Pn], A, B)
```
имеет значение, аналогичное `Def_C([P1, P2, …, Pn], A, B)`: в этом случае обозначение `A` имеет значение `B` в контексте множества всех пунктов между `P1` и `Pn`, включая сами эти пункты.

### 3.5.
~~~
Def_C([P1, P2, …, Pn], A):
```
B
```
~~~
имеет то же значение, что и `Def_C([P1, P2, …, Pn], A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 3.6.
~~~
Def_C([P1-Pn], A):
```
B
```
~~~
имеет то же значение, что и `Def_C([P1-Pn], A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 4. `Def_F`
### 4.1.
Def_C(4-5, `F`):
```
Факт: некое событие, которое случилось в описываем мной случае.
```

### 4.2.
```
Def_F(B)
```
будет обозначать, что `B` — это `F`.

### 4.3.
~~~
Def_F:
```
B
```
~~~
имеет то же значение, что и `Def_F(B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 4.4.
```
Def_F(A, B)
```
будет обозначать, что `B` — это `F`, и для него я использую обозначение `A`.

### 4.5.
~~~
Def_F(A):
```
B
```
~~~
имеет то же значение, что и `Def_F(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 5. `Def_Ph`
### 5.1.
Def_C(5, `Ph`):
```
Феномен: `F`, который вызывает у меня удивление.
```

### 5.2.
```
Def_Ph(B)
```
будет обозначать, что `B` — это `Ph`.

### 5.3.
~~~
Def_Ph:
```
B
```
~~~
имеет то же значение, что и `Def_Ph(B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 5.4.
```
Def_Ph(A, B)
```
будет обозначать, что `B` — это `Ph`, и для него я использую обозначение `A`.

### 5.5.
~~~
Def_Ph(A):
```
B
```
~~~
имеет то же значение, что и `Def_Ph(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 6. `Def_H`
### 6.1.
Def_C(6, `H`):
```
Гипотеза: некое предположение, требующее проверки.
```

### 6.2.
```
Def_H(B)
```
будет обозначать, что `B` — это `H`.

### 6.3.
~~~
Def_H:
```
B
```
~~~
имеет то же значение, что и `Def_H(B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 6.4.
```
Def_H(A, B)
```
будет обозначать, что `B` — это `H`, и для него я использую обозначение `A`.

### 6.5.
~~~
Def_H(A):
```
B
```
~~~
имеет то же значение, что и `Def_H(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 7. `Def_Set`
```
Def_Set(S, I)
```
будет обозначать, что `S` — множество всех возможных `I`.

## 8. `Def_I`
```
Def_I(I, S)
```
будет обозначать, что `I` — элемент множества `S`.

## 9. `Use`
```
Use(A)
```
будет обозначать, что в описываемой мной ситуации я использую `A`.

## 10.
Потенциальный клиент опубликовал на Upwork следующий проект:
### 10.1. Title
Setting up PostgREST for a Postgresql Server

### 10.2. Description
```text
I need someone to help me setup PostgREST for a Postgresql server we have setup. 
The goal is for us to ingest data through REST API into PostgreSQL. 
We just need help setting up the PostgREST portion of it.
```

### 10.3. Tags
Database Design
PostgreSQL
PostgreSQL Programming
Linux

## 11. Информация о клиенте
### 11.1. Местоположение
United States
Brooklyn

## 11.2. Характеристики компании
### 11.2.1. Сектор экономики
Tech & IT
### 11.2.2. Количество сотрудников
1

## 11.3. Характеристики учётной записи на Upwork
### 11.3.1. Member since
Nov 5, 2014
#### 11.3.2. Hire rate (%)
63
#### 11.3.3. Количество опубликованных проектов (jobs posted)
148
#### 11.3.4. Total spent
$36K
#### 11.3.5. Количество оплаченных часов в почасовых проектах
570

## 12.
Def(`C`):
```
клиент пункта 10
```

## 13.
Def(`P`):
```
проект пункта 10
```

## 14.
Def(`Ps`):
```
множество подобных `P` проектов 
```

## 15.
Def(`D`):
```
Описание `P` (пункт 10.2 выше)
```

## 16.
Def(`T`):
```
Задача, о которой `C` пишет в `D`:
~~~
setup PostgREST for a Postgresql server we have setup
~~~
```

## 17.
Def(`D`, «мой ответ `C`»).

## 18.
Содержание `D`:
~~~markdown
PostgREST по-правильному настраивается так:
1) Создать выделенную схему для API (например, `api`) и разместить там только те объекты, которые должны быть доступны извне.
В качестве таких объектов следует использовать `VIEW` и `FUNCTION`, а не сами таблицы.
Основные таблицы с данными при этом должны находиться в отдельной, приватной схеме (например, `private`), которая не указывается в конфигурации PostgREST и, следовательно, остается невидимой для HTTP-клиентов.
1.1) Ещё более сильным вариантом пункта 1 является использование версионирования для публичной схемы: первую версию можно назвать `api_1` вместо `api`, и когда выйдет новая версия API, то создать для неё новую публичную схему: `api_2`.
Такое более сильное решение позволит поддерживать сразу несколько версий API: современную (для новых) и устаревшую (для текущих клиентов, чтобы дать им время на миграцию).
2) Система аутентификации и авторизации PostgREST полностью основана на ролевой модели PostgreSQL. 
Для корректной работы необходимо создать как минимум 3 типа ролей:
2.1) `authenticator`:  используется для подключения PostgREST к базе данных
2.2) `anonymous`:  используется для обработки запросов от анонимных пользователей 
2.3) роли представляют аутентифицированных пользователей с различными уровнями доступа 
3) Авторизация в PostgREST управляется стандартными командами `GRANT` и `REVOKE` в PostgreSQL.
Необходимо точно определить, какие операции каждая роль может выполнять с объектами в схеме `api`.
4) Настройка `postgrest.conf`:
4.1) `db-uri`: нужно установить значение типа `postgres://authenticator:<password>@localhost:5432/<database_name>`
4.2) `db-schemas`: указывает список схем базы данных, разделенных запятыми, которые будут доступны через API (пункт 1 выше).
4.3) `db-anon-role`: имя роли базы данных, которая будет использоваться для обработки неаутентифицированных запросов (пункт 2.2 выше).
4.4) `jwt-secret`: секретный ключ, используемый для проверки криптографической подписи JSON Web Token (JWT).
4.5) `server-port`: TCP-порт, на котором PostgREST будет прослушивать HTTP-запросы. 
По умолчанию используется порт `3000`.
4.6) `admin-server-port`: порт для административного сервера, который предоставляет конечные точки для проверки состояния работоспособности (health check). 
5) PostgREST использует stateless механизм аутентификации. 
Каждый защищенный запрос должен содержать заголовок `Authorization: Bearer <token>`, где `<token>` — это валидный JSON Web Token.
6) PostgREST только проверяет токены, но не создает их. 
Для создания токенов можно использовать расширение `pgjwt`: это позволяет создать простую SQL-функцию login, которая принимает учетные данные, проверяет их по таблице пользователей и в случае успеха возвращает подписанный JWT.
7) Row-Level Security (RLS) позволяет реализовать гранулярный контроль доступа.
Сочетание утверждений в JWT и политик RLS создает чрезвычайно гибкую систему. 
PostgREST передает утверждения из токена в сеанс PostgreSQL, где они становятся доступны через функцию `current_setting('request.jwt.claims', true)`.
Это позволяет политикам RLS принимать решения на основе данных из токена, таких как `user_id` или `tenant_id`.
8) Запуск процесса PostgREST непосредственно из командной строки терминала непригоден для производственной среды, так как процесс не будет автоматически перезапущен в случае сбоя или после перезагрузки сервера. 
Для управления жизненным циклом приложения на современных дистрибутивах Linux используется система инициализации `systemd`. 
9) PostgREST не реализует HTTPS, делегируя эту функцию внешним компонентам.
В производственной среде передача данных, особенно учетных данных или конфиденциальной информации, по незащищенному протоколу HTTP недопустима. 
Поэтому надо настроить обратный прокси-сервер (например, Nginx) для терминирования SSL/TLS соединений.
10) Для включения HTTPS необходим сертификат. 
Его лучше всего настроить через Certbot и Let's Encrypt.
11) PostgREST автоматически создает стандартный RESTful-интерфейс для таблиц и представлений, указанных в схеме API. 
Для таблицы `table` будут доступны следующие основные конечные точки:
11.1) `GET /table`
11.2) `POST /table`
11.3) `PATCH /table?id=eq.<id>`
11.4) `DELETE /table?id=eq.<id>`
12) Для того чтобы выполнить `POST` (пункт 11.2 выше), клиент должен сначала получить JWT, а затем использовать его для аутентификации.
13) PostgREST возвращает сообщения о сбоях в формате JSON со следующими полями:
- `message`: Основной текст сообщения об ошибке.
- `details`: Дополнительные детали.
- `hint`: Подсказка о возможном решении проблемы.
- `code`: либо 5-значный код ошибки PostgreSQL (например, `23505`), либо код PostgREST (например, `PGRST100`).
~~~

## 19.
Def(`D2`, «начальная часть `D`, переведённая с Russian на English»).

## 20.
Содержание `D2`:
~~~markdown
PostgREST is set up as follows:
1) Create a dedicated schema for the API (for example, `api`) and place there only those objects that should be accessible externally.
As such objects, `VIEW` and `FUNCTION` should be used, rather than the tables themselves.
Meanwhile, the main data tables must be located in a separate, private schema (for example, `private`), which is not specified in the PostgREST configuration and, therefore, remains invisible to HTTP clients.
1.1) An even stronger variant of point 1 is the use of versioning for the public schema: the first version can be named `api_1` instead of `api`, and when a new version of the API is released, a new public schema should be created for it: `api_2`.
Such a stronger solution will make it possible to support several API versions simultaneously: a modern one (for new clients) and a legacy one (for current clients, to give them time to migrate).
2) The PostgREST authentication and authorization system is entirely based on the PostgreSQL role model.
For correct operation, it is necessary to create at least 3 types of roles:
2.1) `authenticator`: is used for connecting PostgREST to the database
2.2) `anonymous`: is used for processing requests from anonymous users
2.3) roles representing authenticated users with different access levels
3) Authorization in PostgREST is controlled by the standard `GRANT` and `REVOKE` commands in PostgreSQL.
It is necessary to precisely define which operations each role can perform on the objects in the `api` schema.
4) Configuring `postgrest.conf`:
4.1) `db-uri`: it is necessary to set a value like `postgres://authenticator:<password>@localhost:5432/<database_name>`
4.2) `db-schemas`: specifies a comma-separated list of database schemas to be exposed through the API (point 1 above).
4.3) `db-anon-role`: the name of the database role to be used for processing unauthenticated requests (point 2.2 above).
4.4) `jwt-secret`: a secret key used for verifying the cryptographic signature of a JSON Web Token (JWT).
4.5) `server-port`: The TCP port on which PostgREST will listen for HTTP requests.
By default, port `3000` is used.
4.6) `admin-server-port`: the port for the administrative server, which provides endpoints for the health check.
5) PostgREST uses a stateless authentication mechanism.
Each protected request must contain the `Authorization: Bearer <token>` header, where `<token>` is a valid JSON Web Token.
6) PostgREST only verifies tokens, but does not create them.
To create tokens, the `pgjwt` extension can be used: this allows creating a simple SQL login function that accepts credentials, verifies them against a user table, and upon success, returns a signed JWT.
7) Row-Level Security (RLS) makes it possible to implement granular access control.
The combination of claims in the JWT and RLS policies creates an extremely flexible system.
PostgREST passes the claims from the token to the PostgreSQL session, where they become available through the function `current_setting('request.jwt.claims', true)`.
This allows RLS policies to make decisions based on data from the token, such as `user_id` or `tenant_id`.
~~~

## 21.
Def(`F`, «фрагмент `D`»).

## 22.
Содержание `F`:
~~~markdown
13) PostgREST возвращает сообщения о сбоях в формате JSON со следующими полями:
- `message`: Основной текст сообщения об ошибке.
- `details`: Дополнительные детали.
- `hint`: Подсказка о возможном решении проблемы.
- `code`: либо 5-значный код ошибки PostgreSQL (например, `23505`), либо код PostgREST (например, `PGRST100`).
~~~

## 23.
Переведи `F` на English, с учётом:
- контекста `D`
- `D2`: уже переведённой части `D`
- всех предыдущих пунктов моего запроса

## 24. Правила перевода
### 24.1.
Переводи именно в той стилистике, как написано на Russian.
Не делай перевод более вежливым, чем оригинал.

### 24.2.
Те предложения, которые сейчас полностью на English — оставь без изменения.

### 24.3.
#### 24.3.1.
Не используй Markdown: только plain text.
#### 24.3.2.
При этом можно и нужно использовать то форматирование, которое уже есть в оригинале: его не убирай.
#### 24.3.3.
Не форматируй веб-ссылки посредством Markdown, если они не отформатированы так в оригинале. 
Например, не пиши так:
```
[https://www.eca.web.tr/eca-nita-esnek-uclu-eviye-bataryasi-beyaz-102118110-308](https://www.eca.web.tr/eca-nita-esnek-uclu-eviye-bataryasi-beyaz-102118110-308)
```
если в оригинале скобок `[]()` нет.

### 24.4.
Форматируй перевод в точности как оригинал. 
В частности:
*) каждый абзац должен содержать ровно одно предложение
*) между абзацами не должно оставаться пустых строк.
*) кавычки используй те же, что и в оригинале: «» и ``.

### 24.5.
Не используй сокращения типа «don't». Все подобные фразы пиши полностью: «do not».

### 24.6.
Не используй жаргон.
Вместо этого используй официальные термины.
#### 24.6.1.
В частности, фразы в кавычках используй только в том случае, когда они являются точными цитатами.
Не используй фразы в кавычках для применения жаргонных фраз.
Например, следующий фрагмент текста недопустим, потому что там используется жаргонная фраза «пролетел»: 
```
Например, код, который пушит данные о покупке, подключён асинхронно и загружается с небольшой задержкой, а триггер уже «пролетел».
```

### 24.7.
При обсуждении программного обеспечения используй точные официальные термины на английском языке: именно в том виде, как они указаны в официальной англоязычной документации к этому программному обеспечению.

### 24.8.
Не используй «you need» и другие подобные обращённые к клиенту фразы, перекладывающие действия на него.
Помни: я пишу клиенту или потенциальному клиенту.
Делать в любом случае буду я, а не клиент.
Вместо «you need» используй 2 альтернативы:
#### 24.8.1.
Нейтральные фразы типа «it is necessary».
#### 24.8.2.
Глаголы в неопределённой форме.
Например, во фрагменте ниже использованы подобные глаголы «set up», «create»:
```
1.2) Set up the transfer of login events from WordPress to Power BI using Fabric / OneLake.
1.2.1) Set up a «Data Pipeline» from the WordPress database table that stores login events (see point 1.1) to Fabric / OneLake.
1.2.2) Set up a connection from Power BI to Fabric / OneLake to pass login events.
1.3) Create the data model in Power BI.
```
Обрати внимание, в этом фрагменте не говорится, кто именно будет выполнять описанные действия: ответственность не перекладывается на клиента, в отличие от «you need».

### 24.9.
Никогда не переводи понятие «сайт» / «веб-сайт» как «site». 
Вместо этого используй форму «website»: это является более профессиональным.

### 24.10.
Никогда не переводи понятие «пункт нумерованного списка» как «item».
Всегда переводи это как «point».