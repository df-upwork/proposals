## 1.
Клиент хочет выполнить следующий проект:
### 1.1. Title
Review & Revise VBA Code in an XLAM File
### 1.2. Description
The code is used to aggregate data from excel to interact with Microsoft Outlook and function as an email automation and tracking system. We are looking for someone to clean up the code and expand the functionality of the system.
It’s VBA code written into an XLAM file. All the different copies of the tracker share the same one XLAM file so the code is always the same, it’s just the input data that changes.

### 1.3. Tags
Visual Basic for Applications
Microsoft Excel
Microsoft Outlook

### 1.4. Attachments
Клиент прикрепил файл `Sample Email Blaster.xlsm`

## 2. Что это за формат файла: `.xlsm`?
### 2.1.
Я тебя спросил:
~~~
Итак, файл клиента (пункт 1.4) имеет расширение `.xlsm`.
Что это за формат файла?
~~~

### 2.2.
Ты ответил:
~~~
Формат `.xlsm` — это «макрос-включаемая» (macro-enabled) книга Microsoft Excel.  
- Начиная с версии Excel 2007, Microsoft использует формат Office Open XML (OOXML). Для обычных книг (без макросов) используется расширение `.xlsx`, а для книг, содержащих макросы на VBA (Visual Basic for Applications), — расширение `.xlsm`.  
- Другими словами, `.xlsm` — это практически та же структура, что и `.xlsx`, но с дополнительной поддержкой макросов.  
- Макросы в `.xlsm` позволяют автоматизировать рутинные задачи в Excel, связываться с другими приложениями (например, Outlook) и расширять функциональность электронных таблиц при помощи кода на VBA.
~~~

## 3. Какие существуют способы для экспорта макросов из файла `.xlsm` (пункт 2) в текстовый файл?
### 3.1.
Я тебя спросил:
~~~
Какие существуют способы для экспорта макросов из файла `.xlsm` (пункт 2) в текстовый файл?
~~~

### 3.2.
Ты ответил:
~~~
Ниже приведены основные способы извлечь VBA-код из файла Excel с макросами (`.xlsm`) и сохранить его в текстовый файл. Под «текстовым файлом» здесь подразумевается любой формат, где код будет храниться в виде обычного текста: `.txt`, `.bas`, `.cls`, `.frm` и т. д.

---

## Способ 1. Экспорт модулей вручную через редактор VBA
1. **Откройте Excel** и загрузите в него вашу `.xlsm`-книгу.  
2. **Перейдите в редактор VBA**:  
   - Либо через меню **Разработчик** → **Visual Basic**,  
   - Либо сочетанием клавиш <kbd>Alt</kbd>+<kbd>F11</kbd>.
3. В левой панели «Project Explorer» (если её нет, нажмите <kbd>Ctrl</kbd>+<kbd>R</kbd>), найдите необходимые модули (Module, Class Module, UserForm).
4. **Выделите нужный модуль** (например, `Module1`), нажмите **правой кнопкой** → **Export File…** (или **Файл** → **Export File…** в верхнем меню).
5. Выберите **папку** для экспорта и **формат** (обычно по умолчанию это `.bas` для модулей, `.cls` для классов, `.frm` для форм).
6. Повторите экспорт для всех нужных модулей, чтобы сохранить VBA-код в отдельных `.bas`, `.cls` или `.frm`.  
7. Если нужно объединить всё в один `.txt`-файл, можно либо скопировать текст из каждого полученного `.bas`/`.cls`/`.frm` в свой `.txt`, либо оставить файлы в исходных форматах.

**Плюсы**:  
- Стандартный и надёжный способ, встроенный в Excel.  
- Все комментарии и форматирование сохраняются.

**Минусы**:  
- Нужно вручную экспортировать каждый модуль, если их много.

---

## Способ 2. Копирование кода прямо из редактора VBA
1. **Откройте редактор VBA** (аналогично способу 1).  
2. **Откройте нужный модуль** (двойной клик по `Module1`, `Module2` и т. д.).  
3. **Выделите** весь текст и **скопируйте** (<kbd>Ctrl</kbd>+<kbd>A</kbd>, затем <kbd>Ctrl</kbd>+<kbd>C</kbd>).
4. В любой текстовый редактор (например, Блокнот) вставьте (<kbd>Ctrl</kbd>+<kbd>V</kbd>) и **сохраните** как `.txt` (или любой другой нужный формат).

**Плюсы**:  
- Самый простой и быстрый способ, если нужно «на лету» поделиться каким-то фрагментом кода.

**Минусы**:  
- При большом количестве модулей придётся повторять действия вручную.  
- Утеряется информация о структуре проекта (например, отдельные классы, формы), если всё складывать в один файл.

---

## Способ 3. Использование кнопки «Сохранить проект VBA» в надстройках (MZ-Tools и пр.)
Существуют сторонние надстройки, позволяющие автоматически **«выгрузить»** весь VBA-проект целиком. Самая известная – [MZ-Tools](https://www.mztools.com/v8/) (есть разные версии, в том числе для VBA). У неё есть опция **Export all modules**, которая экспортирует все модули разом в выбранную папку.

**Плюсы**:  
- Позволяет одним нажатием сохранить все файлы модулей VBA в виде `.bas`, `.cls`, `.frm`.  
- Экономит время при большом количестве модулей или форм.

**Минусы**:  
- Надстройка не встроена в Excel, нужно устанавливать отдельно (бесплатные/платные версии).

---

## Способ 4. Программный экспорт через объект `VBProject`
В самом VBA можно написать код, который будет:
1. Перебирать модули в `ThisWorkbook.VBProject.VBComponents`.
2. Вызывать метод `Export` для каждого компонента, указывая путь для сохранения.

Пример упрощённого скрипта (запускать можно из **другого** открытого файла Excel или даже из того же, главное — разрешить доступ к объектной модели VBA в настройках):

```vba
Sub ExportAllVBA()
    Dim vbComp As VBIDE.VBComponent
    Dim exportPath As String
    
    ' Указать путь для экспорта
    exportPath = "C:\MyVBAExport\"

    ' Перебор всех компонентов в проекте
    For Each vbComp In ThisWorkbook.VBProject.VBComponents
        Select Case vbComp.Type
            Case vbext_ct_StdModule, vbext_ct_ClassModule, vbext_ct_MSForm
                ' Экспортируем в .bas, .cls или .frm автоматически
                vbComp.Export exportPath & vbComp.Name & ".bas"
            Case Else
                ' Можно добавить обработку для других типов
        End Select
    Next vbComp
End Sub
```

**Плюсы**:  
- Позволяет автоматизировать экспорт кода, особенно если нужно регулярно или массово выгружать макросы из нескольких книг.

**Минусы**:  
- Требует включённого «доступа к объектной модели VBA» (устанавливается в **Параметрах Excel** → **Центр управления безопасностью** → **Параметры макросов**).  
- Нужно знать немного VBA, чтобы настроить путь и обработку разных типов компонентов.

---

## Способ 5. Распаковка `.xlsm` как `.zip` (не даёт прямого текста кода!)
Формат `.xlsm` физически является ZIP-архивом с набором XML-файлов. Если переименовать `ИмяФайла.xlsm` в `ИмяФайла.zip` и распаковать его, то вы увидите структуру папок и файлов:

- `xl/worksheets/…` – листы  
- `xl/sharedStrings.xml` – строки  
- `xl/vbaProject.bin` – VBA-проект  

Однако VBA-код хранится в двоичном файле `vbaProject.bin`. Его нельзя просто открыть в блокноте и прочитать текст макросов — понадобится специальный анализатор (а по факту, снова возвращаемся к ручному экспорту либо к сторонним утилитам). Таким образом, **этот способ не подходит** для моментального получения текста макросов, но может использоваться для низкоуровневого анализа содержимого (например, при повреждённом файле).

---

## Резюме
1. **Встроенный экспорт из VBA-редактора** – базовый и самый простой (экспорт через «Export File…»).  
2. **Копирование кода** вручную из окна модуля в текстовый редактор – быстро для отдельных фрагментов.  
3. **Сторонние надстройки** (например, MZ-Tools) – удобны для массовой выгрузки кода.  
4. **Программный способ** через объект `VBProject` – автоматизация процесса, если нужно экспортировать код из нескольких файлов.  
5. **Переименование в `.zip`** и распаковка – не даёт готовый VBA-код в текстовом формате, поскольку макросы в `vbaProject.bin` хранятся в двоичном виде.

Для большинства практических случаев достаточно методов № 1 и № 2.  
~~~

## 4. Как распаковать `vbaProject.bin`?
### 4.1.
Я тебя спросил:
~~~
В пункте 3.2 ты написал:
```
## Способ 5. Распаковка `.xlsm` как `.zip` (не даёт прямого текста кода!)
Формат `.xlsm` физически является ZIP-архивом с набором XML-файлов. Если переименовать `ИмяФайла.xlsm` в `ИмяФайла.zip` и распаковать его, то вы увидите структуру папок и файлов:

- `xl/worksheets/…` – листы  
- `xl/sharedStrings.xml` – строки  
- `xl/vbaProject.bin` – VBA-проект  

Однако VBA-код хранится в двоичном файле `vbaProject.bin`. Его нельзя просто открыть в блокноте и прочитать текст макросов — понадобится специальный анализатор (а по факту, снова возвращаемся к ручному экспорту либо к сторонним утилитам). Таким образом, **этот способ не подходит** для моментального получения текста макросов, но может использоваться для низкоуровневого анализа содержимого (например, при повреждённом файле).
```
Как распаковать `vbaProject.bin`?
Ты упомянул некие «анализаторы».
Перечисли конкретные «анализаторы» для распаковки `vbaProject.bin`.
~~~

### 4.2.
Ты ответил:
~~~
Нужно сразу уточнить, что классический «ручной» способ «экспортировать» VBA-код именно в читабельном виде не требует анализа содержимого `vbaProject.bin`—проще сделать это из самого Excel (см. пункты 1–4 в предыдущем ответе). Однако если вас интересует именно **низкоуровневая распаковка** `vbaProject.bin` (например, в рамках анализа повреждённого файла или реверс-инжиниринга макросов без запуска Excel), то без специальных инструментов не обойтись.

Ниже перечислены некоторые утилиты и подходы, которые умеют разбирать (частично или полностью) содержимое `vbaProject.bin`. Часть из них популярна среди специалистов по кибербезопасности при анализе вредоносных макросов.

---

## 1. `oledump.py` (от Didier Stevens)
- **Ссылка**: [https://blog.didierstevens.com/programs/oledump-py/](https://blog.didierstevens.com/programs/oledump-py/)
- **Тип**: Python-скрипт.
- **Что умеет**: 
  - Извлекать потоки OLE2/компоненты из документов (Doc, XLS, XLA, XLSM и др.).
  - Показывать и декодировать VBA-макросы, хранящиеся во внутренней структуре OLE2 или OOXML (`vbaProject.bin`).
  - Позволяет «выдернуть» код макросов либо в «сыром» виде, либо с частичной декодировкой.
- **Особенности**:  
  - Скрипт часто используется для **forensic-анализa** и **поиска вредоносного кода**.  
  - Может работать как с форматами OLE (старая структура Office 97–2003), так и с OOXML (Office 2007+), где VBA-макросы запакованы в `vbaProject.bin`.  

---

## 2. `oletools` (Python OLE Tools)
- **Ссылка**: [https://github.com/decalage2/oletools](https://github.com/decalage2/oletools)
- **Тип**: Набор Python-утилит (by Philippe Lagadec).
- **Что умеет**: 
  - Включает несколько инструментов, в том числе `olevba` для извлечения и анализа VBA-макросов. 
  - Проводит статический анализ кода, вычленяет потенциально опасные вызовы, ищет индикаторы вредоносности.
  - Может парсить `vbaProject.bin` и восстанавливать исходный VBA-текст (включая обфусцированные фрагменты).
- **Особенности**: 
  - Очень популярный инструмент среди специалистов по безопасности и реверс-инжинирингу Office-документов.  
  - Удобен, если нужно быстро посмотреть содержимое макросов без открытия файла в Excel.

---

## 3. `OfficeMalScanner` (сейчас редко обновляется, но ещё встречается)
- **Ссылка**: [https://code.google.com/archive/p/officemalscanner/](https://code.google.com/archive/p/officemalscanner/)
- **Тип**: Утилита командной строки для Windows.
- **Что умеет**:
  - Анализирует структуру документов Office (включая OOXML).
  - Извлекает VBA-модули из OLE/бинарных контейнеров (то есть может работать с `vbaProject.bin`).
  - Изначально создавалась для выявления вредоносных макросов, но подходит и для «обычного» извлечения.
- **Особенности**: 
  - Проект не слишком активен, но при определённых сценариях может помочь достать код.

---

## 4. `ViperMonkey`
- **Ссылка**: [https://github.com/decalage2/ViperMonkey](https://github.com/decalage2/ViperMonkey)
- **Тип**: Python-проект, который умеет **эмулировать** (парсить и интерпретировать) VBA-код.
- **Что умеет**:
  - Извлекать макросы из `.doc`, `.xls`, `.xlsm`, а также из `vbaProject.bin`.
  - Выполнять статический (и частично динамический) анализ VBA-кода, выявлять вызовы функций, распаковывать строки и т.д.
- **Особенности**:
  - В основном предназначен для безопасного анализа потенциально вредоносных макросов, не запуская их в реальном Office.

---

## 5. Специализированные «VBA Decompiler»/«VBA Parser»
- **VBA Decompiler** – так называют разные проекты, встречающиеся в GitHub и на форумах, которые могут «декодировать» структуру VBA из `vbaProject.bin`. 
- **VBADiff** – ещё один инструмент для сравнения двух версий VBA-кода и извлечения макросов.  
  - **Ссылка**: [https://github.com/tylabs/vbadiff](https://github.com/tylabs/vbadiff)

Некоторые из этих проектов помогают не столько «распаковать» в удобочитаемый вид, сколько **сравнить** два бинаря `vbaProject.bin` или найти различия между версиями.

---

## 6. Грубый подход: Hex-редакторы + спецификация формата
Теоретически, если у вас есть:
1. **Hex-редактор** (например, [HxD](https://mh-nexus.de/en/hxd/))  
2. **Спецификация формата OLE2/Compound File** и структуры `vbaProject.bin`  

…то можно вручную пытаться извлечь текст макросов. Но этот способ крайне неудобен: потребуется тщательно парсить потоки внутри бинаря (SectionStreams, Project Stream, Module Streams), реконструировать исходный код и корректно декодировать его. Обычные пользователи (да и разработчики) этим почти не занимаются — гораздо быстрее запустить Excel и сделать экспорт через VBA-редактор.

---

## Резюме
1. **Самый простой и быстрый** путь извлечь VBA-код — через **VBA-редактор** в Excel (экспорт `.bas/.cls/.frm` или копирование текста).  
2. Если **файл повреждён** или нужно сделать **«forensic-анализ»** без запуска Excel — можно обратиться к инструментам, которые умеют парсить `vbaProject.bin`:  
   - [**oledump.py**](https://blog.didierstevens.com/programs/oledump-py/)  
   - [**oletools / olevba**](https://github.com/decalage2/oletools)  
   - [**OfficeMalScanner**](https://code.google.com/archive/p/officemalscanner/) (реже обновляется)  
   - [**ViperMonkey**](https://github.com/decalage2/ViperMonkey)  
   - [**VBADiff**](https://github.com/tylabs/vbadiff)  
   - разного рода «VBA Decompiler» или иные утилиты на GitHub.  
3. **Hex-редактор + спецификация** — это «тяжёлая артиллерия», которая используется крайне редко и требует глубоких знаний структуры офисных форматов.  

Таким образом, если цель состоит просто в «экспорте» макросов в текст, то чтение `vbaProject.bin` напрямую — это избыточно сложный путь. Если же нужна **глубокая диагностика** (например, при подозрении на вирус/ошибку), тогда перечисленные «анализаторы» действительно помогают «распаковать» внутренние потоки и взглянуть на VBA-код, не полагаясь на сам Excel.
~~~

## 5. Как извлечь VBA-код из `.xlsm` посредством LibreOffice Calc?
### 5.1.
Я тебя спросил:
~~~
В пункте 4.2 ты писал:
```
1. **Самый простой и быстрый** путь извлечь VBA-код — через **VBA-редактор** в Excel (экспорт `.bas/.cls/.frm` или копирование текста).  
```
Как я могу сделать это не из Excel, а из LibreOffice Calc?
~~~

### 5.2.
Ты ответил:
~~~
К сожалению, **LibreOffice Calc** не имеет полноценной поддержки VBA‑макросов, в отличие от Microsoft Excel. В большинстве случаев Calc либо **игнорирует** VBA‑код, либо **частично** его конвертирует в LibreOffice Basic, причём конвертация часто бывает неполной (особенно если макросы зависят от Excel/Outlook‑объектов).

Ниже — несколько пояснений и варианты, что можно попробовать сделать в LibreOffice Calc. Однако стоит учесть, что **надежного встроенного аналога «Export File…» для модулей VBA** в LibreOffice нет.

---

## 1. Попытаться открыть и скопировать код через меню «Макросы»
1. **Откройте** `.xlsm`‑книгу в LibreOffice Calc.  
2. Перейдите в меню **Инструменты** → **Макросы** → **Редактировать макросы…**  
   - При открытии файла LibreOffice может выдать предупреждение, что документ содержит макросы (VBA). Иногда Calc предложит «сохранить их» или «отключить», или сразу их игнорирует.  
3. Если LibreOffice сумеет **конвертировать** код (хотя бы частично) в LibreOffice Basic, в редакторе вы увидите какие‑то процедуры (модули) в дереве проекта.  
4. **Попробуйте скопировать текст** макросов из редактора LibreOffice Basic и вставить его в обычный текстовый файл.  

**Минусы и ограничения**:  
- Часто Calc вообще **не покажет** VBA‑код, так как он остаётся «чужеродным» бинарным блоком (`vbaProject.bin`).  
- Даже если код отобразится, это может быть **только фрагмент** или «перевод» на LibreOffice Basic (часть VBA‑функций не импортируется).  
- Никакой функции «Экспортировать в .bas» в LibreOffice Calc нет.

---

## 2. Преобразование `.xlsm` в формат LibreOffice + сохранение макросов
Иногда LibreOffice при открытии `.xlsm` спросит «Конвертировать макросы?». Если вы дадите согласие:

1. Документ может быть **преобразован** в формат `.ods` (родной формат LibreOffice Calc).  
2. Макросы (если они не слишком «заточены» под Excel) будут **частично переписаны** под LibreOffice Basic и окажутся видны в редакторе макросов.  
3. После чего вы снова можете **скопировать** этот код в текстовый редактор.  

Но, повторимся, это **неполная** миграция: Excel-объекты (Outlook, Ribbon, формы, ActiveX и т.д.) в LibreOffice Basic не имеют прямых аналогов.  
 
---

## 3. Использовать Python-утилиты для извлечения кода из `vbaProject.bin` (вне LibreOffice)
Если задача — **достать исходный VBA‑код** (а не пытаться «запустить» или «редактировать» его в LibreOffice), то Calc здесь мало чем поможет. Гораздо надёжнее воспользоваться сторонними инструментами, которые напрямую парсят `vbaProject.bin`:

1. [**oledump.py**](https://blog.didierstevens.com/programs/oledump-py/)  
2. [**oletools (olevba)**](https://github.com/decalage2/oletools)  
3. [**ViperMonkey**](https://github.com/decalage2/ViperMonkey)  
4. И т.п.

Они **извлекают** VBA‑модули из `.xlsm`, фактически «распаковывая» `vbaProject.bin` и восстанавливая текст макросов.

---

## 4. Итог
- **LibreOffice Calc не предоставляет** простого способа «Экспортировать VBA» в том виде, как это делает редактор VBA в Microsoft Excel.  
- Можно **попытаться** открыть `.xlsm` и заглянуть в «Редактировать макросы…» — в некоторых случаях часть макросов будет видна и её можно **скопировать вручную**. Но часто код просто не отображается или конвертируется неполностью.  
- Если нужен **полный исходный код VBA** без Excel, то лучше либо  
  - открыть файл в самом Excel и выполнить стандартный экспорт,  
  - либо применить **программы-анализаторы** (`oledump.py`, `olevba` и др.) для «доставания» кода напрямую из `vbaProject.bin`.
~~~



## 6. В чём состоит стратегическая задача клиента?
### 6.1.
Я тебя спросил:
~~~
В чём состоит стратегическая задача клиента?
Какую проблему он решает?
Что его беспокоит?
~~~

### 6.2.
Ты ответил:
~~~
Судя по описанию задачи (п. 1.2), клиент уже имеет некую рабочую систему, которая:

1. **Собирает (агрегирует) данные** в Excel.  
2. **Взаимодействует с Microsoft Outlook**, выполняя массовую рассылку писем и/или отслеживая, кому и когда было отправлено письмо.  
3. Работает на основе **VBA‑кода**, помещённого в `.XLAM` — это надстройка для Excel, которую используют несколько копий «трекера» (каждый «трекер» подхватывает один и тот же `.XLAM`).  

Однако:  
- Код, скорее всего, **написан постепенно**, без чёткого рефакторинга;  
- Его **нужно «почистить»**, устранить возможные ошибки, улучшить логику;  
- Клиент хочет **«расширить функциональность»** системы, вероятно, добавить новые возможности по учёту/автоматизации писем или аналитике.  

### Стратегическая задача

**Основная стратегическая цель** клиента — **создать и поддерживать** надёжную и гибкую (расширяемую) систему автоматизации рассылок и трекинга почтовых коммуникаций на базе Excel и Outlook. Проще говоря, он хочет, чтобы его «Excel+Outlook»‑инструмент:

1. **Стабильно работал** (был без багов).  
2. Был **удобен в поддержке** (отчистка, оптимизация, понятная структура VBA‑кода).  
3. **Легко дорабатывался** — если потребуется новая логика, новые поля в письмах или расширенные отчёты.  

### Какую проблему он решает

1. **Избыточная сложность и «захламлённость» кода**: без грамотного рефакторинга VBA-макросы могут стать хаотичными, с дублирующимися фрагментами, что затрудняет поддержку.  
2. **Непростая масштабируемость**: чтобы один `.XLAM` корректно обслуживал множество файлов‑«трекеров», надо обеспечить единую, надёжную точку обновления и совместимую архитектуру.  
3. **Ограничения ручных рассылок**: клиент хочет сократить человеческий фактор и рутины при рассылке писем и отслеживании статусов.  
4. **Недостаток аналитики или дополнительных функций**: возможно, нужно более подробное логирование отправленных писем, интеграция с другими системами, гибкая настройка шаблонов и т. д.  

### Что клиента «беспокоит» в текущем решении

- **Сбой при массовой отправке писем** (критично для бизнеса, ведь рассылка может быть большой частью внутренних/внешних коммуникаций).  
- **Неудобство обновления**: если код неоднороден, каждое обновление влечёт исправление ошибок в разных местах.  
- **Проблемы масштабирования**: добавляются новые требования, а код тяжело поддерживать.  
- **Потенциальные баги** (слишком большое число макросов, сложная логика, риск ошибок при повторных правках).  

Таким образом, **ключевой запрос**: «Кто‑то должен аккуратно проанализировать и привести VBA‑код в порядок, а также добавить новые функции, чтобы система продолжала поддерживать потребности бизнеса».
~~~

## 7. Каковы альтернативы решения стратегической задачи клиента (пункт 6) вместо `.xlsm`?
### 7.1.
Я тебя спросил:
~~~
Каковы альтернативы решения стратегической задачи клиента (пункт 6) вместо `.xlsm`?
~~~

### 7.2.
Ты ответил:
~~~
Надстройка `.xlsm` (или `.xlam`) с VBA-макросами — это относительно простой путь «быстрой автоматизации» внутри Excel, но далеко не единственный. Если смотреть **стратегически**, у клиента есть потребность в удобном и гибком инструменте для сбора данных и массовых почтовых рассылок с трекингом (Email Automation & Tracking). Ниже перечислены основные альтернативы, позволяющие избавиться от громоздкой VBA-логики в Excel или существенно её сократить.

---

## 1. Использовать специализированные CRM / Email-маркетинг платформы

### Что это даёт
1. **Готовый функционал** для массовых рассылок, сегментации, шаблонов писем, трекинга открытий/кликов.
2. **Аналитика и отчётность** «из коробки»: метрики по конверсиям, статистика доставки, отписки, интеграции с CRM.
3. **Поддержка масштабирования**: решения обычно «облачные» (SaaS), и могут обрабатывать тысячи писем в сутки без дополнительных усилий со стороны пользователя.

### Примеры решений
- **Mailchimp**, **Sendinblue**, **MailerLite** — для email-рассылок и базового трекинга.
- **HubSpot**, **Zoho CRM**, **Salesforce** — комплексные CRM c почтовой автоматизацией.

### Когда подходит
- Когда основной фокус — **массовая email-коммуникация** (маркетинг, рассылки, реклама, CRM).
- Когда важен **функционал трекинга** (открытия, клики), а не только отправка писем из Outlook.
- Когда есть возможность **перейти на платную подписку** (многие такие сервисы не бесплатны, либо дают бесплатный тариф с ограничениями).

### Плюсы / Минусы
- **Плюсы**: Готовые инструменты, быстрая настройка, мощная аналитика, надёжная доставка писем.  
- **Минусы**: Месячная/годовая **стоимость**, необходимость переноса текущих процессов и данных в другую систему, отказ от «Excel-подхода» или его сокращение до экспорта/импорта списков.

---

## 2. Перейти к облачной платформе Microsoft 365 + Power Automate

### Что это даёт
1. **Power Automate** (ранее Microsoft Flow) позволяет автоматизировать процессы:  
   - Отправлять письма через Office 365 Outlook,  
   - Собирать данные из Excel (онлайн), SharePoint, Forms, других источников,  
   - Включать условную логику («if-then», циклы, проверки).
2. **SharePoint Online** или **Dataverse** (в рамках Power Apps) можно использовать как базу данных вместо хранения в Excel-файле.
3. **Power Apps** даёт конструктор для быстрого создания «бизнес-приложений» без VBA, с автоматическим UI.

### Когда подходит
- Когда организация использует корпоративный **Office 365** (E3, E5 и т.д.) и готова осваивать Power Platform.
- Нужно наладить **более устойчивые** бизнес-процессы без локальной зависимости от каждого пользователя и его Excel-файла.

### Плюсы / Минусы
- **Плюсы**: Графические «no-code/low-code» инструменты, быстрая интеграция с Outlook, Teams, SharePoint. Понятная масштабируемость, работа в облаке.  
- **Минусы**: Требуются дополнительные лицензии (зависят от тарифа), изучение Power Automate / Power Apps. Миграция логики с VBA.

---

## 3. Разработка десктопного приложения / надстройки на .NET (VSTO)

### Что это даёт
1. Более современный код на C# (или VB.NET) в формате **надстройки VSTO** (Visual Studio Tools for Office).  
2. Возможность полноценной интеграции с Outlook и Excel через .NET API, а не VBA.
3. Удобный рефакторинг и отладка в Visual Studio, контроль версий (Git), использование стандартных библиотек .NET.

### Когда подходит
- Когда нужно **тонкое взаимодействие** с Excel или Outlook, но VBA начинает «трещать по швам».
- Когда есть разработчик / команда, владеющая **C# и Visual Studio**, и готовая поддерживать VSTO-проект.

### Плюсы / Минусы
- **Плюсы**: Современный язык, больше возможностей, типизация, интеграция с системами (REST API и т. д.), стабильность и «индустриальный» стек.  
- **Минусы**: Нужно **Visual Studio** и некоторый **уровень .NET-компетенций**. Деплой надстройки на рабочие места может потребовать дополнительной настройки (ClickOnce и пр.).

---

## 4. Web-приложение (интранет-портал) с базой данных

### Что это даёт
1. **Централизованное хранение** данных в базе (SQL или NoSQL), работа через браузер.
2. **Управляемые** роли и доступы: пользователи логинятся на портал, заполняют формы, формируют кампании рассылок.
3. Отправка писем через SMTP-сервер, Exchange API или сторонние почтовые сервисы. Возможна интеграция с Outlook через EWS / Graph API.

### Когда подходит
- При наличии IT-команды, которая готова развивать и поддерживать **веб-приложение** (PHP, Python, Node.js, .NET, Java и т. д.).
- Когда Excel становится узким местом, и нужен более масштабируемый «**единый»** интерфейс без макросов.

### Плюсы / Минусы
- **Плюсы**: Гибкость, расширяемость, всё хранится на сервере, не завязано на локальные файлы. Любая логика может быть доработана без Excel.  
- **Минусы**: Проект требует **значительных ресурсов** на разработку и поддержку, а также серверную инфраструктуру.

---

## 5. RPA-системы (Robotic Process Automation)

### Что это даёт
1. Позволяют «имитировать» действия пользователя в Outlook, Excel и других программах через UI-робота.  
2. Могут забирать данные из файлов/форм, отправлять письма, формировать отчёты и логирование.
3. Есть готовые коннекторы к Outlook, Excel, базам данных, веб-сервисам.

### Примеры решений
- **UiPath**, **Automation Anywhere**, **Blue Prism**, **Power Automate Desktop** (от Microsoft).

### Когда подходит
- Когда нужно **быстро автоматизировать** рутинную работу без написания большого количества кода.
- Когда часть процессов «межприкладная» (не только Excel+Outlook, но и ERP, веб-сервисы и т. д.).

### Плюсы / Минусы
- **Плюсы**: Не требуется переписывать логику, RPA-робот «кликает» и «заполняет» за пользователя. Быстрое прототипирование, масштабирование.  
- **Минусы**: Может получиться дорого, если большой объём процессов. Для сложной бизнес-логики всё равно потребуется написание сценариев и поддержка.

---

## 6. Google Sheets + Apps Script (аналог VBA в облаке)

### Что это даёт
1. Использование **Google Таблиц** вместо Excel. Макросы на **Google Apps Script** (JavaScript-подобный язык).
2. Отправка почты через Gmail API или SMTP, хранение данных в Sheets, интеграция с другими сервисами Google (Drive, Forms, Calendar).
3. Автоматизированные скрипты (triggers), запуск по расписанию или по событию.

### Когда подходит
- Когда команда готова перейти на **Google Workspace** и отойти от Microsoft Outlook (или дополнительно задействовать Google API).
- Нужно **облачное** решение с простым доступом через браузер, без локальных установок.

### Плюсы / Минусы
- **Плюсы**: Бесплатные/доступные инструменты (до определённого лимита), удобное совместное редактирование, современная IDE для Apps Script.  
- **Минусы**: Если вся организация на Microsoft 365/Outlook, придётся «скрещивать» экосистемы. Outlook-объектная модель не поддерживается напрямую.

---

## Итоги и выбор

- **VBA в Excel** («.xlsm/.xlam») хорош как стартовый инструмент или для быстрой реализации локальных автоматизаций, но со временем код становится трудно поддерживать, особенно при расширении функциональности.
- **Если приоритет** — профессиональная email-автоматизация и аналитика, **выигрывают специализированные платформы** для рассылок или CRM: они берут на себя и массовые отправки, и трекинг.
- **Если нужен** контроль рабочих процессов «внутри Microsoft 365», стоит присмотреться к **Power Automate, SharePoint, Power Apps**.  
- **Если компания** готова к разработке, можно **создать собственное приложение** (веб / десктоп / VSTO), более гибкое и надёжное, чем VBA.
- **RPA** (Robotic Process Automation) — вариант, когда надо быстро закрыть разнородные сценарии без глубокой интеграции.
- **Google Sheets + Apps Script** — альтернатива при переходе в экосистему Google.

### Практическая рекомендация
- Проанализировать **масштаб** (количество писем, пользователей, объём данных) и **долгосрочные цели** (только email-рассылка или полноценный CRM / ERP-процесс).
- Оценить **стоимость** лицензий, ресурсов на разработку/поддержку.  
- Сравнить трудоёмкость рефакторинга VBA **против** миграции на новую платформу: иногда проще навести порядок в VBA и продолжать работать, а иногда выгоднее сразу перейти на полноценное решение (CRM, Power Automate, VSTO, веб-приложение).

Так или иначе, **«.xlsm» — лишь одно из многих решений**. Если клиенту нужна устойчивость и лёгкая поддержка в долгосрочной перспективе, есть смысл рассмотреть более «индустриальные» варианты (шаги 1–5 выше) вместо (или параллельно с) дальнейшего развития VBA-макросов.
~~~

## 8. Cпециализированные CRM / Email-маркетинг платформы
### 8.1.
Я тебя спросил:
~~~
В пункте 7.2 ты написал:
```
## 1. Использовать специализированные CRM / Email-маркетинг платформы
<…>
- **HubSpot**, **Zoho CRM**, **Salesforce** — комплексные CRM c почтовой автоматизацией.
<…>
```
Итак, ты перечислил 3 платформы: HubSpot, Zoho CRM, Salesforce.
В чём разница между ними?
~~~

### 8.2.
Ты ответил:
~~~
Ниже приведено обобщённое сравнение трёх популярных платформ — **HubSpot**, **Zoho CRM** и **Salesforce** — с точки зрения их позиционирования, функционала, ценовых моделей и возможностей масштабирования. Все три решения относятся к сегменту CRM и Email-маркетинг/автоматизации, однако их аудитории и «силы» несколько различаются.

---

## 1. **Обзор и позиционирование**

### **HubSpot** 
- **Ключевая идея**: «Всё для inbound-маркетинга, CRM, продаж и сервиса» в одной экосистеме.  
- **Целевая аудитория**: Малый и средний бизнес (SMB), а также компании, которые хотят лёгкий старт и удобный пакет «всё в одном» (маркетинг, продажи, поддержка).  
- **Особенность**: Сильный упор на **inbound-маркетинг**, управление лидами, контент-стратегию, воронку продаж, а также удобные инструменты email-рассылок, лендингов, форм захвата контактов и аналитику. Имеется **бесплатная версия CRM** с базовыми функциями.

### **Zoho CRM**
- **Ключевая идея**: «Гибкая CRM с доступной ценой, интегрированная в экосистему Zoho».  
- **Целевая аудитория**: Широкий спектр компаний — от малого до крупного бизнеса, особенно тех, кто хочет более бюджетное и комплексное решение (Zoho предоставляет целую линейку продуктов: Zoho Mail, Zoho Desk, Zoho Books и т.д.).  
- **Особенность**: Известна как одна из самых **доступных** (по ценам) полнофункциональных CRM, быстро развивающаяся. Хороша для тех, кто хочет пакетную экосистему (модули HR, финансы, проекты и др.) внутри одного поставщика — Zoho.  

### **Salesforce**
- **Ключевая идея**: «Мощная, максимально гибкая и расширяемая CRM-платформа для среднего и крупного бизнеса».  
- **Целевая аудитория**: Enterprise-сегмент, большие компании с серьёзными требованиями к кастомизации, интеграциям, масштабированию и пользовательской поддержке.  
- **Особенность**: Фактически **лидер рынка** CRM по масштабам и экосистеме. Имеет огромное количество модулей (Sales Cloud, Service Cloud, Marketing Cloud, Commerce Cloud, MuleSoft, Tableau и т.д.) и партнёрских решений. Очень гибкая, но и более сложная в настройке/поддержке.

---

## 2. **Ключевые возможности и особенности**

### HubSpot
1. **CRM**: бесплатный базовый функционал (контакты, сделки, воронки, задачи), при необходимости платные расширения.  
2. **Маркетинг**: удобные инструменты email-рассылок, посадочных страниц, лидогенерации, автоматизации nurturing-кампаний.  
3. **Sales**: трекинг сделок, встраиваемые виджеты для почтовых клиентов, возможность логировать переписку, календарь встреч, чаты.  
4. **Service**: тикетная система, база знаний, чат-боты, интеграция с популярными каналами поддержки.  
5. **Аналитика**: отчёты по лидам и сделкам, воронка продаж, детальный маркетинг-репортинг (ROI и т.д.).  
6. **Интеграции**: Slack, Outlook, Gmail, Zoom, соцсети, многие другие. Есть собственный «App Marketplace».  
7. **Особый плюс**: **прозрачный интерфейс**, дружественный для новичков в CRM. Inbound-маркетинг — очень мощный встроенный модуль.

### Zoho CRM
1. **Контакты и сделки**: классическая CRM-функциональность с кастомизацией полей, воронок, автоматизаций.  
2. **Omnichannel-взаимодействие**: электронная почта, веб-формы, социальные сети, чат, телефонная интеграция (через Zoho PhoneBridge).  
3. **Email-маркетинг**: встроенная автоматизация, drip-кампании, конструктор писем, также есть модуль Zoho Campaigns.  
4. **Задачи и напоминания**: планирование и управление продажами, синхронизация с календарём.  
5. **Отчёты и аналитика**: стандартные отчёты + Zoho Analytics (отдельный продукт) для продвинутых дашбордов.  
6. **Расширенная экосистема**: Zoho Desk (саппорт), Zoho Projects, Zoho Books (бухгалтерия), Zoho Forms, Zoho Creator (low-code платформа) и т.д.  
7. **Особый плюс**: **стоимость** (как правило, ниже конкурентов на аналогичном уровне функционала). Глубокая интеграция с другими Zoho-продуктами.

### Salesforce
1. **CRM-модуль**: Sales Cloud — контакты, аккаунты, сделки, прогноз продаж, продвинутая автоматизация (workflow, процесс-билдер, Flow).  
2. **Маркетинг**: Marketing Cloud или Pardot (более B2B-ориентированный) — мощные инструменты сегментации, автоматизации, мультиканальных кампаний, персонализации.  
3. **Service Cloud**: омниканальная поддержка, тикеты, колл-центр, чат-боты, knowledge base.  
4. **Платформа**: широкие возможности кастомизации через Lightning App Builder, Apex (собственный язык программирования Salesforce), Visualforce, Flow и т. д.  
5. **Аналитика**: встроенные отчёты и дашборды, а также Tableau (приобретён Salesforce в 2019).  
6. **Marketplace**: AppExchange — сотни готовых расширений и интеграций (финансы, электронная коммерция, геолокация, телефония, HR и пр.).  
7. **Особый плюс**: **беспрецедентная масштабируемость и кастомизация**. Подходит, если нужны очень сложные бизнес-процессы и интеграции на уровне всего предприятия.

---

## 3. **Ценовые модели**

> **Важно**: Цены регулярно обновляются, поэтому цифры примерные. У всех трёх платформ есть много тарифных планов и опции «до-купить» определённые модули.

### HubSpot
- **Freemium-модель**: базовый CRM бесплатно, ограниченный функционал маркетинга/продаж/сервиса.  
- **Платные пакеты** (Starter, Professional, Enterprise) — оплачиваются отдельно для Marketing Hub, Sales Hub, Service Hub.  
- **Уровень цен**: от ~50 $/мес (Starter-план) до нескольких тысяч $/мес для Enterprise-модулей с расширенными лимитами на контакты и передовые функции (продвинутая аналитика, персонализация).

### Zoho CRM
- Имеется **бесплатный тариф** для 3 пользователей (с ограничениями).  
- **Платные тарифы** начинаются от ~14 $/пользователь/мес (Standard) и могут доходить до ~52 $/пользователь/мес (Ultimate).  
- Дополнительные Zoho-продукты (Desk, Projects, Books и т.д.) могут быть куплены **по отдельности** или в комплексе (Zoho One) — «всё включено» по ~37 $/пользователь/мес (при годовой оплате, при условии лицензирования всех сотрудников).  
- **Уровень цен** обычно **ниже**, чем у HubSpot или Salesforce (при схожих базовых функциях).

### Salesforce
- **Нет** бесплатного тарифа, но есть пробные периоды (Trial).  
- **Sales Cloud** планы начинаются от ~25 $/пользователь/мес (Essentials) и доходят до 300 $/пользователь/мес (Unlimited).  
- **Маркетинг-платформа** (Marketing Cloud, Pardot) — дополнительные, часто довольно дорогие подписки, зависящие от числа контактов/отправленных писем.  
- При крупных внедрениях часто есть **индивидуальные** корпоративные договорённости.  
- **Уровень цен**: может быть **очень высоким** для расширенных функций, что более характерно для среднего и крупного бизнеса.

---

## 4. **Плюсы и минусы каждой платформы (обобщённо)**

### HubSpot
- **Плюсы**  
  - Очень простой старт: бесплатный CRM + низкий порог вхождения.  
  - Сильный функционал inbound-маркетинга.  
  - Единый UX: всё в одном интерфейсе (CRM, маркетинг, support).  
  - Хорошая интеграция с почтовыми системами (Gmail, Outlook).  
- **Минусы**  
  - При росте базы контактов и переходе на проф. тарифы **цена быстро возрастает**.  
  - Модули (Marketing, Sales, Service) приобретаются **по отдельности** — итоговый счёт может быть существенным.  
  - Не такая широкая кастомизация процессов, как у Salesforce.

### Zoho CRM
- **Плюсы**  
  - **Очень конкурентная цена**.  
  - Богатая экосистема Zoho (почта, бухгалтерия, help-desk, проекты) с единой авторизацией.  
  - Достаточно гибкая настройка (модули, поля, API).  
  - Интуитивный интерфейс, в целом простой.  
- **Минусы**  
  - Отдельные модули (Marketing, HR) могут быть **не так развиты**, как у узкоспециализированных лидеров.  
  - Некоторые интеграции «из коробки» либо скромнее, либо требуют доработок.  
  - Крупным компаниям может не хватать «enterprise-функций», и они чаще выбирают Salesforce / Microsoft Dynamics.

### Salesforce
- **Плюсы**  
  - **Лидер рынка** CRM: колоссальные возможности кастомизации, интеграций, автоматизации.  
  - Большая экосистема партнёров и разработчиков, AppExchange.  
  - Подходит для **очень крупных** компаний и сложных бизнес-процессов (вплоть до полноценной ERP-логики).  
  - Постоянные обновления, инновации (AI-модуль Einstein).  
- **Минусы**  
  - **Высокая стоимость** и сложное лицензирование.  
  - Сложность внедрения: обычно требуется участие сертифицированных специалистов/консультантов, особенно для больших проектов.  
  - «Из коробки» может быть избыточен и «тяжеловесен» для малого бизнеса.

---

## 5. **Выбор и рекомендации**

1. **HubSpot**  
   - Отлично подходит, если:  
     - Вы делаете упор на **интернет-маркетинг**, лидогенерацию, контент и хотите CRM, интегрированную с мощным Email-маркетингом и аналитикой.  
     - Нужен максимально «дружественный» интерфейс и быстрый запуск.  
     - Вы готовы к тому, что при росте масштабов может прийтись покупать более дорогие тарифы.  

2. **Zoho CRM**  
   - Рациональный выбор, если:  
     - Бюджет ограничен, но хотите полноценную CRM и **универсальные** инструменты автоматизации.  
     - Планируете использовать экосистему Zoho (заявки/поддержка, бухгалтерия, проекты, почта) — всё будет удобно взаимосвязано.  
     - CRM-кейсы не требуют ультра-сложных сценариев.  

3. **Salesforce**  
   - Подходит тем, кто:  
     - Является средним или крупным бизнесом, готовым вкладываться в IT-инфраструктуру и кастомную разработку.  
     - Нуждается в **высокой масштабируемости**: сотни/тысячи пользователей, сложные интеграции, глобальная филиальная структура.  
     - Расценивает CRM как «центральную платформу» для всего бизнеса и готов нанять (или обучить) специалистов/администраторов Salesforce.  

В итоге, **для малого/среднего бизнеса** часто выбирают либо HubSpot (если важен маркетинг и удобство), либо Zoho CRM (если приоритет — цена и базовый функционал). **Крупные и растущие компании** нередко отдают предпочтение Salesforce (или Microsoft Dynamics 365), когда нужна мощная платформа с практически неограниченной кастомизацией и интеграциями.

---

### Краткое резюме
- **HubSpot**: фокус на inbound-маркетинге, удобство, бесплатный CRM-старт, но быстро растущая стоимость при расширении.  
- **Zoho CRM**: лучший баланс цены и функционала, хорош для многих SMB, обширная экосистема Zoho.  
- **Salesforce**: мощнейшее, гибкое и дорогое решение для средних и крупных компаний с серьёзными требованиями к кастомизации и масштабам.
~~~


## 9. Переход облачной платформе Microsoft 365 + Power Automate
### 9.1.
Я тебя спросил:
~~~
В пункте 7.2 ты писал:
```
## 2. Перейти к облачной платформе Microsoft 365 + Power Automate

### Что это даёт
1. **Power Automate** (ранее Microsoft Flow) позволяет автоматизировать процессы:  
   - Отправлять письма через Office 365 Outlook,  
   - Собирать данные из Excel (онлайн), SharePoint, Forms, других источников,  
   - Включать условную логику («if-then», циклы, проверки).
2. **SharePoint Online** или **Dataverse** (в рамках Power Apps) можно использовать как базу данных вместо хранения в Excel-файле.
3. **Power Apps** даёт конструктор для быстрого создания «бизнес-приложений» без VBA, с автоматическим UI.

### Когда подходит
- Когда организация использует корпоративный **Office 365** (E3, E5 и т.д.) и готова осваивать Power Platform.
- Нужно наладить **более устойчивые** бизнес-процессы без локальной зависимости от каждого пользователя и его Excel-файла.

### Плюсы / Минусы
- **Плюсы**: Графические «no-code/low-code» инструменты, быстрая интеграция с Outlook, Teams, SharePoint. Понятная масштабируемость, работа в облаке.  
- **Минусы**: Требуются дополнительные лицензии (зависят от тарифа), изучение Power Automate / Power Apps. Миграция логики с VBA.
```
В чём разница этого подхода и текущего подхода, используемого клиентом (файл `.xlsm`)?
~~~

### 9.2.
Ты ответил:
~~~
Ниже — основные различия между текущим **«локальным»** подходом (Excel + VBA в `.xlsm/.xlam`) и вариантом на основе **облачной платформы Microsoft 365 + Power Automate**.  

---

## 1. **Размещение и хранение данных**  
**Вариант с `.xlsm`:**  
- Данные хранятся в локальном файле Excel (или на общедоступной сетевой папке).  
- Макросы (VBA) «зашиты» в самом файле `.xlsm` или `.xlam`.  
- Каждый пользователь открывает файл (или свою копию) в локальном Excel.  

**Вариант с Power Automate / SharePoint / Dataverse**:  
- Данные хранятся **в облачных сервисах** (например, в SharePoint Online или Dataverse).  
- Общий доступ, версии и изменения управляются в одном месте — нет риска «разъезда» копий.  
- Автоматизация (flows) также запускается в облаке, а не на машине конкретного пользователя.

**Ключевая разница**: Вариант с `.xlsm` завязан на локальные (или сетевые) файлы, тогда как Power Automate и SharePoint — это централизованное решение в облаке.

---

## 2. **Логика и автоматизация**  
**Вариант с `.xlsm`:**  
- Основная логика — это VBA‑макросы, которые работают **только** при открытом Excel и разрешённых макросах.  
- Рассылка писем идёт через Outlook «от имени» пользователя, запущенного на его ПК (или на сервере, но всё равно требует среду Excel + Outlook).  
- Расширение и поддержка функционала требуют правки кода VBA в редакторе Excel и рассылку обновлённой версии `.xlam` всем пользователям (или хранение одной версии в общей папке).

**Вариант с Power Automate / Power Apps**:  
- Используются **no-code/low-code** потоки (flows), которые можно собирать в веб-интерфейсе Power Automate.  
- Можно настроить автоматическую отправку писем, интеграцию с Outlook, Excel Online, Forms и т.д. **без написания VBA**.  
- Процессы работают **«на сервере Microsoft»**: даже если у пользователя закрыт Excel или Outlook, поток может запускаться по расписанию, по триггеру изменения данных в SharePoint и т.п.  
- Обновлять или править логику можно через веб-интерфейс, и все пользователи сразу работают с новой версией потока (нет «нескольких копий файла»).  

---

## 3. **Устойчивость и масштабируемость**  
**Вариант с `.xlsm`:**  
- Устойчивость зависит от корректной работы **каждого** клиента, у которого открыт Excel. Сбой на одной машине может остановить часть логики.  
- Если нужно большое количество писем или запросов, «Excel+VBA+Outlook» может упираться в лимиты локальной почты, скорости макросов, возможные ошибки при закрытии файла и т. д.  
- Масштабирование часто означает «больше копий Excel», что усложняет контроль за версией макросов.  

**Вариант с Power Automate / SharePoint**:  
- Потоки работают в **облачном** окружении, обслуживаемом Microsoft. Если правильно настроены лицензии, процессы могут обрабатывать большие объёмы (зависит от тарифного плана).  
- Надёжность в целом выше, так как процесс не зависит от того, запущен ли у кого-то Excel/Outlook локально.  
- Легче добавлять новых пользователей или команды — им достаточно дать доступ к SharePoint / Power Apps / Power Automate.

---

## 4. **Безопасность и контроль версий**  
**Вариант с `.xlsm`:**  
- Макросы VBA могут быть отключены политиками безопасности (или включены с предупреждениями).  
- Файлы `.xlsm` подвержены риску случайного удаления, неправильных изменений, вирусных макросов.  
- Версионность обычно вручную или за счёт средств сетевого хранения (SharePoint/OneDrive/другие) без тесной интеграции с логикой макроса.  

**Вариант с Power Automate / SharePoint**:  
- Управление доступом идёт через **Azure AD** (корпоративная учетная запись Office 365, группы безопасности).  
- Каждый поток/приложение Power Apps можно контролировать, кто может его запускать или редактировать.  
- Хранение данных в SharePoint или Dataverse автоматически даёт версионность, журналы изменений, правила безопасности (DLP, Conditional Access).

---

## 5. **Разработка и поддержка**  
**Вариант с `.xlsm`:**  
- Нужно знание VBA для внесения изменений, поддержка Outlook Object Model (для отправки писем), подчас сложная отладка, особенно если несколько пользователей/версий.  
- Любые дополнения/исправления — это ручное редактирование кода, пересохранение файлов, риск потерять синхронность.  
- Подключение к сторонним сервисам (REST API, базам данных) не всегда удобно в VBA.  

**Вариант с Power Automate / Power Apps**:  
- Логика процессов собирается в **визуальном редакторе** (условия, циклы, коннекторы к Outlook, Excel Online, SharePoint, Teams, Forms и т. д.).  
- Используются уже готовые коннекторы или действия; минимальное ручное кодирование. При необходимости — Power Fx (язык выражений) или «custom connectors» (но это всё равно проще, чем полноценная разработка на VBA).  
- При расширении функционала достаточно отредактировать поток и сохранить новую версию — изменения сразу доступны.  

---

## 6. **Лицензирование и стоимость**  
**Вариант с `.xlsm`:**  
- Нужна **лицензия на Microsoft Office** (локальный Excel + Outlook) для всех пользователей.  
- Нет дополнительной платы за использование VBA (он включён в десктопный Excel).  

**Вариант с Power Automate / Microsoft 365**:  
- Требуется соответствующий **Microsoft 365-план** (E3, E5 или Business Premium и т. д.) с включённым Power Automate.  
- Некоторые расширенные сценарии могут потребовать **отдельных лицензий** Power Apps / Power Automate (например, если нужно обращаться к Dataverse, Premium-коннекторам).  
- Однако для большинства базовых операций внутри Office 365 (SharePoint, Outlook, OneDrive, Excel Online) достаточно стандартных лицензий Microsoft 365.  

---

## 7. **Итоговое сравнение**  

| Критерий                | \*.xlsm + VBA                        | Microsoft 365 + Power Automate           |
|-------------------------|--------------------------------------|------------------------------------------|
| **Место хранения**      | Локальный или сетевой Excel-файл     | Облачное хранилище (SharePoint, OneDrive, Dataverse) |
| **Логика автоматизации**| Макросы VBA                          | Cloud Flows (Power Automate), без VBA    |
| **Запуск процессов**    | Через открытый Excel, ручной/полуавтомат | Автоматически на сервере (по расписанию, событию) |
| **Устойчивость**        | Зависит от корректной работы у каждого пользователя | Работа на серверах Microsoft, меньше «ручных» узких мест |
| **Масштабирование**     | Множество копий, трудно централизовать| Централизованное решение, легко добавлять пользователей |
| **Безопасность**        | Локальные макросы, риск отключения или заражения | Единая Azure AD аутентификация, управление доступами |
| **Поддержка**           | Правка VBA-кода, рассылка обновлённых файлов | Редактор Power Automate/Power Apps, мгновенные обновления |
| **Стоимость**           | Только лицензия Office (VBA встроен)  | Лицензии Microsoft 365; иногда нужна доп. лицензия Power Automate/Power Apps |

**Главная идея**: переход к Microsoft 365 + Power Automate делает всю систему **облачной, централизованной, более удобной в обслуживании** и **менее зависимой** от локального Excel и VBA. При этом придётся:  
- Перенести данные (например, из Excel-файла в SharePoint-список).  
- Переписать/воссоздать логику макросов в Power Automate (или Power Apps).  
- Освоить управление лицензиями и настройку облачных сервисов.  

Если компания уже в экосистеме Microsoft 365, такой переход упрощается и часто даёт **более надёжное** решение, чем классические `.xlsm`-файлы с макросами.
~~~



## 10. Переход от `.xlsm` к облачной платформе Microsoft 365 + Power Automate 
### 10.1.
Я тебя спросил:
~~~
Допустим, клиент хочет перейти от своей текущей технологии (файл `.xlsm`) к решению пункта 9 (облачная платформа Microsoft 365 + Power Automate).
Каким образом ему нужно портировать свой VBA-код на новую платформу?
~~~

### 10.2.
Ты ответил:
~~~
Ниже приведён общий план, как можно **перенести логику VBA-макросов** (файл `.xlsm` или `.xlam`) в облачную экосистему **Microsoft 365 + Power Automate**. Важно понимать, что это не буквальный «прямой конвертер» кода: придётся **переосмыслить** архитектуру, вынести данные из локальной книги Excel и перевести логику автоматизации в «flows» (потоки) Power Automate.

---

## 1. **Анализ текущего VBA-кода и структуры данных**

1. **Выявите ключевые процессы**:
   - Как запускаются макросы (по кнопке на листе, при открытии файла, по расписанию и т.д.)?
   - Какие входные данные используют? (таблицы Excel, листы, диапазоны).
   - Как формируются письма (шаблоны, переменные поля, вложения)?
   - Есть ли внешние интеграции (другие файлы, базы данных, Outlook-объекты, API-запросы)?

2. **Определите, где и как хранятся данные**:
   - Только ли в одной Excel-книге `.xlsm`?
   - Есть ли у каждого пользователя своя копия?
   - Требуется ли централизованное хранение?

3. **Опишите бизнес-логику** «человеческим языком»:
   - Какие шаги выполняет макрос?  
   - Какие условия (if-then) и циклы?  
   - Какие события инициируют запуск?

Задача этого этапа — **вычленить** чисто «бизнес-процесс» из кода, чтобы в дальнейшем перенести его в Power Automate.

---

## 2. **Выбор целевой архитектуры в Microsoft 365**

Чтобы «отвязаться» от локальных `.xlsm`-файлов, обычно используют:

1. **SharePoint Online** или **OneDrive** для хранения данных:  
   - Вместо одной книги Excel на диске вы можете завести **список в SharePoint** (или несколько списков), куда пользователи вносят данные.  
   - Либо продолжать хранить Excel-файл, но уже **в SharePoint/OneDrive** и работать с ним через «Excel Online connector».

2. **Power Automate** (Flows) для автоматизации:  
   - Организовать **потоки (flows)**, которые будут, например, запускаться по расписанию, или при добавлении/изменении записи в SharePoint, или при обновлении строки в Excel Online.

3. **Outlook / Office 365 connector** в Power Automate для рассылки писем:  
   - Вместо Outlook, работающего через VBA-объекты, теперь рассылка писем будет идти **из облака** (Office 365 Outlook connector).  

4. **Power Apps** (при необходимости пользовательского интерфейса):  
   - Если нужно заменить пользовательские формы в Excel (или пользовательские диалоги VBA), можно собрать **приложение Power Apps** на базе SharePoint/Dataverse.  

5. При более сложных сценариях — **Dataverse** (база данных в Power Platform) или **Azure SQL** (если нужна гибкая БД).

**Важный момент**: решите, **куда** переносить логику (SharePoint-списки, Excel Online, Power Apps) и **как** будет выглядеть процесс запуска (триггер Power Automate, нажатие кнопки в SharePoint/Power Apps и т.д.).

---

## 3. **Перенос данных из Excel**

1. **Создайте нужные структуры** в SharePoint (или в Dataverse):  
   - Если у вас в Excel были таблицы с полями (например, «Email», «Сумма», «Дата»), то в SharePoint создайте соответствующий список (или несколько).  
   - Продумайте типы полей (число, текст, дата, «Choice» и т.д.).  

2. **Мигрируйте существующие данные**:  
   - Можно вручную скопировать из Excel (через «Копировать/Вставить») или импортировать файл CSV в SharePoint.  

3. **Определите схему обновления**:
   - Будут ли пользователи напрямую редактировать SharePoint-список?  
   - Нужно ли делать загрузку из других систем?

> *Если хотите оставить Excel как «фронтенд», то храните книгу в SharePoint/OneDrive и обращайтесь к ней через Power Automate (Excel Online connector). Но с точки зрения централизации и отказа от VBA — удобнее передать всё в SharePoint.*

---

## 4. **Воссоздание логики макросов в Power Automate**

1. **Определите триггеры** (Triggers):
   - По расписанию (Scheduler) — аналог «Timer» в VBA или ручного запуска раз в день.  
   - При добавлении/изменении элемента в SharePoint («When an item is created or modified»).  
   - По нажатию кнопки в Power Apps или в самих SharePoint-списках (Power Automate button).

2. **Определите действия** (Actions):
   - **Получить данные** из SharePoint (Get items / Get item).  
   - **Обработать** логику (Branching condition, loops).  
   - **Сформировать и отправить письмо** (Office 365 Outlook connector: «Send an email (V2)»), при необходимости использовать динамическое содержание (текст, переменные).  
   - **Записать результат** (например, обновить поле «Статус» или «Дата отправки письма» в SharePoint).

3. **Если код VBA делает что-то сложное**:
   - Например, формирует динамический текст письма, подставляет значения в шаблон, прикрепляет файлы — всё это можно реализовать в Power Automate с помощью встроенных **«мейл-шаблонов»** (Compose, HTML table, Append to string, Attachments).
   - Если нужно отправлять индивидуальные письма по списку получателей, используйте **циклы (Apply to each)**.  

4. **Управление ошибками и логирование**:
   - В VBA можно было выводить MsgBox на экран, а здесь — лучше вести логи в SharePoint или в «Run History» Power Automate.  
   - Можно настраивать дополнительную отправку уведомлений (например, если произошла ошибка).

5. **Отказ от VBA-специфики**:
   - Многие «VBA-трюки» (например, работа с Range, Cells, Selection) в облаке не нужны. Теперь данные приходят напрямую из SharePoint или Excel Online connector в виде таблиц/списков.

---

## 5. **Перенос дополнительных функциональностей**

- **Формы и интерфейсы**:  
  Если в `.xlsm` были пользовательские формы (UserForm), их можно заменить:
  1. **Power Apps** (Canvas Apps / Model-driven Apps),  
  2. **SharePoint Forms** (встроенная форма списка, возможно с Power Apps Custom Form),  
  3. **Microsoft Forms** (для простых опросов/запросов).  

- **Обработчики событий (Workbook_Open, Worksheet_Change)**:  
  Вместо срабатывания при открытии файла можно организовать триггер Power Automate (по расписанию, по добавлению записи).  
  Если нужно немедленное реагирование на введённые данные, есть вариант использовать **Excel Online (Business) connector** с триггером «When a row is added/modified (Preview)», но он требует, чтобы Excel находился в OneDrive / SharePoint и был формально «подключён» к таблице.

- **Сложные расчёты**:  
  - Если VBA выполняет массивные расчёты, может быть резонно сделать их Power Query / Power Pivot / Power BI или вообще на стороне SQL/другого сервиса.  
  - Power Automate пригоден для автоматизации «шагов», но для чисто вычислительных задач большие объёмы данных иногда удобнее обработать в Power BI.

---

## 6. **Тестирование и отладка**

1. **Создайте тестовый Power Automate Flow** и прогоните несколько кейсов, аналогичных тем, что выполнялись раньше макросами.  
2. **Проверяйте почтовые отправления** (убедитесь, что письма действительно отправляются, формат корректен).  
3. **Проверьте «граничные случаи»** (пустые данные, неверные форматы).  
4. Используйте **«Test»** и «Flow Checker» в Power Automate, чтобы отлавливать ошибки.

---

## 7. **Внедрение и обучение пользователей**

1. **Дайте доступ** нужным сотрудникам к SharePoint (или Power Apps), укажите их в параметрах Flow (кто может запускать, просматривать).  
2. **Раздайте инструкции**, как теперь работать:  
   - Где вносить данные (SharePoint-список? Excel Online?).  
   - Как запускаются процессы (автоматически, кнопкой, расписанием).  
3. **Отключите старый `.xlsm`** или переведите в «readonly» (чтобы сотрудники не путались и не продолжали пользоваться старыми макросами).

---

## 8. **Учет лицензирования и дополнительных сервисов**

- Большинство базовых коннекторов Power Automate (SharePoint, Excel Online, Outlook) входят в стандартные планы **Microsoft 365** (например, E3/E5/Business Premium).  
- **Dataverse**, Premium-коннекторы или расширенные объёмы могут потребовать отдельной Power Automate / Power Apps лицензии.  
- Если у вас уже есть Office 365 корпоративного уровня, скорее всего, **Power Automate** для базовой автоматизации будет доступен без доплаты.

---

## 9. **Сводка: «прямого» переноса VBA-кода нет, нужен реинжиниринг**

### Ключевые моменты:

1. **Нет автоматической миграции кода**: VBA-привязки к Excel/Outlook придется **«разобрать на составляющие»** и перенести логику в Power Automate-шаги.  
2. **Облачное хранение**: данные и файлы лучше держать в SharePoint или OneDrive, чтобы потоки могли работать 24/7, без локального Excel.  
3. **Триггеры и действия**: вместо `Workbook_Open` или `Application.OnTime` используйте «Scheduled Flow» или «When an item is created» в SharePoint и т.д.  
4. **Управление доступом**: теперь всё централизовано (Azure AD, лицензии), а не через расшаренный .xlsm-файл.  
5. **Обновления**: любой рефакторинг (новые поля, условия) делается через веб-интерфейс Power Automate, и все пользователи сразу видят актуальную версию.

Таким образом, **перенос макросов** — это фактически **«переписывание»** бизнес-логики на языке/принципах Power Automate с переносом данных из локального Excel в облако. Но результатом станет **централизованная, более надёжная** система, которая не требует от каждого пользователя держать открытым файл `.xlsm` и правильно настроенный Outlook.
~~~



## 11. Каким образом делается рефакторинг VBA-кода в файле `.xlsm`?
### 11.1.
Я тебя спросил:
~~~
В пункте 6.2 ты писал:
```
1. **Избыточная сложность и «захламлённость» кода**: без грамотного рефакторинга VBA-макросы могут стать хаотичными, с дублирующимися фрагментами, что затрудняет поддержку.  
```
Каким образом делается рефакторинг VBA-кода в файле `.xlsm`?
~~~

### 11.2.
Ты ответил:
~~~
Ниже описан **общий подход** к тому, как можно последовательно привести VBA‑код в порядок (рефакторинг) в файле **`.xlsm`** или в надстройке **`.xlam`**. Эти принципы применяются и к другим языкам, но с учётом **специфики VBA** и Excel.

---

## 1. Предварительный аудит и анализ кода

1. **Сбор исходной структуры**:
   - Изучите, какие **модули** (Modules) и **объекты** (ThisWorkbook, листы, формы) уже существуют.
   - Найдите **«ключевые» процедуры**: часто они называются `Main()`, `SendEmails()`, `UpdateData()`, и т.д.  
   - Составьте *«карту вызовов»*: какие процедуры и функции вызывают друг друга, какие объекты Excel и внешние ресурсы (Outlook, файлы) они трогают.
   
2. **Определите болевые точки**:
   - «Спагетти»-участки: длинные процедуры (сотни строк), много вложенных `If…Then` / `Select Case`.
   - **Дублирующийся код**: одинаковые блоки логики, разбросанные по разным модулям или процедурам.
   - Глобальные переменные (особенно если их много), использование `Public` переменных в нескольких местах.
   - Запутанная работа с листами (много магических ссылок вида `Sheets("Лист1").Range("A1")`).
   - Слабая система обработки ошибок (например, повсеместные `On Error Resume Next`).

3. **Выясните назначение** каждой части кода:
   - Какие задачи реально **нужны** бизнесу, а какие — «следы» старой логики, которую давно уже не используют?
   - Есть ли **устаревшие процедуры**, которые никто не вызывает?

Главная цель этапа: **получить общее понимание**, что именно делает код, где наиболее хаотичные участки и где «быстро выиграть» (например, сгруппировать дублированные фрагменты в одну функцию).

---

## 2. Подготовка и настройка среды

1. **Включить `Option Explicit`**:  
   - В каждом модуле VBA (Menu: Tools → Options → «Require Variable Declaration» или вручную в начале модуля) добавляйте строку  
     ```vb
     Option Explicit
     ```
   - Это заставляет объявлять все переменные явно с помощью `Dim`. Так вы избежите массы ошибок, связанных с опечатками в именах.

2. **Настроить «MZ-Tools» или «Rubberduck»** (по желанию):
   - **[MZ-Tools](https://www.mztools.com/v8/)** — коммерческая, но популярная надстройка для ускорения разработки VBA: шablony кода, рефакторинг, поиск дубликатов, документация и т. д.
   - **[Rubberduck](https://rubberduckvba.com/)** — бесплатный open-source плагин для VBA, помогает анализировать код, делать инспекции, автозавершение, юнит-тесты.

3. **Настроить контроль версий** (по возможности):
   - Вы можете периодически **экспортировать модули** (файлы `.bas`, `.cls`, `.frm`) и хранить их в Git или другом VCS, чтобы отслеживать изменения.  
   - Если код небольшой, это можно делать вручную; для больших проектов автоматизируют с помощью скриптов/надстроек.

---

## 3. Структуризация модулей и разбиение на логические блоки

1. **Группировка процедур** по назначению:
   - Создайте отдельные модули (стандартные `Module`), например:  
     - `modEmail` — всё, что связано с отправкой почты,  
     - `modDataProcessing` — обработка данных в Excel (сбор, фильтрация, сводка),  
     - `modHelpers` или `modUtils` — вспомогательные функции (преобразование дат, логгирование, форматирование строк).  
   - Если есть логика, связанная с формами (UserForm), держите код формы в соответствующем объекте `.frm`; но «бизнес-логику» (подготовку данных) лучше вынести в отдельные модули.

2. **Отделение интерфейсного кода** от логики:
   - В идеале, код, который отвечает за **UI** (показ MsgBox, работа с элементами на листе), должен быть минимальным и вызывать хорошо структурированные процедуры для «бизнес-логики».  
   - Это упростит отладку и тестирование, так как бизнес-логика будет меньше зависеть от пользовательских форм и активных листов.

3. **Разделение крупных процедур**:
   - Если у вас гигантская процедура на 300–500 строк, попробуйте разбить её на под-процедуры.  
   - Например, вынести создание письма в одну функцию, добавление вложений — в другую, логику цикла — в третью, и т. д.

---

## 4. Устранение дублирующегося кода и повторяющихся фрагментов

1. **Факторизация общих операций** в функции/процедуры:
   - Если видите два куска кода, которые почти идентичны, замените их вызовом **одного** общего метода с параметрами.
2. **Систематизируйте константы**:
   - Вместо повторяющихся литералов вроде `"A1"`, `"Отчёт"`, `"smtp.server"`, используйте `Const` в начале модуля или общий модуль «констант» (`modConstants`).
   - Это облегчает поддержку (достаточно изменить значение в одном месте).

---

## 5. Улучшение именования и явности кода

1. **Имена переменных и функций**:
   - Давайте понятные названия, например, `EmailBodyTemplate`, `SendEmailToManager`, `UpdateTracker`.  
   - Избегайте слишком коротких имён (`a`, `x`) или «говорящих ни о чём» (`Temp`, `Test`).

2. **Типизация переменных**:
   - После включения `Option Explicit` настоятельно рекомендуется явно указывать типы (`Dim rowCount As Long`, `Dim userName As String`), что исключает случайные ошибки и даёт лучшую читаемость.

3. **Упрощение вложенных условий**:
   - Если в VBA встречается громоздкое «лесенкой» `If ... ElseIf ... ElseIf ... End If`, попробуйте заменить на `Select Case` (когда это логически оправдано).
   - Разделяйте логику на более мелкие проверяющие функции, если одно условие получилось слишком длинным.

---

## 6. Введение более надёжной обработки ошибок

1. **Избегайте `On Error Resume Next` без нужды**:
   - Это маскирует ошибки, и вы не узнаете, что пошло не так.  
   - Вместо этого используйте `On Error GoTo ErrorHandler` и в конце процедуры блок `ErrorHandler:` с обработкой.

2. **Логируйте** ошибки:
   - Можно сделать процедуру `LogError(errMsg As String)` и в случае ошибки записывать данные в какой-либо лист «Log» или в текстовый файл, или хотя бы выводить MsgBox для разработчика.

3. **Возврат из функций**:
   - Если функция может вернуть некий код ошибки или признак успеха (Boolean), пользуйтесь этим, а не глобальными переменными/флагами.

---

## 7. Переход на объектно-ориентированные приёмы (по возможности)

VBA поддерживает **классы** (Class Modules), хотя это и не так распространено, как в .NET или Java. Если приложение уже достаточно большое:

1. **Создайте классы** для сущностей:
   - Например, `clsEmailMessage` (хранит поля письма, методы отправки),  
   - `clsPerson` (описывает контакт, его атрибуты).  
2. **Используйте свойство `Let/Get`** для контроля над доступом к полям класса.  
3. При этом даже небольшой «объектный» подход может сильно улучшить читаемость: всё, связанное с «Письмом», будет в одном классе, а не разбросано по разным модулям.

---

## 8. Оптимизация взаимодействия с Excel-объектами

1. **Работа с диапазонами**:
   - Избавьтесь от магического `Select`. Вместо:
     ```vb
     Sheets("Лист1").Select
     Range("A1").Select
     Selection.Value = 10
     ```
     используйте сразу:
     ```vb
     Worksheets("Лист1").Range("A1").Value = 10
     ```
   - Это сделает код быстрее и чище.

2. **Сократите обращения к листам**:  
   - Если нужно обработать много ячеек, лучше считывать их в массив, обрабатывать массив в VBA и потом «одним залпом» выгружать обратно, чем ходить по каждой ячейке в цикле.

3. **Application.ScreenUpdating = False** и т. д.:
   - При долгих операциях старайтесь отключать обновление экрана, автоматический пересчёт, чтобы ускорить макрос и не мелькала картинка.

---

## 9. Тестирование и проверка на регрессии

1. **Создайте тестовые сценарии**:
   - Даже если нет формальной системы юнит-тестов, сделайте несколько листов/наборов данных, на которых вы проверяете корректность работы после каждого изменения.

2. **Пошаговый отладчик VBA**:
   - Используйте точки останова (Breakpoint), проверяйте значения переменных в «Locals Window».  
   - Очень полезно для сложных циклов или условий.

3. **Проверяйте крайние случаи**:
   - Пустые значения, нулевые суммы, некорректные даты и т. д. — всё, что раньше могло привести к сбою.

---

## 10. Документация и поддержка итогового кода

1. **Добавляйте комментарии**:
   - В начале каждого модуля и процедур кратко указывайте, что именно тут делается, какие входные/выходные параметры.  
   - Важно не перегружать код избыточными комментариями — описывайте только то, что не очевидно из названия переменной или процедуры.

2. **Оформите структуру**:
   - Можно завести небольшой «README» (в отдельном листе Excel или в текстовом файле) с описанием общей архитектуры и ключевых модулей.

3. **Соблюдайте единый стиль**:
   - Консистентное именование (строчные/верхние буквы, префиксы для переменных) делает код более читаемым. Например, некоторые используют венгерскую нотацию (`strName`, `lngCount`), но это на вкус команды. Главное — единообразие.

---

## Итого: какие выгоды даёт рефакторинг

1. **Улучшенная поддерживаемость**: код легче читать, понимать и изменять; новые функции проще добавлять без риска «сломать всё».
2. **Устранение дубликатов**: одно изменение в общей процедуре автоматически корректирует все места, где она используется.
3. **Надёжная обработка ошибок**: меньше неожиданных «молчаливых» сбоев.
4. **Повышение производительности** (при оптимизации доступа к листам, массивам).
5. **Прозрачность структуры**: новые разработчики (или вы сами через полгода) быстрее разберутся, где какой кусок логики.

---

### Краткое резюме

**Рефакторинг VBA** — это не просто «починить пару строк», а **планомерный** процесс:  
1. **Аудит** (понять логику и проблемы),  
2. **Упорядочение модулей и процедур** (разбить по смыслу, убрать дубликаты),  
3. **Чистка кода** (Option Explicit, осмысленные имена, обёртки для общих операций),  
4. **Улучшаем обработку ошибок**,  
5. **Тестируем и документируем**.

При больших проектах имеет смысл подключить **инструменты** вроде MZ‑Tools, Rubberduck, а также хранить исходники под **контролем версий**. Следуя этим шагам, ваш `.xlsm` станет гораздо более **поддерживаемым** и **надёжным**, даже если на момент старта код выглядел «сплошным спагетти».
~~~

## 12. Экспорт модулей из `.xlsm`
### 12.1.
Я тебя спросил:
~~~
В пункте 11.2 ты писал:
```
Вы можете периодически **экспортировать модули** (файлы `.bas`, `.cls`, `.frm`) и хранить их в Git или другом VCS, чтобы отслеживать изменения.
```
Как это сделать?
И в чём разница между таким экспортом и задачей пункта 3?
~~~

### 12.2.
Ты ответил:
~~~
Ниже описано, **как** именно можно экспортировать VBA‑модули (в виде `.bas`, `.cls`, `.frm`) и **чем** такой «регулярный экспорт для Git» отличается от тех способов, о которых шла речь в пункте 3 (где мы перечисляли приёмы одноразового извлечения кода).

---

## 1. Как экспортировать модули из `.xlsm` (или `.xlam`)

### Способ A. Ручной экспорт через редактор VBA

1. **Откройте Excel** и загрузите соответствующий файл (например, `MyFile.xlsm`).  
2. Нажмите <kbd>Alt</kbd>+<kbd>F11</kbd>, чтобы перейти в **VBA Editor** (или используйте меню **Разработчик** → **Visual Basic**).  
3. В левой панели «Project Explorer» (если её нет, нажмите <kbd>Ctrl</kbd>+<kbd>R</kbd>) найдите нужный **модуль** или **класс** или **UserForm**:  
   - `Module1`, `Module2`, `ThisWorkbook` (кроме служебных методов), `Class1.cls`, и т.д.  
4. **Правый клик** по нужному элементу → **Export File…**  
5. **Выберите папку** и сохраните его как:  
   - **`.bas`** (для стандартных модулей),  
   - **`.cls`** (для модулей класса),  
   - **`.frm`** (для пользовательских форм).  
6. Повторите для всех нужных модулей.  

Таким образом вы получите набор текстовых файлов, которые можно добавить в любую систему контроля версий (Git, SVN, Mercurial и т. д.).

> *Совет:* В настройках **VBE** можно включить *«Require Variable Declaration»*, чтобы в новых экспортируемых `.bas` по умолчанию вставлялась строка `Option Explicit`.

---

### Способ B. Использование сторонних надстроек (MZ‑Tools, Rubberduck)

- **MZ‑Tools** (коммерческая надстройка) имеет функции **«Export all modules»** или более гибкие инструменты для группового экспорта.  
- **Rubberduck** (open source) также умеет **«Extract project»** целиком, плюс выполняет статические анализы кода, инспекции и т.п.

С их помощью можно быстрее выгружать весь проект целиком в папку, не делая экспорт каждого модуля вручную. Это удобно для **регулярного** сопровождения и синхронизации с Git.

---

### Способ C. Программная автоматизация через VBA

Можно написать макрос, который **пробегается** по объектам `VBProject.VBComponents` и вызывает метод `.Export`:

```vba
Sub ExportAllModules()
    Dim vbComp As VBIDE.VBComponent
    Dim exportPath As String
    
    exportPath = "C:\MyVBAExport\"
    
    For Each vbComp In ThisWorkbook.VBProject.VBComponents
        ' Экспортируем только те, которые можно выгрузить (модули, классы, формы)
        Select Case vbComp.Type
            Case vbext_ct_StdModule, vbext_ct_ClassModule, vbext_ct_MSForm
                vbComp.Export exportPath & vbComp.Name & ".bas"
        End Select
    Next vbComp
End Sub
```

> *Важно:* Чтобы этот код работал, в **настройках Excel** необходимо разрешить «Доступ к объектной модели проектов VBA» (в Центре управления безопасностью).

Такой макрос можно запускать периодически, автоматически сохраняя все модули в нужную папку, откуда затем удобно делать коммит в Git.

---

## 2. Чем этот «регулярный экспорт» отличается от задач пункта 3?

В **пункте 3** (про «Какие существуют способы для экспорта макросов … в текстовый файл?») мы рассматривали **общие** или **одноразовые** приёмы извлечения кода. Иными словами — как **вытащить** VBA из `.xlsm`, если нужно поделиться фрагментом, показать код, проанализировать вредонос, и т.д. То есть цели были примерно такие:

1. **Одноразовый экспорт** (ручной, копирование текста из VBE и вставка в `.txt` или `.bas`).  
2. **Экспорт для архива** (например, переслать кому-то один раз).  
3. **Использование forensic-инструментов** (oledump, oletools, если нет возможности открыть Excel).  

**Регулярный экспорт** для Git/контроля версий — это более **систематический** процесс. Он нужен, чтобы:

1. Хранить **все исходники** модулей в человекочитаемом виде (`.bas`, `.cls`, `.frm`) в репозитории (Git).  
2. Отслеживать **историю изменений** и делать **pull requests** или **merge** при командной разработке.  
3. Автоматизировать **собственную «CI/CD»** (насколько это возможно с VBA) — например, чтобы при каждом изменении кода в Excel автоматически обновлять файлы `.bas` в Git.

### Кратко

- **Пункт 3**: «Как любым способом извлечь код в текст, если вообще не можем открыть Excel или хотим быстро поделиться?»  
- **Экспорт для VCS** (Git) подразумевает **регулярное** выгружание всех модулей, версионирование, рефакторинг и командную работу над проектом.  

**Технически** — действия похожи (надо «Экспортировать» модули), но **задачи** разные. При работе с Git вы делаете это **постоянно**, а при одноразовой выгрузке — эпизодически и без сложной структуры (может хватить и простого копирования).

---

## 3. Рекомендуемый процесс при работе с Git

1. **Выделить папку** для хранения модулей (например, `MyProject\Source\Modules\…`).  
2. С помощью **ручного экспорта** или скрипта (см. выше) выгрузить все модули `.bas`, `.cls`, `.frm`.  
3. Закоммитить их в Git-репозиторий.  
4. При каждом изменении или значительном рефакторинге в Excel — **повторить экспорт** (либо вручную, либо скриптом).  
5. Сравнить («diff») предыдущие версии файлов в Git, чтобы посмотреть, что действительно поменялось в коде.  

> *Если у вас одна версия Excel-файла (.xlsm), а у другого разработчика другая, и вы оба экспортируете в Git, то Git покажет расхождения. Можно будет «мержить» и выбирать нужные изменения — конечно, вручную, так как VBA часто требует аккуратного слияния.*  

Таким образом, у вас будет **централизованное** место, где хранится весь VBA‑код и его история, вместо того чтобы «искать нужную версию» в старых копиях `.xlsm`.

---

### Итог

- **Как сделать?** — Технически это та же операция «Export File…», описанная в пункте 3, но выполняемая **регулярно** и с организационными целями (хранение в Git).  
- **Разница** — в задаче: в пункте 3 речь шла о _способах разовой выгрузки_, а тут мы говорим о _постоянном «версионировании» кода_ и интеграции с системами контроля версий.  

Этот подход полезен при **рефакторинге и командной разработке** VBA, когда нужно документировать и отслеживать все изменения в коде, а не просто получить копию макросов «один раз».
~~~


## 13. Как сделать «Extract project» в Rubberduck?
### 13.1.
Я тебя спросил:
~~~
В пункте 12.2 ты писал:
```
- **Rubberduck** (open source) также умеет **«Extract project»** целиком, плюс выполняет статические анализы кода, инспекции и т.п.
```
Как сделать «Extract project» в Rubberduck?
Я установил Rubberduck в папку `C:\ProgramData\Rubberduck`.
Дальше что делать?
~~~

### 13.2.
Ты ответил:
~~~
Ниже приведены **общие шаги**, как настроить Rubberduck и использовать функцию **Extract Project** (или «Export all modules»). Интерфейс может слегка меняться от версии к версии, но логика примерно одинакова.

---

## 1. Убедиться, что Rubberduck корректно установлен и загружен в VBA

1. **Установите Rubberduck** стандартным способом (через `.msi`‑инсталлятор или ZIP) и обратите внимание, что:
   - По умолчанию Rubberduck ставится в папку вроде  
     ```
     C:\Program Files\Rubberduck
     ```
     или  
     ```
     C:\ProgramData\Rubberduck
     ```
     (в зависимости от версии/установщика).
   - Может потребоваться **.NET Framework** (чаще всего 4.7.2 или выше) и административные права при установке.  
   - Если у вас 64‑битный Office, убедитесь, что используете совместимую сборку Rubberduck.

2. **Запустите Excel** и откройте **VBA‑редактор** (<kbd>Alt</kbd>+<kbd>F11</kbd> или **Разработчик → Visual Basic**).  
3. Проверьте, что в **верхнем меню** VBE появилась вкладка **Rubberduck** (или на одной линии с «File», «Edit», «View» и т. д.). Если вкладки нет:
   - Зайдите в VBE → **Tools** → **Add-ins…** → Проверьте, что Rubberduck отмечен как загруженный (Load/Loaded).  
   - Или в Excel → **Файл → Параметры → Надстройки** (Add-ins), дальше выбрать «COM‑надстройки» (COM Add-ins) и включить Rubberduck, если он там отображается.  
   - Возможно, потребуется перезапуск Excel после включения надстройки.

Если вкладка Rubberduck видна и в ней есть пункты меню вроде **Refresh**, **Code Explorer**, **Inspection Results** и т. д., значит Rubberduck подхватился.

---

## 2. Где искать пункт «Extract Project»?

Обычно в свежих версиях Rubberduck (2.5.x и выше) есть **меню** или **подменю** для экспорта кода. Пункты могут называться чуть по‑разному (например, «Export Project», «Extract Project», «Export All Projects»), в зависимости от сборки. Как правило, это можно найти:

1. **В главном меню Rubberduck**:  
   - Например, **Rubberduck** → **Code Explorer** → (правый клик на проект) → «Export Project…»  
     или  
   - **Rubberduck** → **Refactor** / **Tools** → «Extract/Export Project…»  
2. **В контекстном меню** «Code Explorer»:
   - Откройте окно **Rubberduck → Code Explorer** (или нажмите иконку с деревом кода).  
   - Найдите там ваш VBA‑проект (название файла `.xlsm` или `.xlam` будет вверху дерева).  
   - Клик правой кнопкой → «Export Entire Project» / «Extract Project».  

**Важно**: Название и местоположение команды могут отличаться в зависимости от версии Rubberduck. Если не видите «Extract Project», посмотрите в меню **Refactor** или **Tools** — иногда авторы меняли расположение опции между релизами.

---

## 3. Как выглядит процесс «Extract Project»

1. **Укажите папку** для сохранения экспортируемых файлов. Rubberduck спросит, куда именно выгрузить код.  
2. После подтверждения Rubberduck пробежится по всем модулям VBA‑проекта (включая модули классов, стандартные модули, формы) и **сохранит их** в соответствующие `.bas`, `.cls`, `.frm` файлы.  
3. В результате вы получите полноценную **структуру исходников** на диске, где каждый модуль будет отдельным файлом. Это удобно для:
   - **Хранения в Git** или другой системе контроля версий;  
   - Автоматического сравнения изменений (diff/merge);  
   - Рефакторинга и документирования.

---

## 4. Что делать, если нужной опции нет?

- **Обновите Rubberduck** до более новой версии (в идеале 2.5+). Посмотрите [GitHub-репозиторий Rubberduck](https://github.com/rubberduck-vba/Rubberduck) — там есть инструкции по установке и описания актуальных функций.  
- Проверьте, не отключена ли функция «Experimental features» или «Load all refactor commands» в настройках Rubberduck. Иногда в ранних версиях нужно было включать кое-что вручную.  
- Если опции «Extract Project» не видно, можно воспользоваться **альтернативным** способом экспорта:
  - **Rubberduck → Export → Export Active Project** (или похожее название).  
  - Либо **Refactor → Extract → Whole Project**.  
  - Или, в самом крайнем случае, задействуйте встроенный в VBE **ручной экспорт** (правый клик → Export File…), но тогда это придётся делать для каждого модуля по отдельности.

---

## 5. Что дальше?

Когда у вас на диске появилась папка со всеми `.bas/.cls/.frm`:

1. **Создайте Git-репозиторий** (либо используйте уже существующий).  
2. **Скопируйте** экспортированные файлы туда, сделайте `git add .` → `git commit -m "Initial Rubberduck export"`.  
3. При **каждом изменении** кода в VBA (через VBE) повторяйте «Extract Project» и сравнивайте разницу в Git (`git diff`).  
4. Теперь вы сможете **отслеживать историю** кода VBA: когда, кем и что именно менялось. Это сильно упрощает рефакторинг и командную разработку.

---

### Краткое резюме

1. **Установить Rubberduck** так, чтобы он появился в меню VBA (убедиться, что COM‑надстройка активна).  
2. **Открыть** в VBE меню **Rubberduck** (или «Code Explorer») и найти пункт **Extract/Export Project**.  
3. **Выбрать папку**, дождаться окончания экспорта всех модулей.  
4. **Использовать** выгруженные файлы `.bas/.cls/.frm` по назначению (Git, анализ, рефакторинг и т. д.).

Если по каким‑то причинам «Extract Project» не обнаружен, воспользуйтесь:
- Ручным экспортом каждого модуля;
- Или сторонними надстройками (MZ‑Tools, скриптом через `VBProject.VBComponents.Export`).

Но в большинстве свежих сборок Rubberduck есть простой способ «Export/Extract Project» прямо из контекстного меню Code Explorer или через главное меню Rubberduck.
~~~

## 14. Как использовать Rubberduck из LibreOffice Calc?
### 14.1.
Я тебя спросил:
~~~
В пункте 13.2 ты писал:
```
2. **Запустите Excel** и откройте **VBA‑редактор** (<kbd>Alt</kbd>+<kbd>F11</kbd> или **Разработчик → Visual Basic**).  
3. Проверьте, что в **верхнем меню** VBE появилась вкладка **Rubberduck** (или на одной линии с «File», «Edit», «View» и т. д.).
```
Как использовать Rubberduck из LibreOffice Calc?
~~~

### 14.2.
Ты ответил:
~~~
К сожалению, **Rubberduck** предназначен **только** для Microsoft VBA (Visual Basic for Applications) и интегрируется напрямую в редактор VBA, который встроен в **Microsoft Excel** (и другие приложения Office). В **LibreOffice Calc** используется совсем другая среда макросов и язык (LibreOffice Basic), поэтому установить и запустить Rubberduck в ней нельзя.

### Почему так?

1. **Rubberduck** — это COM-надстройка (COM Add-in) для **Visual Basic Editor** (VBE), который есть в Microsoft Office.  
2. **LibreOffice Calc** не имеет VBE и не поддерживает VBA так, как это делает Excel. У LibreOffice есть свой редактор **LibreOffice Basic** и собственный API (UNO).  
3. Rubberduck использует внутренний объектный модель VBE (VBIDE) для анализа, рефакторинга и инспекций кода VBA. LibreOffice Basic — это другая платформа, другой язык, другая архитектура.

### Чем пользоваться в LibreOffice Basic?

Если вы пишете макросы непосредственно в **LibreOffice**, то для отладки и анализа кода существуют другие инструменты, например:

- **XRay** или **MRI** — надстройки для LibreOffice Basic, которые помогают исследовать объекты UNO, просматривать свойства и методы объектов, изучать структуру документа.  
- Встроенный редактор LibreOffice Basic имеет базовые возможности отладки (пошаговое выполнение, точки останова, просмотр переменных), но не предоставляет столь развитого рефакторинга, как Rubberduck.  

Однако аналоги Rubberduck, который бы выполнял масштабный статический анализ, рефакторинг и юнит-тесты для LibreOffice Basic, на сегодняшний день практически не развиты.

### Если нужен именно Rubberduck

Для использования Rubberduck вы **обязательно** должны открыть файл (или VBA-проект) в **Microsoft Excel** и работать в **Visual Basic Editor**.  
- В случае, когда макросы изначально писались под Excel/VBA и вы имеете файл `.xlsm` или `.xlam`, Rubberduck прекрасно подойдёт.  
- Если же код ориентирован на LibreOffice Basic, придётся либо переписывать его под VBA, либо продолжать использовать встроенный в LibreOffice инструментарий.

---

**Вывод**: **Rubberduck и LibreOffice Calc несовместимы**. Rubberduck интегрируется только в VBE (Microsoft Office). Для рефакторинга или анализа макросов в LibreOffice Basic вам понадобятся другие утилиты, однако полного аналога Rubberduck под LibreOffice не существует.
~~~



## 15. «All the different copies of the tracker share the same one XLAM file»
### 15.1.
Я тебя спросил:
~~~
В пункте 1.2 клиент пишет:
```
All the different copies of the tracker share the same one XLAM file so the code is always the same, it’s just the input data that changes.
```
Что он имеет в виду?
~~~

### 15.2.
Ты ответил:
~~~
Клиент имеет в виду, что у него есть **одна надстройка** (один файл `.XLAM`), в котором **находится весь VBA‑код**. При этом существует несколько «копий» или «вариантов» так называемого «трекера» (это могут быть разные файлы `.xlsx` или `.xlsm` с разными наборами данных), **но все они используют один и тот же `.XLAM`**.  

Другими словами:
1. **Логика и макросы** живут централизованно в файле надстройки `.XLAM`.  
2. У пользователя может быть, например, десять разных «трекеров» (Excel‑файлов) — для разных команд, отделов или проектов, у которых **разные входные данные** (разные листы, таблицы, значения).  
3. Каждый такой «трекер» просто **подключается** к одной и той же надстройке `.XLAM`, и благодаря этому **код во всех трекерах абсолютно одинаковый** (при обновлении кода в `.XLAM` обновляются возможности сразу у всех).

Таким образом, фраза «All the different copies of the tracker share the same one XLAM file» означает, что *«разрозненные Excel-книги с данными пользуются одним источником VBA‑макросов, поэтому везде единая версия кода — меняются только данные, а не логика»*.
~~~

## 16. Почему клиент прикрепил к проекту именно файл `.xlsm` (пункт 1.4), а не `.xlam`?
### 16.1.
Я тебя спросил:
~~~
В пункте 15.2 ты писал:
```
Клиент имеет в виду, что у него есть **одна надстройка** (один файл `.XLAM`), в котором **находится весь VBA‑код**. При этом существует несколько «копий» или «вариантов» так называемого «трекера» (это могут быть разные файлы `.xlsx` или `.xlsm` с разными наборами данных), **но все они используют один и тот же `.XLAM`**. 
```
Почему же тогда клиент прикрепил к проекту именно файл `.xlsm` (пункт 1.4), а не `.xlam`?
Я посмотрел: в этом файле `.xlsm` действительно содержится код VBA.
Каковы связи этого файла `.xlsm` с упоминаемым клиентом в пункте 1.2 «XLAM file»?
~~~

### 16.2.
Ты ответил:
~~~
Скорее всего, клиент прикрепил **`.xlsm`** по одной из следующих причин (а возможно, сразу по нескольким), даже несмотря на то, что в описании упоминается **`.xlam`** как «общий» источник кода:

1. **Демонстрационный пример**.  
   Клиент мог выслать **пример рабочей книги** (`.xlsm`) с тестовыми данными, чтобы наглядно показать, **как** макросы запускаются, **какой** интерфейс или листы используются, **какие** поля есть в письме.  
   - `.xlam` — это чистая надстройка, она может не содержать наглядной таблицы или «живых» данных.  
   - А `.xlsm` даёт вам «реальный» образец использования и позволяет протестировать логику прямо на примере.

2. **Пример кода «в действии»**.  
   Иногда в самой надстройке (`.xlam`) хранится «центральная» часть кода, но **часть процедур** или **инициализация** могут находиться и в файле `*.xlsm`. Либо в `.xlsm` прописаны **обработчики событий** (Workbook_Open, Worksheet_Change), которые взаимодействуют с кодом надстройки.  
   - То есть `.xlsm` может «подключаться» к `.xlam` как внешней библиотеке, а заодно содержать вспомогательные макросы/демо-скрипты.

3. **Ограничения на передачу `.xlam`**.  
   Возможно, **`.xlam` — это корпоративная надстройка**, которую клиент не хочет выкладывать публично или не готов расшаривать целиком (там может быть больше кода или конфиденциальная логика).  
   - Вместо этого он даёт «выдержку» или «урезанную версию» в виде `.xlsm`, где всё ещё присутствуют нужные фрагменты VBA, необходимые для оценки проекта.

4. **«Sample Email Blaster.xlsm» как отдельная часть системы**.  
   Из описания следует, что у клиента есть **несколько «копий трекера»** — это, по сути, разные Excel-файлы. Похоже, что «Sample Email Blaster.xlsm» — одна из таких «копий» или тестовый вариант «трекера», где есть **несколько макросов** или «обвязка» вокруг вызова кода.  
   - Фактически клиент показывает, **как именно** их система отправляет письма, какие поля используются, какой UI или какие листы.

5. **Привычка или простота**.  
   Иногда люди просто привыкли присылать `.xlsm`, потому что его проще открыть и сразу же просмотреть код через Alt+F11, без дополнительной регистрации надстройки.  
   - `.xlam`, будучи надстройкой, не всегда удобен для быстрой проверки — нужно сначала установить или подключить ее в Excel как надстройку, или открыть напрямую через VBE.

---

### Как именно `.xlsm` связан с `.xlam`?

- **В производственной среде** у клиента, судя по всему, все «трекеры» (возможно, и «Sample Email Blaster.xlsm» тоже) **подключают** одну и ту же надстройку `.xlam`.  
- Но **в этом присланном `.xlsm`** может дублироваться часть кода или содержаться дополнительные процедуры для демонстрации, отладки или тестирования — либо это вообще «одиночный» файл, который на деле выполняет ту же работу, что и код из `.xlam`.
  
Таким образом, фраза клиента о «едином файле `.xlam` для всех трекеров» указывает на **архитектуру в боевых условиях**, а присланный `.xlsm` — это **пример** (или тестовый прототип) с реальными листами и макросами, чтобы **показать**, как всё устроено и какие доработки нужны.
~~~



## 17. Дублируется ли код VBA в прикреплённом клиентом файле `.xlsm` (пункт 1.4) и упоминаемом клиентом в пункте 1.2 «XLAM file»?
### 17.1.
Я тебя спросил:
~~~
Как ты думаешь, дублируется ли код VBA в прикреплённом клиентом файле `.xlsm` (пункт 1.4) и упоминаемом клиентом в пункте 1.2 «XLAM file»?
Или же в этих файлах содержится разный код VBA?
~~~

### 17.2.
Ты ответил:
~~~
Точного и универсального ответа, увы, не существует без фактического просмотра обоих файлов. Однако **чаще всего** в подобных сценариях **код в файле `*.xlsm` и в файле `*.xlam` не полностью совпадает** и служит разным целям. Ниже — почему.

---

## 1. Зачем вообще держать код в двух местах (XLAM и XLSM)
1. **Главная надстройка (`.xlam`)** содержит «универсальную» часть кода, то есть _основную логику_, которой пользуются все «трекеры» (или другие Excel-файлы).  
2. **Отдельная книга (`.xlsm`)** может содержать:  
   - Дополнительные процедуры (макросы), которые **конкретно** применяются в этом конкретном файле/трекере.  
   - Код, который **подключается** к `.xlam` или вызывает её функции, но при этом в `*.xlsm` реализован свой интерфейс (кнопки на листе, пользовательские формы, события Workbook_Open и т.п.).  
   - Демонстрационные/тестовые фрагменты, не вошедшие в основную надстройку.  
   - Старую/прежнюю копию кода, которая когда-то дублировала `.xlam`, но теперь, возможно, устарела или нужна в «off-line»‑сценариях (без подключения надстройки).

Таким образом, в `*.xlsm` _может_ находиться часть логики, дублирующаяся с `.xlam`, но нередко она **неполная** или **расширенная**.

---

## 2. Варианты отношения кода в `.xlsm` и `.xlam`
1. **Частичное дублирование**  
   - _Базовый_ функционал (например, ядро рассылки) прописан в `.xlam`.  
   - В `*.xlsm` есть «обёртки» или вспомогательные процедуры, вызывающие этот функционал, плюс свой интерфейс.  
   - Некоторая часть кода в `*.xlsm` может частично повторять логику из `.xlam` (например, если пользователь всё же скопировал отдельные процедуры ради доработок, не меняя надстройку).

2. **Практически полный дубликат**  
   - Реже встречается, когда `.xlsm` буквально содержит почти весь код из надстройки (например, «старый вариант», а `.xlam` — «новый», но их забыли синхронизировать).  
   - Тогда часть функций и процедуры действительно будут «поглощены» и там, и там. Но это обычно ведёт к путанице — какая из копий актуальна?

3. **Разное содержимое**  
   - Возможно, в `.xlsm` вообще _другая_ логика (лишь несколько вспомогательных макросов), а весь основной код находится в `.xlam`.  
   - Или `.xlsm` служит демо-примером, где код специально «вынули» из надстройки и разместили в одной книге для теста, не дублируя версию из боевого `.xlam`.

---

## 3. Почему клиент прикрепил именно `*.xlsm` (а не `*.xlam`)
- **Показать рабочий пример:** пользователь может открыть «Sample Email Blaster.xlsm» и сразу увидеть, как макросы взаимодействуют с данными, не подключая надстройку вручную.  
- **Дать часть кода**: бывает, что `.xlam` — это более крупный корпоративный проект, который клиент не хочет (или не может) передавать целиком. Поэтому присылается «упрощённый» или «демонстрационный» `.xlsm` со схожей логикой.  
- **Упростить отладку**: `.xlsm` можно открыть и запустить напрямую, а надстройки `.xlam` нужно сперва «Подключить» через настройки Excel → «Надстройки».

---

## 4. Итог: дублируется ли код?
1. **Может быть** частичное или даже полное дублирование — _если_ `.xlsm` создан как «локальная копия» кода, который когда-то был в `.xlam`.  
2. **Может быть** разный код — _если_ `.xlsm` содержит лишь вспомогательные/пользовательские макросы, а основная логика сосредоточена в `.xlam`.  
3. **Скорее всего**, клиент добавил в `*.xlsm` **какой-то** VBA-код (или его часть) _для демонстрации_ или _для конкретного сценария_, в то время как в `.xlam` продолжает жить общий «ядро» системы.

**Без прямого сравнения** обоих файлов (открыв их в VBA-редакторе) нельзя сказать наверняка, где код совпадает, а где различается. Но почти всегда они **не идентичны**: либо `.xlsm` включает часть общего кода плюс специфические процедуры, либо содержит другую/облегчённую версию.
~~~
