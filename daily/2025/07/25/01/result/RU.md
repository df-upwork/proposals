1) Я рекомендую следующий авторизации с использованием Microsoft Entra ID (`EI`) и Keycloak (`K`):
1.1) В основе предлагаемого решения лежит архитектурный паттерн «Identity Brokering», также известный как «Identity Federation». 
`K` обладает встроенной поддержкой данного паттерна, позволяя делегировать процесс аутентификации внешнему, доверенному поставщику удостоверений, который в данном контексте именуется «Identity Provider» (`IP`).
1.2) `EI` выступает в роли авторитетного `IP`.
Это означает, что именно `EI` отвечает за хранение учётных данных пользователей, проверку их подлинности (аутентификацию) и предоставление информации об этих пользователях.
1.3) `K`, в свою очередь, конфигурируется как «Identity Broker»: промежуточный сервис, который устанавливает доверительные отношения с `EI`. 
Конечное клиентское приложение (`A`) не взаимодействует с `EI` напрямую. 
Вместо этого оно полностью доверяет `K`, который предоставляет ему унифицированный интерфейс для аутентификации и авторизации.
2) Мой подход (пункт 1) создаёт важный слой абстракции, который даёт следующие преимущества: 
2.1) Централизация управления `IP`. 
Если в будущем потребуется добавить других поставщиков удостоверений (например, Google, Facebook или другой корпоративный SAML `IP`), все изменения будут производиться централизованно в `K`. 
`A` останется неизменным, так как оно по-прежнему будет взаимодействовать только с `K`. 
2.2) Упрощение `A`. 
Разработчикам `A` не нужно реализовывать логику для взаимодействия с различными протоколами и API множества `IP`. 
Им достаточно интегрироваться с одним сервисом (`K`) по одному стандартизированному протоколу.
2.3) Обогащение и трансформация токенов. 
`K` может получать информацию от внешнего `IP`, а затем обогащать или преобразовывать её перед передачей `A`. 
Например, он может сопоставлять группы из `EI` с внутренними ролями `K`.
3) В моём подходе `K` выполняет двойную роль:
3.1) С точки зрения `A`, `K` является его `IP`. 
`A` обращается к `K` за аутентификацией и получает от него токены. 
3.2) С точки зрения `EI`, `K` — это клиентское приложение, которое запрашивает аутентификацию. 
В терминологии протоколов он выступает как «Service Provider» (`SP`) или «Relying Party» (`RP`). 
4) Двойственность пункта 3 имеет критическое значение при диагностике проблем. 
Например, сбой аутентификации может быть связан либо с токеном, который `K` получает от `EI` (его роль как `SP`/`RP`), либо с токеном, который он выдаёт конечному приложению (его роль как `IP`).
Чёткое разграничение этих ролей позволяет точно локализовать источник проблемы.
5) `K` поддерживает два основных протокола для федерации удостоверений: Security Assertion Markup Language 2.0 (SAML) и OpenID Connect 1.0 (`OIDC`).
Я рекомендую в вашем случае `OIDC` по следующим причинам:
5.1) Учитывая технологический стек проекта, указанный вами в тегах (Java, JavaScript, PHP, Amazon Web Services), который явно ориентирован на современные веб-технологии и облачные сервисы.
5.2) `OIDC` — это более современный стандарт, построенный как простой слой идентификации поверх протокола авторизации OAuth 2.0. 
Для передачи данных `OIDC` использует формат JSON и токены JWT («JSON Web Tokens»). 
Он изначально проектировался с учётом потребностей современных веб-приложений, мобильных клиентов и RESTful API.
6) Общая схема взаимодействия:
6.1) Пользователь (`U`) пытается получить доступ к защищённому ресурсу в `A`.
6.2) `A`, обнаружив отсутствие активной сессии, перенаправляет `U` на страницу входа `K`.
6.3) `K`, в свою очередь, видит, что `U` не аутентифицирован, и перенаправляет его на сконфигурированный внешний `IP`: `EI`.
6.4) `U` вводит свои корпоративные учётные данные на странице входа `EI` и успешно проходит аутентификацию.
6.5) `EI` генерирует «ID Token» (`T`), содержащий claims о `U`, включая его идентификаторы групп, и перенаправляет браузер `U` обратно на специальный «Redirect URI» в `K`.
6.6) `K` получает `T` от `EI`, проверяет его цифровую подпись и валидность.
6.7) `K` извлекает из `T` claims. 
6.8) На основе claims `K` либо создаёт в своей БД новую учётную запись для `U`, либо обновляет  существующую. 
На этом же этапе происходит ключевой процесс — сопоставление (маппинг) идентификаторов групп из claim «groups» на внутренние роли `K`. 
6.9) `K` создаёт собственную сессию для `U`.
6.10) `K` генерирует собственные токены (`K-TT`) для `A`:
- Собственный «ID Token» (не путать с `T`) 
- «Access Token». 

`K-TT` содержат роли, которые были назначены `U` внутри `K`. 
6.11) `K` перенаправляет браузер `U` обратно на «Redirect URI» `A`.
6.12) `A` получает `K-TT` от `K`, валидирует их и извлекает из них информацию о ролях `U`. 
6.13) `A` принимает решение о предоставлении или запрете доступа `U` к запрошенному ресурсу.
