## 1.
Клиент хочет выполнить следующий проект:
### 1.1. Title
Need Sr Dev - Next, Nest, Stripe, AWS

### 1.2. Description
We have an active bug which we can't resolve in an app built by a contracted firm. 
This is a trial to see how well we work together and what you can produce.
We have a React hook bug which is causing a stripe embedded form to continuously reload in a loop. 
This is the highest priority.

### 1.3. Местоположение клиента
United States
St. Louis

### 1.4. Tags
React
Amazon Web Services
Node.js
JavaScript

## 2. «a React hook bug which is causing a stripe embedded form to continuously reload in a loop»
### 2.1.
Я тебя спросил:
~~~
В пункте 1.2 клиент пишет:
```
We have a React hook bug which is causing a stripe embedded form to continuously reload in a loop. 
```
Перечисли наиболее вероятные причины проблемы клиента.
~~~

### 2.2.
Ты ответил:
#### 2.2.1. Ответ 1
~~~
Ниже перечислены наиболее вероятные причины бесконечного перезагрузочного цикла (infinite loop) при использовании React-хуков в связке со Stripe:

1. **Неверная настройка зависимостей в useEffect**  
   - Если в `useEffect` не указан корректный список зависимостей (или он пуст, когда это не нужно, или наоборот содержит переменную, которая меняется на каждом рендере), то хук может вызываться при каждом обновлении компонента, запуская перезагрузку формы снова и снова.

2. **Постоянное изменение состояния или пропсов**  
   - Например, если в теле компонента или в `useEffect` есть вызов `setState` или функция, изменяющая пропсы, причём это изменение срабатывает при каждом рендере, то в результате возникает постоянный цикл: изменение состояния → повторный рендер → снова изменение состояния.

3. **Пересоздание Stripe-элемента на каждом рендере**  
   - Некоторые API Stripe (или любые внешние библиотеки) могут требовать инициализации один раз, а не при каждом рендере. Если при каждом рендере компонента происходит повторная инициализация (например, из-за отсутствия мемоизации), это может привести к перезагрузке формы.

4. **Неправильное использование контекста или глобального состояния**  
   - Если Stripe-форму обёртывают в контекст, который изменяется на каждом шаге (например, контекст пересоздаётся при каждом рендере родительского компонента), это тоже может вызывать повторный рендер и перезагрузку.

5. **Конфликт между серверным и клиентским рендером (Next.js)**  
   - При использовании Next.js нужно уделять особое внимание тому, как Stripe интегрируется на стороне клиента. Если код Stripe вызывается до того, как компонент окончательно "гидратирован" (hydrated) на клиенте, может возникать рассинхронизация и, как следствие, зацикливание.

6. **Неправильно настроенный обработчик событий**  
   - Если код, отвечающий за обработку события (например, на изменение полей формы Stripe), напрямую влияет на состояние, которое опять же вызывает повторный рендер, может возникнуть бесконечный цикл обновлений.

7. **Использование неподдерживаемых методов жизненного цикла или нестабильных решений**  
   - Если проект переходит с классовых компонентов на хуки или наоборот, может возникать конфликт логики (например, повторные вызовы эффектов или устаревшие паттерны, препятствующие корректной работе хуков).

Обычно для устранения подобной проблемы нужно внимательно проверить:
- Как вы передаёте зависимости в `useEffect`.
- Используете ли вы мемоизацию (React.useMemo, React.useCallback) там, где это необходимо.
- Не происходит ли повторная инициализация Stripe-объектов на каждом рендере.
- Нет ли какой-то "цепочки" изменений в стейте, которая снова и снова вызывает рендер компонента.
~~~
#### 2.2.2. Ответ 2
~~~
Ниже перечислены наиболее частые причины, по которым в React-приложениях может возникать «бесконечный цикл перезагрузки» (re-render loop) при работе с хуками и, в частности, со встраиваемыми сторонними компонентами (например, Stripe). Каждая из них может быть релевантна для описанного случая со Stripe form:

1. **Неправильная конфигурация или отсутствие зависимостей в useEffect**  
   - Частая ошибка: вызов `setState` или иной метод изменения состояния внутри `useEffect`, который не имеет корректного массива зависимостей (или массив зависимостей пуст, когда он не должен быть пустым, или наоборот — отсутствует там, где он нужен).  
   - В результате на каждом рендере `useEffect` выполняется заново, снова меняет состояние, снова вызывает рендер, и так до бесконечности.

2. **Постоянное изменение Props/State, приводящее к перерисовке**  
   - Если компонент передаёт во вложенный (дочерний) компонент какие-то пропсы, которые вычисляются заново на каждом рендере (например, новая функция или новый объект), это может привести к тому, что дочерний компонент будет постоянно «пересоздаваться» и, как следствие, инициировать повторный рендер.  
   - В случае с интеграцией Stripe это особенно критично, если для перерисовки или инициализации формы используется объект, который создаётся в локальном состоянии при каждом рендере.

3. **Использование setState (или похожих вызовов) непосредственно в теле компонента**  
   - Вызовы, которые должны быть в `useEffect`, ошибочно располагают в теле компонента (за пределами хуков), что приводит к тому, что при каждом рендере состояние меняется заново.  
   - Это мгновенно вызывает следующий рендер, и цикл повторяется.

4. **Несанкционированный перезапуск встраиваемого компонента (Stripe) из-за неверной логики**  
   - При первой загрузке Stripe-формы, возможно, срабатывает какая-то проверка/инициализация, после чего приложение пытается заново установить форму (пересоздать Stripe-элемент).  
   - Может случиться, что при каждом рендере логика повторно создаёт элемент Stripe, и, как следствие, обновляет состояние, провоцируя ещё один рендер.

5. **Неправильное использование Next.js и серверного рендеринга**  
   - Если приложение использует Next.js, ошибки в коде, связанного с SSR (Server-Side Rendering) и гидратацией (hydration) на клиенте, могут привести к конфликтам состояния, инициализации или условий рендера.  
   - Некорректная проверка «окружения» (например, отсутствие `window` на сервере) нередко провоцирует перезагрузки или бесконечные циклы.

6. **Рекурсивные вызовы или некорректная логика в React Router / Redirect**  
   - В случае, если задействованы роуты или редиректы (например, после инициализации Stripe-компонента), ошибочная логика условий (всё время возвращающая `true`) может вызывать постоянный «прыжок» по маршрутам или повторную инициализацию формы.  

7. **Неправильное взаимодействие с глобальным состоянием (Redux, MobX, Context и т.п.)**  
   - Если Stripe или другой внешний сервис диспатчит события (например, при монтировании), которые изменяют глобальный стейт, а глобальный стейт в свою очередь меняет пропсы компонента — это может повлечь за собой непрерывный круг реакций «стрейт → глобальное состояние → рендер → снова стрейт».

8. **Версионные или конфигурационные конфликты библиотек Stripe и React**  
   - Использование устаревшей версии Stripe SDK или несовместимых версий React/Nest.js/Next.js может приводить к непредвиденному поведению при инициализации и монтировании компонента.  
   - В отдельных случаях это может выражаться в зависаниях или перезагрузках, если Stripe SDK не получает ожидаемых пропов или некорректно управляет состоянием.

---

Чтобы локализовать причину, обычно необходимо:
- Проверить правильность зависимостей в `useEffect`.
- Убедиться, что состояние или пропсы не меняются бесконечно внутри одного рендера (например, с помощью логов в консоли посмотреть, что именно триггерит изменение).
- Убедиться, что компонент Stripe инициализируется всего один раз или согласно корректным условиям, а не при каждом обновлении рендера.
- Посмотреть на логику SSR/Next.js (если используется) и правильно обработать инициализацию на стороне клиента.
~~~
#### 2.2.3. Ответ 3
~~~
Ниже перечислены несколько наиболее распространённых причин, по которым интеграция Stripe или любой сторонний компонент внутри React может вызывать бесконечный цикл перезагрузки/перерисовки. Скорее всего, причина проблемы кроется в неверном использовании React-хуков (useEffect, useState, useMemo и т.д.) или в особенностях инициализации сторонних скриптов (Stripe). Обратите внимание на следующее:

1. **useEffect без корректных зависимостей**  
   - Если внутри `useEffect` устанавливается состояние (через `setState`) или вызывается какой-то побочный эффект, который снова вызывает ререндер, а в массиве зависимостей (`[])`) этого эффекта указаны переменные, меняющиеся на каждом ререндере, то может возникнуть бесконечный цикл.  
   - Например, нередко встречается ситуация, когда внутри `useEffect` вы пытаетесь установить состояние, но при этом не указываете пустой массив зависимостей или указываете зависимости, которые меняются при каждом ререндере. В результате каждый новый ререндер снова вызывает `setState` и компонент перерисовывается бесконечно.

2. **Повторная инициализация Stripe-объекта или формы**  
   - Если код инициализации Stripe (подключение скрипта, создание элемента формы и т.д.) вызывается при каждом ререндере, это может приводить к тому, что форма постоянно перезагружается.  
   - Нужно убедиться, что Stripe-объект создаётся (или форма инициализируется) один раз, либо только при тех изменениях, когда действительно нужно пересоздать компонент.

3. **Конфликт логики Next.js (SSR) и Client-side рендера**  
   - Если в Next.js на сервере и на клиенте получаются разные значения для какого-то состояния или пропсов (например, что-то зависит от `window` или `document`, недоступных на сервере), может происходить расхождение, которое приводит к повторному рендеру.  
   - Важно убедиться, что логика, завязанная на объект `window`/`document`, вызывается только на клиенте (через `useEffect` или проверку типа `typeof window !== "undefined"`).

4. **Неправильная работа с состоянием (useState) и пропсами**  
   - Если есть компонент-родитель, который в каждом рендере передаёт новые пропсы ребёнку (например, новую функцию или новый объект), а в компоненте-потомке это состояние снова меняется, запуская эффект, может получиться «цепная реакция» перерисовок.  
   - Проверьте, не передаёте ли вы из родительского компонента постоянно новые объекты/функции, которые не мемоизированы (например, c помощью `useCallback`, `useMemo`) и вызывают у дочернего компонента обновление.

5. **Рендеринг компонента форм внутри эффекта**  
   - Если вы пытаетесь программно монтировать компонент Stripe (через вызовы типа `ReactDOM.render` или напрямую добавляя его в DOM) внутри `useEffect`, и при этом эффект срабатывает при каждом обновлении, то форма будет каждый раз создаваться заново.  
   - Важно либо вынести логику рендеринга из эффекта, либо ограничивать срабатывание эффекта нужными зависимостями.

6. **Отсутствие проверки на готовность данных или скриптов**  
   - Часто бывает, что в компонент приходит пропс (например, конфигурация для Stripe), который изначально `undefined` или пустой. Если не делать проверку, инициализация идёт с неверными данными, вылетает ошибка, а React пытается заново перерисовать компонент. Это может проявляться как бесконечная перезагрузка.  
   - Необходимо проверять, что данные (ключи API, объекты Stripe, необходимые props) действительно загружены и валидны перед вызовом инициализирующих функций.

7. **Бесконечный цикл из-за рефов или других хуков**  
   - Иногда рефы (`useRef`) используются для хранения промежуточных данных, которые внутри эффекта могут обновляться. Если эти данные снова влияют на состояние или пропсы, это также способно вызвать зацикливание.  
   - Следите за тем, чтобы обновления рефа не вызывали перерисовку, если это не нужно.

---

### Как подойти к диагностике

1. **Изучите массив зависимостей во всех `useEffect`**  
   - Убедитесь, что вы чётко понимаете, при каких условиях каждый эффект должен срабатывать.  
   - Убедитесь, что в эффектах не вызывается `setState`, который меняет зависимость этого же эффекта.

2. **Изолируйте логику инициализации Stripe**  
   - Попробуйте вынести всю логику инициализации Stripe (подключение скрипта, создание `stripe` или `elements`) в отдельный блок, который вызывается единожды, например, на уровне верхнего компонента или в момент, когда вы точно знаете, что страница не будет меняться.  
   - Используйте дополнительные проверки (например, `if (!stripe) { ... }`) и убедитесь, что данные не инициализируются повторно.

3. **Проверьте, не вызываете ли вы сами `window.location.reload` или что-то похожее**  
   - Иногда в коде может быть логика «подцепить новую сессию» или «обновить страницу при ошибке», что тоже может приводить к бесконечной перезагрузке при возникновении ошибки.

4. **Локализуйте проблему**  
   - Попробуйте временно отключить компонент Stripe, чтобы проверить, исчезает ли бесконечная перезагрузка. Если да — значит проблема именно в интеграции с Stripe. Если нет — ищите в другом месте (например, в другом компоненте/хуке).

5. **Проверьте наличие ошибок или предупреждений в консоли**  
   - В зависимости от версии React и от того, как настроены логи, там могут быть наводки на причину ререндеров или ошибки инициализации.

Чаще всего бесконечная перезагрузка (или ререндер) возникает из-за неверного использования хуков: `useEffect` с некорректным массивом зависимостей, бесконечного вызова `setState` внутри эффекта или повторной инициализации сторонних компонентов (как в случае со Stripe). Рекомендуется поэтапно изолировать каждую часть логики, проверять зависимости хуков, а также упростить код (убрать всё лишнее), чтобы локализовать проблемный участок.
~~~

## 3. «Неверная настройка зависимостей в useEffect»
### 3.1.
Я тебя спросил:
~~~
В пункте 1 своего ответа пункта 2.2.1 ты писал:
```
1. **Неверная настройка зависимостей в useEffect**  
   - Если в `useEffect` не указан корректный список зависимостей (или он пуст, когда это не нужно, или наоборот содержит переменную, которая меняется на каждом рендере), то хук может вызываться при каждом обновлении компонента, запуская перезагрузку формы снова и снова.
```
Опиши подробнее, каким образом «Неверная настройка зависимостей в useEffect» может приводить к проблеме клиента.
~~~

### 3.2.
Ты ответил:
~~~
Ниже приведён более детальный разбор, почему именно «неверная настройка зависимостей в `useEffect`» может приводить к бесконечному циклу и, как следствие, к постоянной перезагрузке/рендерингу Stripe-формы.

---

### 1. Как работает массив зависимостей в `useEffect`

- Когда вы указываете массив зависимостей в `useEffect`, React сравнивает значения этих зависимостей при каждом рендере компонента с их значениями при предыдущем рендере.
- Если хотя бы одно значение в массиве зависимостей изменилось, `useEffect` срабатывает снова.
- Если массив зависимостей пуст (`[]`), эффект выполнится только один раз — при маунте (первом рендере) компонента.  
- Если массив зависимостей не передан вообще, эффект будет выполняться **при каждом рендере**.

### 2. Типичные сценарии, ведущие к бесконечному циклу

1. **Зависимость «меняется» при каждом рендере**  
   - Например, в компоненте на каждом рендере создаётся новый объект или функция, которая (без мемоизации) всегда будет иметь новое значение в памяти.  
   - React видит, что «старое значение зависимостей» и «новое значение зависимостей» не совпадают (даже если, по логике, содержимое объектов/функции одинаковое).  
   - Каждый рендер → `useEffect` видит, что зависимость изменилась → вызывает эффект → меняет состояние (или, например, заново инициализирует Stripe-форму) → снова рендер. Получается бесконечный цикл.

2. **Внутри эффекта вызывается `setState` / изменение пропсов, которое в свою очередь влияет на зависимость**  
   - Представим, что в `useEffect` вы вызываете `setState`, а это состояние указано (напрямую или косвенно) в массиве зависимостей.  
   - После каждого рендера React повторно «замечает», что соответствующая зависимость изменилась (из-за `setState`), и снова вызывает тот же эффект.  
   - В итоге получается зацикливание: `setState` → рендер → `useEffect` → снова `setState` → рендер → и так далее.

3. **Отсутствие (или ошибка) массива зависимостей, когда эффект не должен выполняться при каждом рендере**  
   - Если массив зависимостей не указан вообще, React будет вызывать этот эффект **каждый** раз при любой перерисовке компонента.  
   - Для инициализации Stripe (или любой другой внешней библиотеки), обычно достаточно вызвать логику один раз или лишь при определённых условиях. Если же эффект будет запускаться при каждом рендере, библиотека будет пересоздаваться/перезагружаться, вызывая новый рендер → который опять перезапустит эффект и так далее.

### 3. Как это проявляется при работе со Stripe

При интеграции Stripe (через `stripe.js` или компоненты `react-stripe-js`) часто есть отдельный блок кода, который:

- Создаёт объект `Stripe` или `elements`.
- Вешает обработчики на события или монтирует форму на страницу.

Если этот блок кода находится внутри `useEffect`, и:

1. **Эффект срабатывает постоянно **  
   - То каждый раз создаётся (или переинициализируется) новый объект формы Stripe.  
   - Stripe видит, что форму пересоздают, «размонтирует» старую и снова рендерит новую → в интерфейсе пользователя может возникать видимость «мигающей» или «перезагружающейся» формы.  
   - А React при этом считает, что надо снова обновить состояние/props для нового объекта формы. В результате получается бесконечный цикл.

2. **Внутри `useEffect` есть вызов `setState`, а в массиве зависимостей — значение, которое зависит от этого же состояния**  
   - Вызов `setState` триггерит новый рендер → новое значение состояния снова вызывает `useEffect`, потому что оно «изменилось» → снова `setState` → и так до бесконечности.  
   - Это может приводить к тому, что каждая попытка «обновить» или «проверить» состояние перезагружает всю логику Stripe.

3. **Указаны неуместные переменные в зависимостях**  
   - Например, в массив зависимостей помещают функцию, которая создаётся на каждом рендере (без `useCallback`). React считает, что функция «новая» при каждом рендере, и, следовательно, всегда вызывает эффект заново.  
   - Или в зависимостях указывают объект конфигурации для Stripe, который внутри компонента пересоздаётся при каждом рендере (опять же, без мемоизации).

### 4. Пример «неверной» конфигурации `useEffect`

```jsx
function StripeForm() {
  const [reload, setReload] = useState(false);
  
  useEffect(() => {
    // Инициализируем или монтируем Stripe-форму (допустим)
    // ...
    // А затем вызываем setReload
    setReload(!reload); // <-- состояние reload меняется каждый раз
    
    // Массив зависимостей
  }, [reload]);
  
  return <div id="stripe-form"></div>;
}
```

- Что происходит:  
  1. Компонент монтируется, `reload` = `false`.  
  2. `useEffect` вызывается (т.к. `reload` в зависимостях при первом рендере). Внутри эффекта `setReload(!reload)`, то есть `setReload(true)`.  
  3. Состояние `reload` меняется на `true`, компонент перерисовывается.  
  4. `useEffect` опять вызывается, так как `reload` из `false` стал `true`. Внутри эффекта снова `setReload(!reload)` → снова `false`.  
  5. Цикл повторяется бесконечно.  

- Параллельно, если там ещё и логика инициализации/монтирования Stripe-формы, она тоже будет «дёргаться» при каждом рендере, что может выглядеть как бесконечная перезагрузка формы.

### 5. Как правильно поступать

1. **Убедиться, что инициализация Stripe выполняется один раз**  
   - Если действительно нужно вызвать логику ровно при первом рендере (маунте), можно использовать пустой массив зависимостей:
     ```jsx
     useEffect(() => {
       // Инициализируем Stripe один раз
     }, []);
     ```
   - Так эффект не будет вызываться снова без необходимости.

2. **Тщательно определять массив зависимостей**  
   - Если внутри эффекта вы обращаетесь к некоторым переменным или функциям, надо задаться вопросом: «Должен ли эффект срабатывать при изменении этих значений?»  
   - Если да, эти переменные должны быть в массиве зависимостей. Если нет, то либо нужно их мемоизировать (`useMemo`, `useCallback`), либо вынести из эффекта.

3. **Следить за тем, что `useEffect` не вызывает беспричинное изменение состояния**  
   - Если внутри `useEffect` вызывается `setState`, которое всегда генерирует новое значение — это почти наверняка признак потенциального бесконечного цикла.  
   - Необходимо либо добавить условие (например, «обновлять состояние только в том случае, если значение действительно изменилось»), либо перенести логику в другой хук/место.

4. **Мемоизировать создаваемые объекты или колбэки**  
   - Если вам нужно, чтобы какая-то функция или объект в дочерний компонент передавались **без** «нового» значения при каждом рендере, используйте `useCallback` или `useMemo`.  
   - Это поможет избежать ситуации, когда React считает, что «зависимость изменилась» на каждом шаге.

---

### Ключевая идея

«Неверная настройка зависимостей в `useEffect`» сводится к тому, что **любой** вызов эффекта, который **не должен** происходить при каждом рендере, но всё же происходит, может спровоцировать «зацикливание» рендеров. При интеграции сторонних форм (Stripe, PayPal, и т.д.) это особо критично, так как инициализация форм или внешних скриптов, повторяющаяся бесконечно, приводит к визуальной «перезагрузке» компонента или к ошибкам библиотеки.

При диагностике такого поведения почти всегда стоит:
1. Посмотреть в консоли, что триггерит перерисовку (вывести лог при каждом рендере).
2. Проверить все массивы зависимостей в `useEffect`.
3. Убедиться, что вы не вызываете `setState` при каждом выполнении эффекта **без** дополнительных условий.

Если в итоге оказывается, что эффект должен выполняться один раз (или по строго определённому условию), а выполняется всегда — значит, дело именно в «неверной настройке зависимостей» или в отсутствии нужной мемоизации.
~~~

## 4. «Постоянное изменение состояния или пропсов»
### 4.1.
Я тебя спросил:
~~~
В пункте 2 своего ответа пункта 2.2.1 ты писал:
```
2. **Постоянное изменение состояния или пропсов**  
   - Например, если в теле компонента или в `useEffect` есть вызов `setState` или функция, изменяющая пропсы, причём это изменение срабатывает при каждом рендере, то в результате возникает постоянный цикл: изменение состояния → повторный рендер → снова изменение состояния.
```
Опиши подробнее, каким образом «Постоянное изменение состояния или пропсов» может приводить к проблеме клиента.
~~~

### 4.2.
Ты ответил:
~~~
Ниже приведён более детальный разбор того, почему непрерывное (или «бесконечное») изменение состояния (state) или пропсов (props) способно вызывать постоянные перерисовки (re-renders), которые внешне выглядят как бесконечная перезагрузка/обновление компонента или формы (например, Stripe-формы).

---

## 1. Как React обрабатывает изменения состояния и пропсов

1. **Изменение состояния** (через `setState` в классовых компонентах или через `useState`/`useReducer` в функциональных компонентах) автоматически приводит к новому рендеру компонента.  
2. **Изменение пропсов** в дочерних компонентах тоже может привести к новому рендеру дочерних компонентов. Ведь если родитель пересылает другие значения, дочерний компонент должен обновиться.  

Важно понимать, что **каждый рендер** запускает новую итерацию жизненного цикла у функциональных компонентов, что включает повторное выполнение тела компонента (а значит и повторный вызов хуков) или метода `render` у классовых компонентов.

Если в ходе **каждого** нового рендера снова меняется состояние или пропсы — мы получаем эффект «бесконечного цикла» перерисовок.

---

## 2. Типичные сценарии, ведущие к бесконечной перерисовке

1. **Вызов `setState` или изменения пропсов внутри тела компонента**  
   - Если в функциональном компоненте что-то вроде:
     ```jsx
     function MyComponent() {
       const [count, setCount] = useState(0);
       
       // Ошибка: вызов setCount на каждом рендере без условий
       setCount(prev => prev + 1);

       return <div>{count}</div>;
     }
     ```
   - При **каждом** рендере вызывается `setCount`, что немедленно инициирует очередной рендер, и так по кругу.  
   - Аналогичная логика может находиться в `useEffect` или в другом месте компонента, но если она срабатывает при **каждом** рендере без каких-либо проверок, цикл будет бесконечным.

2. **Функция, изменяющая состояние, вызывается безусловно**  
   - Например, в `useEffect` стоит код:
     ```jsx
     useEffect(() => {
       setStripeReady(true); // или любое другое изменение состояния
     });
     ```
     без массива зависимостей или с зависимостью, которая всегда меняется.  
   - В итоге **каждый** рендер снова вызывает `setStripeReady(true)`, даже если оно уже было `true`.  
   - React считает, что состояние меняется, делает повторный рендер, где снова срабатывает `useEffect` и т.д.

3. **Изменение пропсов (родитель → ребёнок) на каждом рендере**  
   - Если родительский компонент при **каждом** своём рендере генерирует новые объекты или функции и передаёт их дочернему компоненту, дочерний может расценивать это как «новые пропсы» и обновляться.  
   - В некоторых случаях это оправдано, но если внутри дочернего компонента обновление пропсов снова меняет состояние или вызывает дополнительные эффекты, можно получить цикл.  
   - Особенно критично, если дочерний компонент, реагируя на новые пропсы, вызывает у родителя какое-то действие (через callback), которое снова меняет пропсы родителя, и процесс повторяется.

4. **Некорректная логика, связанная с глобальным состоянием или контекстом**  
   - Если при каждом рендере компонента изменяется глобальный стейт (например, Redux, MobX или Context), а при изменении глобального стейта этот же компонент/его родитель снова меняют локальное состояние — может возникнуть «кольцевая» реакция:  
     1. Рендер компонента →  
     2. Диспатч в глобальный стейт →  
     3. Глобальный стейт вызывает обновление подписчиков →  
     4. Компонент снова меняется →  
     5. Снова диспатч…  
   - В результате — бесконечный цикл.

---

## 3. Как это проявляется при работе со Stripe

При интеграции со Stripe (или другим внешним сервисом) часто есть логика:

1. **Монтирования/инициализации** платежной формы.  
2. **Отслеживания готовности** формы (например, «Stripe Elements создан»).  
3. **Отправки данных** на сервер при каком-то изменении.

Если при каждом рендере компонента:

- Вы безусловно обновляете состояние (например, `stripeReady = true`),  
- Или передаёте вниз новые пропсы, которые снова изменяют состояние,  
- Или снова «создаёте» объекты Stripe и записываете их в состояние,

то на практике получаете замкнутый цикл: *«каждый рендер → изменение → следующий рендер»*.

Например, упрощённый сценарий:

```jsx
function StripeForm() {
  const [stripeReady, setStripeReady] = useState(false);

  // Имитируем получение/инициализацию Stripe на каждом рендере
  const stripeInstance = initializeStripeSomehow(); // Возвращает всегда новый объект

  // useEffect без зависимостей или с неправильными зависимостями
  useEffect(() => {
    // Если stripeInstance есть, ставим ready = true
    if (stripeInstance) {
      setStripeReady(true); 
    }
  }, [stripeInstance]); // stripeInstance создаётся заново на каждом рендере

  return <div>Form {stripeReady ? "Ready" : "Loading"}</div>;
}
```

- При первом рендере `initializeStripeSomehow()` возвращает объект.  
- В `useEffect` вызывается `setStripeReady(true)`.  
- Состояние меняется — это вызывает повторный рендер.  
- На повторном рендере `initializeStripeSomehow()` опять возвращает «новый» объект (без мемоизации или безусловно). React видит, что в массиве зависимостей эффекта `stripeInstance` опять «изменился» (это новый объект по ссылке), → снова срабатывает эффект → снова `setStripeReady(true)` → ещё один рендер… — и так бесконечно.

---

## 4. Как предотвратить подобные сценарии

1. **Условие/Проверка перед вызовом `setState`**  
   - Если требуется изменить состояние, убедитесь, что вы не вызываете `setState` каждый раз без необходимости.  
   - К примеру, изменяйте состояние только тогда, когда оно действительно должно измениться.  
   - Используйте подход «только если новое значение отличается от старого».

2. **Вынесение инициализации в `useEffect` с правильными зависимостями**  
   - Если инициализация Stripe (или другой объект) нужна лишь один раз, используйте пустой массив зависимостей:  
     ```jsx
     useEffect(() => {
       // Инициализация однажды
     }, []);
     ```
   - Если инициализация зависит от конкретных пропсов, завязывайтесь только на них, и *обязательно* проверяйте, что при их неизменности не будет повторного вызова.

3. **Мемоизировать объекты и колбэки**  
   - Если у вас есть функция или объект, который создаётся заново на каждом рендере, но по сути — не меняется, используйте `useMemo` / `useCallback`.  
   - Это позволит React считать, что значение зависимостей *не* менялось, и избежать бесконечного рендера.

4. **Внимательно следить за взаимодействием родительских и дочерних компонентов**  
   - Если родитель при каждом рендере создаёт новые пропсы (объекты/функции), а дочерний на это реагирует дополнительным изменением состояния, можно получить «пинг-понг» рендера.  
   - Выносите колбэки в `useCallback`, объекты в `useMemo` или используйте другие способы избежать бесконечных обновлений.

5. **В случае с глобальным состоянием**  
   - Избегайте «двустороннего» (кольцевого) обновления, когда локальное состояние в компоненте влечёт обновление глобального состояния, а обновление глобального состояния влечёт ещё одно изменение локального состояния без проверки.  
   - Используйте логику, которая меняет глобальный стейт *только* если действительно есть новые данные.

---

## 5. Итоговая идея

«Постоянное изменение состояния или пропсов» — это ситуация, когда **при каждом** проходе рендера мы порождаем новое изменение, которое гарантированно вызовет ещё один рендер.  

Визуально (и функционально) это проявляется так, что компонент «мигает», «перезагружается», или возникает «бесконечная петля», где библиотека (например, Stripe) каждый раз заново инициализируется.  

Чтобы этого не происходило, необходимо:

- *Явно* контролировать, когда и зачем мы вызываем `setState` или изменяем пропсы.  
- Убедиться, что мы не вызываем обновление состояния **на каждом** рендере безусловно.  
- Использовать правильную мемоизацию (там, где нужны однотипные/однократные объекты или функции).  
- Проверять логику взаимодействия между родительскими и дочерними компонентами (или глобальным стейтом), чтобы не возникало бесконечной рекурсии изменений.
~~~

## 5. «Пересоздание Stripe-элемента на каждом рендере»
### 5.1.
Я тебя спросил:
~~~
В пункте 3 своего ответа пункта 2.2.1 ты писал:
```
Пересоздание Stripe-элемента на каждом рендере
```
Опиши подробнее, каким образом «Пересоздание Stripe-элемента на каждом рендере» может приводить к проблеме клиента.
~~~

### 5.2.
Ты ответил:
~~~
Ниже приведено детальное пояснение, почему именно повторная (пере)создача Stripe-элементов (Stripe Elements, Payment Request Button и пр.) при **каждом** рендере React-компонента способна вызывать «бесконечную перезагрузку» или постоянный цикл обновлений.

---

## 1. Как обычно инициализируют Stripe-элементы
- В большинстве официальных и неофициальных руководств по работе со Stripe Elements (особенно через `react-stripe-js`) указывается, что объект `Elements` и отдельные элементы (например, `CardElement`) нужно инициализировать один раз, либо при смене конкретных условий (например, при получении нового ключа Stripe, при смене пользователя, и т.п.).
- Как только элемент проинициализирован и «привязан» к DOM-узлу (чаще всего к контейнеру в React-компоненте), он **не** должен пересоздаваться на каждом последующем рендере. Иначе библиотека Stripe снова монтирует элемент, сбрасывает его внутреннее состояние, обнуляет введённые данные и т.д.

Если же код, отвечающий за создание элемента (например, `const cardElement = elements.create('card', { ... })`) вызывается **каждый** раз при рендере компонента без мемоизации или без ограничения условий — мы фактически получаем:

1. **Постоянную переинициализацию** Stripe-формы.  
2. **Перерисовку** компонента (так как возникает обновление состояния или пересоздание DOM-структуры для Stripe).  
3. **Сбой в работе** формы или «мигание» интерфейса, а в ряде случаев — бесконечный цикл изменений.

---

## 2. Почему пересоздание элемента порождает бесконечные рендеры

1. **Инициализация Stripe-элемента часто связана с обновлением состояния**  
   - После создания элемента, в коде React-разработчики могут вызывать `setState`, чтобы сохранить ссылку на объект Stripe (или на элемент) в локальном состоянии (или передать его дальше через контекст/props).  
   - Если этот `setState` вызывается при **каждом** рендере (без проверки, создавали ли мы элемент ранее), в итоге мы имеем:  
     - «Создали новый элемент» → `setState` → рендер → «Снова создаём новый элемент» → `setState`… и так бесконечно.

2. **Реинициализация элемента сбрасывает его и вызывает «обновление родителя»**  
   - Stripe-элемент может вызывать колбэки (например, события `onChange`, `onReady`, `onFocus` и т.д.), которые в свою очередь меняют состояние React-приложения. Если элемент «каждый раз новый», эти события снова и снова срабатывают, каждый раз уведомляя React о каком-то новом состоянии.  
   - Возникает «кольцевая» реакция: новый элемент → событие → обновление состояния → рендер → снова новый элемент…

3. **Данные внутри формы стираются и инициализация начинается заново**  
   - С точки зрения Stripe, при каждом новом рендере компонент может «размонтироваться» и тут же смонтироваться заново. Это выглядит, как если бы пользовательскую форму удалили и снова вставили в DOM.  
   - Библиотека Stripe может трактовать это как ошибку, и в попытке перезапустить или почистить ресурсы триггерит новые колбэки, что опять ведёт к ререндеру.

---

## 3. Пример кода, где элемент пересоздаётся на каждом рендере

Условный (упрощённый) пример:

```jsx
function PaymentForm() {
  const [cardElement, setCardElement] = useState(null);

  // Имитируем получение объекта elements
  const stripe = window.Stripe('...'); 
  const elements = stripe.elements();

  // На каждом рендере заново создаём CardElement
  const newCardElement = elements.create('card', { style: { base: { fontSize: '16px' } } });

  // Далее сохраняем его в state
  setCardElement(newCardElement);

  return (
    <div>
      <div id="card-element-container"></div>
      {/* Теоретически мы могли бы cardElement монтировать куда-то */}
    </div>
  );
}
```

В чём проблема:
1. При **первом** рендере `newCardElement` создаётся, вызывается `setCardElement`, что меняет состояние и вызывает **новый** рендер.
2. На **втором** рендере снова создаётся новый элемент (ведь строка `elements.create('card', …)` вызывается каждый раз). React видит, что `cardElement` — это другое значение, снова вызывает `setCardElement` и т.д.  
3. В итоге компонент рендерится бесконечно, одновременно «дёргая» Stripe, пытаясь пересоздать элемент.

---

## 4. Как правильно инициализировать элемент Stripe один (или ограниченное) количество раз

1. **Использовать `useEffect` с пустым массивом зависимостей**  
   - Если нужно создать элемент **однократно** при монтировании, поместите вызов `elements.create(...)` в `useEffect(() => { ... }, [])`.  
   - Сохраните результат в `useState` или в `useRef`, но *не* вызывайте `setState` на каждом рендере.

2. **Мемоизировать объекты инициализации**  
   - Если инициализация зависит от каких-то пропсов, используйте `useMemo` или проверяйте эти пропсы, чтобы не вызывать `create` при каждой их незначительной смене.

3. **Рассмотреть использование готовых компонентов из `react-stripe-js`**  
   - В `react-stripe-js` обычно уже решены многие вопросы по инициализации: вы оборачиваете всё в `<Elements>` и используете готовые `<CardElement>` и т.д. Это сводит к минимуму риск неправильной переинициализации.

4. **Явно проверять, не создан ли элемент ранее**  
   - Если у вас не классический подход с `react-stripe-js`, а своя обёртка, то перед созданием нового элемента стоит проверять, существует ли он уже:  
     ```jsx
     if (!cardElement) {
       const newElement = elements.create('card', { /* ... */ });
       setCardElement(newElement);
     }
     ```

---

## 5. Итоговая мысль

«Пересоздание Stripe-элемента на каждом рендере» — это классический путь к бесконечным перерисовкам и визуальной «перезагрузке формы», потому что:
1. Каждая новая инициализация Stripe-элемента расценивается как изменение (состояния/DOM/логики).  
2. Изменение состояния или DOM влечёт новый рендер.  
3. Новый рендер заново инициализирует элемент… и так до бесконечности.

Чтобы это предотвратить:
- Создавайте элемент **один раз** или только при **реальной** необходимости (смена ключей, смена типа формы и т.п.).
- Используйте эффекты и мемоизацию корректно. 
- Избегайте безусловного вызова `setState` внутри рендера/хуков, если это приводит к повторной инициализации.
~~~

## 6. «Конфликт между серверным и клиентским рендером (Next.js)»
### 6.1.
Я тебя спросил:
~~~
В пункте 5 своего ответа пункта 2.2.1 ты писал:
```
5. **Конфликт между серверным и клиентским рендером (Next.js)**  
   - При использовании Next.js нужно уделять особое внимание тому, как Stripe интегрируется на стороне клиента. Если код Stripe вызывается до того, как компонент окончательно "гидратирован" (hydrated) на клиенте, может возникать рассинхронизация и, как следствие, зацикливание.
```
Опиши подробнее, каким образом «Конфликт между серверным и клиентским рендером (Next.js)» может приводить к проблеме клиента.
~~~

### 6.2.
Ты ответил:
~~~
Ниже приведён более детальный разбор, почему при использовании **Next.js** (или любого другого фреймворка, в котором есть **Server-Side Rendering** и «гидратация» на клиенте) может возникнуть конфликт, приводящий к бесконечному циклу рендеринга — в частности, если в вашем коде неверно учтён порядок/режим исполнения инициализации **Stripe**.

---

## 1. Как работает рендеринг в Next.js

1. **Server-Side Rendering (SSR)**  
   - Когда пользователь запрашивает страницу, Next.js может сгенерировать (отрендерить) ваш React-компонент **на сервере** и выдать готовую HTML-разметку в ответ на запрос.  
   - Это означает, что уже на этапе сервера выполняется код, который строит дерево компонентов и формирует HTML.

2. **Hydration (гидратация) на клиенте**  
   - После того, как браузер получает HTML, запускается «гидратация»: React на клиенте «привязывается» к уже существующей разметке.  
   - При этом React пытается «сопоставить» то, что было сгенерировано на сервере, со своим виртуальным DOM-контекстом на клиенте.  
   - Если расхождений нет, всё проходит гладко, и React считает компонент готовым к дальнейшим рендерам.  
   - Если возникают несоответствия, React может попытаться перерендерить компонент, подкорректировать DOM или выдать предупреждения/ошибки.

3. **Client-Side Rendering (CSR) и дальнейшие обновления**  
   - После гидратации React-приложение в браузере работает в обычном «клиентском» режиме, реагируя на события, хуки, изменения состояния и т.д.

---

## 2. Где может возникнуть конфликт со Stripe

### Ситуация 1. Доступ к `window` или `document` во время SSR

- При серверном рендеринге среды **нет** объекта `window`/`document`, потому что код выполняется в Node.js.  
- Если вы используете Stripe (через `window.Stripe` или через `document.createElement`, и т.д.) прямо в коде, который может выполниться на сервере, возникнет ошибка «window is not defined» (либо «document is not defined»).  
- В некоторых случаях разработчики пытаются обойти это, завернув логику в условие, которое проверяет, находится ли код на клиенте. Но если сделано это неправильно, то уже при «гидратации» может возникнуть несоответствие данных, влекущее дополнительные рендеры.

### Ситуация 2. Различие состояния/props между сервером и клиентом

- Допустим, при серверном рендере компонент получает одни данные (например, пустой ключ Stripe или отсутствие доступа к локальному хранилищу), а при клиентском рендере эти данные меняются (клиент загружает реальные ключи или конфигурацию).  
- Это означает, что HTML и состояние, сгенерированные на сервере, **не совпадают** с тем, что React ожидает на клиенте.  
- React, обнаружив несоответствие, пытается перестроить компонент (вплоть до полного размонтирования и повторного монтирования). Если в ходе этого процесса заново инициализируется Stripe, он может инициировать события, которые снова меняют состояние. Возникает «зацикливание» в сценарии:  
  - *«Гидратация → расхождение → перерендер → заново монтируем Stripe → что-то меняется → ещё рендер → снова расхождение…»*.

### Ситуация 3. Условный рендеринг Stripe-компонентов

- Часто в Next.js проектах делают условный рендеринг, вроде: «Показывать компонент Stripe только на клиенте». Например:
  ```jsx
  function MyPage() {
    const [isClient, setIsClient] = useState(false);
    
    useEffect(() => {
      setIsClient(true);
    }, []);

    return (
      <div>
        {isClient ? <StripeForm /> : null}
      </div>
    );
  }
  ```
- При SSR `isClient` = `false`, поэтому на сервере мы не рендерим `StripeForm`.  
- На клиенте, при первом эффекте, `isClient` меняется на `true`, компонент перестраивается и теперь рендерит `StripeForm`.  
- Если внутри `StripeForm` дополнительная логика тоже зависима от состояния, которое при каждом рендере слегка меняется, можно получить cascade из нескольких перерисовок:  
  1. Сервер рендерит без `StripeForm`.  
  2. Клиент «гидратирует» компонент, видит отсутствие `StripeForm`.  
  3. `useEffect` включает `StripeForm`.  
  4. `StripeForm` монтируется, инициализирует Stripe.  
  5. Stripe генерирует событие/вызывает `setState`.  
  6. Снова рендер… и при неправильной настройке зависимостей (или бесконечном создании объекта) это уходит в цикл.

### Ситуация 4. SSR ключи или токены отличаются от клиентских

- Допустим, на сервере вы не имеете реального доступа к API-ключу Stripe (или используете публичный тестовый ключ), а на клиенте подгружаете другой (боевой) ключ.  
- Если код, который сравнивает/устанавливает ключ, запускается при каждом изменении ключа, то после гидратации видим: *«О, теперь ключ другой, пересоздадим Stripe!»* → *«Снова проинициализируем, снова рендер…»*  
- В сочетании с неправильными проверками в `useEffect` это приводит к постоянному пересозданию элемента, который снова и снова срабатывает при каждом рендере.

---

## 3. Как это приводит к бесконечным рендерам

1. **Расхождение HTML** (сервер vs. клиент) → React «гидратирует» → видит mismatch → принудительно перерисовывает компонент.  
2. **В процессе перерисовки** вызывается инициализация или обновление Stripe, что меняет состояние (или вызывает другие эффекты).  
3. **Состояние снова меняется** → новый рендер, который, если не скорректирован логикой, приводит к повторной инициализации…  
4. Получается «петля» (*«мismatch → перерендер → инициализация → новый mismatch → снова перерендер…»*).

---

## 4. Как избежать конфликтов SSR и Stripe

1. **Изолировать инициализацию Stripe на клиенте**  
   - Обычно рекомендуют проверять `typeof window !== 'undefined'` или использовать специальный хук `useEffect` (который не запускается на сервере):  
     ```jsx
     useEffect(() => {
       // Код инициализации Stripe, т.к. здесь уже есть window, document
     }, []);
     ```
   - Либо использовать встроенные механизмы, например `dynamic` импорт с опцией `{ ssr: false }` в Next.js, чтобы компонент Stripe не рендерился на сервере.

2. **Следить за тем, чтобы объект конфигурации/ключ Stripe не «скакал»** между сервером и клиентом  
   - Если на сервере `stripeApiKey` = `""` (или другое значение), а на клиенте — реальный ключ, оберните логику в условие, которое не перезапускает инициализацию при каждом обновлении.  
   - Например, делайте инициализацию `Stripe` только когда `stripeApiKey` действительно установлен и **не** меняется между рендерами.

3. **Использовать готовые решения** (например, `react-stripe-js` + `<Elements>`)  
   - В связке с Next.js нередко рекомендуют рендерить `<Elements>` только на клиенте (через `dynamic`), чтобы избежать SSR-конфликтов.  
   - Это упрощает логику: SSR отдаёт «заглушку» или базовую вёрстку, а на клиенте происходит полноценная инициализация.

4. **Убедиться, что при гидратации не происходит «волн» неконтролируемых обновлений**  
   - Иногда могут быть дополнительные факторы (запросы к API, валидация, контекст и пр.), которые на старте запускают несколько `setState`.  
   - Нужно либо объединять эти обновления, либо использовать соответствующие проверки (например, не вызывайте повторный `setState`, если значение уже установлено).

---

## 5. Итоговая мысль

При использовании Next.js (SSR + гидратация):
- **Различия** в состоянии/props между серверным HTML и клиентским рендером вызывают повторные рендеры.  
- **Stripe** (или другие внешние библиотеки, требующие доступ к `window/document`) **нельзя** корректно инициализировать на сервере, поэтому нужно либо отключать SSR для соответствующих компонентов, либо делать защитные проверки на клиенте.  
- Если логика инициализации Stripe «цепляется» за каждый новый рендер и повторно создаёт форму, возникает бесконечная петля.

Именно это имеют в виду, когда говорят о **«конфликте между серверным и клиентским рендером (Next.js)»**: небольшая ошибка в порядке инициализации или несогласованность состояния между сервером и клиентом может привести к постоянному «дёрганию» компонента и внешней библиотеки (Stripe), в результате чего вы получаете бесконечный цикл перезагрузки формы.
~~~

## 7. «Неправильно настроенный обработчик событий»
### 7.1.
Я тебя спросил:
~~~
В пункте 6 своего ответа пункта 2.2.1 ты писал:
```
6. **Неправильно настроенный обработчик событий**  
   - Если код, отвечающий за обработку события (например, на изменение полей формы Stripe), напрямую влияет на состояние, которое опять же вызывает повторный рендер, может возникнуть бесконечный цикл обновлений.
```
Опиши подробнее, каким образом «Неправильно настроенный обработчик событий» может приводить к проблеме клиента.
~~~

### 7.2.
Ты ответил:
~~~
Ниже приведён более детальный разбор того, как «неправильно настроенный обработчик событий» (event handler) может привести к проблеме бесконечных перерисовок (re-render loop) в React-приложении, особенно при работе со **Stripe** и её формами.

---

## 1. Как обрабатываются события в React

1. **Событие в элементе (onChange, onClick, onSubmit и т.д.)**  
   При срабатывании события React вызывает соответствующую функцию-обработчик (event handler).  

2. **Обработчик события** может выполнять различный код, в том числе:
   - Менять состояние через `setState` (в классовом компоненте) или `useState` (в функциональном).
   - Вызывать колбэки, которые могут влиять на родительский/глобальный стейт.
   - Выполнять логику, которая приводит к ререндеру.

3. **Каждый вызов `setState` или изменение пропсов** порождает новый цикл рендера.  
   Если логика внутри обработчика события **каждый раз** вызывает какое-то действие, которое влечёт немедленный повторный вызов того же события (или непрерывное изменение состояния), то получаем «бесконечный цикл»: *обработчик события → изменение состояния → рендер → снова событие → снова изменение состояния…*

---

## 2. Типичный сценарий «неправильного» обработчика

### 2.1. Пример с `onChange` и бесконечным циклом

Представьте, что вы интегрируете **Stripe** и отслеживаете события изменения полей (например, `CardElement` из `react-stripe-js` или собственную интеграцию через `stripe.js`). У вас может быть:

```jsx
function StripeForm() {
  const [cardNumber, setCardNumber] = useState("");
  
  const handleCardChange = (event) => {
    // Например, здесь вы записываете в state текущее значение поля
    setCardNumber(event.complete ? event.value : "");
    
    // ...и тут же вызываете дополнительную логику, которая, в свою очередь, 
    // снова влияет на рендер или вызывает пересоздание формы
  };

  return (
    <CardElement
      onChange={handleCardChange}
      /* ...другие настройки... */
    />
  );
}
```

Само по себе это нормально, если:
- Вы вызываете `setState` **только** когда значение действительно новое (или меняется условно).  
- Или если `event` действительно предоставляет новое состояние (например, поле заполнилось полностью).

Однако проблема возникает, если внутри `handleCardChange` есть **дополнительная** логика, которая каждый раз порождает новое состояние (или вызывает side-effect), не проверяя, изменилось ли что-то реально. Например:

```jsx
const handleCardChange = (event) => {
  // "Каждый раз" при любом изменении полей вызываем обновление стейта
  setCardNumber(Date.now().toString()); 
  // ДАЖЕ когда ввод не меняется (или поле пустое)
};
```

В таком случае:
- Каждый чих в событии (каждый ввод символа, каждое размонтирование/перемонтирование, каждое изменение фокуса) меняет состояние на новое, ведь `Date.now()` всегда выдаёт разное число.  
- React видит, что состояние поменялось → рендер.  
- Переотрисовка снова может спровоцировать дополнительные события (например, если при обновлении компонента Stripe пересоздаёт что-то и снова вызывает `onChange`).  
- В итоге можно попасть в непрекращающийся цикл рендера → события → рендера → события…

### 2.2. Пример с «обработчиком, вызывающим пересоздание Stripe-элемента»

Допустим, ваш обработчик события (например, `onReady` или `onChange` элемента Stripe) напрямую вызывает функцию, которая пересоздаёт объект Stripe или его элемент:

```jsx
const handleCardReady = () => {
  // Прямо из обработчика "готовности" элемента
  // мы снова инициализируем этот же элемент или заново создаём объект Stripe:
  initializeStripe(); 
};
```

- Если `initializeStripe()` внутри себя делает `setState` или ещё что-то, вызывающее полный рендер родительского компонента, то React снова будет рендерить компонент.  
- При новом рендере элемент может замонтироваться заново, что вновь вызовет `onReady`.  
- Обработчик `onReady` опять вызовет `initializeStripe()`.  
- Ситуация повторяется бесконечно.

---

## 3. Как это выглядит с точки зрения Stripe

Stripe-элементы посылают события в разных ситуациях:
- Когда пользователь печатает в поле.
- Когда поле получает/теряет фокус.
- Когда форма загружается или готова к вводу.
- Когда происходит ошибка валидации.

Если при **каждом** таком событии вы меняете состояние **безусловно** (или запускаете какую-то «тяжёлую» логику с пересозданием компонентов), у вас может произойти бесконечная «петля». А пользователь увидит, как форма «дёргается» (мелькает, перезагружается) или даже не сможет ввести данные.

---

## 4. Основные причины, почему это приводит к «бесконечной перезагрузке»

1. **Отсутствие проверки на актуальное значение**  
   Обработчик события вызывается **каждый** раз, но вы не проверяете, действительно ли значение поменялось. В итоге `setState` с одинаковым или «всегда новым» значением срабатывает при любом событии → новый рендер → снова событие.

2. **В обработчике вызывается пересоздание/повторная инициализация**  
   Если при **каждом** событии вы заново монтируете или инициализируете форму, компонент бесконечно перерисовывается (см. «пересоздание Stripe-элемента» выше).

3. **Событие триггерит изменение глобального состояния**  
   Если при каждом вводе/событии обрабатывается `dispatch` в Redux/MobX/Context, который в ответ обновляет пропсы родителя, а родитель снова рендерит ребёнка, можно получить кольцевую цепочку рендеров.

4. **Вызов редиректа или другого побочного эффекта**  
   В некоторых случаях обработчик события может вызывать, например, `window.location.reload()` или `router.push()`. Если логика выстроена так, что на новой странице/роуте снова происходит та же инициализация и возврат обратно, можно «зациклить» приложение.

---

## 5. Как правильно настроить обработчики событий

1. **Обновлять состояние **только** при реальном изменении**  
   - Применяйте условные проверки. Например, не вызывайте `setState` без надобности.  
   - Убедитесь, что новое значение действительно **отличается** от старого.  
   - Если вы используете данные из события (например, `event.complete`, `event.error`), проверяйте, не повторяются ли значения.

2. **Не пересоздавать Stripe-элементы в обработчиках**  
   - Логику инициализации Stripe надо делать либо один раз при маунте (в `useEffect` с пустым массивом зависимостей), либо только когда **действительно** меняются критические условия (например, новый ключ API).  
   - Не ставьте `initializeStripe()` внутрь `onChange`, `onReady` и т.д., если не требуется реальная перезагрузка формы.

3. **Мемоизируйте/запоминайте колбэки**  
   - Если вы передаёте обработчик события как проп в дочерний компонент (Stripe-элемент) и он пересоздаётся на каждом рендере, может возникнуть ситуация, при которой дочерний компонент будет считать, что «обработчик обновился» и повторно вызывает логику.  
   - Используйте `useCallback`, чтобы обработчик не считался «новым» на каждом шаге, когда это возможно.

4. **Отлаживайте логику с помощью console.log**  
   - Часто, чтобы понять, что всё зациклилось, достаточно вывести в консоль: «handleCardChange triggered» и «new state = …» — и вы увидите, что вызовы идут бесконечным потоком.

5. **Не смешивайте разные источники истины**  
   - Если часть данных хранится в локальном состоянии компонента, а часть — в глобальном (Redux/Context), убедитесь, что нет постоянного «пинга» между ними (например, локальная форма говорит глобальному стейту «обновись», а глобальный стейт в ответ снова меняет пропсы формы).  

---

## 6. Итоговая идея

«Неправильно настроенный обработчик событий» — это ситуация, при которой **каждый** вызов события (даже если он не несёт новых данных) приводит к изменению состояния или запуску побочной логики, которая, в свою очередь, вызывает повторный рендер, заново генерируя то же событие.  

При работе со **Stripe**, где события сыплются часто (при каждом изменении поля, при фокусе/блюре, при инициализации), ошибка легко приводит к тому, что форма непрерывно перезагружается или приложение впадает в бесконечный цикл рендеров.  

Чтобы избежать этого:

- **Используйте условные проверки** в обработчике (сохраняйте новое состояние **только** если оно отличается от старого).  
- **Не пересоздавайте Stripe-элемент** или «обёртку» для него при каждом событии.  
- **Локализуйте логику** и смотрите в консоли, как часто срабатывают обработчики и почему они вызывают новые рендеры.
~~~

## 8. «Неправильное использование контекста или глобального состояния»
### 8.1.
Я тебя спросил:
~~~
В пункте 4 своего ответа пункта 2.2.1 ты писал:
```
4. **Неправильное использование контекста или глобального состояния**  
   - Если Stripe-форму обёртывают в контекст, который изменяется на каждом шаге (например, контекст пересоздаётся при каждом рендере родительского компонента), это тоже может вызывать повторный рендер и перезагрузку.
```
Опиши подробнее, каким образом «Неправильное использование контекста или глобального состояния» может приводить к проблеме клиента.
~~~

### 8.2.
Ты ответил:
~~~
Ниже приведён детальный разбор того, каким образом ошибки в использовании глобального состояния (Redux, MobX и пр.) или контекста (React Context API) могут вызвать бесконечные рендеры и «перезагрузку» компонентов, в частности при интеграции со Stripe.

---

## 1. Механизм обновления контекста и глобального состояния

1. **React Context**  
   - При использовании `React.createContext` и соответствующего провайдера `<MyContext.Provider>`, **любое** изменение значения `value` в провайдере приводит к повторному ререндеру **всех** потребителей (consumers), т.е. всех компонентов, использующих `useContext(MyContext)` или `<MyContext.Consumer>`.  
   - Если значение контекста на каждом рендере «с нуля» пересоздаётся (новый объект, новая функция), все эти компоненты будут перерисовываться снова и снова.

2. **Redux, MobX, Zustand или любая другая глобальная «store»-логика**  
   - При изменении данных в глобальном состоянии вызывается перерисовка компонентов, которые подписаны на эти данные.  
   - Если у вас есть цикл, где компонент, получая новые данные из store, тут же диспатчит очередное изменение в store, и это изменение снова затрагивает тот же компонент, можно легко заполучить «бесконечную рекурсию» изменения state → ререндер → снова изменения state и т.д.

Когда в коде есть интеграция Stripe, которая, например, завязана на контекст или глобальный стейт (к примеру, хранит в store информацию о том, «готов ли Stripe» или «есть ли sessionId»), такие циклы могут приводить к постоянному пересозданию или «миганию» формы Stripe.

---

## 2. Типичные примеры неправильного использования контекста/глобального состояния

1. **Контекст пересоздаётся на каждом рендере родительского компонента**  
   ```jsx
   const MyContext = React.createContext();

   function Parent() {
     const [count, setCount] = useState(0);

     const contextValue = {
       count: count,
       setCount: setCount,
       // или любой другой объект, который пересоздаётся каждый раз
     };

     return (
       <MyContext.Provider value={contextValue}>
         <Child />
       </MyContext.Provider>
     );
   }
   ```
   - Здесь на **каждом** рендере `Parent` создаётся новый объект `contextValue`.  
   - В результате `Child` и все компоненты ниже по дереву, использующие `MyContext`, будут постоянно получать «новое» значение, даже если `count` не менялся.  
   - Они будут заново ререндериться. Если у `Child` есть логика, меняющая state (например, вызывать `setCount` или что-то, что в свою очередь вызывает новый рендер `Parent`), можно получить бесконечный цикл.

2. **Глобальное состояние изменяется при каждом рендере**  
   ```jsx
   function PaymentForm() {
     const stripeStatus = useSelector(state => state.stripeStatus);
     const dispatch = useDispatch();

     // Ошибка: при каждом рендере мы диспатчим экшен безусловно
     dispatch({ type: 'UPDATE_STRIPE_STATUS', payload: 'ready' });

     return <div>Stripe status: {stripeStatus}</div>;
   }
   ```
   - Каждый рендер диспатчит `UPDATE_STRIPE_STATUS` → это меняет глобальное состояние (даже если устанавливается то же самое значение).  
   - Любое изменение store вызывает новый ререндер `PaymentForm`, и так по кругу бесконечно.  

3. **Взаимная «передача» через контекст**  
   - Родительский компонент читает из контекста некие данные о Stripe, а дочерний компонент (или хук) пишет в этот же контекст (изменяя его), что приводит к обновлению родителя. Родитель, обновившись, опять меняет данные в контексте… и так по цепочке.  
   - Это может выглядеть примерно так:  
     - Родитель берёт `isStripeReady` из контекста, видит, что `false`, и решает инициализировать Stripe.  
     - После инициализации записывает в контекст `isStripeReady = true`.  
     - Дочерний компонент, заметив, что теперь `isStripeReady = true`, вызывает свой эффект, который снова (по ошибке) ставит `isStripeReady = false`.  
     - Родитель снова видит изменения в контексте… и цикл повторяется бесконечно.

4. **Массовые перерисовки из-за контекста, в котором лежит много несвязанных данных**  
   - Если в одном контексте содержится и «статус Stripe», и «текущий пользователь», и какие-то «настройки интерфейса», то при любом изменении чего-либо в контексте **всё** дерево будет ререндериться.  
   - А если логика Stripe при этом повторно запускается на каждом рендере (например, пересоздаёт форму), то получаем «зацикливание».  
   - Хорошая практика — разбивать контекст на несколько: один для Stripe, один для пользовательских данных и т.д.

---

## 3. Как именно это приводит к «бесконечной перезагрузке» Stripe-формы

В контексте Stripe:

1. **Пересоздаётся контекстное значение** —> все компоненты, включая тот, что отвечает за рендер формы, рендерятся заново.  
2. **Компонент, отвечающий за Stripe, в процессе нового рендера может заново проинициализировать форму** или вызвать обновление стейта (например, «установить флаг готовности»).  
3. **Обновлённые данные** снова записываются в тот же контекст или глобальный стейт.  
4. **Контекст/стейт меняется** —> ререндер опять.  
5. Новый ререндер снова пересоздаёт Stripe-элемент (или вызывает колбэки).  
6. Цикл продолжается бесконечно, если нет дополнительных проверок/условий.

С точки зрения пользователя, это может выглядеть как «мигание» формы, постоянный спиннер «loading…», или даже полная недоступность функционала (пока процесс не будет прерван).

---

## 4. Как избежать проблем с контекстом или глобальным состоянием

1. **Мемоизировать контекстное значение**  
   - Если объект контекста каждый раз формируется заново, можно использовать `useMemo`, чтобы он не «пересоздавался» на каждом рендере, когда это не нужно:
     ```jsx
     const contextValue = useMemo(() => ({ count, setCount }), [count]);
     ```
   - Таким образом, если `count` не меняется, `contextValue` остаётся той же ссылкой, и дочерние компоненты не будут бесконечно ререндериться.

2. **Избегать безусловных диспатчей в глобальный стейт**  
   - Проверяйте, действительно ли нужно вызывать `dispatch` при каждом рендере. Если нет, сделайте это внутри `useEffect` с определёнными зависимостями или добавьте проверку, изменилось ли значение.  
   - Например:
     ```jsx
     useEffect(() => {
       if (stripeStatus !== 'ready') {
         dispatch({ type: 'SET_STRIPE_STATUS', payload: 'ready' });
       }
     }, [stripeStatus, dispatch]);
     ```
   - Так вы не будете «гонять» одно и то же действие.

3. **Локализуйте данные**  
   - Храните в контексте или глобальном стейте только действительно «глобальные» вещи. Если что-то относится только к одному компоненту (например, текущий шаг валидации формы), пусть это будет локальный state.  
   - Если нужно передавать глобально только итоговое состояние «форма заполнена / не заполнена», заведите отдельный флаг. Не тащите в контекст весь объект Stripe, если он не нужен всему приложению.

4. **Используйте специализированные хуки для Stripe**  
   - `react-stripe-js` предоставляет свои механизмы `<Elements>` и `useStripe`, `useElements`. В них уже учтена правильная организация контекста (StripeContext), и нет риска, что он будет пересоздаваться без причины.  
   - Это упрощает логику и снижает вероятность «зацикливания» при инициализации.

5. **Следите за тем, чтобы изменения контекста/глобального стейта не вызывали «обратного» изменения, если это не требуется**  
   - Если у вас есть эффект, который реагирует на обновление контекста и снова пытается изменить контекст, убедитесь, что такие обновления не запускаются бесконечно (используйте проверки «если что-то не совпадает»).

---

## 5. Итоговая идея

Ошибки при работе с контекстом или глобальным состоянием приводят к тому, что **любой** рендер, который порождает новое контекстное значение (или новое значение в store), снова вызывает рендер потребителей, и если один из этих потребителей обратно меняет контекст — происходит бесконечный цикл.

В случае со Stripe, это оборачивается тем, что при **каждом** рендере форма переинициализируется или обновляет своё состояние, а любое обновление формы (например, событие `onChange`) может снова менять глобальный стейт. Получается «пинг-понг»:

- Контекст/глобальное состояние → рендер → пересоздание Stripe → событие Stripe → обновление контекста/глобального состояния → новый рендер → …

Чтобы избежать этого, нужно:

1. **Минимизировать количество перерисовок** (мемоизировать контекстное значение, правильно использовать зависимости эффектов).  
2. **Чётко разграничивать, где локальное состояние, а где глобальное**, и не обновлять состояние/контекст без надобности.  
3. **Убедиться, что логика инициализации/изменения Stripe не вызывается повторно** при каждом малейшем изменении контекста, а только тогда, когда это действительно нужно.
~~~

## 9. «Использование неподдерживаемых методов жизненного цикла или нестабильных решений»
### 9.1.
Я тебя спросил:
~~~
В пункте 7 своего ответа пункта 2.2.1 ты писал:
```
7. **Использование неподдерживаемых методов жизненного цикла или нестабильных решений**  
   - Если проект переходит с классовых компонентов на хуки или наоборот, может возникать конфликт логики (например, повторные вызовы эффектов или устаревшие паттерны, препятствующие корректной работе хуков).
```
Опиши подробнее, каким образом «Использование неподдерживаемых методов жизненного цикла или нестабильных решений» может приводить к проблеме клиента.
~~~

### 9.2.
Ты ответил:
~~~
Ниже приведено более развёрнутое объяснение того, почему «использование неподдерживаемых методов жизненного цикла или нестабильных решений» может приводить к ошибкам типа «бесконечного рендера» (re-render loop) и, как следствие, к непрерывной перезагрузке (в частности, Stripe-формы).

---

## 1. Что значит «неподдерживаемые методы жизненного цикла» и «нестабильные решения»

1. **Неподдерживаемые методы жизненного цикла** — это устаревшие (deprecated) методы в классовых компонентах, которые React может уже не рекомендовать использовать (например, `componentWillMount`, `componentWillReceiveProps`, `componentWillUpdate`). В новых версиях React эти методы заменили на `componentDidMount`, `componentDidUpdate`, `componentDidCatch`, а также на более гибкий API хуков в функциональных компонентах.  
2. **Нестабильные решения** — паттерны кода, которые работают в обход стандартного жизненного цикла, либо используют неофициальные/приватные API React, либо искажают предназначение хуков (например, вызывают хуки в условиях или циклах, нарушая правила React).

Когда проект «мигрирует» с классовых компонентов на функциональные или поддерживает параллельно обе парадигмы, может возникнуть конфликт логик, особенно если часть кода опирается на старые методы или костыли, противоречащие рекомендациям React.

---

## 2. Как старые методы жизненного цикла могут вызывать бесконечный цикл обновлений

1. **`componentWillMount`**  
   - Этот метод раньше вызывался **до** первого рендера на клиенте. Однако при работе с серверным рендерингом (SSR), а также при переходе к хукам, он может срабатывать (или не срабатывать) в моменты, которые разработчику неочевидны.  
   - Если в `componentWillMount` вносится изменение состояния (например, `this.setState(...)`), React может инициировать рендер раньше времени или повторно, что в связке с другой логикой приводит к «кольцу» перерисовок.

2. **`componentWillReceiveProps`**  
   - Устаревший метод, который срабатывал при обновлении пропсов до рендера. Если в этом методе вызывался `this.setState`, а обновлённое состояние вновь влияло на пропсы (через родителя или контекст), получался «пинг-понг» рендера.  
   - В современных версиях React и при использовании хуков подобную логику рекомендуют переносить в `useEffect` (с корректными зависимостями) или использовать `getDerivedStateFromProps` (но и он требует аккуратного обращения).

3. **`componentWillUpdate`**  
   - Аналогично: если в этом методе меняется состояние или идёт обращение к пропсам, можно спровоцировать дополнительные рендеры. При миграции на хуки разработчики ошибочно могут смешивать этот метод с `useEffect`, вызывая дублирующую логику.

4. **Взаимодействие с SSR и Hydration**  
   - Если при серверном рендеринге (Next.js, Gatsby и т.д.) используются методы, которые некорректно учитывают разницу между «сервером» и «клиентом», в момент «гидратации» (hydration) могут возникать несогласованные состояния.  
   - Старые методы жизненного цикла, не предназначенные для работы в SSR, могут вызывать дополнительные обновления на клиенте, когда React пытается «сопоставить» клиентский рендер с серверной разметкой.

---

## 3. «Нестабильные» паттерны при использовании хуков

1. **Вызов хуков внутри условий или циклов**  
   - Согласно документации React, хуки нельзя вызывать внутри условных операторов (`if`), циклов (`for`, `while`) или вложенных функций. Делать это нужно исключительно на верхнем уровне тела компонента. Иначе порядок вызовов хуков при каждом рендере может меняться, что приводит к непредсказуемым ошибкам — в том числе к бесконечным перерисовкам.

2. **Несоблюдение массива зависимостей**  
   - Когда разработчик вручную переносит логику из классов в хуки, он может неверно указать (или вовсе забыть) массив зависимостей в `useEffect`. В результате эффект, который по задумке должен выполняться при определённых изменениях, начинает вызываться на каждом рендере (см. предыдущие пункты про «неверную настройку зависимостей»).

3. **Смешивание хуков и классов без необходимости**  
   - Если часть компонента написана как класс, а часть логики выносят в хуки, может возникать дублирование. Например, `componentDidMount` класса и `useEffect(() => {}, [])` функционального компонента могут одновременно пытаться сделать одну и ту же инициализацию состояния или вызывать Stripe. Это приводит к двойным обновлениям и, при ошибочной логике, к бесконечному циклу.

---

## 4. Пример конфликтующей логики при переходе с классов на функциональные компоненты

Предположим, у нас был класс:

```jsx
class StripeFormClass extends React.Component {
  state = { loaded: false };

  componentWillMount() {
    if (!this.state.loaded) {
      // Инициализация Stripe
      this.setState({ loaded: true });
    }
  }

  render() {
    return <div>Stripe Form (Class)</div>;
  }
}
```

Теперь мы решили переписать логику на хуки, но при этом **оставили** этот класс в дереве компонентов и добавили функциональный компонент, который тоже инициализирует Stripe:

```jsx
function StripeFormHooks() {
  const [loaded, setLoaded] = useState(false);

  useEffect(() => {
    if (!loaded) {
      // Инициализация Stripe
      setLoaded(true);
    }
  }, [loaded]);

  return <div>Stripe Form (Hooks)</div>;
}

// Родитель, где подключены оба:
function Parent() {
  return (
    <>
      <StripeFormClass />
      <StripeFormHooks />
    </>
  );
}
```

- Проблема в том, что при маунте `StripeFormClass` вызывает `this.setState({ loaded: true })`, инициируя рендер. В это время `StripeFormHooks` делает то же самое, но каждый из них потенциально может влиять на общий глобальный стейт, контекст или пропсы друг друга.  
- Если между ними существует логика «когда один грузит Stripe, другой тоже меняет состояние» (например, через контекст), легко получить замкнутый круг: изменение стейта класса → изменение стейта хуков → снова класс → снова хуки…  
- Ситуация усугубляется, если используются ещё и устаревшие методы: `componentWillMount`, `componentWillUpdate` и т.д.

---

## 5. Как избежать проблем при миграции и использовании хуков

1. **Не смешивать старые и новые подходы «ради эксперимента»**  
   - Лучше чётко разделить: либо весь функционал в классовом компоненте (и учитывать, какие методы в нём устарели), либо полностью перейти на функциональные компоненты и хуки.  
   - Если приходится совмещать, надо внимательно контролировать, чтобы не было дублирующейся инициализации / дублирующихся вызовов состояния.

2. **Изучить актуальный жизненный цикл**  
   - Вместо `componentWillMount` и `componentWillReceiveProps` следует использовать `componentDidMount`, `componentDidUpdate` (или хуки-эквиваленты).  
   - Убедиться, что ни один из устаревших методов не вызывает безусловного `setState` на каждом проходе.

3. **Отказаться от приватных API**  
   - Не использовать внутренние поля типа `__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED`, не модифицировать напрямую объекты контекста. Подобные хаки могут работать непредсказуемо и вызывать неконтролируемые обновления.

4. **Правильно настроить хуки**  
   - Для логики, которая должна выполняться один раз на маунте, использовать `useEffect(..., [])`.  
   - Для логики, которая зависит от конкретных пропсов/значений, правильно формировать массив зависимостей.  
   - Не вызывать хуки внутри условных операторов или циклов, что может ломать порядок хуков и приводить к багам.

5. **Тестировать переход поэтапно**  
   - Если приложение большое, миграцию часто проводят постепенно: сначала переводят отдельные «изолированные» компоненты на хуки, тестируют, убеждаются в отсутствии бесконечных рендеров. Только потом двигаются дальше.

---

## 6. Итоговая мысль

«Использование неподдерживаемых методов жизненного цикла или нестабильных решений» часто становится причиной бесконечных циклов рендера, поскольку в старых методах легко допустить ошибку логики (например, безусловный `this.setState` в `componentWillMount`). При совмещении с хуками или при работе с SSR эффект может многократно усиливаться.

Чтобы избежать подобных проблем:

- **Избавляйтесь от устаревших методов**: переносите логику из `componentWillMount` или `componentWillReceiveProps` в современные аналоги (`componentDidMount`, `componentDidUpdate`, `getDerivedStateFromProps`) или в хуки (`useEffect`).  
- **Следуйте правилам хуков**: не вызывайте хуки в условных конструкциях, корректно указывайте зависимости.  
- **Не дублируйте инициализацию**: если вы уже вызываете инициализацию (например, Stripe) в одном месте, не нужно повторять её в другом, чтобы не образовывались замкнутые круги обновления.

Таким образом, использование неподдерживаемых (deprecated) методов и «нестабильных» паттернов легко может обернуться бесконечным рендером, если внутри них вызываются изменения состояния или пропсов на каждом проходе жизненного цикла.
~~~

## 10. Мой ответ клиенту
Я хочу ответить клиенту так:
~~~
2 most likely reasons:
1) Possibly, the program code that initializes Stripe is placed inside `useEffect`, which triggers on every render (for example, due to incorrect dependencies).
When an array of dependencies is specified in `useEffect`, React compares the values of these dependencies on each render of the component with their values on the previous render.
If at least one value in the array of dependencies has changed, `useEffect` runs again.
For example, in a component on each render a new object or function is created, which (without memoization) will always have a new value in memory.
React sees that the old dependency values and the «new dependency values» do not match (even if, logically, the contents of the objects or the function are the same).
It works as follows:
- render calls `useEffect`.
- `useEffect` sees that the dependency has changed and calls the effect.
- the effect changes the state (or, for example, reinitializes the Stripe form).
- this leads to a new render.
This results in an infinite loop.
2) If the component passes any Props or State to the nested (child) component that are computed again on each render (for example, a new function or a new object), this can lead to the child component being constantly recreated and, as a result, triggering a repeated render.
This leads to an infinite re-render loop.
After the element is created, in the React code developers can call `setState` to store the reference to the Stripe object (or the element) in local state (or pass it further through context or props).
If that `setState` is called on every render (without checking whether the element was already created earlier), as a result we have: «Created a new element» → `setState` → render → «Create a new element again» → `setState`… and so on infinitely.
~~~

## 11. Твоя задача
Проанализируй следующий фрагмент моего ответа клиенту (пункт 10) на наличие языковых ошибок/недостатков:
<фрагмент>
STUB
</фрагмент>

## 12. Требования к твоему ответу
### 12.1.
Анализируй только тот фрагмент текста, который указан в пункте 11.

### 12.2.
Используй полный текст моего ответа клиенту (пункт 10) для понимания контекста анализируемого фрагмента (пункт 11).

### 12.3.
Используй все предыдущие пункты моего запроса для понимания обсуждаемой в моём ответе клиенту (пункт 10) предметной области.

### 12.4. 
Анализ языковых ошибок (пункт 11) веди на русском языке.

### 12.5.
К уловым кавычкам `«»` не придирайся.

### 12.6.
Каждую языковую ошибку нумеруй.

### 12.7. Итоговый вариант
#### 12.7.1
После своего анализа каждой из языковых ошибок предложи итоговый вариант улучшения анализируемого фрагмента (пункт 11). 
#### 12.7.2
Назови этот раздел своего ответа «Итоговый вариант».
Сделай это заголовком 2-го уровня (используй `##`).
#### 12.7.3
Свой итоговый вариант помести внутрь backticks таким образом:
```
Текст итогового варианта
```
Мне это нужно, чтобы я мог одним кликом скопировать твой итоговый вариант.
#### 12.7.4
Не добавляй новую разметку Markdown к итоговому варианту.
Используй только ту разметку Markdown, которая имелась в исходном варианте.
#### 12.7.5
Форматируй итоговый вариант в точности как исходный фрагмент. 
В частности:
*) каждый абзац должен содержать ровно одно предложение
*) между абзацами не должно оставаться пустых строк.
*) кавычки используй те же, что и в оригинале: «» и ``.
### 12.7.6
Не используй в итоговом варианте сокращения типа «don't». 
Все подобные фразы пиши полностью: «do not».

### 12.8.
Не используй «you need» и другие подобные обращённые к клиенту фразы, перекладывающие действия на него.
Помни: я пишу клиенту или потенциальному клиенту.
Делать в любом случае буду я, а не клиент.
Вместо «you need» используй 2 альтернативы:
#### 12.8.1.
Нейтральные фразы типа «it is necessary».
#### 12.8.2.
Глаголы в неопределённой форме.
Например, во фрагменте ниже использованы подобные глаголы «set up», «create»:
```
1.2) Set up the transfer of login events from WordPress to Power BI using Fabric / OneLake.
1.2.1) Set up a «Data Pipeline» from the WordPress database table that stores login events (see point 1.1) to Fabric / OneLake.
1.2.2) Set up a connection from Power BI to Fabric / OneLake to pass login events.
1.3) Create the data model in Power BI.
```
Обрати внимание, в этом фрагменте не говорится, кто именно будет выполнять описанные действия: ответственность не перекладывается на клиента, в отличие от «you need».

### 12.9.
Никогда не переводи понятие «сайт» / «веб-сайт» как «site». 
Вместо этого используй форму «website»: это является более профессиональным.

### 12.10.
Никогда не переводи понятие «пункт нумерованного списка» как «item».
Всегда переводи это как «point».