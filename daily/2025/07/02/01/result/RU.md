PostgREST настраивается так:
1) Создать выделенную схему для API (например, `api`) и разместить там только те объекты, которые должны быть доступны извне.
В качестве таких объектов следует использовать `VIEW` и `FUNCTION`, а не сами таблицы.
Основные таблицы с данными при этом должны находиться в отдельной, приватной схеме (например, `private`), которая не указывается в конфигурации PostgREST и, следовательно, остается невидимой для HTTP-клиентов.
1.1) Ещё более сильным вариантом пункта 1 является использование версионирования для публичной схемы: первую версию можно назвать `api_1` вместо `api`, и когда выйдет новая версия API, то создать для неё новую публичную схему: `api_2`.
Такое более сильное решение позволит поддерживать сразу несколько версий API: современную (для новых) и устаревшую (для текущих клиентов, чтобы дать им время на миграцию).
2) Система аутентификации и авторизации PostgREST полностью основана на ролевой модели PostgreSQL. 
Для корректной работы необходимо создать как минимум 3 типа ролей:
2.1) `authenticator`:  используется для подключения PostgREST к базе данных
2.2) `anonymous`:  используется для обработки запросов от анонимных пользователей 
2.3) роли представляют аутентифицированных пользователей с различными уровнями доступа 
3) Авторизация в PostgREST управляется стандартными командами `GRANT` и `REVOKE` в PostgreSQL.
Необходимо точно определить, какие операции каждая роль может выполнять с объектами в схеме `api`.
4) Настройка `postgrest.conf`:
4.1) `db-uri`: нужно установить значение типа `postgres://authenticator:<password>@localhost:5432/<database_name>`
4.2) `db-schemas`: указывает список схем базы данных, разделенных запятыми, которые будут доступны через API (пункт 1 выше).
4.3) `db-anon-role`: имя роли базы данных, которая будет использоваться для обработки неаутентифицированных запросов (пункт 2.2 выше).
4.4) `jwt-secret`: секретный ключ, используемый для проверки криптографической подписи JSON Web Token (JWT).
4.5) `server-port`: TCP-порт, на котором PostgREST будет прослушивать HTTP-запросы. 
По умолчанию используется порт `3000`.
4.6) `admin-server-port`: порт для административного сервера, который предоставляет конечные точки для проверки состояния работоспособности (health check). 
5) PostgREST использует stateless механизм аутентификации. 
Каждый защищенный запрос должен содержать заголовок `Authorization: Bearer <token>`, где `<token>` — это валидный JSON Web Token.
6) PostgREST только проверяет токены, но не создает их. 
Для создания токенов можно использовать расширение `pgjwt`: это позволяет создать простую SQL-функцию login, которая принимает учетные данные, проверяет их по таблице пользователей и в случае успеха возвращает подписанный JWT.
7) Row-Level Security (RLS) позволяет реализовать гранулярный контроль доступа.
Сочетание утверждений в JWT и политик RLS создает чрезвычайно гибкую систему. 
PostgREST передает утверждения из токена в сеанс PostgreSQL, где они становятся доступны через функцию `current_setting('request.jwt.claims', true)`.
Это позволяет политикам RLS принимать решения на основе данных из токена, таких как `user_id` или `tenant_id`.
8) Запуск процесса PostgREST непосредственно из командной строки терминала непригоден для производственной среды, так как процесс не будет автоматически перезапущен в случае сбоя или после перезагрузки сервера. 
Для управления жизненным циклом приложения на современных дистрибутивах Linux используется система инициализации `systemd`. 
9) PostgREST не реализует HTTPS, делегируя эту функцию внешним компонентам.
В производственной среде передача данных, особенно учетных данных или конфиденциальной информации, по незащищенному протоколу HTTP недопустима. 
Поэтому надо настроить обратный прокси-сервер (например, Nginx) для терминирования SSL/TLS соединений.
10) Для включения HTTPS необходим сертификат. 
Его лучше всего настроить через Certbot и Let's Encrypt.
11) PostgREST автоматически создает стандартный RESTful-интерфейс для таблиц и представлений, указанных в схеме API. 
Для таблицы `table` будут доступны следующие основные конечные точки:
11.1) `GET /table`
11.2) `POST /table`
11.3) `PATCH /table?id=eq.<id>`
11.4) `DELETE /table?id=eq.<id>`
12) Для того чтобы выполнить `POST` (пункт 11.2 выше), клиент должен сначала получить JWT, а затем использовать его для аутентификации.
13) PostgREST возвращает сообщения о сбоях в формате JSON со следующими полями:
- `message`: Основной текст сообщения об ошибке.
- `details`: Дополнительные детали.
- `hint`: Подсказка о возможном решении проблемы.
- `code`: либо 5-значный код ошибки PostgreSQL (например, `23505`), либо код PostgREST (например, `PGRST100`).

