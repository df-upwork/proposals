# 1.
## 1.1.
`Aᨀ` ≔ (мой ответ `ꆜ`)

## 1.2.
Содержание `Aᨀ`:
~~~markdown
Задача моделирования ragged hierarchy в Alteryx One Platform решается так:
1) Подготовка данных (Основной Workflow)
Перед началом итеративной обработки необходимо консолидировать данные из всех исходных таблиц в единую структуру.
1.1) Импортировать данные.
Использовать инструмент «Input Data» для загрузки всех таблиц Excel, описывающих иерархию.
1.2) Консолидировать и нормализовать структуру.
Объединить данные из разных таблиц в единый поток данных со структурой списка смежности (Adjacency List), то есть в формате Parent-Child. 
Использовать инструменты «Union» и «Join». 
Результирующий набор данных (далее `Hierarchy_Data`) должен содержать как минимум поля идентификатора родителя (например, `ParentID`), идентификатора потомка (например, `ChildID`), а также все поля, необходимые для условной логики соединения (далее `ConditionFields`).
Единая структура Parent-Child необходима для универсальной реализации итеративной логики обхода иерархии.
1.3) Определить начальные узлы.
Определить узлы, с которых начнется обход иерархии (например, корневые узлы, где `ParentID` равен `Null`). Использовать инструмент «Filter».
1.4. Подготовить данные для итерации.
Для реализации обхода иерархии (например, для её развертывания в плоский список отношений Предок-Потомок) необходимо добавить служебные поля к начальным узлам. 
Использовать инструмент «Formula» для добавления полей:
- `AncestorID`: Идентификатор предка (изначально равен идентификатору самого узла).
- `CurrentID`: Идентификатор текущего узла (изначально равен идентификатору самого узла).
- `Level`: Уровень иерархии (изначально 0 или 1).
Этот набор данных (далее `Initial_Nodes`) инициирует процесс.
2) Реализация Conditional Join в Alteryx
Инструмент «Join» в Alteryx поддерживает только соединения на основе равенства (equi-joins).
Поэтому для репликации условной логики необходимо использовать комбинацию инструментов после «Join».
2.1) Реализация Conditional Inner Join.
Если требуется включить в результат только те записи, для которых совпали ключи и выполнено условие:
2.1.1) Использовать инструмент «Join» для соединения по ключам.
2.1.2) Подключить инструмент «Filter» к выходу «J» (Joined) инструмента «Join».
2.1.3) Сконфигурировать «Filter» для проверки дополнительных условий (`ConditionFields`).
2.1.4) Выход «T» (True) инструмента «Filter» содержит результат Conditional Inner Join.
2.2) Реализация Conditional Outer Join (например, Left Outer Join).
Если требуется сохранить записи из левой таблицы, даже если условие не выполнено (но поля из правой таблицы должны быть Null):
2.2.1) Использовать инструмент «Join» для соединения по ключам.
2.2.2) Подключить инструмент «Formula» к выходу «J» инструмента «Join».
2.2.3) В инструменте «Formula» для каждого поля, пришедшего из правой таблицы, применить логику: если дополнительное условие не выполнено, заменить значение поля на Null. 
Пример: `IF [Condition] THEN [Right_Field] ELSE Null() ENDIF`.
2.2.4) Использовать инструмент «Union» для объединения выхода «L» (Left Unjoined) инструмента «Join» и выхода инструмента «Formula».
3) Создание Iterative Macro
Необходимо создать отдельный Workflow для реализации рекурсивной логики. 
В большинстве случаев для обхода иерархии в рекурсивном шаге используется логика Inner Join (нахождение существующих связей).
3.1) Установить тип Workflow.
В новом Workflow открыть панель «Workflow Configuration». 
На вкладке «Workflow» в разделе «Type» выбрать «Macro», затем «Iterative Macro».
«Iterative Macro» выполняет процесс циклически, передавая результаты одной итерации на вход следующей, что позволяет обрабатывать данные рекурсивно или до выполнения определенного условия. 
3.2) Определить входы макроса.
Добавить два инструмента «Macro Input» из категории «Interface».
3.2.1) Итерационный вход (например, `Input_I`).
Принимает данные для текущей итерации. 
Схема должна соответствовать `Initial_Nodes` (поля `AncestorID`, `CurrentID`, `Level`).
3.2.2) Фиксированный вход (например, `Input_H`).
Принимает полный набор данных иерархии (`Hierarchy_Data`).
3.3) Реализовать логику итерации и условное соединение.
Необходимо найти следующий уровень иерархии, применяя логику Conditional Inner Join (см. пункт 2.1).
3.3.1) Добавить инструмент «Join». Соединить `Input_I` (вход «L») и `Input_H` (вход «R»).
3.3.2) Сконфигурировать соединение: `L.CurrentID` = `R.ParentID`.
3.3.3) Добавить инструмент «Filter», подключенный к выходу «J».
3.3.4) Сконфигурировать «Filter» на основе `ConditionFields` из `Input_H` (и, возможно, данных из `Input_I`).
3.4) Подготовить данные для следующей итерации.
Выход «T» инструмента «Filter» содержит успешные соединения. Необходимо обновить данные для следующего шага.
3.4.1) Добавить инструмент «Formula», подключенный к выходу «T».
3.4.2) Обновить поля:
- `AncestorID`: оставить значение из `Input_I` (переносится через итерации).
- `CurrentID`: установить значение `ChildID` из `Input_H` (новый текущий узел).
- `Level`: увеличить значение на 1 (можно также использовать `[Engine.IterationNumber] + 1`).
3.4.3) Использовать инструмент «Select» для обеспечения точного соответствия схемы данных (имена полей, типы, порядок) схеме `Input_I`.
3.5) Определить выходы макроса.
Добавить два инструмента «Macro Output».
3.5.1) Выход результата (например, `Output_R`).
Подключить выход инструмента «Select» (шаг 3.4.3). 
Этот выход накапливает все найденные связи Предок-Потомок на всех итерациях.
3.5.2) Итерационный выход (например, `Output_I`).
Также подключить выход инструмента «Select» (шаг 3.4.3). 
Эти данные передаются обратно на `Input_I`. 
Макрос остановится, когда этот выход будет пуст.
4) Конфигурация параметров макроса
4.1) Открыть Interface Designer.
Перейти в меню «View» → «Interface Designer».
4.2) Настроить свойства итерации.
Перейти в раздел «Properties» (иконка гаечного ключа или шестеренки).
4.2.1) В поле «Iteration Input» выбрать `Input_I`.
4.2.2) В поле «Iteration Output» выбрать `Output_I`.
4.2.3) В поле «Maximum Number of Iterations» установить достаточно большое значение (например, 100) для предотвращения бесконечных циклов из-за циклических ссылок в данных.
Обоснование: Эти настройки определяют, как Alteryx Engine управляет потоком данных между итерациями.
4.3) Сохранить макрос (например, как файл `ProcessHierarchy.yxmc`).
5) Выполнение (Основной Workflow)
5.1) Вставить макрос.
В основном Workflow кликнуть правой кнопкой мыши на холсте → «Insert» → «Macro...» и выбрать файл `ProcessHierarchy.yxmc`.
5.2) Подключить данные.
5.2.1) Соединить `Hierarchy_Data` (шаг 1.2) с входом `Input_H` макроса.
5.2.2) Соединить `Initial_Nodes` (шаг 1.4) с входом `Input_I` макроса.
5.3) Обработать результаты.
Выход `Output_R` макроса содержит развернутую иерархию (все связи Предок-Потомок). 
При необходимости можно использовать инструмент «Union», чтобы добавить начальные узлы (`Initial_Nodes`) к этому результату для получения полного набора данных.
~~~

# 2. `᛭T`
Проанализируй `Aᨀ`:
1) Есть ли там логические ошибки?
2) Есть ли там фактические ошибки?

# 3. Требования к твоему ответу
## 3.1.
Отвечай на русском языке.
## 3.2.
Мой вопрос не пересказывай.
## 3.3.
Уже сформулированную мной информацию не пересказывай.
## 3.4.
Писать свою версию `Aᨀ` не нужно: просто укажи свои замечания по пунктам.
## 3.5.
До и после списка замечаний ничего не пиши.
## 3.6.
Нумерация замечаний должна быть сквозной.

# 4. Источники информации
## 4.1.
Используй авторитетные источники информации на английском языке, относящиеся к предметной области `P⁎` и `P†`.

## 4.2.
В первую очередь используй официальные источники: https://alteryx.com