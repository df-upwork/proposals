## 1.
Клиент хочет выполнить следующий проект:
### 1.1. Title
Power BI & MySQL Troubleshooting Expert

### 1.2. Description
We are experiencing an issue in Power BI where our dashboards and visuals are failing to display new data after refreshing our MySQL database. We suspect it may not be a simple filter problem. We need an expert to help us:
Identify and Fix Issues: Diagnose the root cause (relationships, data types, queries, or other data modeling issues).
Optimize Data Model: Ensure our Power BI data model aligns with the MySQL structure.
Validate Visuals: Confirm that our reports, filters, and slicers are working correctly after the fix.
Requirements:
Strong Power BI expertise, including advanced data modeling.
Experience with MySQL, including troubleshooting schema and data type issues.
Familiarity with Power BI’s refresh process, query settings, and gateway configurations.
Excellent communication skills and a willingness to walk us through the troubleshooting steps.
Preferred Qualifications:
Previous experience working with ERP-integrated databases.
Track record of resolving complex Power BI–MySQL sync problems.
If you have a proven history of diagnosing and resolving Power BI data refresh issues, we’d love to work with you! Please share any relevant examples or case studies.

### 1.3. Местоположение клиента
United States
Miami

### 1.4. Tags
Microsoft Power BI
MySQL

## 2. «our dashboards and visuals are failing to display new data after refreshing our MySQL database»
### 2.1.
Я тебя спросил:
~~~
В пункте 1.2 клиент пишет:
```
We are experiencing an issue in Power BI where our dashboards and visuals are failing to display new data after refreshing our MySQL database. We suspect it may not be a simple filter problem.
```
Перечисли наиболее вероятные причины проблемы клиента.
~~~

### 2.2.
Ты ответил:
~~~
Ниже перечислены наиболее вероятные причины, по которым новые данные из MySQL могут не отображаться в Power BI после обновления:

1. **Неверные связи или несоответствие структуры данных**  
   - Неправильно выстроенные связи между таблицами (включая отсутствие ключевых полей или некорректно заданные отношения «один-ко-многим» и т. д.).  
   - Некорректная структура данных в MySQL (например, изменились схемы, поля были добавлены/удалены, а в Power BI модель не обновилась).  

2. **Несоответствие или неправильные типы данных**  
   - Поля в MySQL могут иметь один тип (например, текст), а в Power BI они определены другим (например, число).  
   - Возможно, после изменения структуры таблиц в MySQL некоторые столбцы получили другие типы данных, что приводит к ошибкам или некорректным обновлениям в Power BI.  

3. **Ошибки в запросах или трансформациях Power Query**  
   - В «Шаги» (Steps) внутри Power Query мог закрасться баг (например, ссылка на несуществующее поле).  
   - Неверно прописанные фильтры, фильтрация по старой схеме или забытые «условные столбцы» могут приводить к тому, что новые записи отбрасываются.  

4. **Неактивированные/неверно настроенные инкрементальные обновления**  
   - Если включено инкрементальное обновление, но оно неправильно настроено (не те поля для отслеживания, неверные диапазоны дат и т. п.), новые данные могут не попадать в итоговый набор.  

5. **Проблемы с Power BI Gateway или настройками подключения**  
   - Сломанный или некорректно сконфигурированный шлюз (Data Gateway) может не обновлять данные из базы MySQL.  
   - Учетные данные (credentials) просрочены или не совпадают с теми, что нужны для чтения новых данных.  

6. **Закэшированные данные и несоответствие режимов (Import vs. DirectQuery)**  
   - При режиме Import данные могут не обновляться в реальном времени, а в расписании обновления могла произойти ошибка.  
   - В случае DirectQuery могут возникать проблемы с запросами из-за ограничения прав или неверной конфигурации сервера.  

7. **Фильтры, срезы (slicers) или уровни безопасности (RLS)**  
   - Хоть клиент и подозревает, что дело не только в фильтрах, их влияние всё же стоит проверить. Иногда активные фильтры или RLS (Row-Level Security) скрывают новые данные.  
   - Если настроены сложные выражения DAX, они могут некорректно исключать часть свежих записей.  

8. **Отсутствие публикации изменений после локальной работы**  
   - Если клиент вносил изменения в Power BI Desktop, но не опубликовал их в сервис Power BI, изменения и обновления могут не дойти до конечной онлайн-дашборда.  

9. **Проблемы на стороне MySQL**  
   - Ошибки в самой базе (например, “пустые” записи, проблемы с индексацией или блокировки транзакций).  
   - При обновлении таблиц в MySQL не все данные физически пишутся в те же таблицы, которые подключены к Power BI (могут быть задействованы временные таблицы или staging-слои).  

Проверка и поочередное исключение (или подтверждение) этих пунктов поможет определить конкретную причину, по которой новые данные не отображаются в отчетах Power BI.
~~~

## 3. «Неправильно выстроенные связи между таблицами»
### 3.1.
Я тебя спросил:
~~~
В пункте 2.2 ты писал:
```
 - Неправильно выстроенные связи между таблицами (включая отсутствие ключевых полей или некорректно заданные отношения «один-ко-многим» и т. д.). 
```
Опиши подробнее, каким образом «Неправильно выстроенные связи между таблицами» может приводить к проблеме клиента.
~~~

### 3.2.
Ты ответил:
~~~
Ниже приведены основные ситуации, при которых некорректные связи между таблицами могут приводить к тому, что новые данные из MySQL не отображаются в Power BI:

1. **Отсутствие или неправильная настройка ключевых полей**  
   - В реляционных моделях (и в Power BI в частности) связь между таблицами строится через ключевые поля (например, первичный ключ в «факте» ссылается на соответствующий столбец в «измерении»).  
   - Если в Power BI в качестве ключа используется столбец, где значения повторяются или несодержательны (нет уникальных значений), то связь может работать некорректно.  
   - Новые записи в MySQL могут иметь значения ключа, которые не совпадают (или конфликтуют) с уже существующими, из-за чего новые данные не «присоединяются» к нужным строкам и не отображаются в отчёте.

2. **Некорректная кардинальность (один-к-одному, один-ко-многим, многие-ко-многим)**  
   - Если по логике модели таблица должна быть в связке «один-ко-многим», но в Power BI неправильно выбрана «один-к-одному», новые данные могут не попадать в связку или вызывать конфликты.  
   - «Многие-ко-многим» является более сложным типом отношений и, если его использовать неосмотрительно, часть записей может «затеряться» при агрегациях или при наложении фильтров.

3. **Неактивные связи**  
   - В Power BI можно иметь несколько связей между двумя таблицами, но лишь одна может быть «активной». Если активная связь не та, которая должна учитывать новые данные, то визуалы (особенно срезы и фильтры) могут по умолчанию работать не с нужной связью.  
   - В результате при обновлении данные как бы загружаются, но не отображаются, потому что Power BI ссылается не на ту связь, которая отражает нужные поля для сопоставления.

4. **Несоответствие типов полей для связей**  
   - Допустим, в MySQL столбец с ID или кодом хранится как `VARCHAR`, а в Power BI этот же столбец определяется как `числовой`. При сопоставлении могут возникать ошибки, приводящие к тому, что часть значений не стыкуется между таблицами.  
   - В итоге, когда идет обновление, Power BI «видит» несоответствия в данных, и новые строки просто не привязываются к таблице-фильтру или не учитываются в итоговых расчётах.

5. **Проблемы с изоляцией данных в разных таблицах**  
   - Если у клиента есть несколько таблиц фактов (Fact) и измерений (Dimension), и логика подразумевает, что новая запись должна связаться с новыми или старыми записями в других таблицах, но соответствующие связи не проставлены или отсутствуют, то для Power BI такая новая запись может оставаться «одинокой».  
   - Например, новая строка в фактической таблице продаж не отображается в визуале, если нет соответствующей строки в справочнике товаров или если связь между «Продажи» и «Товары» не настроена или настроена неверно.

6. **Ошибочные фильтры в таблицах с отношениями**  
   - Если модель Power BI использует фильтрацию «Применять фильтрацию в обеих таблицах» (cross-filter direction = Both), некорректная связь может привести к тому, что фильтр (слайсер) из одной таблицы будет исключать новые записи в другой.  
   - Это особенно часто встречается, когда у таблиц есть вторичные связи через промежуточные таблицы, и неправильная настройка отношений может блокировать вывод нужных данных.

7. **Изменения структуры в MySQL без обновления модели Power BI**  
   - Если в MySQL добавлено новое поле или переименовано старое, а в Power BI связь всё ещё ссылается на старое название или старую структуру, то при обновлении эта часть данных может не учитываться.  
   - Внешне может показаться, что просто «новые данные не подтягиваются», хотя на самом деле модель в Power BI не «видит» обновлённые поля в MySQL.

---

### Как определить, что проблема в связях

1. **Проверить связанные поля**  
   - Открыть «Управление связями» (Manage Relationships) в Power BI и удостовериться, что каждое связанное поле в Power BI соответствует правильному столбцу в MySQL по типу и содержимому.

2. **Включить/отключить автодетектирование**  
   - Power BI умеет автоматически определять связи, но иногда он ошибается, выбирая неправильный тип отношений или связывая «похожие по названию» столбцы, которые на самом деле не должны быть связаны.

3. **Изучить таблицы-источники**  
   - Убедиться, что в MySQL действительно существуют нужные уникальные ключи или хотя бы логическая схема (например, DateKey в таблицах дат, ProductKey в таблице продуктов и т. п.).  
   - Сравнить фактические данные: если в MySQL есть новая запись, посмотреть, есть ли соответствующее значение ключа в связанной таблице. Если нет — отношения в Power BI, скорее всего, будут «обрезать» такие записи.

4. **Проверить DAX-меры и выражения**  
   - Иногда DAX-меры (Measures) ссылаются на определённую связь или требуют активной связи (через `USERELATIONSHIP`, например). Если DAX написан под неактивную или неверную связь, это тоже может приводить к тому, что новые данные игнорируются.

В результате, если связи между таблицами в Power BI не соответствуют фактической схеме данных в MySQL, свежие записи могут не отображаться в отчётах, потому что при агрегациях или при наложении фильтров Power BI не видит «пути» для этих новых записей в модели. Исправление связей или корректная перенастройка модели чаще всего решает проблему отображения новых данных.
~~~

## 4. «Некорректная структура данных в MySQL (например, изменились схемы, поля были добавлены/удалены, а в Power BI модель не обновилась)»
### 4.1.
Я тебя спросил:
~~~
В пункте 2.2 ты писал:
```
Некорректная структура данных в MySQL (например, изменились схемы, поля были добавлены/удалены, а в Power BI модель не обновилась)
```
Опиши подробнее, каким образом «Некорректная структура данных в MySQL (например, изменились схемы, поля были добавлены/удалены, а в Power BI модель не обновилась)» может приводить к проблеме клиента.
~~~

### 4.2.
Ты ответил:
#### 4.2.1. Ответ 1
~~~
Ниже рассмотрены основные аспекты, как изменения структуры в MySQL (добавление, удаление, переименование столбцов или таблиц) могут приводить к тому, что новые данные не отображаются в Power BI:

---

### 1. Несоответствие полей между MySQL и моделью Power BI
- **Добавление новых полей в MySQL**  
  Если в таблицу MySQL добавили столбец, который важен для анализа (например, новая метрика или ключ), а в Power BI не обновили запрос (Power Query) и модель, этот столбец попросту не попадёт в набор данных.  
  - Пример: в базе появилась колонка `DiscountRate`, но в Power BI Query Editor её не добавили в список выбираемых полей (Select columns). Следовательно, при обновлении данные о скидках не подтягиваются.

- **Удаление или переименование существующих полей**  
  Если столбец в MySQL был переименован или удалён, а в Power BI он всё ещё используется (например, в шагах Power Query, в DAX-выражениях, в измерениях или связях), то обновление может выдавать ошибки либо игнорировать часть данных.  
  - Пример: в MySQL столбец `customer_id` переименовали в `client_id`, а в Power BI всё ещё пытаются обращаться к `customer_id`. В итоге при обновлении в отчётах может показываться неполная информация или вовсе возникать сбой.

---

### 2. Изменение типов данных
- **Непредусмотренное изменение типа столбца**  
  Если в MySQL поле было `INT` (числовое), а затем его изменили на `VARCHAR` (текстовое) или наоборот, Power BI может перестать корректно интерпретировать эти данные.  
  - Пример: новый тип данных может не совпадать с тем, что ожидалось в фильтрах или визуализациях (например, число теперь воспринимается как текст, и агрегаты не рассчитываются).  
  - Результат: при загрузке может возникать предупреждение/ошибка, либо новые записи будут пропускаться.

---

### 3. Разрыв в связях между таблицами (Relationships) из-за изменения структуры
- **Разрушение связей**  
  Если ключевое поле таблицы (используемое в отношениях) было удалено или переименовано, то связь в Power BI станет некорректной или «неактивной».  
  - В результате при попытке отобразить данные из двух связанных таблиц часть записей (особенно новых) не будет находить «сопоставление», и визуалы будут показывать неполную картину.

- **Новые таблицы MySQL без обновления модели Power BI**  
  Если добавили новую таблицу/представление (view) в MySQL, и именно там теперь находятся актуальные данные, но в Power BI по-прежнему ссылаются на старую таблицу или вообще на другую схему, то необходимые данные не попадут в отчёт.  
  - Пример: перенесли исторические записи в новую таблицу `sales_history`, а в Power BI всё ещё загружается старая `sales_archive`. Новые данные останутся «за кадром».

---

### 4. Ошибки в Power Query (шаги не соответствуют обновлённым данным)
- **Неактуальные M-скрипты**  
  Power BI при загрузке данных использует M-код (Power Query) для извлечения и трансформации столбцов. Если в скрипте явно перечислены поля, которых уже нет в базе (или которые были переименованы), при обновлении может возникнуть ошибка либо новые записи (включающие новые поля) не будут учитываться.  
  - Пример: в шаге `Table.SelectColumns` прописан список из 5 столбцов, а в базе теперь их 6 или изменились названия. Power BI будет игнорировать новый столбец и не покажет связанные с ним данные.

- **Зависимости в шагах трансформации**  
  Некоторые шаги могут опираться на столбец, который был удалён, — из-за этого последующие шаги тоже станут невалидными. Power Query может пропускать часть данных или выдавать «крестик» (ошибку) на этапе обновления.

---

### 5. Сбой в расписании обновлений (Scheduled Refresh)
- Если в MySQL что-то радикально поменяли (например, структуру таблиц) и при этом в Power BI не обновили настройки подключения (Gateway и т. п.), могут возникать ошибки на уровне сервиса Power BI.  
- В таких случаях новые данные могут вообще не подтягиваться, хотя локально в Power BI Desktop (при ручном обновлении) всё может выглядеть исправно (или наоборот).

---

### Как проявляется проблема на практике
1. **Частичное отсутствие данных**  
   - Новые строки есть в MySQL, но в отчёте остаются старые значения.  
   - Некоторые визуалы показывают либо пустые поля, либо «(Blank)».

2. **Ошибки при обновлении**  
   - Power BI может выдавать сообщение об ошибке вроде «The column `<column_name>` of the table was not found…»  
   - Или более общие сбои в рефреше: «Failed to save modifications to the server».

3. **Неожиданные изменения в фильтрах и измерениях**  
   - Фильтры или срезы (slicers) в отчётах перестают работать или показывают некорректные диапазоны.  
   - Если столбец исчез, может «слететь» логика измерений (Measures) и вычислений DAX.

---

### Рекомендации по устранению
1. **Синхронизировать модель Power BI с актуальной схемой MySQL**  
   - Перепроверить в Query Editor, какие таблицы и столбцы выбираются. Убедиться, что столбцы не были переименованы или удалены.  
   - При необходимости вручную обновить шаги Power Query (особенно `Table.SelectColumns`, `Renamed Columns` и т. п.).

2. **Проверить типы данных**  
   - Сопоставить типы данных в MySQL и в Power BI. Если типы не совпадают, привести их к единому виду (при необходимости добавить конверсию в Power Query).

3. **Обновить (или перестроить) связи**  
   - Зайти в «Управление связями» (Manage Relationships) и убедиться, что ключевые поля на месте и правильно сопоставлены.  
   - Если таблица или столбец, участвующие в связи, были переименованы в MySQL, указать это же новое имя в Power BI.

4. **Проверить M-скрипты и DAX-выражения**  
   - Убедиться, что нигде не ссылаетесь на несуществующие поля.  
   - Если используется `USERELATIONSHIP` или другие функции, проверить, что аргументы соответствуют текущим именам столбцов и таблиц.

5. **Убедиться в корректности настроек обновления (Refresh) в сервисе Power BI**  
   - Если используется Power BI Gateway, проверить, что он подключается к правильной базе, и в нём отражены актуальные таблицы.  
   - Перепроверить, что учётные данные (Credentials) корректны и имеют доступ к обновлённой схеме MySQL.

---

Таким образом, когда структура данных в MySQL меняется, но соответствующие корректировки не вносятся в Power BI (в модель, связи, запросы и т. д.), это прямой путь к тому, что часть или даже все новые записи перестанут подтягиваться. Важно всегда поддерживать модель Power BI в актуальном состоянии относительно исходной базы данных, чтобы избежать подобных сбоев.
~~~
#### 4.2.2. Ответ 2
~~~
Ниже описаны основные случаи, когда изменения или несоответствия структуры MySQL-таблиц приводят к тому, что в Power BI не отображаются новые данные:

1. **Добавление или удаление столбцов (Columns)**  
   - Если в MySQL была добавлена новая колонка (например, `NewField`), а в Power BI модель (или Power Query) по-прежнему ожидает старую структуру таблицы, при обновлении могут происходить ошибки или предупреждения.  
   - Аналогично, если разработчики удалили либо переименовали столбец в MySQL, но в Power BI запрос (Power Query) ссылается на старое имя, обновление будет либо выдавать ошибку, либо пропускать часть данных.

2. **Изменение типов полей (Data Types)**  
   - Допустим, в MySQL поле хранилось как `INT`, а затем кто-то изменил его на `VARCHAR` или `TEXT`. При этом в Power BI оно по-прежнему воспринимается как число.  
   - В результате могут возникать несовпадения: Power BI может «отсеивать» новые строки, не распознавая их корректно, либо выдавать ошибку преобразования данных (Data Conversion Error).

3. **Изменение структуры отношений (Foreign Keys, Primary Keys)**  
   - Если на стороне MySQL изменилась логика первичных или внешних ключей, а в Power BI остались старые настройки связей, это может привести к тому, что часть данных не будет подтягиваться в отчёт.  
   - Например, была переименована или удалена таблица-справочник, на которую шла ссылка из основной таблицы. В этом случае Power BI будет видеть «обрыв» связи и игнорировать или отбрасывать новые записи.

4. **Разделение таблиц или перенос данных в другие схемы**  
   - Случается, что разработчики баз данных переносят часть столбцов в другую таблицу или даже в другую схему, а название/настройки подключения в Power BI не меняется. Тогда Power BI при запросе старых таблиц не находит часть данных.  
   - Новые записи могут физически находиться в новой структуре, которая просто не подключена к текущей модели Power BI.

5. **Несоответствие при повторном использовании имён**  
   - Иногда администраторы MySQL могут удалить столбец/таблицу и создать новый объект с таким же именем, но другим типом данных или другой логикой. Power BI, «думая», что это та же структура, продолжает обрабатывать данные по старым правилам и даёт ошибку или некорректный результат.

6. **Зависание кэша метаданных и отсутствие обновления схемы**  
   - Power BI кэширует схему (metadata) источника данных. Если изменения в базе произошли недавно, а в настройках Power Query не была выполнена «перезагрузка» (Refresh Preview) либо не был обновлён столбец (через «Refresh fields» в Query Editor), то Power BI может работать с устаревшими сведениями о схеме.  
   - В итоге новые столбцы/данные не учитываются при визуализации, или наоборот — отчёт «сыпется» ошибками при обращении к старым столбцам.

---

### Как проверить и устранить проблему со структурой данных

1. **Сравнить структуру таблиц Power Query со структурой MySQL**  
   - Зайти в редактор Power Query и проверить список столбцов, их названия и типы. Сопоставить их с текущей схемой MySQL (можно использовать инструменты администрирования MySQL или SQL-запрос `DESCRIBE table_name;`).

2. **Обновить превью в Power Query**  
   - В редакторе Power Query нажать «Refresh Preview» или «Обновить данные» (перезагрузить превью), чтобы убедиться, что Power BI видит актуальную структуру.

3. **Исправить шаги трансформации**  
   - Если есть ошибки на одном из шагов (Step) в Power Query (например, «Column ‘OldName’ not found»), нужно обновить соответствующую трансформацию: поменять ссылки на актуальные столбцы, удалить или переименовать шаг.

4. **Проверить настройки типов данных**  
   - Убедиться, что тип поля в Power BI соответствует типу в MySQL. При необходимости — выполнить явное преобразование типа (например, из `Text` в `Decimal` или из `Decimal` в `Whole Number`).  
   - Проверить, не пропадают ли данные при таких преобразованиях.

5. **Убедиться в правильных связях**  
   - Если вместе со структурой MySQL менялась и логика внешних ключей, нужно в Power BI актуализировать или пересоздать связи («Manage Relationships»).

6. **Проверить источники, если таблицу переместили**  
   - Если таблица была перенесена в другую схему (например, из `old_schema.TableA` в `new_schema.TableA`), нужно в настройках Power Query обновить путь к источнику. Иначе запрос по-прежнему будет смотреть в старое место.

7. **Тестовое обновление отчёта**  
   - После внесения изменений обязательно выполнить «Обновить» (Refresh) отчёт в Power BI Desktop и проверить, появились ли новые данные. Затем опубликовать обновлённый файл (PBIX) в сервис Power BI (если используется облачный отчёт).

---

Таким образом, если структура данных в MySQL меняется (добавляются, удаляются, переименовываются поля и таблицы) и модель Power BI не адаптируется под эти изменения, то часть новых данных может не попадать в отчёты, либо обновление будет проваливаться с ошибками. Решение — синхронизировать модель Power BI с фактической структурой MySQL и при необходимости обновить шаги Power Query, связи и настройки типов данных.
~~~

## 5. «Поля в MySQL могут иметь один тип (например, текст), а в Power BI они определены другим (например, число)»
### 5.1.
Я тебя спросил:
~~~
В пункте 2 своего ответа пункта 2.2 ты писал:
```
Поля в MySQL могут иметь один тип (например, текст), а в Power BI они определены другим (например, число)
```
Опиши подробнее, каким образом «Поля в MySQL могут иметь один тип (например, текст), а в Power BI они определены другим (например, число)» может приводить к проблеме клиента.
~~~

### 5.2.
Ты ответил:
#### 5.2.1. Ответ 1
~~~
Ниже рассмотрены ситуации, когда несоответствие типов данных между MySQL и Power BI приводит к тому, что новые (или даже старые) записи не отображаются или отображаются некорректно:

---

### 1. Ошибки при загрузке или пропуск строк

- **Числовой столбец в MySQL, но текстовый в Power BI**  
  Допустим, в базе MySQL поле хранится как `INT` или `DECIMAL`, а при загрузке в Power BI оно было автоматически (или вручную) сконвертировано в текстовый тип (`Text`).  
  - В таком случае при обновлениях могут появляться предупреждения или ошибки преобразования (Data Conversion Error).  
  - Либо Power BI не сможет корректно агрегировать такие данные (например, сумму продаж) и часть записей может не учитываться в мерах и визуалах.

- **Текстовый столбец в MySQL, но в Power BI ожидается число**  
  Если Power BI считает, что поле числовое (Whole Number, Decimal Number и т. п.), а в MySQL в том же столбце содержатся текстовые значения (вплоть до «abc123»), то при попытке преобразовать эти строки в число может возникать ошибка.  
  - Часть «нечистых» данных (где есть несоответствие формату числа) может отбрасываться или становиться `Null`.

---

### 2. Сбой в фильтрах и связях из-за неверных типов

- **Невалидные ключи**  
  Если столбец, который участвует в связях между таблицами (например, `OrderID`), на самом деле текстовый (VARCHAR) в MySQL, а в Power BI его по ошибке назначили как числовой тип, это может привести к «обрывам» связей.  
  - Новые записи, где `OrderID` не преобразуется должным образом в число, могут не находить соответствий в связанных таблицах и не отображаться в отчёте.

- **Некорректные фильтры и срезы (slicers)**  
  Если Power BI воспринимает поле как число, то при использовании фильтра или среза по этому полю отсекаются записи, у которых фактически нечисловые значения (или они пустые).  
  - В итоге визуалы могут показывать только те строки, которые удачно сконвертировались в число, а «проблемные» не отображаются.

---

### 3. Ошибки при вычислениях (Measures, DAX)

- **Арифметические операции над текстовым столбцом**  
  Если в DAX-мере предполагается, что поле — это число (например, расчёт суммы или среднего), но Power BI видит там текст, функция не сможет корректно обработать такие значения.  
  - Результат: неверные итоги, пустые или «(Blank)» значения в таблицах и визуалах.

- **Сложность в датах и временных метках**  
  Часто встречается ситуация, когда поле «Дата/Время» в MySQL хранится как `DATETIME`, а в Power BI его считывают как текст. При попытках сделать фильтр по дате (например, «Период с… по…») Power BI не сможет правильно сравнивать значения.  
  - Новые записи, у которых дата не приводится к формату Date/Time, могут не попадать в интервал фильтра.

---

### 4. Проблемы в Power Query (M-код)

- **Неявная конверсия типов**  
  Иногда Power BI пытается автоматически привести текст к числу или число к тексту. Если в столбце MySQL есть «гибридные» значения (часть строк чисто цифровые, часть — с буквами или символами), при обновлении может возникать ошибка.  
  - В итоге Power BI либо «ломает» обновление, либо «тихо» отбрасывает проблемные строки.

- **Выборочное отбрасывание строк**  
  При несоответствии типов Power Query может пропускать или заменять некорректные значения на `Null`. Если среди новых данных все значения не соответствуют ожидаемому формату, вся партия новых строк не будет отображаться.

---

### 5. Сложности при инкрементальных обновлениях

- Если используется инкрементальное обновление (Incremental Refresh) и фильтрация по дате (или по другому столбцу), а этот столбец имеет неверный тип, новые данные могут не попадать в заданный «диапазон».  
- Пример: фильтр настроен по дате в числовом формате `YYYYMMDD`, а в MySQL поле стало текстовым. Инкрементальное обновление, ожидая число, не найдёт в тексте нужных значений.

---

### Как проверить и устранить проблему с типами данных

1. **Сравнить типы столбцов в MySQL и в Power BI**  
   - Использовать SQL-запрос `DESCRIBE table_name;` (или аналогичные инструменты) и проверить, какой тип данных фактически прописан в столбце.  
   - В Power BI открыть редактор Power Query и посмотреть, какой тип присвоен столбцу (иконка «ABC», «123», «Date», «Date/Time» и т. п.).

2. **Явно приводить столбцы к нужному типу**  
   - В Power Query можно использовать шаг «Transform» → «Data Type» (или в M-коде `Table.TransformColumnTypes`) и задать правильный тип для каждого столбца.  
   - Если в столбце реальные числовые значения, указываем Whole Number / Decimal Number. Если даты, указываем Date / DateTime.

3. **Обрабатывать ошибки преобразования**  
   - Если часть строк не подходит под нужный тип (например, текст «N/A» в числовом поле), решить, как с этим быть: возможно, нужно заменить невалидные значения на 0 или `Null`.  
   - Проверить, не теряются ли при этом нужные данные.

4. **Перепроверить связи (Relationships)**  
   - Если столбец участвует в связях (связь «один-ко-многим»), проследить, чтобы типы данных в обоих таблицах совпадали.  
   - Пример: «Покупатель ID» не должен быть `Text` в одной таблице и `Whole Number` в другой.

5. **Тестировать обновление отчёта**  
   - После исправления типов данных выполнить «Refresh» в Power BI Desktop, убедиться, что новые строки подтягиваются и отображаются в визуалах.  
   - Если используется Power BI Service, опубликовать обновлённую модель и проверить, что запланированное обновление (Schedule Refresh) проходит без ошибок.

---

Таким образом, если в MySQL поле имеет один тип (например, текст), а в Power BI ему был назначен другой (число, дата и т. п.), данные могут либо частично пропадать, либо выдавать ошибки при обновлении, либо некорректно отображаться в визуалах и связях. Важно регулярно сопоставлять и синхронизировать типы данных в базе и в Power BI, чтобы все новые (и старые) записи корректно загружались и анализировались.
~~~
#### 5.2.2. Ответ 2
~~~
Ниже рассмотрены основные сценарии, при которых несоответствие типов данных между MySQL и Power BI (например, в базе поле хранится как текст, а в Power BI оно ожидается как число) приводит к тому, что новые записи либо не загружаются, либо не отображаются корректно:

---

## 1. Ошибки при загрузке или преобразовании данных (Data Conversion Errors)

1. **Неявное преобразование типов**  
   - Если в MySQL колонка хранится как `VARCHAR` (текст), а в Power BI она помечена как числовая (`Whole Number`, `Decimal Number` и т.д.), при обновлении Power BI пытается преобразовать каждый текстовый элемент в число.  
   - Если в тексте попадаются некорректные символы (например, буквы, пробелы, знаки) или пустые значения, Power BI выдаст ошибку преобразования (Conversion Error) и не загрузит новые строки.

2. **Прерывание загрузки**  
   - Иногда достаточно одной «неправильной» строки (например, `ABC123`) в текстовом поле, чтобы весь процесс обновления прервался на этапе Power Query. В результате, ни новые данные, ни уже существующие строки не подтягиваются в модель.

3. **Частичное игнорирование строк**  
   - В некоторых случаях Power BI может загрузить часть данных, но пропустить те строки, где преобразование из текста в число невозможно. Тогда визуально кажется, что «какая-то часть новых записей не приходит».

---

## 2. Нарушение связей (Relationships) из-за типа ключей

1. **Некорректное сопоставление ключевых полей**  
   - Если поле, которое в MySQL является ключом (например, `OrderID`), хранится как `VARCHAR`, а в Power BI это же поле определено как числовой ключ, то при попытке построить связь (Relationship) может возникать несоответствие типов.  
   - В итоге новые данные (у которых, например, `OrderID` содержит буквы или нестандартные символы) не будут находить совпадения в связанной таблице. Это приведёт к тому, что в фактическом отчёте свежие строки не появятся (не «присоединятся» к измерениям).

2. **Проблемы с активной связью**  
   - Даже если Power BI сумеет «догрузить» данные, но связь окажется «неактивной» или «неоднозначной» (Ambiguous), то при выборе полей из связанных таблиц новые записи могут не агрегироваться и не отображаться в визуалах.

---

## 3. Ошибки и некорректные результаты в DAX-вычислениях

1. **Невозможность корректной агрегации**  
   - Если поле предполагается использовать для суммирования или расчёта среднего (например, `SUM`, `AVERAGE`), но в Power BI это поле почему-то прочиталось как текст, то при попытке сделать числовую операцию Power BI будет выдавать ошибку или возвращать 0.  
   - Визуалы, основанные на таких мерах (Measures), могут показывать некорректные итоги или вовсе «падать» с ошибкой.

2. **Некорректные фильтры на числовые поля**  
   - Допустим, в отчёте есть срез (Slicer), который фильтрует число по диапазону (например, суммы заказов). Если в реальности поле — текст, Power BI может создавать неадекватные интервалы или вообще не позволять фильтрацию.  
   - Новые данные не будут отображаться под ожидаемым диапазоном, поскольку строковые значения сортируются иначе, чем числа (к примеру, «1000» может идти перед «2» при лексикографическом сравнении).

---

## 4. Проблемы с отображением дат, времени и других форматов

1. **Даты и время**  
   - Порой в MySQL поле с датой (`DATE`, `DATETIME`) хранится как строка (например, `'2025-03-01'`), а в Power BI оно определено как тип Дата (Date/Time). При попытке преобразовать текст, который не соответствует формату даты (например, `'03-01-2025'`, если ожидается `'YYYY-MM-DD'`), могут возникать ошибки.  
   - Это приводит к «обрезанию» набора данных или неправильному сортированию/фильтрации по датам.

2. **Локализация и форматы**  
   - Если в тексте содержатся символы, зависящие от региональных настроек (точка и запятая в качестве разделителя десятичных долей, особенности формата даты), то Power BI может неверно трактовать данные.  
   - Это тоже может привести к тому, что новые записи окажутся «за бортом», поскольку не преобразуются корректно.

---

## 5. Признаки проблемы на уровне отчётов и обновлений

1. **Частичное или полное отсутствие свежих строк**  
   - При обновлении отчёта пользователь видит, что новые данные из MySQL не появляются, хотя в самой базе они есть.  
   - В истории обновлений Power BI (особенно при включённом детальном логе) можно заметить сообщения об ошибках преобразования типов.

2. **Пустые или некорректные поля в визуалах**  
   - Вместо чисел отчёт может показывать пустые поля `Blank`, либо наоборот — текст `Error`.  
   - В фильтрах (slicers) может отсутствовать ожидаемый диапазон значений.

3. **Ошибки вида «Couldn’t convert text to Number»**  
   - При ручном обновлении в Power BI Desktop иногда всплывают диалоговые окна с сообщением, что часть строк не удалось преобразовать из текста в число.

---

## 6. Как проверить и решить проблему

1. **Проверить тип данных в MySQL**  
   - Используя SQL-запрос (например, `DESCRIBE table_name;`) или инструменты администрирования (phpMyAdmin, MySQL Workbench и т.п.), посмотреть, как именно объявлено поле (например, `INT`, `VARCHAR`, `DECIMAL`, `DATETIME` и т.д.).  
   - Посмотреть, какие данные фактически хранятся в этом поле (нет ли там нечисловых символов, если тип заявлен как `VARCHAR` и предполагается хранить числа).

2. **Сопоставить с типом в Power BI**  
   - Открыть редактор Power Query и посмотреть, как Power BI интерпретирует это поле (иконка «ABC123» означает текст, «1.2» — десятичное число, «1» — целое, «Calendar» — дата/дата-время).  
   - При необходимости вручную настроить тип данных («Transform» → «Data Type») и проследить, чтобы при конвертации не появлялось ошибок.

3. **Обработка ошибок в Power Query**  
   - Если в столбце встречаются «плохие» значения (например, «—» или «N/A»), можно добавить шаг очистки данных (Replace Values, Remove Errors). Это позволит избегать полного срыва обновления из-за нескольких некорректных строк.  
   - В некоторых случаях можно использовать условные столбцы (Conditional Column) или функции M (например, `Number.FromText`, `Date.FromText`) с проверкой, являются ли значения корректными.

4. **Проверить связи (Relationships)**  
   - Если это поле — часть ключа, проверить, есть ли уникальные значения и совпадают ли они действительно с тем, что хранится в другой таблице.  
   - Убедиться, что после приведения к нужному типу связи работают корректно, и при выборе полей в визуалах данные агрегируются ожидаемым образом.

5. **Убедиться в корректном отображении новых данных**  
   - После правок сделать полное обновление отчёта (Refresh) в Power BI Desktop, посмотреть, появились ли новые записи.  
   - Если всё работает, опубликовать отчёт в сервис Power BI и проверить расписание обновлений (Scheduled Refresh) — чтобы убедиться, что на уровне шлюза (Data Gateway) также не возникает конфликтов типов.

---

## Итог

Разница между типами данных в MySQL и Power BI (например, столбец хранится как текст в базе, а в Power BI он задан как числовой) способна приводить к целому спектру проблем:

- Ошибки или сбои при загрузке и преобразовании данных.  
- Потеря (пропуск) части новых строк.  
- Неправильная работа измерений, мер (Measures) и фильтров.  
- Нарушение связей между таблицами и «невидимость» свежих данных в визуалах.

Чтобы устранить эту проблему, нужно синхронизировать типы данных в MySQL и Power BI, проверить очистку и преобразование полей в Power Query, а также удостовериться, что связи и фильтры в модели Power BI учитывают корректный тип столбца.
~~~

## 6. «Возможно, после изменения структуры таблиц в MySQL некоторые столбцы получили другие типы данных»
### 6.1.
Я тебя спросил:
~~~
В пункте 2 своего ответа пункта 2.2 ты писал:
```
   - Возможно, после изменения структуры таблиц в MySQL некоторые столбцы получили другие типы данных, что приводит к ошибкам или некорректным обновлениям в Power BI. 
```
Опиши подробнее, каким образом «после изменения структуры таблиц в MySQL некоторые столбцы получили другие типы данных» может приводить к проблеме клиента.
~~~

### 6.2.
Ты ответил:
~~~
Ниже описано, как именно изменения в схеме MySQL и смена типов данных в столбцах могут приводить к тому, что Power BI не отображает новые записи или работает некорректно при обновлении:

---

## 1. Несоответствие ожидаемого типа данных в Power BI

### Сценарий

1. **Столбец был `INT`, а стал `VARCHAR`**  
   - Ранее в MySQL поле хранило целочисленные значения (например, идентификаторы заказов). В Power BI это поле было настроено как числовое (Whole Number).  
   - После изменения типа в базе на `VARCHAR` значения могут содержать буквы, пробелы, дефисы и т. п.  
   - При загрузке Power BI пытается конвертировать текст в число. Если встретит некорректные символы, возникнут либо ошибки преобразования (Conversion Error), либо часть строк будет заменена на `Null`.

2. **Столбец был `VARCHAR`, а стал `DECIMAL` (или другой числовой тип)**  
   - Если до изменения в столбце находились чисто текстовые данные (например, коды с буквами), а теперь предполагается хранить только числа с плавающей точкой, то в Power BI возможны разрывы в преобразованиях.  
   - Если Power Query продолжает трактовать поле как текст, новые числовые значения могут «обрезаться» или некорректно интерпретироваться (например, «1.23» может восприниматься как строка «1,23» в другой локали и вызывать ошибки).

3. **Столбец был `DATE/DATETIME`, а стал `VARCHAR`**  
   - Если раньше Power BI воспринимал столбец как дату, и в отчётах были фильтры по дате (например, срез «за месяц»), то при смене типа в MySQL на текст Power BI может потерять возможность фильтровать по календарю.  
   - Новые строки (хранящиеся как текст) перестают попадать в корректные диапазоны дат и не отображаются в визуалах.

---

## 2. Нарушение связей (Relationships) и логики модели

### Сценарий

1. **Ключевой столбец (Primary/Foreign Key) меняет тип**  
   - Если столбец, который связывает таблицу фактов и таблицу измерений (например, `OrderID`), из `INT` превращается в `VARCHAR`, в Power BI связь может стать «битой».  
   - При обновлении модели Power BI может не найти соответствия в типах и либо отключить связь, либо показать предупреждение/ошибку.  
   - В результате новые записи не «присоединяются» к справочным таблицам, а визуалы показывают неполную информацию.

2. **Изменение типа полей, участвующих в фильтрации**  
   - Если поле, по которому чаще всего делают срезы (например, «Категория товара»), внезапно сменило тип (или структуру значений) в базе, Power BI может не суметь отфильтровать новые записи.  
   - Часто это приводит к тому, что часть срезов (slicers) перестаёт работать или новые категории не отображаются.

---

## 3. Ошибки при обновлении (Refresh) и пропуск новых данных

### Сценарий

1. **Power Query ждёт старой структуры**  
   - В M-коде (шаги преобразований) может быть прописано явное преобразование столбца к определённому типу (например, `Int64.Type`). Если теперь столбец в MySQL стал текстовым, при обновлении мы получим ошибку «Couldn’t convert to Number» или аналогичные.  
   - Иногда Power BI «тихо» заменяет проблемные строки на `Null` и не сообщает явно об ошибке, из-за чего кажется, что «новые данные не пришли».

2. **Инкрементальное обновление «теряет» новые записи**  
   - Если используется Incremental Refresh (инкрементальное обновление) по дате или по другому полю, а тип этого поля неожиданно поменялся в MySQL, Power BI может не идентифицировать новые строки для включения в диапазон обновления.  
   - В результате инкрементальное обновление либо пропускает часть данных, либо вылетает с ошибкой из-за неверного типа.

---

## 4. Признаки проблемы и где их искать

1. **Сообщения об ошибках в Power Query**  
   - При ручном обновлении в Power BI Desktop часто всплывает окно с указанием, что не удалось преобразовать текст к числу (или число к дате).  
   - Либо в списке шагов Power Query некоторые шаги помечены крестиком (ошибкой), указывающей на несоответствие типов.

2. **Пустые или «(Blank)» значения в визуалах**  
   - Если Power BI «не смог» корректно конвертировать значение, в итоговой модели может появиться множество `Blank`.  
   - Фильтры и меры, завязанные на таких столбцах, возвращают непредсказуемые результаты.

3. **Частичное отсутствие новых строк**  
   - Может показаться, что часть новых данных появилась, а часть — нет. Это возможно, если отдельные строки удовлетворяют требованиям преобразования (например, содержат только цифры), а другие нет (содержат буквы, нестандартные символы и т. д.).

---

## 5. Как проверить и устранить проблему

1. **Проверить актуальную структуру MySQL**  
   - Использовать `DESCRIBE table_name;` или аналогичные инструменты (MySQL Workbench, DBeaver, phpMyAdmin), чтобы увидеть новые типы полей после изменения схемы.  
   - Обратить особое внимание на ключевые и часто используемые столбцы.

2. **Сравнить с Power Query**  
   - Открыть редактор Power Query и для каждой таблицы посмотреть, какие типы столбцов назначены (иконки «ABC», «1.2», «Date», «Any» и т. д.).  
   - Если обнаружился конфликт (например, в базе `VARCHAR`, а в Power Query — `Decimal Number`), нужно вручную настроить корректное преобразование.

3. **Перестроить (или обновить) шаги преобразований**  
   - Проверить каждый шаг (Step) в Query Editor (особенно те, где есть `Changed Type`, `Renamed Columns`, `Table.SelectColumns`). Убедиться, что новые столбцы или новые типы данных учитываются.  
   - Если есть строки с некорректными символами, решить, как их обрабатывать (заменять на `Null`, фильтровать или чистить текст).

4. **Убедиться в правильной настройке связей**  
   - «Manage Relationships» → проверить, не слетела ли связь из-за смены типа ключевого поля. При необходимости выбрать правильную кардинальность и сопоставить совпадающие типы данных.  
   - Если связь была «Many-to-Many» (многие-ко-многим), перепроверить логику — возможно, теперь она не нужна или, наоборот, стала обязательной.

5. **Протестировать полное обновление**  
   - Сделать «Refresh» в Power BI Desktop. Если всё прошло успешно и данные отобразились, опубликовать обновлённый отчёт в Power BI Service (если используется облачная среда).  
   - Проверить расписание обновлений (Scheduled Refresh) и логи — нет ли там новых ошибок.

---

## Итог

Когда в MySQL меняется структура и типы данных столбцов (из-за миграций, оптимизаций или других правок), модель Power BI может «отстать» от актуального состояния базы. Если Power BI продолжает ожидать старые типы полей, то при обновлении:

- **Часть новых данных отбрасывается** из-за ошибок преобразования.  
- **Могут слететь связи**, и записи не будут отображаться в визуалах.  
- **Фильтры и меры** перестают корректно работать, не показывая свежие значения.

Чтобы этого избежать, важно после любых изменений в схеме MySQL оперативно синхронизировать модель Power BI: проверить шаги Power Query, типы данных и связи в отчёте, а также протестировать обновление, убедившись, что все новые записи загружаются и визуализируются верно.
~~~

## 7. «В «Шаги» (Steps) внутри Power Query мог закрасться баг (например, ссылка на несуществующее поле)»
### 7.1.
Я тебя спросил:
~~~
В пункте 3 своего ответа пункта 2.2 ты писал:
```
   - В «Шаги» (Steps) внутри Power Query мог закрасться баг (например, ссылка на несуществующее поле). 
```
Опиши подробнее, каким образом «В «Шаги» (Steps) внутри Power Query мог закрасться баг (например, ссылка на несуществующее поле)» может приводить к проблеме клиента.
~~~

### 7.2.
Ты ответил:
~~~
Ниже рассмотрены основные ситуации, когда в процессе подготовки данных (Power Query) могут появиться ошибки из-за некорректных шагов (Steps), в частности при обращении к несуществующим столбцам или при других сбоях в M-коде. Это приводит к тому, что обновлённые (новые) данные из MySQL не доходят до визуалов в Power BI или часть строк пропадает.

---

## 1. Сломанные ссылки на удалённые или переименованные столбцы

1. **Изменение структуры MySQL**  
   - Если в базе данных MySQL был удалён или переименован столбец, а в Power Query по-прежнему есть шаг `Table.SelectColumns`, `Rename Columns` или другой, ссылающийся на старое имя, при обновлении возникнет ошибка.  
   - В результате весь следующий за этим шагом процесс трансформации может «обрушиться», и в итоге новые данные не будут попадать в итоговую модель.

2. **Явная выборка нужных столбцов (SelectColumns)**  
   - В M-коде встречается конструкция вида `Table.SelectColumns(PreviousStep, {"ColA", "ColB", ...})`. Если из исходной таблицы исчез один из столбцов или поменялось его имя, Power Query выдаст сообщение об ошибке вроде «Column ‘ColA’ not found».  
   - Когда такая ошибка появляется, дальнейшие шаги не выполняются, и в итоге визуалы могут показывать устаревшие данные или вовсе пустые значения.

---

## 2. Проблемы с автоматическим определением столбцов

1. **Автодетектирование и изменение типа**  
   - Power Query автоматически пытается определить типы столбцов и их названия на основе структуры данных при первом подключении. Если потом в источнике (MySQL) структура изменилась, а пользователь не обновил её в Query Editor, ссылки на «старые» столбцы сохраняются.  
   - Автодетектирование может «почти» правильно отработать, но если новый столбец не подходит под старые шаги (либо вместо старого столбца появилось поле с другим именем), Power Query потеряет согласованность.

2. **Шаблонные (generic) шаги**  
   - Иногда в M-коде встречаются функции или шаги, зависящие от имени столбца, которое меняется динамически (например, автоматически сформированные названия при «Развернуть таблицу» (Expand Table Column) или «Pivot/Unpivot»). Любое изменение структуры может «сломать» такой код.

---

## 3. Скрытые ошибки, ведущие к пропуску строк

1. **Молчаливое отбрасывание проблемных строк**  
   - В некоторых сценариях Power Query не прерывает процесс, а просто заменяет «проблемные» значения (или даже целые строки) на `Null`. Визуально это может быть незаметно на этапе редактирования, но при обновлении появится меньше строк, чем есть в базе.  
   - Клиент замечает, что «новые записи не отображаются», хотя технически обновление проходит без явной ошибки. В логах же (в Power Query или в сервисе Power BI) может быть предупреждение, что часть строк пропущена.

2. **Нарушение логики на последующих шагах**  
   - Один «битый» шаг (например, несуществующий столбец) может вызвать сбои в цепочке зависимых шагов. Если в одном шаге недоступен столбец `ColA`, а в следующем шаге идёт фильтрация по этому же столбцу, все новые данные (или даже вся таблица) окажутся недоступны в итоге.

---

## 4. Ошибки в формульных выражениях (M-коде)

1. **`#"Changed Type"` и другие автошаги**  
   - При создании запроса Power Query добавляет автоматические шаги, такие как `#"Changed Type"`, где для каждого столбца прописано:  
     ```m
     Table.TransformColumnTypes(
       PreviousStep, 
       {
         {"Column1", Int64.Type}, 
         {"Column2", type text}, 
         ...
       }
     )
     ```
   - Если теперь в источнике переименовали `Column1` → `NewColumnName`, а в этом шаге осталось старое название, возникнет «Column ‘Column1’ not found».  
   - Либо если `Column1` остался, но его тип в MySQL изменился (например, на текст), а в шаге всё ещё прописан `Int64.Type`, при обновлении возникнет ошибка преобразования типа.

2. **Ручные правки в M-коде**  
   - Если разработчик напрямую редактировал M-код, мог случайно допустить опечатку в названии столбца или таблицы. При ручном обновлении в Desktop это может проявиться сразу, либо может «всплыть» только в облачном Power BI Service (в зависимости от настроек).

3. **Функции объединения (Merge, Append)**  
   - При объединении таблиц (Merge Queries или Append Queries) Power Query ожидает, что в обеих таблицах есть определённые столбцы. Если в одной из таблиц столбец был удалён или переименован на стороне MySQL, объединение «поломается» и новые записи не будут корректно сопоставлены (или вовсе не появятся).

---

## 5. Признаки проблемы, связанные с «битым» шагом в Power Query

1. **Ошибка при ручном обновлении**  
   - При нажатии «Refresh» в Power Query Editor может появиться всплывающее окно с текстом вроде «Expression.Error: The column ‘…’ of the table wasn’t found…».  

2. **Красный крестик рядом с шагом**  
   - В списке Applied Steps (Применённые шаги) появляется «иконка ошибки». Нажав на шаг, можно прочитать причину ошибки в правом окне («не найден столбец», «ошибка преобразования типа» и т. д.).

3. **Частичное отсутствие данных**  
   - Если Power Query не выдаёт явную ошибку, а лишь «съедает» строки, то на этапе визуализации в отчёте мы обнаружим, что новые записи из MySQL «не приехали», хотя обновление будто бы прошло успешно.

4. **Различие количества строк в Source и в финальной таблице**  
   - Иногда можно заметить, что на шаге «Source» или «Navigation» отображается, к примеру, 1000 строк, а после нескольких шагов — только 850 строк. При этом в базе может быть 1100 строк (из них 100 новые), но из-за ошибки в каком-то шаге «теряются» и старые, и новые данные.

---

## 6. Как обнаружить и устранить подобные баги

1. **Проверить все шаги (Applied Steps)**  
   - В редакторе Power Query (Query Editor) последовательно кликать на каждый шаг. Если где-то появляется ошибка, нужно выяснить её причину (не найден столбец, неверное преобразование типа и т. д.).  
   - Часто уже по названию шага («Changed Type», «Renamed Columns», «Expanded ColumnX») можно понять, где мог нарушиться соответствующий столбец.

2. **Сверить список столбцов с реальной структурой MySQL**  
   - Использовать `DESCRIBE table_name;` (или MySQL Workbench, DBeaver и т. п.), чтобы увидеть актуальные названия и типы столбцов. Сравнить с тем, что Power Query пытается выбрать в шаге `Table.SelectColumns` или `Table.RenameColumns`.

3. **Обновить (или убрать) явные ссылки на старые столбцы**  
   - Если столбец удалён из MySQL, но продолжает фигурировать в Power Query, — нужно либо удалить шаг, который пытается выбрать или переименовать этот столбец, либо подставить новое имя, если было переименование.

4. **Использовать «Восстановить столбцы» (Rebuild) при необходимости**  
   - Иногда проще заново выбрать нужные столбцы, чем пытаться вручную править шаги, если структура сильно изменилась. Можно удалить лишние шаги и заново применить «Choose Columns» или «Remove Other Columns».

5. **Проверить объединения (Merge, Append)**  
   - Если соединяются две таблицы, убедиться, что в обеих таблицах действительно есть те столбцы, по которым происходит объединение. При необходимости обновить поля для Merge.

6. **Повторно обновить запрос**  
   - После правок в редакторе Power Query заново выполнить «Refresh Preview», убедиться, что ошибка исчезла, а количество строк соответствует ожиданию.  
   - Затем вернуться в Power BI Desktop, сделать полноценный «Refresh» отчёта и проверить, подтянулись ли новые данные во все визуалы.

---

### Итог

Когда в «Шагах» Power Query оказывается ссылка на несуществующий столбец (или некорректный тип, или неверное имя таблицы), при обновлении могут происходить следующие сбои:

- Полное или частичное падение запроса с ошибкой.  
- Тихое отбрасывание проблемных строк и непопадание новых данных в итоговую модель.  
- «Съезжают» фильтры, меры и связи в Power BI, так как часть полей становится пустой или `Null`.

Чтобы исправить это, необходимо регулярно проверять Applied Steps в редакторе Power Query после любых изменений на стороне MySQL (удаление, добавление, переименование столбцов), корректировать ссылки и типы данных, а затем тестировать обновление, удостоверяясь, что все новые записи благополучно попадают в отчёт.
~~~

## 8. «Неверно прописанные фильтры»
### 8.1.
Я тебя спросил:
~~~
В пункте 3 своего ответа пункта 2.2 ты писал:
```
   - Неверно прописанные фильтры, фильтрация по старой схеме или забытые «условные столбцы» могут приводить к тому, что новые записи отбрасываются. 
```
Опиши подробнее, каким образом «Неверно прописанные фильтры» может приводить к проблеме клиента.
~~~

### 8.2.
Ты ответил:
~~~
Ниже рассмотрены основные сценарии, когда «неверно прописанные фильтры» (как на уровне Power Query, так и на уровне визуалов в Power BI) могут приводить к тому, что новые записи из MySQL не отображаются в отчётах:

---

## 1. Фильтры в Power Query (редактор запросов)

1. **Фильтрация строк (Row filtering)**  
   - В Power Query можно явно отфильтровать строки, используя шаги вроде `Table.SelectRows`, выборку по датам, по значениям столбца и т.п.  
   - Если этот фильтр жёстко зафиксирован (например, «Показывать записи только до 2024-12-31»), новые данные с датами после этой даты просто не попадут в итоговую модель Power BI.  
   - Или, если в фильтре есть условие по полю, которое изменилось в MySQL (название столбца или тип данных), фильтр может вести себя некорректно и «пропускать» (или «отсеивать») новые строки.

2. **Фильтр, завязанный на старой структуре**  
   - Бывает, что в Power Query оставлен фильтр по полю, которого уже нет в схеме MySQL (или оно было переименовано). В таком случае запрос может «тихо» выдавать меньше строк или вовсе обрываться, не сообщая в явном виде причину.  
   - Результат: часть данных не загружается, а пользователь видит только те строки, которые прошли через «старый» или некорректный фильтр.

3. **«Скрытая» фильтрация через автошаги**  
   - При первоначальном импорте данных Power Query может автоматически вставить шаги (например, автоопределение типов и фильтров). Если позже структура MySQL поменялась, в одном из шагов может оказаться неявный фильтр, который отсекает новые записи.  
   - Например, иногда Power Query при автоопределении типов помечает строки с ошибкой преобразования как «удалённые» (Remove Errors). Тогда любые новые строки с непредусмотренным форматом тоже будут автоматически исключаться.

---

## 2. Фильтры на уровне визуалов и полей (Report / Data View в Power BI)

1. **Фильтры и срезы (Slicers) в отчёте**  
   - Если в визуале или на странице отчёта установлен срез (Slicer) или фильтр, который не учитывает новые значения (например, срез «Категория товара = ‘Старый’»), новые записи с другой «Категорией» не будут показаны.  
   - Иногда пользователь случайно забывает сбросить фильтр или выбирает слишком узкий диапазон дат («только последние 7 дней»), а новые данные могут относиться к более раннему/позднему периоду или не подходят под условие.

2. **Фильтры уровня страницы или уровня отчёта (Page/Report Filters)**  
   - В Power BI есть несколько уровней фильтрации: на отдельном визуале, на странице, на весь отчёт. Если на каком-то из уровней стоит ограничение (например, «Region = ‘East’»), а новые данные относятся к «West», они не появятся.  
   - Такие фильтры иногда бывают «невидимыми» для пользователя (особенно если их настроил другой человек), поэтому проверить все уровни фильтров — важный шаг.

3. **Row-Level Security (RLS)**  
   - Если настроена безопасность на уровне строк (RLS), пользователь может не видеть новые данные из-за того, что те «не попадают» в доступную ему область. Например, если у пользователя доступ только к записям, где `Region = ‘East’`, а новые записи имеют `Region = ‘South’`, они не будут показаны.  
   - Клиент может забыть, что у него вообще есть такой RLS-фильтр (или он был настроен администратором), и списывать всё на «ошибку обновления».

4. **Неверная логика в вычисляемых столбцах или мерах (Measures)**  
   - Иногда «фильтр» может появляться не в явном виде, а через DAX-вырaжения. Например, в вычисляемом столбце или мере есть условие, которое отбрасывает часть записей (например, `CALCULATE(SUM(…); Table[Column] = "SomeValue")`). Если в новых строках другое значение, они не включаются в расчёт и кажутся «пропавшими».

---

## 3. Проблемы с датами и временными интервалами

1. **Жёстко зафиксированный интервал дат**  
   - Если визуал показывает, к примеру, «Данные за январь 2025 года», а новые данные относятся к февралю 2025, они не отобразятся, пока пользователь не расширит фильтр даты.  
   - Аналогичная ситуация: в Power Query может быть настроен шаг типа «Filter Rows», где указано «DateColumn < 31.01.2025». Все более поздние даты не попадают в модель.

2. **Фильтр «Relative Date Filtering»**  
   - В Power BI есть особый тип фильтров («Relative Date Filtering» — «Фильтрация по относительной дате»). Если он некорректно настроен (например, «Показывать данные только за последние 30 дней»), а новые записи имеют дату, выходящую за эти рамки, они не появятся.

---

## 4. Кейс «Забытые условные столбцы» или сложные фильтрации в Power Query

1. **Условные столбцы (Conditional Columns)**  
   - Пользователь мог создать «условный столбец» (Conditional Column), где по определённым условиям (if / then / else) одни записи помечаются как «Include», другие — как «Exclude». Затем в следующем шаге фильтруются только «Include».  
   - Если новые записи не соответствуют нужному условию (или если логика была прописана под старый формат данных), они окажутся в категории «Exclude» и пропадут.  
   - Например, если условный столбец проверяет конкретный текст (например, «Category = "A"»), а в новых данных появляется «Category = "A1"», то такой товар будет отсеян.

2. **Группировка (Group By) с дополнительной фильтрацией**  
   - В некоторых сценариях пользователи перед группировкой (Group By) фильтруют таблицу, убирая строки «без продаж» или «с нулевым количеством». Если тип данных в новом поле или сама логика «больше 0» изменилась, новые записи могут не соответствовать фильтру.

---

## 5. Признаки, что проблема связана именно с фильтрами

1. **Отчёт обновляется, но в визуалах часть (или все) новые данные отсутствуют**  
   - При этом нет явных ошибок коннектора, ошибок преобразования типов и т. д.; просто новые строки как будто «невидимы» для отчёта.

2. **При снятии всех фильтров или при просмотре данных прямо в Query Editor новые записи «вдруг появляются»**  
   - Если в редакторе Power Query в самом первом шаге («Source» или «Navigation») видно, что новые записи есть, а на финальном шаге их нет, значит, где-то в промежутке стоит фильтр, который их убирает.  
   - Если в режиме отчёта нажать «Очистить фильтры» (Clear Filters) или удалить все срезы (Slicers), и данные начнут отображаться, значит фильтрация была причиной пропажи.

3. **При проверке «View Native Query» или логов базы видно, что SQL-запрос ограничивает строки**  
   - Если Power Query генерирует нативный SQL с условием типа `WHERE date < '2025-01-31'`, это явный сигнал, что в запросе есть жёсткий фильтр.

---

## 6. Как устранить проблему с фильтрами

1. **Проверить Applied Steps в Power Query**  
   - Просмотреть все шаги (Step by Step), особенно там, где есть `Table.SelectRows`, «Filter Rows», «Remove Rows» и т. п. Убедиться, что нет случайно зафиксированной даты, категории или другого ограничения, из-за которого отбрасываются нужные данные.

2. **Сравнить данные на уровне Source и на финальном шаге**  
   - Нажать на самый первый шаг (Source / Navigation) и посмотреть, сколько строк там (и есть ли там свежие). Затем кликать шаг за шагом, пока не станет ясно, на каком этапе количество строк сокращается (или пропадают новые записи).

3. **Изучить фильтры, срезы и уровень безопасности в Power BI**  
   - В режиме Report проверить Filter Pane (панель фильтров) для текущей страницы, для отчёта целиком, а также фильтры на уровне визуалов. Сбросить все фильтры и посмотреть, появятся ли данные.  
   - Если используется RLS, проверить роли, которые назначены пользователю. Убедиться, что новые записи не исключаются логикой RLS.

4. **Снять или скорректировать неверные фильтры**  
   - Если фильтр по дате или значению поля нужен, но диапазон устарел, расширить его (например, вместо «до 2025-01-31» сделать «до 2026-12-31» или вообще убрать верхнюю границу).  
   - Если фильтр был временным решением для теста, его нужно удалить, чтобы не мешал загрузке новых данных.

5. **Проверить визуалы и DAX-меры на предмет жёстко прописанных условий**  
   - Иногда в выражениях DAX (например, `CALCULATE(SUM(Sales[Amount]), Sales[Category] = "OldCat")`) жёстко стоит старая категория. Новые категории не попадут в вычисления. Нужно заменить на более универсальное условие или убрать его, если оно больше не актуально.

6. **Обновить отчёт**  
   - После снятия или корректировки фильтров сделать Refresh, убедиться, что новые данные подтянулись. Если всё в порядке, опубликовать обновлённую версию (если используется Power BI Service).

---

### Итог

«Неверно прописанные фильтры» (или забытые ограничения на уровне Power Query, визуалов, RLS и т.д.) часто становятся причиной того, что свежие строки из MySQL не видны в отчёте. При этом технически данные могут успешно загружаться, но из-за фильтрации они отбрасываются и не отображаются. Чтобы решить проблему, нужно последовательно проверить все места, где мог быть установлен фильтр (включая автоматические шаги Power Query и разные уровни фильтров в Power BI) и убедиться, что в модель попадают все необходимые данные.
~~~

## 9. «фильтрация по старой схеме»
### 9.1.
Я тебя спросил:
~~~
В пункте 3 своего ответа пункта 2.2 ты писал:
```
- Неверно прописанные фильтры, фильтрация по старой схеме или забытые «условные столбцы» могут приводить к тому, что новые записи отбрасываются.
```
Опиши подробнее, каким образом «фильтрация по старой схеме» может приводить к проблеме клиента.
~~~

### 9.2.
Ты ответил:
~~~
Ниже описаны основные ситуации, при которых «фильтрация по старой схеме» — то есть устаревшие фильтры или логика отбора данных, оставшаяся от прежней структуры MySQL или от первоначальной настройки Power Query, — могут приводить к тому, что новые записи не попадают в отчёт:

---

## 1. Фильтры, ссылающиеся на несуществующие/изменённые поля

1. **Удалён или переименован столбец, на который наложен фильтр**  
   - Если в MySQL столбец был переименован, а в Power Query остался шаг с фильтром `Table.SelectRows(...)`, где условие ссылается на старое название, при обновлении может возникать ошибка или тихий сбой.  
   - Иногда Power Query «молча» не применяет такой фильтр к новым данным, а иногда полностью обрывает загрузку. В итоге новые записи могут не пройти фильтрацию, потому что условие ссылается на неактуальное поле.

2. **Фильтры по старым значениям**  
   - Когда в базе меняются справочники или типы данных (например, «Статус заказа» был текстовый, а стал числовой), фильтр, ожидающий старые текстовые значения, не будет пропускать новые записи с другими статусами.  
   - Внешне может казаться, что «система не видит новых статусов», хотя причина — в устаревшем условии отбора.

---

## 2. Жёсткая селекция «Table.SelectColumns» и «Remove Other Columns»

1. **Старый набор столбцов**  
   - Если раньше в Power Query жёстко выбирали (через `Table.SelectColumns`) только определённые поля (например, `{"Date", "ProductID", "Amount"}`), а в MySQL поменяли схему или добавили новые поля (например, `Discount`), то фильтр/выборка по старой схеме может не только игнорировать новые поля, но и отбрасывать новые строки, если в них появились значения, несовместимые со старой логикой отбора (см. п. 3 о «условных столбцах»).  
   - Иногда в самих шагах могут стоять дополнительные условия (например, «взять столбец только если он не пуст»), которые не работают корректно с новыми столбцами.

2. **Исключение таблиц или представлений**  
   - При подключении к MySQL пользователь мог явно выбрать одну конкретную таблицу (которая больше не актуальна или переименована), а всю остальную схему (где есть новые данные) — проигнорировать.  
   - Если в старой схеме таблица называлась `sales_data`, а теперь она разделена на `sales_data_current` и `sales_data_history`, Power Query по-прежнему «цепляется» за `sales_data` и не видит новых записей в `sales_data_current`.

---

## 3. Забытая логика «условных столбцов» (Conditional Columns) и фильтрация

1. **Фильтрация на основании вычисляемого поля**  
   - В Power Query могли быть добавлены «условные столбцы» (Conditional Column), которые затем участвуют в фильтре. Например, создаётся столбец `CustomStatus` на основе нескольких старых полей (или старых значений).  
   - Если в MySQL эти поля изменили тип или удалили, вычисляемый столбец будет давать ошибку или `Null` вместо ожидаемых значений. Тогда шаг фильтрации (который выбирает строки, где `CustomStatus = "Active"`) станет некорректным, и все новые строки могут отбрасываться.

2. **Жёсткие проверки против устаревших кодов**  
   - Допустим, условный столбец проверяет, равен ли «код продукта» некоему фиксированному значению. Если в MySQL коды теперь другие (или столбца с кодами вообще нет), логика отбора не пройдёт, и новые записи не пройдут фильтр.  
   - В результате создаётся впечатление, что данные не обновляются, хотя фильтр просто не пропускает их.

---

## 4. Использование старых параметров запроса (Query Parameters)

1. **Параметры Power Query с жёстко зашитым условием**  
   - Например, в Power Query есть параметр `StartDate` = 2024-01-01, и в шаге фильтра мы видим: `Table.SelectRows(Source, each [OrderDate] >= StartDate)`. Если в базе поле `OrderDate` поменялось на `Timestamp` (другой тип), или теперь хранится как текст, фильтр может не находить совпадений.  
   - При этом пользователь может и не догадываться, что этот параметр устарел, и что новые данные (с другим форматом дат) отбрасываются.

2. **Фильтры «склейки строк» в SQL**  
   - Иногда в Power Query создают «дополнительные» фильтры на уровне исходного SQL-запроса (через «Advanced Query»), где поля фильтруются по старой логике. Если в MySQL эти поля переименованы, обновлённые строки могут не удовлетворять WHERE-условию.

---

## 5. Режим DirectQuery и старые фильтры

1. **Условия в DAX или Custom SQL**  
   - Если отчёт работает в режиме DirectQuery и где-то в настройках (или в самом DAX) зашиты фильтры вида `FILTER('Table', 'Table'[SomeField] = "OldValue")`, то при изменении структуры и значений в MySQL новые записи с другими значениями поля не попадут в результат.  
   - Такое часто встречается, когда разработчики вручную прописывают ограничение «показывать только записи актуального состояния», но забывают обновить условие, если в MySQL теперь используются другие статусы, даты, коды и т. д.

2. **Row-Level Security (RLS)**  
   - Если включена RLS, и правила фильтрации (Roles) построены на поле, которое менялось в MySQL (переименовали столбец, заменили значение), могут появиться «дыры» в доступе — новые записи не соответствуют старому условию безопасности, поэтому не показываются для конкретных ролей пользователей.

---

## 6. Признаки проблемы и как её обнаружить

1. **Внешне всё обновляется без явных ошибок**  
   - Power BI может не показывать ошибок в логах, потому что фильтр — технически корректный, просто он «выбирает 0 строк» из новых данных.  
   - Пользователи видят, что «дата обновления» отчёта свежая, но при этом никаких новых записей в визуалах нет.

2. **Сравнение количества строк в исходном запросе и итоговой таблице**  
   - Если сделать в Power Query шаг с просмотром исходной таблицы (Source) и увидеть там, скажем, 10 000 строк, а в финальном шаге (после всех фильтров) остаётся 9 800, возможно, 200 новых строк отфильтровалось по условию, уже неактуальному для новой схемы.

3. **Отсутствие новых справочных значений**  
   - Если в фильтрах использовались справочники (Dimension Tables), и в них появились новые категории или коды, которые не учтены в условиях отбора, тогда новые категории вообще не попадут в отчёт.  
   - Например, есть условие «Category IN (‘A’, ‘B’, ‘C’)», а в базе появилась новая категория ‘D’, которая остаётся «за бортом».

---

## 7. Как устранить проблему «фильтрации по старой схеме»

1. **Аудит всех шагов Power Query**  
   - Проверить Applied Steps:  
     - Где именно мы делаем фильтрацию (SelectRows)?  
     - Есть ли жёстко прописанные значения (строки, даты, статусы)?  
     - Существуют ли ссылки на старые названия столбцов или таблиц?

2. **Сравнить логику фильтрации с актуальной структурой MySQL**  
   - Убедиться, что все поля, по которым мы фильтруем, реальны и содержат нужные значения.  
   - Проверить, не изменились ли справочные таблицы, статусы, коды. При необходимости обновить условие фильтра.

3. **Пересмотреть «SelectColumns» / «Remove Other Columns»**  
   - Если в M-коде есть шаги, которые выбирают только ограниченный набор столбцов, проверить, нет ли там случайного отбрасывания новых полей. Возможно, стоит использовать «Remove Other Columns» осознанно или, наоборот, удалить этот шаг, чтобы сохранять все новые столбцы.

4. **Проверить параметры (Query Parameters) и пользовательские функции**  
   - Убедиться, что устаревшие параметры дат, статусов или диапазонов больше не перекрывают новые записи.  
   - При необходимости скорректировать их под новую схему данных.

5. **Убедиться в корректной работе RLS (если используется)**  
   - Проверить, что правила безопасности не фильтруют новые записи из-за несовпадения старых/новых значений полей.

6. **Тестовое обновление и сверка итоговых данных**  
   - После внесения правок обновить Power Query (Refresh Preview) и затем обновить весь отчёт в Power BI Desktop.  
   - Сравнить количество строк/значений, попадающих в модель, с тем, что есть в MySQL (например, сделав SQL-запрос напрямую).

---

### Вывод

«Фильтрация по старой схеме» — это ситуация, при которой в Power Query (или в самом Power BI) сохранились настройки отбора (старые столбцы, значения, статусы), не соответствующие реальным данным в MySQL после обновлений или изменений структуры. В результате **новые записи могут тихо отбрасываться**, не попадая в итоговую модель. Чтобы исправить это, важно регулярно проверять и актуализировать все фильтры, условия, связанные таблицы и параметры, чтобы они отражали текущее состояние базы данных и позволяли новым данным корректно загружаться в отчёт.
~~~

## 10. «забытые «условные столбцы»»
### 10.1.
Я тебя спросил:
~~~
В пункте 3 своего ответа пункта 2.2 ты писал:
```
- Неверно прописанные фильтры, фильтрация по старой схеме или забытые «условные столбцы» могут приводить к тому, что новые записи отбрасываются.
```
Опиши подробнее, каким образом «забытые «условные столбцы»» может приводить к проблеме клиента.
~~~

### 10.2.
Ты ответил:
~~~
Ниже описано, что такое «условные столбцы» в Power Query, как они могут «забыться» или быть настроены неверно, и почему из-за этого новые записи иногда не попадают в итоговые данные отчёта.

---

## 1. Что такое «условные столбцы» (Conditional Columns) в Power Query

- **Условный столбец** — это столбец, значение которого рассчитывается на основе одного или нескольких условий, заданных пользователем.  
- В редакторе Power Query его можно создать через меню «Add Column» → «Conditional Column». В окне «Добавление условного столбца» вы указываете логику типа:  
  - Если `[Category] = "Electronics"`, то вернуть `"Tech"`.  
  - Если `[Category] = "Clothes"`, то вернуть `"Apparel"`.  
  - И так далее.  

При этом Power Query формирует M-код, где для каждой строки исходных данных проверяются условия и подставляется результат, либо `null`/значение по умолчанию, если ни одно условие не выполнено.

---

## 2. Как «забытые» или неверно настроенные условные столбцы могут приводить к отбрасыванию новых данных

1. **Фильтрация на базе условного столбца**  
   - После создания условного столбца пользователь может добавить фильтр (например, оставить только строки, где условный столбец не равен `null` или имеет определённое значение).  
   - Если новые данные не удовлетворяют прописанным условиям (или условие сработало иначе, чем ожидалось), в условном столбце может появиться `null` (или другое «неподходящее» значение).  
   - В результате на следующем шаге Power Query (или в самом этом шаге) строки с таким значением фильтруются и исчезают из набора данных.

2. **Условие, «не видящее» новые коды или категории**  
   - Часто условные столбцы создают, чтобы категоризировать данные по некоему справочнику (например, «если код товара 100–200, то это категория A, если 201–300, то категория B»). Если в MySQL появились новые коды (скажем, 301 и дальше), а в условном столбце нет логики для них, они могут оставаться с `null` или вообще вызывать ошибку.  
   - Дальше либо стоит фильтр «где столбец не равен null», либо DAX-вычисление, которое не учитывает `null`. В итоге новые записи «теряются».

3. **Старая логика, ориентированная на устаревшие значения**  
   - Допустим, раньше поле `[Status]` в MySQL могло принимать значения `"Open"`, `"Closed"`, `"Pending"`. А условный столбец был прописан так:  
     - Если `[Status] = "Open"`, то `"Открытые"`.  
     - Если `[Status] = "Closed"`, то `"Закрытые"`.  
     - Иначе — `null`.  
   - Если теперь в MySQL появились новые статусы (например, `"In Progress"`, `"On Hold"` и т. д.), они в условном столбце окажутся `null`. Если где-то стоит фильтр «[Условный столбец] <> null», новые строки отсеются.

4. **Ошибки или пропуски при создании/редактировании условного столбца**  
   - Иногда разработчик случайно прописывает условие вида «Если `[FieldX] = "ABC"`» (строгое равенство), хотя в данных может быть `"Abc"` или другие варианты. Из-за чувствительности к регистру или тонкостей сравнения условие для новых строк не срабатывает.  
   - В результате столбец становится `null` и, если дальше идёт фильтрация на `null`, — строки игнорируются.

5. **Влияние автогенерированных шагов**  
   - Когда пользователь добавляет условный столбец, Power Query автоматически создаёт соответствующий шаг. Если затем структура данных в источнике изменилась (переименовался столбец, появились новые значения), но условный столбец не обновили под новую схему, логика может давать неверные результаты и отбрасывать новые записи.

---

## 3. Почему проблему с условным столбцом бывает не сразу видно

1. **Нет явной ошибки**  
   - Часто при условных столбцах Power Query не выдаёт «красного» сообщения об ошибке, даже если большая часть строк получает `null`. С точки зрения M-кода, это всё ещё «валидный» результат.  
   - Пользователю при обновлении кажется, что всё работает, т. к. никаких аварийных сообщений нет, однако фактически новые данные не проходят фильтр.

2. **Локально в Desktop данные могут показываться, а в Service — нет**  
   - При тестировании несколько строк могут «вписаться» в условия, а в полноценной БД — наоборот. Или наоборот, в Service используется другой диапазон данных (инкрементальное обновление), и там новые строки вообще игнорируются.  
   - Создаётся путаница: «почему при локальном обновлении вроде вижу часть данных, а онлайн нет?».

3. **Условный столбец мог быть создан давно и «забыт»**  
   - Иногда модель разрабатывалась поэтапно, и кто-то когда-то добавил условный столбец, который теперь неочевиден. Человек, который сейчас поддерживает отчёт, может не подозревать о существовании этого шага/фильтра в Power Query.

---

## 4. Как распознать, что условный столбец «съедает» новые записи

1. **Внимательно просмотреть Applied Steps**  
   - В редакторе Power Query кликнуть на каждый шаг и смотреть предварительный просмотр (Preview). Обращать внимание, где резко уменьшается количество строк или где большая часть значений условного столбца становится `null`.  
   - Если заметно, что на одном из шагов происходит значительный «отсев» строк, смотреть логику условного столбца и последующих фильтров.

2. **Сравнить условия с реальными данными в MySQL**  
   - Проверить, какие значения на самом деле находятся в поле, по которому строится условный столбец. Возможно, там появились новые категории, статусы, форматы, а в условном столбце они не учтены.  
   - Если условная логика не охватывает новые значения, все такие строки попадут в ветку `Else`, которая может быть `null`, и затем фильтроваться.

3. **Смотреть на изменения в M-коде**  
   - Открыть шаг с условным столбцом в режиме «Дополнительно» (Advanced Editor) и убедиться, что все условия действительно соответствуют реальной задаче.  
   - Например, если есть что-то вроде:  
     ```m
     = Table.AddColumn(
         PreviousStep, 
         "CustomColumn", 
         each if [Status] = "Open" then "Откр" 
              else if [Status] = "Closed" then "Закр"
              else null
       )
     ```  
     и в MySQL недавно добавили `Status = "InProgress"` или `"Hold"`, — эти значения вернут `null`.

---

## 5. Как исправить проблему с условными столбцами

1. **Обновить логику условия**  
   - Добавить ветвь в условие для новых значений (либо общий сценарий «иначе = что-то разумное», если статус незнакомый).  
   - Либо расширить диапазоны (например, если раньше были жёсткие интервалы `IF [Value] < 100 THEN "Low"`, стоит убедиться, что для `Value > 100` тоже есть ветка).

2. **Убрать или изменить фильтр, зависящий от условного столбца**  
   - Если фильтр «CustomColumn <> null» уже не нужен, его можно отключить или перенастроить.  
   - Если нужна логика выбора только определённого значения, убедиться, что новые данные не должны туда попадать (или настроить, чтобы попадали при нужном условии).

3. **Перепроверить соответствие типов данных**  
   - Если условный столбец ожидает, что `[Field]` будет числом, а в MySQL это строка, сравнения могут работать не так, как задумано. Привести к корректному типу (числу, тексту, дате) до применения условий.

4. **Добавить диагностику**  
   - В Power Query можно добавить шаги, которые подсчитывают, сколько строк проходит на каждом этапе (например, используя превью или пользовательские функции). Это позволит быстро найти место, где строки «пропадают».

5. **Документировать логику**  
   - Если модель поддерживает несколько человек, полезно описать, зачем был нужен условный столбец, по каким полям идёт условие, чтобы в будущем при изменении структуры MySQL сразу знать, куда заглянуть.

---

### Итог

Когда в Power Query остаются «забытые» или неверно сконфигурированные условные столбцы, они могут:

- **Неправильно обрабатывать новые значения** (новые коды, статусы, диапазоны).  
- **Выдавать `null`**, а затем фильтр «отсекает» такие строки.  
- **Тихо терять часть данных**, если логика не учитывает новые сценарии или формы записи.  

Чтобы избежать этого, нужно периодически просматривать Applied Steps, обновлять условные столбцы под изменения в MySQL и следить за фильтрами, зависящими от таких столбцов. Если же условный столбец не нужен, лучше удалить или отключить его, чтобы не возникало неожиданного отсеивания данных.
~~~

## 11. «Неактивированные/неверно настроенные инкрементальные обновления»
### 11.1.
Я тебя спросил:
~~~
В пункте 4 своего ответа пункта 2.2 ты писал:
```
4. **Неактивированные/неверно настроенные инкрементальные обновления**  
   - Если включено инкрементальное обновление, но оно неправильно настроено (не те поля для отслеживания, неверные диапазоны дат и т. п.), новые данные могут не попадать в итоговый набор.
```
Опиши подробнее, каким образом «Неактивированные/неверно настроенные инкрементальные обновления» может приводить к проблеме клиента.
~~~

### 11.2.
Ты ответил:
~~~
Ниже рассмотрено, как именно неправильные настройки или отсутствие инкрементального обновления (Incremental Refresh) в Power BI могут приводить к тому, что новые данные в MySQL не отображаются в отчётах:

---

## 1. Что такое инкрементальное обновление и зачем оно нужно

**Инкрементальное обновление** (Incremental Refresh) — это механизм Power BI (особенно в Power BI Service и Power BI Premium), который позволяет загружать только новые или изменённые данные за определённый период, вместо того чтобы каждый раз полностью перезагружать всю таблицу. Это значительно ускоряет процесс обновления и снижает нагрузку на источники данных.

Однако, если инкрементальное обновление **неверно настроено**, может возникнуть ситуация, при которой новые записи просто не попадают в модель Power BI.

---

## 2. Проблемы при «неактивированном» инкрементальном обновлении

1. **Избыточная полная загрузка вместо инкрементальной**  
   - Если инкрементальное обновление в принципе **не включено**, а набор данных (dataset) очень большой, то при попытке полного рефреша могут происходить сбои или тайм-ауты.  
   - В результате Power BI может не завершать обновление корректно, и последние данные «не докачиваются» до отчёта. В сервисе Power BI это иногда проявляется как «Failed Refresh» с ошибкой, и пользователь видит лишь старые данные.

2. **Отсутствие обновлений на уровне сервиса**  
   - Некоторые полагают, что инкрементальный механизм «включён по умолчанию», но на самом деле нужно явно настраивать Policy (политику) инкрементального обновления (RangeStart, RangeEnd и т. д.).  
   - Если этого не сделано, а в расписании (Scheduled Refresh) есть лишь попытки полного рефреша, новые данные могут не загружаться или загружаться не полностью при больших объёмах.

---

## 3. Проблемы при «неверно настроенном» инкрементальном обновлении

### 3.1 Неправильный выбор столбца для отслеживания изменений

- **Инкрементальное обновление требует столбца типа «дата/время»** (DateTime) или «числового» (реже используют числовые surrogate keys) для того, чтобы понимать, какие строки новые или изменённые.  
- Если при настройке указали неподходящий столбец (например, не тот, в котором реально отражается дата создания или изменения записи), Power BI будет «пропускать» свежие данные.  
  - Пример: в MySQL есть столбец `CreatedDate`, а в настройках инкрементального обновления в Power BI случайно указали `OrderDate`. Если при сохранении записи `OrderDate` остаётся пустым или не обновляется, новые строки не попадут в диапазон инкрементального обновления.

### 3.2 Неверные диапазоны дат (RangeStart, RangeEnd)

- **Механизм инкрементального обновления в Power BI** опирается на параметры `RangeStart` и `RangeEnd`, чтобы определять, какой временной период загружать/обновлять.  
- Если границы установлены неправильно (например, `RangeStart` лежит дальше во времени, чем фактическое начало данных), или же `RangeEnd` стоит в прошлом дне вместо текущего, новые записи, которые выпадают за эти границы, могут вовсе не загружаться.  
- Может случиться и такая ситуация: при переезде на другой месяц или год настройки параметров забыли обновить — Power BI считает, что работает лишь с предыдущим периодом, а «свежие» данные остаются за рамками фильтра.

### 3.3 Проблемы с обновлением политики (Partition Policy)

- При работе с инкрементальным обновлением Power BI разбивает данные на партиции (Partitional Data). Если эта политика сформирована неверно (к примеру, слишком короткие или длинные интервалы, либо неправильные правила обновления старых партиций), часть строк может не освежаться.  
- Иногда при ручном вмешательстве в настройки партиций (особенно в Power BI XMLA- или табличной модели) можно случайно задать «заморозку» старых партиций и пропустить обновление новых.

### 3.4 Неправильная логика «Изменённые строки» (Detect data changes)

- В Power BI можно настроить инкрементальное обновление не только на добавленные, но и на **изменённые** строки (Detect data changes) с помощью дополнительного столбца (например, `LastModifiedDate`).  
- Если этот столбец не обновляется в MySQL при изменении строк, Power BI не будет считать их «изменёнными» и не загрузит обновлённую версию данных.  
- В итоге клиент видит, что какие-то новые или откорректированные записи так и не попали в отчёт.

---

## 4. Признаки, указывающие на проблему с инкрементальным обновлением

1. **Запланированный (Scheduled) рефреш проходит без явных ошибок, но новые данные не видны**  
   - В логе обновлений (Refresh History) сервис Power BI может указывать, что обновление выполнилось успешно, — однако в отчёте новые строки не появляются.

2. **Данные видны только при полном обновлении (Refresh) в Desktop**  
   - Если пользователь вручную в Power BI Desktop делает «Refresh», и все данные загружаются, а при автоматическом (или ручном) обновлении в облаке «что-то» не появляется, это прямой признак неверной конфигурации инкрементального механизма или шлюза (Gateway).  

3. **Отставание во времени**  
   - Заметно, что данные «застряли» на определённой дате, хотя в базе MySQL есть более свежая информация. Возможно, в настройках указан слишком короткий или вообще неактуальный диапазон.  

4. **Ошибки при публикации модели**  
   - Если при публикации набора данных с инкрементальным обновлением Power BI предупреждает о несоответствии типов столбца (дата/время), либо о неправильной конфигурации RangeStart/RangeEnd, нужно проверить, правильно ли всё настроено.

---

## 5. Как проверить и исправить настройки инкрементального обновления

1. **Убедиться, что столбец для инкремента действительно отражает «новые» записи**  
   - Например, в MySQL может быть столбец `CreatedAt` (дата создания) или `UpdatedAt` (дата последнего изменения). Надо выбрать тот, который действительно будет «двигаться» вместе с новыми данными.  

2. **Проверить тип столбца**  
   - Столбец, по которому идёт инкремент, должен быть формата «Дата/Время» в Power BI. Если он числовой (например, `YYYYMMDD`), тоже можно настроить инкремент, но важно корректно трактовать этот столбец (Whole Number или Decimal) и учесть это в параметрах RangeStart/RangeEnd.

3. **Проверить RangeStart и RangeEnd**  
   - Зайти в Power Query Editor → «Manage Parameters» → «RangeStart», «RangeEnd» (или иные названия). Убедиться, что они заданы корректно и включают период, в котором находятся новые данные.  
   - При необходимости расширить диапазон или проверить логику (особенно при переходе на следующий месяц/год).

4. **Обновить политику (Partition Policy)**  
   - В настройках инкрементального обновления (в Power BI Desktop: «Modeling» → «Incremental Refresh» для набора данных) настроить, сколько лет/месяцев хранить (Store) и сколько из них переобновлять (Refresh).  
   - Убедиться, что нужные интервалы не заблокированы и что Power BI не пытается «закрыть» партиции, в которые ещё приходят данные.

5. **Проверить столбец «Detect data changes» (если используется)**  
   - Если включена галочка «Detect data changes», убедиться, что в базе MySQL действительно обновляется дата изменения (или счётчик версий) для новых/изменённых строк.  
   - Если этого нет, либо обновляется не в том формате, Power BI будет считать, что строки не менялись.

6. **Ручное тестовое обновление в Power BI Service**  
   - После правок настроек опубликовать отчёт в сервис Power BI и нажать «Refresh now».  
   - Посмотреть в «Dataset → Settings → Refresh History», прошло ли обновление успешно и какой объём строк был обработан.  
   - Сравнить полученный результат с фактическим количеством строк в MySQL.

---

## Итог

Если инкрементальное обновление в Power BI **не настроено** или настроено **некорректно**:

- Новые записи могут **никогда не подгружаться** в отчёт, если они не попадают в ошибочно заданный диапазон дат (или другой ключевой столбец).  
- При ошибочном выборе столбца для инкрементального отслеживания Power BI может считать, что новых или изменённых строк **нет**, и пропускать загрузку.  
- При «неактивированном» инкрементальном обновлении система может пытаться делать полный рефреш, который **прерывается** ошибками или тайм-аутом, и, как следствие, **свежие данные не обновляются**.

Чтобы устранить проблему, нужно тщательно проверить:

1. Какой столбец выступает в роли «дата/время» или счётчика изменений.  
2. Корректны ли параметры RangeStart и RangeEnd (или их аналоги).  
3. Работает ли механизм Detect data changes, если он включён.  
4. Включено ли инкрементальное обновление в принципе и не «слетели» ли настройки при последних изменениях модели.

После правильной настройки инкрементального обновления Power BI будет подгружать только новые или изменённые строки из MySQL, и проблема с «пропавшими» новыми данными должна решиться.
~~~

## 12. «Сломанный или некорректно сконфигурированный шлюз (Data Gateway)»
### 12.1.
Я тебя спросил:
~~~
В пункте 5 своего ответа пункта 2.2 ты писал:
```
- Сломанный или некорректно сконфигурированный шлюз (Data Gateway) может не обновлять данные из базы MySQL.
```
Опиши подробнее, каким образом «Сломанный или некорректно сконфигурированный шлюз (Data Gateway)» может приводить к проблеме клиента.
~~~

### 12.2.
Ты ответил:
~~~
Ниже рассмотрены основные аспекты, при которых неправильная конфигурация или поломка Power BI Gateway (Шлюза данных) может приводить к тому, что отчёты Power BI не получают новые данные из MySQL и не отображают актуальную информацию.

---

## 1. Зачем нужен Data Gateway

1. **Связь между облаком и локальными источниками**  
   - Если база MySQL расположена в локальной инфраструктуре (on-premises) или за корпоративным файрволом, сервис Power BI (в облаке) не может напрямую подключиться к этой базе.  
   - Data Gateway обеспечивает зашифрованный канал, через который Power BI Service обращается к локальному серверу MySQL и получает обновлённые данные.

2. **Единая точка управления соединением**  
   - Gateway хранит учётные данные и настройки подключения, позволяя централизованно настраивать доступ к базе.  
   - Пользователи могут в отчётах указать источник «через шлюз», не настраивая вручную сетевые подключения.

---

## 2. Основные проблемы с некорректным шлюзом

1. **Неверные или устаревшие учетные данные (credentials)**  
   - При настройке шлюза нужно указать логин и пароль для MySQL, а также указать правильный сервер/порт/название базы. Если эти данные введены некорректно или поменялись в MySQL, а в шлюзе осталось старое значение, обновление не сработает.  
   - Результат: Power BI Service при запуске refresh пытается подключиться, получает ошибку авторизации и не загружает новые данные.

2. **Сбои из-за несовместимости версий**  
   - Шлюз (On-premises Data Gateway) регулярно обновляется. Если его версия устарела или не совместима с текущим выпуском Power BI, могут возникать ошибки при подключении к базе MySQL.  
   - Также сама MySQL может быть обновлена до версии, с которой старая сборка Gateway не умеет корректно работать.

3. **Неправильно настроенный драйвер MySQL**  
   - Для подключения к MySQL через шлюз необходим ODBC- или другой драйвер, который Gateway будет использовать. Если драйвер не установлен или установлен неверной версии (например, 32-бит вместо 64-бит при требуемом 64-битном шлюзе), соединение ломается.  
   - Нередко забывают на Production-сервере установить соответствующий драйвер, в итоге соединение «из облака» не работает.

4. **Проблемы с сетевыми и файловыми разрешениями**  
   - Gateway должен иметь доступ к сети, где расположен сервер MySQL. Если файрвол (Firewall) или прокси-сервер блокирует нужные порты (например, порт 3306), то Power BI Service не сможет достучаться до MySQL через шлюз.  
   - При внутренней ошибке или при выключенном порте на самом сервере MySQL соединение будет постоянно отбрасываться.

5. **Сбой самого сервиса шлюза**  
   - Программа (служба) On-premises Data Gateway должна работать на фоне (Windows service). Если по каким-то причинам служба остановлена, зависла или некорректно запущена, то все запросы из Power BI Service будут заверяться ошибкой.  
   - Нередко это происходит после перезагрузки сервера, когда служба Gateway не успела стартовать или стартовала с ошибкой.

---

## 3. Как это выглядит со стороны Power BI

1. **Ошибки при обновлении (Refresh failed)**  
   - В журнале обновлений (Refresh history) Power BI Service может появиться сообщение вида:  
     > "The gateway is not reachable"  
     > "Invalid connection credentials"  
     > "Could not create a connection to the data source"  
   - При локальном обновлении в Power BI Desktop всё может работать (если доступ к MySQL настроен напрямую), а вот в сервисе — нет, именно из-за проблем со шлюзом.

2. **Отсутствие новых данных в отчёте**  
   - Если шлюз не работает, сервис Power BI не сможет выполнить запланированное обновление (Scheduled Refresh). Отчёт останется «замороженным» на старом состоянии данных.  
   - Пользователи видят устаревшие визуалы, где отсутствуют новые записи из MySQL.

3. **Сбой при тесте соединения с шлюзом**  
   - В настройках набора данных (DataSet Settings) в Power BI можно проверить Gateways и «Test connection». Если шлюз настроен неправильно, тест выдаёт ошибку.

---

## 4. Частые причины некорректной конфигурации шлюза

1. **Неверно указанный сервер или база**  
   - В параметрах шлюза можно ошибиться в названии MySQL-сервера, IP-адресе или имени базы. Даже мелкие опечатки приводят к «Could not resolve server name» или «Unknown database».  
   - Или в MySQL изменилась схема / название БД, а в шлюзе — старые настройки.

2. **Истёкшие, неправильные учётные данные**  
   - Если администратор MySQL сменил пароль пользователя, а в шлюзе остался старый пароль, при следующем обновлении появится ошибка авторизации.  
   - Иногда после смены пароля в самом интерфейсе Power BI забывают обновить его в конфигурации шлюза.

3. **Отсутствующие права (permissions)**  
   - Учётная запись, под которой шлюз обращается к MySQL, может не иметь достаточных прав для чтения всех нужных таблиц (например, новый пользователь с ограничениями).  
   - При попытке выполнить SELECT на определённые таблицы / поля MySQL возвращает «Access denied».

4. **Отключенный/необновлённый сервис Gateway**  
   - Администраторы могут случайно отключить службу Gateway в Windows. Или служба не запускается после обновления системы.  
   - Без запущенной службы никакие запросы не будут передаваться из облака в локальную сеть.

5. **Несовпадение битности (32/64) или версии .NET Framework**  
   - Если шлюз требует 64-битную среду, а установлен 32-битный драйвер MySQL, интеграция не сработает.  
   - Или установлена старая версия .NET, которая не совместима с текущим релизом шлюза.

---

## 5. Как проверить и устранить проблему со шлюзом

1. **Проверить статус шлюза**  
   - В «Управлении шлюзами» (Power BI Service → Settings → Manage Gateways) посмотреть, включён ли шлюз, работает ли он (Online/Offline).  
   - Убедиться, что нет статуса «Not configured correctly» или «Offline».  

2. **Тестировать соединение**  
   - В настройках источника данных (Data Source Settings) внутри шлюза нажать «Test Connection». Если видим ошибки, изучить их текст, чтобы понять проблему (пароль неверен, сервер недоступен и т. д.).  

3. **Обновить версию шлюза и драйвер MySQL**  
   - С официального сайта Microsoft скачать последнюю версию On-premises Data Gateway.  
   - Убедиться, что установлен подходящий драйвер для MySQL (ODBC или Connector/NET) соответствующей битности.  

4. **Перепроверить учётные данные**  
   - Зайти в «Управление источником данных» (Manage Data Sources) → «Edit credentials», ввести актуальный логин и пароль.  
   - При необходимости проверить, есть ли у этого пользователя MySQL права SELECT на нужные таблицы.  

5. **Убедиться в корректной сети и открытых портах**  
   - На сервере, где установлен шлюз, проверить, что порт 3306 (или другой, если MySQL настроен нестандартно) не блокируется файрволом.  
   - Проследить, что шлюз видит MySQL-сервер в локальной сети (ping, telnet, mysql -h ...).  

6. **Перезапустить службу Gateway**  
   - Иногда достаточно перезапустить (или переустановить) службу On-premises Data Gateway на сервере, чтобы восстановить корректное соединение.  

7. **Проверить логи**  
   - Логи шлюза (обычно в C:\Program Files\On-premises data gateway\logs или схожих путях) могут подсказать, почему соединение падает.  
   - При возникновении специфических ошибок (SSL-сертификаты, TLS-версии и т. п.) логи дают больше деталей.  

---

## Итог

Если Data Gateway сломан или настроен неверно, Power BI Service просто не сможет «добраться» до MySQL, чтобы подтянуть новые данные. В результате при обновлении отчёта данные остаются старыми или рефреш падает с ошибками. Решение состоит в том, чтобы:

- **Проверить статус шлюза** (онлайн/офлайн).  
- **Обновить** сам Gateway до последней версии.  
- **Убедиться в корректных настройках**: правильный сервер, база, логин/пароль, драйвер MySQL, сетевые порты.  
- **Проверить права** пользователя MySQL и работоспособность службы в Windows.

После устранения проблем со шлюзом обновление снова начинает успешно получать свежие данные из MySQL, и визуалы в отчёте Power BI отображают актуальную информацию.
~~~

## 13. «Учетные данные (credentials) просрочены или не совпадают с теми, что нужны для чтения новых данных»
### 13.1.
Я тебя спросил:
~~~
В пункте 5 своего ответа пункта 2.2 ты писал:
Учетные данные (credentials) просрочены или не совпадают с теми, что нужны для чтения новых данных.

Опиши подробнее, каким образом «Учетные данные (credentials) просрочены или не совпадают с теми, что нужны для чтения новых данных.» может приводить к проблеме клиента.
~~~

### 13.2.
Ты ответил:
~~~
Ниже описано, каким образом проблемы с учётными данными (credentials) могут приводить к тому, что новые данные из MySQL не отображаются в Power BI:

---

## 1. Истечение срока действия (expiration) или утрата актуальности учётных данных

1. **Пароль устарел или был принудительно сброшен**  
   - В некоторых организациях действует политика регулярной смены паролей. Если пароль для подключения к MySQL меняется (или сбрасывается администратором), а в Power BI остался «старый» пароль, то при обновлении данные больше не подтягиваются.  
   - Иногда при локальной работе в Power BI Desktop учётные данные ещё актуальны, а в сервисе Power BI (через шлюз, Power BI Gateway) — уже нет.

2. **Учетная запись (логин) может быть заблокирована**  
   - Если администратор базы или система безопасности заблокировала пользователя за превышение числа неудачных попыток входа или за нарушение политики, соединение с базой будет невозможным.  
   - Это приведёт к тому, что при попытке обновить отчёт в Power BI появится ошибка авторизации или, в некоторых случаях, обновление просто не отдаст нужные данные.

---

## 2. Несоответствие прав доступа новому набору данных

1. **Недостаточно прав для чтения новых таблиц или столбцов**  
   - Допустим, разработчики добавили в MySQL новые таблицы или поля, а права (GRANT SELECT) на них не были выданы текущему пользователю. При обновлении Power BI не сможет читать новые данные и, соответственно, не покажет их в отчёте.  
   - Даже если старые таблицы доступны, но часть столбцов теперь закрыта для чтения, новые записи (например, ссылающиеся на эти столбцы) могут не подгружаться корректно.

2. **Изменения в политике безопасности**  
   - Иногда администраторы меняют роль пользователя (например, снимают часть привилегий). Если у пользователя остались только права на определённую схему или ограниченные столбцы, Power BI при запросе данных из всей таблицы/схемы может получать неполный результат или ошибку.  
   - Это особенно актуально, если новые данные фактически пишутся в другой схеме или таблице, где у прежнего пользователя нет прав.

---

## 3. Разница между локальными учётными данными и данными для Power BI Service

1. **Другие credential’ы в Power BI Desktop и в Power BI Service**  
   - Часто бывает, что при настройке подключения в Power BI Desktop пользователь вводит одни данные авторизации, а при публикации отчёта в сервис Power BI забывает обновить учётные данные в настройках источника данных (Data Source Settings) или в шлюзе (Gateway).  
   - В итоге локально (в Desktop) отчёт может работать и отображать новые данные, а в облаке (на портале Power BI) при автоматическом обновлении используется «старый» или неверный логин/пароль. Тогда в облаке отчёт не видит обновлённых данных.

2. **Проблемы с Power BI Gateway**  
   - Если используется локальный шлюз (On-premises Data Gateway) для доступа к MySQL, нужно, чтобы в нём были настроены правильные, свежие учетные данные. Если там остался старый пароль или неверное имя пользователя, при попытке Scheduled Refresh (запланированного обновления) получим ошибку.  
   - Иногда обновление проходит «формально», но возвращает пустой или неполный набор строк, если права ограничены.

---

## 4. Ошибки при переезде или смене сервера MySQL

1. **Подключение к старому серверу**  
   - Если в организации была миграция на новый сервер MySQL, а старые учётные данные ведут к «застывшей» базе (которая больше не обновляется или даже не содержит новых таблиц), Power BI будет каждый раз обращаться к этой «старой» базе. Естественно, никаких новых записей там не появится.  
   - Это часто не выглядит как явная ошибка — просто данные больше не обновляются.

2. **Новые реквизиты подключения**  
   - При переезде на новый сервер меняется адрес (хост/порт), возможно — имя базы (schema), а также могут меняться и учётные данные. Если в Power BI забыли обновить эти параметры, загрузка новых данных будет невозможна.

---

## 5. Признаки проблем с учётными данными

1. **Сообщения об ошибках авторизации**  
   - При ручном обновлении отчёта в Power BI Desktop или в логах Power BI Service может появляться ошибка вроде:  
     > `We couldn’t authenticate with the credentials provided`  
     или  
     > `Invalid username or password`  
   - Однако если кто-то не проверяет логи, то может просто видеть, что «данные не обновились».

2. **Неполные данные без явной ошибки**  
   - Если учётная запись частично ограничена (например, нет прав на новые столбцы), Power BI может загружать «старые» столбцы без явной ошибки, но новые поля останутся пустыми или не будут видны.  
   - При этом пользователь замечает, что «новые записи не отображаются» или «недостаёт новых колонок», хотя формально загрузка «проходит успешно».

3. **Разное поведение в Desktop и в облаке**  
   - На локальной машине (Power BI Desktop) всё прекрасно обновляется (потому что там хранится верный логин/пароль), а в опубликованной версии отчёта (на сайте Power BI) — нет. Это классический признак несинхронизированных учётных данных.

---

## 6. Как проверить и устранить проблему

1. **Проверить настройки источника данных (Data Source Settings) в Power BI Desktop**  
   - Убедиться, что в разделе «Data source settings» → «Change source…» или «Edit Credentials…» указаны актуальные логин/пароль и правильный сервер MySQL.  
   - При необходимости обновить пароль, если он недавно менялся.

2. **Проверить настройки в Power BI Service**  
   - Зайти в раздел «Datasets» → «Settings» (Настройки) → «Data source credentials» (Учётные данные источника). Убедиться, что там прописан тот же логин/пароль, что и в Desktop, и он «Valid».  
   - Если используется Gateway, открыть «Manage Gateways», найти нужный источник данных и сверить учётные данные. Иногда их нужно вручную обновить.

3. **Проверить права пользователя в MySQL**  
   - Попросить администратора MySQL выполнить `SHOW GRANTS FOR 'user_name'@'host';` и посмотреть, есть ли необходимые привилегии (SELECT, а если нужны обновления — UPDATE, INSERT и т. д.) для нужных таблиц/баз.  
   - Убедиться, что таблицы, где лежат новые данные, тоже входят в список доступных для чтения объектов.

4. **Тестовое подключение вне Power BI**  
   - Можно попробовать подключиться к MySQL теми же логином/паролем через клиент (MySQL Workbench, DBeaver и т. п.) и проверить, видны ли новые таблицы/записи. Если там доступ отсутствует, значит, проблема не в Power BI, а в правах MySQL.

5. **Синхронизировать Environment (окружения)**  
   - Убедиться, что Desktop, Gateway и Service указывают на один и тот же сервер/базу и используют одинаковые credentials. Если они отличаются, то логично, что где-то данные будут обновляться, а где-то нет.

6. **Отслеживать изменения паролей**  
   - Если в организации введена политика регулярного изменения паролей, нужно завести процедуру (или напоминание), чтобы своевременно обновлять пароль в Power BI Service/Gateway.

---

### Итог

Если учётные данные, которыми Power BI подключается к MySQL, устарели (сменился пароль или пользователь был заблокирован) или не имеют достаточных прав (нет доступа к новым таблицам/столбцам), то при обновлении отчёта новые данные не попадут в модель. Проблема может проявляться по-разному:

- Прямые ошибки авторизации, из-за которых обновление вообще не проходит.  
- Тихое «отсутствие» новых записей в отчёте, если у учётной записи нет прав на их чтение.  
- Различия в результатах обновления между локальным Desktop и сервисом (если там заданы разные credentials).

Для решения нужно проверить и привести в соответствие учётные данные в настройках Power BI и права доступа в MySQL, чтобы Power BI имел возможность полноценно видеть и загружать новые (и старые) данные.
~~~

## 14. «При режиме Import данные могут не обновляться в реальном времени»
### 14.1.
Я тебя спросил:
~~~
В пункте 6 своего ответа пункта 2.2 ты писал:
```
- При режиме Import данные могут не обновляться в реальном времени, а в расписании обновления могла произойти ошибка.
```
Опиши подробнее, каким образом «При режиме Import данные могут не обновляться в реальном времени» может приводить к проблеме клиента.
~~~

### 14.2.
Ты ответил:
~~~
Ниже рассмотрено, как использование режима **Import** (импорт данных в Power BI) и отсутствие «живого» подключения может приводить к тому, что новые записи из MySQL не отображаются сразу в отчётах и дашбордах:

---

## 1. Как работает режим Import в Power BI

1. **Импорт данных «срезом» (Snapshot)**  
   - При режиме Import Power BI загружает все выбранные данные из источника (MySQL) в собственную внутрь-памятную модель (базу данных на движке Vertipaq).  
   - После этого отчёт работает с уже загруженными данными (кэшем), а **не** с данными непосредственно из MySQL в реальном времени.

2. **Необходимость «ручного» или «планового» обновления**  
   - Чтобы данные в отчёте обновились, нужно выполнить обновление (Refresh). Это может быть ручное обновление в Power BI Desktop или запланированное обновление (Scheduled Refresh) в Power BI Service.  
   - Если обновление не произошло (или произошло с ошибками), данные в отчёте останутся теми, что были на момент последней удачной загрузки.

---

## 2. Почему в Import-режиме отчёт не показывает новые данные «здесь и сейчас»

1. **Зависимость от расписания (Schedule Refresh)**  
   - Если отчёт опубликован в Power BI Service, чаще всего ему назначают расписание обновления (например, раз в день, раз в час и т. п.). Между запусками обновления данные в отчёте не меняются.  
   - Если в MySQL появляются новые записи в 15:00, а следующее обновление запланировано на 16:00, то пользователь с 15:00 до 16:00 не увидит эти новые записи в отчёте.

2. **Ошибки или сбои при запланированном обновлении**  
   - Даже если расписание существует, возможны сбои (проблемы со шлюзом, неверные учётные данные, таймауты и т. п.). Тогда обновление «падает» и в отчёте продолжает отображаться старая информация.  
   - В таком случае пользователю кажется, что «мы нажимаем обновление, но ничего не меняется», хотя на самом деле отчёт просто не получает свежую порцию данных.

3. **Отсутствие ручного обновления в Power BI Desktop**  
   - Если разработчик проверяет отчёт в Power BI Desktop и видит старые данные, возможно, он не сделал «Refresh» внутри Desktop после обновления базы MySQL. Или, если сделал, но увидел ошибку (и не устранил её), данные не обновились.

---

## 3. Ситуации, при которых клиент может думать, что «обновил базу, но Power BI не видит новые записи»

1. **Нет автоматического обновления**  
   - Клиент внёс изменения в MySQL (например, загрузил новую информацию об операциях), ожидает, что отчёт «тотчас» покажет свежие данные. Но поскольку режим Import не обновляет модель «на лету», в отчёте по-прежнему старые цифры.

2. **Неправильное или редкое расписание обновлений**  
   - Если расписание стоит только раз в сутки (в полночь), то все данные, появившиеся в течение дня, в отчёт попадут лишь после полуночи.  
   - Пользователи, которые смотрят отчёт днём, не увидят актуальных данных и подумают, что «обновление не работает».

3. **Ошибки настроек Gateway**  
   - При размещении отчёта в облаке (Power BI Service) и использовании локального MySQL-сервера нужен Power BI Gateway. Если шлюз не настроен правильно (или не запущен), обновление просто не происходит — отчёт в сервисе остаётся со старыми данными.

---

## 4. Как именно это может приводить к «неотображению» новых данных

1. **Клиент обновил MySQL, но в отчёте данные не изменились**  
   - Поскольку модель Power BI в Import-режиме не «подтягивает» данные сама по себе в реальном времени, клиент замечает, что «новые записи не появятся, пока не сработает очередной рефреш или пока вручную не нажмут обновление в Desktop/Service».

2. **Пользователи полагают, что отчёт «в реальном времени»**  
   - Иногда есть недопонимание: пользователи думают, что любой отчёт Power BI сразу «заглядывает» в базу, как только там появились новые строки. Но в Import-режиме этого не происходит — нужна отдельная операция Refresh.  
   - Из-за этого складывается впечатление, что «отчёт не работает», хотя на самом деле он просто не обновлялся по расписанию или вручную.

---

## 5. Признаки, что дело именно в режиме Import, а не в других ошибках

1. **Успешный рефреш всё же подтягивает свежие данные**  
   - Если после нажатия «Refresh» в Power BI Desktop (или после срабатывания расписания) данные **всё-таки** обновляются, но не обновлялись между этими событиями — это классический признак Import-режима.

2. **Визуалы показывают устаревшую дату выгрузки**  
   - Часто в отчёте или в заголовке указывают дату последнего обновления (Last Refresh Date). Если там написано «Последнее обновление: вчера 23:00», а у нас уже 15:00 текущего дня, значит новые данные ещё не загрузились.  
   - Проверка журнала обновлений (Refresh History) в Power BI Service также покажет, когда последний раз обновлялась модель.

3. **Отсутствие прямого соединения (DirectQuery) или Live Connection**  
   - Если посмотреть в «Настройки источника данных» (Data Source Settings) и увидеть, что у таблиц/запросов выбран режим Import, то ясно, что данные грузятся пакетами, а не транслируются в реальном времени.

---

## 6. Как решить или обойти проблему в Import-режиме

1. **Настроить корректное расписание обновлений (Scheduled Refresh)**  
   - Установить более частый интервал обновлений (например, каждые 15–30 минут, если объём данных и лицензия Power BI позволяют).  
   - Внимательно проверить конфигурацию шлюза (Data Gateway), убедиться, что там верно указаны учётные данные для MySQL, и что обновление действительно проходит без ошибок.

2. **Использовать ручной рефреш при необходимости**  
   - При работе в Power BI Desktop (или на сайте Power BI Service) можно вручную нажать кнопку «Refresh now». Если новые данные должны отобразиться «прямо сейчас», это помогает при условии, что нет других препятствий (ошибок запросов, конфликтов типов данных и т. д.).

3. **Перейти на DirectQuery (если подходит под сценарий)**  
   - Если очень важно видеть данные в реальном времени, можно рассмотреть режим DirectQuery. Тогда Power BI будет напрямую выполнять SQL-запросы к MySQL при каждом взаимодействии с визуалами.  
   - Однако для MySQL и DirectQuery требуются определённые условия (включая производительность базы, сетевую доступность, ограничения на DAX-функциональность). Не всегда это лучший выбор, особенно при больших объёмах данных или сложной трансформации.

4. **Учитывать лимиты Power BI**  
   - В бесплатной и Pro-версии есть ограничения по количеству ежедневных обновлений (до 8 в Pro, до 1 в Free), а также по размеру набора данных и ряду других параметров. Нужно убедиться, что эти лимиты не мешают своевременно обновлять отчёт.

---

### Итог

Если отчёт в Power BI настроен в режиме **Import**, то:

- **Данные не обновляются автоматически в момент их появления** в MySQL.  
- **Обновление** происходит только по расписанию или при ручном запросе (Refresh).  
- Если **расписание не настроено** (или настроено редко) либо **происходит сбой** в обновлении, отчёт будет показывать **старые данные**.  

В результате пользователи видят «неактуальные» цифры, даже когда в базе MySQL уже есть новые записи. Это может создавать впечатление, что «дашборды и визуалы не отображают новую информацию», хотя на самом деле проблема в том, что модель в Import-режиме просто не загружала (не «импортировала») свежие данные.
~~~

## 15. «в расписании обновления могла произойти ошибка»
### 15.1.
Я тебя спросил:
~~~
В пункте 6 своего ответа пункта 2.2 ты писал:
```
- При режиме Import данные могут не обновляться в реальном времени, а в расписании обновления могла произойти ошибка.
```
Опиши подробнее, каким образом «в расписании обновления могла произойти ошибка» может приводить к проблеме клиента.
~~~

### 15.2.
Ты ответил:
~~~
Ниже рассмотрены основные причины и механизмы, из-за которых при режиме **Import** в Power BI может возникнуть ошибка в расписании обновления (Scheduled Refresh), приводящая к тому, что в отчёт не попадают новые данные из MySQL:

---

## 1. Проблемы с учётными данными (Credentials)

1. **Истёкшие или неверные Credentials**  
   - Если в настройках подключения (Data Source Settings) или в Power BI Service при настройке Scheduled Refresh указаны неверные учётные данные (пароль поменялся, аккаунт заблокирован и т. п.), автоматический рефреш будет прерываться ошибкой.  
   - При этом в самом отчёте могут оставаться данные от последней удачной ручной загрузки (Refresh в Desktop), и пользователь не заметит проблему сразу.

2. **Изменения на стороне MySQL**  
   - Если администратор на стороне MySQL поменял правила аутентификации, добавил SSL-сертификаты, ограничил IP-адреса или port, а в Power BI остались старые настройки, Scheduled Refresh может перестать работать корректно.

---

## 2. Сбой в Data Gateway

1. **Некорректная конфигурация или сбой Gateway**  
   - Если для подключения к локальной базе MySQL используется **On-premises Data Gateway**, любые проблемы с самим шлюзом (не запускается служба, отсутствует связь с сервером, устаревшая версия gateway) приведут к ошибке обновления.  
   - Power BI Service регулярно пытается запустить рефреш по расписанию; если соединиться с MySQL не удаётся, задача падает с ошибкой, и новые данные не загружаются.

2. **Конфликт версий**  
   - При обновлении Power BI Gateway (или MySQL Connector) может случиться конфликт версий. Например, если установлен новый коннектор, а Gateway не обновлён до соответствующей версии, рефреш будет выдавать ошибку.

---

## 3. Неправильное или отключённое расписание

1. **Расписание не настроено вовсе**  
   - Иногда пользователь считает, что обновление по расписанию есть, но на самом деле никакое расписание не задано (или оно было отключено). В результате Power BI Service не делает попыток обновить отчёт.  
   - Тогда новые данные появятся только после ручного обновления в Desktop и повторной публикации.

2. **Ошибки в конфигурации расписания**  
   - Может быть задано условие инкрементального обновления (Incremental Refresh), но при этом неверно прописаны диапазоны дат или Partition Policy. В итоге система «думает», что нет новых данных в целевом диапазоне, и не догружает свежие записи.  
   - Либо расписание стоит слишком редко или в неудобное время (например, один раз в месяц), и пользователь ожидает новые данные «сегодня», а обновление запланировано только через неделю.

3. **Ограничение на количество обновлений**  
   - В Power BI Pro обычно есть лимит на 8 обновлений в сутки (в Power BI Premium — больше). Если настроено слишком частое обновление, часть «запусков» может просто не выполняться, а пользователь не замечает, что новые данные не подтягиваются.

---

## 4. Ошибки при выполнении самого процесса обновления (Refresh Error)

1. **Time-out или медленный SQL-запрос**  
   - Если запрос к MySQL обрабатывается очень долго, может происходить таймаут в Power BI Service. Тогда Scheduled Refresh падает с ошибкой.  
   - Итог: отчёт так и остаётся на старом состоянии данных.

2. **Недостаточно ресурсов (Memory, CPU) на сервере Gateway**  
   - Если при выполнении обновления нагрузки слишком высоки, шлюз может «не успеть» обработать большой объём данных и выдать ошибку.  
   - В логах Power BI Service можно увидеть сообщения о нехватке ресурсов или обрыв соединения (Disconnect).

3. **Частичные обновления (отсутствие повторных попыток)**  
   - Если обновление стартовало, но «упало» на середине, у Power BI Service есть ограниченные механизмы повторной попытки (retry). Если retry не сработал — рефреш полностью прерван.  
   - В некоторых сценариях может загрузиться только часть данных (например, одна таблица успела обновиться, другая — нет), что приводит к расхождениям в отчёте.

---

## 5. Отсутствие явных уведомлений для пользователя

1. **Пользователь может не следить за ошибками рефреша**  
   - Владелец отчёта или другой пользователь иногда не проверяет вкладку «Refresh history» в Power BI Service, где отображаются все удачные/неудачные обновления.  
   - Если за этим не следить, можно долго не замечать, что новые данные не загружаются.

2. **Последние данные «кажутся» свежими**  
   - Визуально в отчёте нет явного указания на дату последнего успешного обновления (или это не вынесено на дашборд). Пользователи думают, что видят «текущую» картину, хотя на самом деле данные «застыли» на момент последнего удачного рефреша (например, неделю назад).

---

## 6. Как проверить и устранить проблему в расписании обновления

1. **Проверить статус обновлений в Power BI Service**  
   - Зайти в **Datasets** или **Dataflows** (если используется Dataflow) → «Schedule Refresh» → «Refresh history». Там видно, были ли ошибки (Failed, Cancelled) или успехи (Completed).  
   - Если ошибки есть, прочитать текст: часто он указывает на некорректные креденшлы, сбой в gateway, timeout или иные причины.

2. **Убедиться, что Gateway доступен и работает**  
   - В разделе **Manage Gateways** проверить статус установленного шлюза и соответствие версий.  
   - Попробовать «Test all connections» (Проверка всех подключений). Если тест не пройден, нужно обновить или перенастроить gateway.

3. **Перепроверить учётные данные**  
   - В **Data source credentials** заново ввести логин/пароль для MySQL. Убедиться, что они валидны и имеют нужные права (SELECT) на целевую схему/таблицы.

4. **Оптимизировать запросы**  
   - Если рефреш часто падает по таймауту, имеет смысл улучшить SQL-запросы (добавить индексы, сократить объём выгружаемых данных, использовать инкрементальные обновления).  
   - Проверить, не слишком ли большой набор данных обрабатывается при каждом запуске.

5. **Настроить уведомления о сбое обновления**  
   - В Power BI Service можно настроить оповещения по e-mail, когда рефреш не удался. Это позволит быстрее реагировать на проблемы.  
   - Или использовать сторонние инструменты мониторинга, если нужно более гибкое оповещение.

6. **Соблюдать лимиты и планировать частоту обновления**  
   - Если отчёт обновляется очень часто, убедиться, что он не превышает лимиты (например, 8 раз в сутки для Pro).  
   - Выставить расписание так, чтобы рефреш выполнялся в периоды меньшей нагрузки на сервер MySQL и Gateway.

---

### Итог

Когда Power BI работает в режиме **Import**, данные не подтягиваются автоматически «на лету» из MySQL, а берутся из загруженного набора (dataset) в определённые моменты — при ручном обновлении (Refresh) в Desktop или по **расписанию** (Scheduled Refresh) в Service. Если в расписании произошла ошибка — будь то сбой соединения, неверные креденшлы, устаревший Gateway или лимиты обновлений, — свежие данные не будут видны в отчёте. При этом пользователи могут и не заметить проблему, полагая, что дашборд «актуален», пока не проверят историю обновлений или не увидят нестыковку с реальными данными в MySQL. Правильная диагностика и настройка Scheduled Refresh — один из ключевых шагов, чтобы новые данные корректно отображались в Power BI.
~~~

## 16. «В случае DirectQuery могут возникать проблемы с запросами из-за ограничения прав или неверной конфигурации сервера»
### 16.1.
Я тебя спросил:
~~~
В пункте 6 своего ответа пункта 2.2 ты писал:
```
В случае DirectQuery могут возникать проблемы с запросами из-за ограничения прав или неверной конфигурации сервера
```
Опиши подробнее, каким образом «В случае DirectQuery могут возникать проблемы с запросами из-за ограничения прав или неверной конфигурации сервера» может приводить к проблеме клиента.
~~~

### 16.2.
Ты ответил:
~~~
Ниже описано, почему при использовании режима DirectQuery в Power BI могут возникать проблемы с отображением новых данных из MySQL, если присутствуют ограничения прав доступа, неправильная конфигурация сервера или прочие сетевые/инфраструктурные сбои.

---

## 1. Что такое DirectQuery в контексте Power BI

1. **Режим DirectQuery**  
   - В этом режиме Power BI не загружает данные «внутрь» себя (как при Import). Вместо этого все запросы и фильтры при построении визуалов напрямую отправляются в источник данных (MySQL).  
   - При каждом действии пользователя (изменение слайсера, фильтра, переход на другую страницу отчёта) Power BI формирует SQL-запрос и отправляет его на сервер MySQL.

2. **Особенности**  
   - Преимущество: данные всегда «живые» (актуальные), без необходимости полного рефреша набора данных.  
   - Недостаток: возможны задержки в обработке запросов, зависимость от производительности сервера и наличия нужных прав.

---

## 2. Проблемы с правами (permissions) на стороне MySQL

1. **Ограниченные права учетной записи**  
   - Если в MySQL пользователь (credential), через которого Power BI подключается, не имеет прав SELECT на новые таблицы (или столбцы), то при попытке запросить данные эти столбцы будут «пустыми» или вернётся ошибка.  
   - Аналогично, если на уровне MySQL настроен Row-Level Security (или аналог с помощью VIEW/политик), и у данной учётной записи нет доступа к новым записям, то Power BI не увидит эти строки.

2. **Изменение схемы без обновления прав**  
   - Часто бывает, что администраторы MySQL меняют структуру базы (добавили новую таблицу, перенесли столбцы), но не выдали права на чтение этой новой части схемы. В результате пользователь, под которым работает Power BI, не может читать данные.  
   - При Import-режиме это заметнее (обновление упадёт с ошибкой), а при DirectQuery может казаться, что «просто не отображаются новые записи», поскольку SQL-запрос возвращает пустой результат для новых участков схемы.

3. **Неявное блокирование (Locks) или ограничения транзакций**  
   - Если MySQL-сервер использует специфичные механизмы блокировок, при которых запросы на чтение части данных не разрешены (или задерживаются), то Power BI в DirectQuery-режиме не дождётся ответа в разумные сроки и может возвращать старые кэшированные результаты или выдавать ошибку.  
   - На практике это встречается реже, но тоже может привести к тому, что пользователь «не видит» свежие данные.

---

## 3. Неверная конфигурация сервера, сетевые и инфраструктурные проблемы

1. **Настройки MySQL, не поддерживающие нужные запросы**  
   - Если MySQL-сервер настроен так, что блокирует определённые SQL-предикаты, JOIN’ы или подзапросы, которые генерирует Power BI, то результат может возвращаться частично или выдаваться ошибка.  
   - Например, Power BI может использовать синтаксис, который не разрешён в конкретной версии или сборке MySQL.

2. **Проблемы с сетевым доступом или VPN**  
   - При DirectQuery все запросы «летят» к базе по сети. Если соединение нестабильное или пропуск запросов ограничен фаерволом, часть пакетов может теряться, запросы — прерываться.  
   - В таком случае Power BI может либо показывать устаревшие закэшированные данные, либо выдавать «Couldn’t connect to the data source» и не догружать новые строки.

3. **Неправильная настройка параметров соединения (Connection String)**  
   - Если в настройках Power BI или в Power Query указан неверный порт, таймаут слишком маленький или сам MySQL-сервер настроен с непривычным портом, а фаервол по умолчанию блокирует его, — новые данные физически не могут быть прочитаны в момент запроса.

4. **Избыточная нагрузка и таймаут**  
   - При высокой нагрузке на MySQL-сервер (большое количество параллельных запросов) и медленных запросах, DirectQuery может «не успевать» возвращать свежие данные вовремя, в результате отчёт в Power BI либо зависает, либо показывает частичные результаты.  
   - Если пользователи видят, что «новые записи отсутствуют» или видят данные с задержкой, иногда это просто вопрос производительности и конфигурации сервера.

---

## 4. Кэширование в Power BI Service и Gateway

1. **Кэширование на уровне Power BI**  
   - В DirectQuery-режиме Power BI старается минимально кэшировать данные, но в некоторых случаях (особенно в Power BI Service) может быть включена функция «Query Caching» или агрессивный кэш на уровне пользовательской сессии.  
   - Если настройки кэширования не оптимальны, пользователь может видеть «старый» срез данных, пока не истечёт время кэша или пока вручную не будет принудительно обновлён визуал.

2. **Data Gateway (если база On-Premises)**  
   - Если MySQL установлен локально, а Power BI Service подключается к нему через Data Gateway, сбои или неверная конфигурация шлюза могут приводить к тому, что часть запросов не доходит до сервера.  
   - Пример: Gateway настроен на другой сервер MySQL или использует учётку без нужных прав — в итоге в отчёте пусто.

---

## 5. Итоговые симптомы и проявления

1. **Частичное отображение данных**  
   - Пользователь видит, что часть таблицы обновилась, а часть — нет.  
   - Иногда при фильтрации в отчёте новые записи появляются, но при другом срезе пропадают.

2. **Ошибки «Access Denied», «Permission Denied»**  
   - Может появляться при попытке просмотра поля или таблицы, к которым нет прав.

3. **Сообщения о таймауте**  
   - «The operation has timed out…» или «OLE DB or ODBC error…», что говорит о том, что запрос не выполнился вовремя.

4. **Несоответствие данных локальному запросу**  
   - Если в MySQL Workbench при запросе SELECT видно новые строки, а в Power BI DirectQuery — нет, почти наверняка проблема связана с правами, конфигурацией или сетевым доступом.

---

## 6. Как проверить и устранить проблемы DirectQuery

1. **Проверить учётные данные и права (Credentials)**  
   - Убедиться, что пользователь MySQL, указанный в Power BI, имеет достаточные права на все необходимые таблицы/представления.  
   - Если структура базы изменилась (добавлены новые таблицы, поля), нужно выдать на них SELECT-привилегии.

2. **Проверить логи MySQL**  
   - В логе сервера могут быть заметны ошибки авторизации, блокировок, таймаутов. Так можно понять, дошёл ли запрос от Power BI до базы и как он обработался.

3. **Настройка и тестирование соединения**  
   - В Power BI Service (если отчёт опубликован) проверить настройки Data Source Credentials и Data Gateway. Убедиться, что всё указывает на правильный сервер, порт, базу данных.  
   - Выполнить тестовое соединение и убедиться, что «Connection Successful».

4. **Оптимизация производительности**  
   - Проанализировать SQL-запросы, которые Power BI отправляет в MySQL (можно включить профайлер или General Log в MySQL), — если запрос слишком сложный, возможно, нужно оптимизировать индексы, упростить джоины, создать представления (views).  
   - Увеличить таймаут, если запрос обрабатывается дольше стандартного лимита.

5. **Отключить или настроить кэширование Power BI**  
   - Если подозрение, что данные просто не обновляются из кэша, проверить настройки «Dataset settings» в Power BI Service. Можно временно отключить кэш (Query Caching) или использовать кнопку «Refresh visuals» (на панели отчёта).

6. **Перейти на Import (при необходимости)**  
   - Если DirectQuery даёт слишком много ограничений (права, производительность, сложные запросы), возможно, целесообразно использовать режим Import и обновлять данные по расписанию. Тогда данные будут гарантированно обновляться в момент рефреша, без постоянных запросов к серверу.

---

### Вывод

В режиме DirectQuery Power BI постоянно обращается к MySQL-серверу за актуальными данными. Если в конфигурации прав (permissions), сетевых настройках, параметрах соединения или производительности MySQL есть проблемы, новые записи могут не отображаться — либо из-за того, что Power BI фактически не видит новых строк (нет прав), либо не может корректно завершить запрос (таймаут, блокировки), либо показывает устаревшую версию из кэша. 

Чтобы исправить ситуацию, нужно:

- Убедиться, что у Power BI есть все права на чтение новых данных.  
- Проверить конфигурацию сервера и сетевые настройки (порты, брандмауэр, таймауты).  
- Оптимизировать SQL-запросы и при необходимости откорректировать кэширование.  
- Использовать корректно настроенный Data Gateway, если база данных локальная.
~~~

## 17. «активные фильтры <…> скрывают новые данные»
### 17.1.
Я тебя спросил:
~~~
В пункте 7 своего ответа пункта 2.2 ты писал:
```
- Хоть клиент и подозревает, что дело не только в фильтрах, их влияние всё же стоит проверить. Иногда активные фильтры или RLS (Row-Level Security) скрывают новые данные.
```
Опиши подробнее, каким образом «активные фильтры <…> скрывают новые данные» может приводить к проблеме клиента.
~~~

### 17.2.
Ты ответил:
~~~
Ниже описаны основные сценарии, при которых фильтры и другие механизмы ограничения данных (включая RLS — Row-Level Security) могут приводить к тому, что новые записи не видны в отчёте, несмотря на успешное обновление в Power BI:

---

## 1. Срезы (Slicers) и визуальные фильтры, ограничивающие диапазон или значения

1. **Фильтр по дате, не включающий новые данные**  
   - Классическая ситуация: в отчёте есть срез или визуальный фильтр по дате (например, «Показать данные за последний месяц» или «От 1 января до 31 января»).  
   - Если новые строки относятся к периоду за февраль, они просто не попадают в отображаемый диапазон, и кажется, что «данные не приходят».  
   - Или наоборот: в срезе выбраны конкретные значения (например, дата = «1–10 января»), а новые данные — это 11–15 января, которые не отобразятся, пока пользователь не изменит фильтр.

2. **Категориальные фильтры, не учитывающие новые категории**  
   - Если в отчёте присутствует фильтр по полю «Категория» (Category), и пользователь вручную выбрал только определённые категории (например, A, B, C), а в базе появилась новая категория D, она не будет отображаться в визуале, поскольку её нет среди выбранных элементов.  
   - Визуально может показаться, что данные по категории D просто «не пришли», хотя технически они уже есть в модели Power BI.

3. **Уровень фильтра на странице или уровне отчёта**  
   - Помимо срезов, в Power BI есть фильтры на визу, на страницу (Page level filter) и на весь отчёт (Report level filter). Если разработчик или пользователь задал условие, которое исключает новые записи, то всё обновление «пройдёт», но данных не будет видно.  
   - Часто случается, когда кто-то из коллег «скрыл» часть данных фильтром на уровне страницы, а остальные пользователи не догадываются о существовании этого фильтра.

---

## 2. Автоматически устанавливаемые фильтры (Drillthrough, Cross-filter)

1. **Drillthrough Filter**  
   - При переходе по детализации (Drillthrough) из одного отчёта в другой Power BI может автоматически передавать значения для фильтрации. Если в новом отчёте поле для фильтра не включает диапазон новых данных, записи не будут отображаться.  
   - Пользователь может даже не замечать, что попал на детальную страницу с автоподстановкой фильтра.

2. **Cross-filtering между визуалами**  
   - Когда пользователь кликает на элемент одной диаграммы (например, категорию «X»), все связанные визуалы могут отфильтроваться только по этой категории. Если новые записи относятся к категории «Y», визуалы не покажут их, пока не снять выделение.

---

## 3. Режимы безопасности (RLS — Row-Level Security)

1. **Динамические роли, скрывающие часть данных**  
   - Если в отчёте настроен RLS (Row-Level Security) и пользователь входит в роль, которая позволяет видеть только конкретные подразделения, регионы или категории, то все новые записи, не относящиеся к этим подразделениям/регионам, будут для него недоступны.  
   - Это особенно часто встречается, когда новую запись в базе MySQL присваивают не тому региону (или она вообще не привязана к региону), и роль пользователя не даёт прав на просмотр «непривязанной» информации.

2. **Фильтрация по UserPrincipalName**  
   - В DAX-правилах RLS нередко используются функции вроде `USERNAME()`, `USERPRINCIPALNAME()`, сравнивающие текущего пользователя с полем в таблице. Если в новых записях нет значения, соответствующего залогиненному пользователю (или там пустота), данные не отображаются.

---

## 4. Особенности измерений (Measures) и вычислений

1. **DAX-меры, отбрасывающие «нулевые» или пустые значения**  
   - Иногда меры настроены так, чтобы не отображать строки, если показатель (Measure) равен 0 или `BLANK()`. Если новые данные формально дают 0 в этой мере (или не заполнены необходимые поля), визуалы могут эти строки не показывать.  
   - Пример: «Показать только товары, у которых продажи > 0» — если у новых позиций пока 0 продаж, они не появятся.

2. **Фильтр-меры в выражениях DAX**  
   - Реализованные вручную фильтры в DAX (через CALCULATE, FILTER и т. п.) могут приводить к тому, что только данные, соответствующие определённым условиям, попадают в итоги. Если новые записи этим условиям не удовлетворяют — они не отобразятся.

---

## 5. Признаки, что дело именно в фильтрах

1. **Данные видны без фильтра, но исчезают при включении фильтров**  
   - Если при «очистке» всех срезов и фильтров (Ctrl+Click по срезам или кнопка «Очистить фильтры») новые записи становятся видны, а при возврате фильтров исчезают, значит проблема точно в настройках фильтра.

2. **В другом отчёте или другой странице те же данные отображаются**  
   - Если в другом отчёте (или в другой вкладке без фильтров) та же самая таблица и всё показывается корректно, значит фильтр настроен именно в первой вкладке (либо на уровне отчёта).

3. **Нет ошибок при обновлении, но часть строк скрыта**  
   - С точки зрения Power Query или отношений (Relationships) всё корректно — модель обновляется, типы данных в порядке, связи активны, а фактически новые записи не видны. Это говорит о том, что данные «дошли» до модели, но где-то их исключают.

---

## 6. Как проверить и устранить проблему, связанную с фильтрами

1. **Сбросить или отключить все фильтры/срезы**  
   - В Power BI Desktop можно открыть панель «Фильтры» (Filters) и вручную проверить фильтры на уровне отчёта, страницы и визуала. Убрать или временно отключить их все, чтобы понять, появляются ли новые данные.

2. **Проверить роли RLS**  
   - Если используется Row-Level Security, надо убедиться, что у тестового пользователя либо нет ограничивающей роли, либо в этой роли точно прописано разрешение видеть нужные записи.  
   - Подключиться под ролью «без ограничений» или вообще отключить RLS, чтобы проверить, «приходят» ли новые данные.

3. **Посмотреть таблицу целиком (Table Visual)**  
   - Добавить на страницу простую таблицу или матрицу с максимальным количеством столбцов (или хотя бы ключевыми полями) и отключить в ней все фильтры. Если в такой «сырой» таблице новые строки видны, значит, в других визуалах их скрывают фильтры.

4. **Анализировать меры и вычисления DAX**  
   - Проверить, нет ли в формулах условий, наподобие `CALCULATE(SUM(Sales[Amount]), Sales[Amount] > 0)`. Если в новых записях `Amount` = 0 или `Blank()`, они исключаются.  
   - При необходимости убрать такие условия или смягчить их, чтобы увидеть, отображаются ли новые данные.

5. **Проверить Drillthrough и Cross-filter**  
   - Убедиться, что не осталось активного клика на другом визуале, который «фиксирует» фильтрацию. Можно нажать на пустое место визуала или Ctrl+клик, чтобы снять выделение.

---

### Итог

Даже если в MySQL появились новые записи и Power BI их корректно загрузил, различные фильтры (дата, категория, диапазон значений) и механизмы безопасности (RLS) могут «скрывать» эти данные от конкретного пользователя или визуала. Поэтому всегда имеет смысл проверять:

- Не включён ли фиксированный период времени или ограниченный список категорий.  
- Нет ли активных ролей, которые не дают видеть часть строк.  
- Не заданы ли меры (Measures) или DAX-фильтры, отбрасывающие пустые или не удовлетворяющие условию строки.

Снятие или корректировка таких фильтров чаще всего решает проблему «пропавших» новых данных.
~~~

## 18. «RLS (Row-Level Security) скрывают новые данные»
### 18.1.
Я тебя спросил:
~~~
В пункте 7 своего ответа пункта 2.2 ты писал:
```
- Хоть клиент и подозревает, что дело не только в фильтрах, их влияние всё же стоит проверить. Иногда активные фильтры или RLS (Row-Level Security) скрывают новые данные.
```
Опиши подробнее, каким образом «RLS (Row-Level Security) скрывают новые данные» может приводить к проблеме клиента.
~~~

### 18.2.
Ты ответил:
~~~
Ниже рассмотрены основные механизмы того, как **Row-Level Security (RLS)** в Power BI может «прятать» вновь загруженные данные от определённых пользователей или даже от владельца отчёта (при неправильной настройке):

---

## 1. Что такое RLS и как оно работает

1. **Суть RLS**  
   - Row-Level Security позволяет ограничивать доступ к строкам таблицы в модели Power BI в зависимости от роли пользователя.  
   - Например, у каждой записи может быть поле «Регион» или «Отдел», и администратор задаёт правило, что пользователь `UserA` видит только строки с `Region = 'North'`.

2. **DAX-фильтрация**  
   - В Power BI RLS реализуется через фильтры на уровне модели (Roles → Table Filters). При включённом RLS для конкретной роли (например, Role «ManagerNorth») Power BI автоматически «применяет» этот фильтр ко всем визуалам отчёта.  
   - В результате любые строки, не соответствующие условию фильтра, исключаются из итогового набора данных.

3. **Статическая vs. динамическая RLS**  
   - Статическая: когда в настройках роли жёстко прописано «Region = "North"».  
   - Динамическая: когда фильтр привязан к логину пользователя (например, «Region = USERNAME()» или через связь c таблицей пользователей).  
   - В обоих случаях, если у новых строк поле `Region` или другие признаки не совпадают с тем, что «ожидает» RLS, эти строки становятся «невидимы».


---

## 2. Как RLS может скрывать новые данные

1. **Новые записи не попадают под роль**  
   - Предположим, в базе MySQL появились новые строки с `Region = 'South'`. Если у текущего пользователя или роли RLS установлено условие `Region = 'North'`, то такие строки в отчёте не показываются.  
   - Внешне кажется, что «новые данные не загрузились», хотя на самом деле они есть, просто «отрезаются» RLS-фильтром.

2. **Отсутствие связанных значений для нового региона/отдела**  
   - Если в модели Power BI организован фильтр через таблицу-справочник (Dimension), а в ней отсутствуют записи для нового региона (или другого параметра), то при наложении RLS-фильтра данные из фактической таблицы могут не отображаться.  
   - Пример: новая запись в факте продаж (`SalesFact`) с `Region = 'X'`, а в таблице `RegionDim` нет строки `X`, либо RLS настроена только на существующие регионы. В итоге Power BI «выбрасывает» новые строки, не находя соответствия.

3. **Динамическая RLS «не знает» о новом пользователе/значении**  
   - Если в настройках RLS фильтр ссылается на таблицу пользователей (User Table), а информация о новом сотруднике или новом подразделении не внесена, то для этого пользователя могут быть не настроены правильные права.  
   - Новые строки, связанные с новым пользователем или отделом, окажутся невидимыми, пока администратор не обновит таблицу пользователей или роли.

4. **Недоступность полей для проверки**  
   - Иногда правила RLS используют определённые столбцы, которые могли измениться или удалиться в MySQL. Если связь или фильтр «сломаны», Power BI может применить «пустой» фильтр, скрывающий часть строк.  
   - Пример: в MySQL поле `DepartmentID` переименовали, а в Power BI логика RLS всё ещё ссылается на старое название. В итоге фильтрация может работать некорректно или «обрезать» новые данные.


---

## 3. Типичные признаки «виновности» RLS

1. **Администратор (Role = Admin) видит все данные, а рядовые пользователи — нет**  
   - Когда админ заходит в отчёт, новые данные появляются и кажутся в порядке. Но для остальных пользователей (с ограниченными ролями) новые строки отсутствуют.  
   - Это явный признак, что срабатывают ограничения RLS.

2. **Различие данных при переключении роли**  
   - В Power BI Desktop можно проверить, как отчёт выглядит под разными ролями (в меню «Modeling» → «View as Roles»). Если под одной ролью новые данные видны, а под другой — нет, значит RLS фильтрует их.

3. **Общее число записей (или сумма, если это метрика) меньше ожидаемого**  
   - Часто по показателю «количество строк» или «сумма продаж» видно, что значение меньше, чем фактически загружено из источника. Если при этом ошибок загрузки нет, велика вероятность, что часть строк попадает под ограничения безопасности.


---

## 4. Как проверить, действительно ли RLS скрывает новые записи

1. **Отключить (или обойти) RLS на тест**  
   - Если есть права администратора, можно либо переключиться в роль без ограничений (View as → No RLS), либо совсем убрать роли (убрать фильтр таблицы).  
   - После обновления отчёта посмотреть, появились ли все строки. Если да, то причина точно в RLS-настройках.

2. **Зайти под другой ролью или пользователем**  
   - Проверить, отличаются ли доступные данные под другой ролью, у которой менее строгие фильтры. Если при этом новые записи вдруг «возникают», значит, для исходной роли фильтр был слишком жёстким.

3. **Посмотреть логи обновления**  
   - На стороне Power BI Service есть журнал обновлений (Refresh history). Если обновление проходит без ошибок, но данные не отображаются, часто дело именно в фильтрации, а не в технической ошибке.


---

## 5. Способы решения и рекомендации

1. **Убедиться, что роли действительно должны скрывать новые данные**  
   - Проверьте, не должны ли, например, пользователи «North Region» видеть `Region = 'South'` тоже, если компания реорганизовалась и изменилась логика доступа.  
   - Возможно, RLS надо скорректировать или вообще отменить для некоторых групп.

2. **Обновить таблицу справочников / пользователей**  
   - Если новый регион, отдел или пользователь не прописан в таблице, которая участвует в фильтре RLS, нужно добавить недостающие записи. Тогда Power BI сможет корректно применять фильтры к новым данным.

3. **Перепроверить DAX-условия**  
   - Зайти в «Modeling» → «Manage Roles» и открыть выражение фильтра. Убедиться, что при изменениях в структуре MySQL (или в логике полей) эти выражения всё ещё действительны.  
   - Если было переименование полей, нужно обновить имена в фильтре RLS.

4. **Тестировать логику RLS после каждого изменения структуры**  
   - Если базу MySQL меняют регулярно (новые поля, новые справочники), нужно каждый раз проверять, не «сломалась» ли RLS.  
   - Полезно иметь роль «Тестовая» без ограничений, чтобы сравнивать, сколько всего строк в наборе данных и сколько строк видит конкретная роль.

5. **Использовать «View as Roles» при разработке**  
   - При работе в Power BI Desktop можно моделировать различные роли, чтобы убедиться, что данные показываются корректно (особенно новые записи).


---

### Вывод

Если в модели Power BI включён Row-Level Security, то даже при корректном обновлении данных из MySQL часть новых (или всех) строк может оказаться «невидимой» для некоторых (или всех) пользователей. Это происходит из-за фильтрации на уровне строк, когда новые значения полей (регион, отдел, категория) не попадают под заданные роли, либо у пользователя нет соответствующих прав просмотра.

Поэтому, если клиент жалуется, что «новые данные не отображаются», стоит проверить и сценарий RLS — возможно, именно механизмы безопасности «вырезают» вновь появившиеся записи из итоговых визуалов.
~~~

## 19. «Отсутствие публикации изменений после локальной работы»
### 19.1.
Я тебя спросил:
~~~
В пункте 8 своего ответа пункта 2.2 ты писал:
```
- Если клиент вносил изменения в Power BI Desktop, но не опубликовал их в сервис Power BI, изменения и обновления могут не дойти до конечной онлайн-дашборда.
```
Опиши подробнее, каким образом «Отсутствие публикации изменений после локальной работы» может приводить к проблеме клиента.
~~~

### 19.2.
Ты ответил:
~~~
Ниже рассмотрено, как отсутствие или несвоевременная публикация отчёта из Power BI Desktop в Power BI Service способна приводить к тому, что изменения (включая корректное обновление данных) не отображаются на конечном дашборде или в онлайн-рабочей области:

---

## 1. Разница между локальным отчётом и отчётом в облаке

1. **Локальная версия в Power BI Desktop**  
   - Когда вы работаете в Power BI Desktop, вы можете:  
     - Подключаться к источникам (MySQL и др.),  
     - Настраивать Queries (запросы) в Power Query,  
     - Создавать или менять меры (Measures), визуалы, настроенные связи и т. д.  
   - Все эти изменения сохраняются в `.pbix`-файле локально на компьютере.

2. **Опубликованная версия в Power BI Service**  
   - Чтобы отчёт и дашборды в облаке (в workspace на сайте Power BI) «увидели» новые настройки и модели, нужно **опубликовать** локальный отчёт в Power BI Service.  
   - Если этого не сделать, облачная версия по-прежнему использует старую модель и старые настройки данных — следовательно, любые новые данные или изменения логики отображения не будут учитываться.

---

## 2. Что происходит при обновлении отчёта в Power BI Service

1. **Refresh в сервисе (Scheduled Refresh, Manual Refresh)**  
   - В Power BI Service вы можете настроить расписание обновлений или инициировать обновление вручную (Manual Refresh).  
   - Но это обновление выполняется на базе модели данных и запросов, которые **загружены** (опубликованы) в текущую версию отчёта на сервисе.  
   - Если на сервисе осталась «старая» модель (до ваших последних правок), при обновлении будут подгружаться данные по старым правилам: старые связи, старые трансформации, возможно, неправильные источники и т. д.

2. **Разрыв между локальной и облачной копией**  
   - Допустим, вы локально изменили структуру запросов (или логику DAX, или добавили новый столбец из MySQL), а отчёт на сервисе об этих изменениях «не знает».  
   - В результате при обновлении на сервисе новые поля или новая логика не задействованы — и вы получаете «старые» визуалы, которые не отражают реальное состояние данных.

---

## 3. Признаки проблемы, когда отчёт не опубликован

1. **«У меня на компьютере всё работает»**  
   - В Power BI Desktop после ручного обновления (Refresh) вы видите, что новые данные из MySQL подтягиваются и визуалы отражают актуальную картину.  
   - Но при открытии отчёта через браузер в Power BI Service или при просмотре дашборда всё ещё показываются устаревшие данные.

2. **Расхождение дат последнего обновления**  
   - В Power BI Service можно посмотреть дату и время последнего успешного обновления (Last Refresh). Если она существенно отстаёт от того момента, когда вы вносили изменения, значит, сервис работает со старой моделью.  
   - На локальном десктопном файле, напротив, вы можете видеть более свежую дату/время обновления.

3. **Отсутствие новых визуалов, мер, таблиц**  
   - Если вы добавляли новые поля, новые визуалы или слайсеры, в облачном отчёте их не видно вовсе. Это явный признак того, что отчёт в сервисе не был обновлён (не опубликован).

---

## 4. Почему это мешает появлению новых данных

1. **Изменения в структуре запроса (Query) не загружены**  
   - Вы могли, к примеру, исправить ошибку в Power Query, которая не давала подтянуть новые строки из MySQL, — но если вы не опубликовали обновлённый отчёт, сервис продолжает работать с «битым» старым M-кодом.

2. **Обновлённые связи или типы данных не применены**  
   - Иногда причиной отсутствия новых данных является неправильная связь или неверный тип столбца. Если вы локально это поправили, но не залили в сервис, там всё ещё действует старая конфигурация, которая «не видит» свежие записи.

3. **Глобальные настройки (Gateway, Data Source Credentials)**  
   - Может быть, вы локально задали новые параметры подключения к MySQL (например, поменяли хост или учетные данные), но в сервисе всё ещё прописаны старые.  
   - Публикация нового `.pbix` даёт возможность обновить конфигурацию источника (хотя иногда настройки шлюза настраиваются дополнительно в самом сервисе, но в любом случае должна быть актуальная модель).

---

## 5. Как правильно публиковать изменения

1. **Использовать кнопку «Publish» в Power BI Desktop**  
   - После того как убедились, что локальный отчёт корректно отображает новые данные, нажмите «Publish» и выберите нужный workspace в Power BI Service.  
   - При совпадении названий отчёт и набор данных (Dataset) в сервисе будут перезаписаны новой версией.

2. **Проверить успешность публикации**  
   - Убедитесь, что в Power BI Desktop появилось сообщение об успешной публикации, и/или в самом Power BI Service на портале видна новая дата последней загрузки набора данных (Dataset).  
   - После этого откройте отчёт в сервисе (через браузер) и проверьте, действительно ли там отобразились новые визуалы, связи и данные.

3. **Настроить или обновить Gateway при необходимости**  
   - Если вы используете On-premises Gateway для MySQL (особенно если база не в облаке, а в локальной сети), убедитесь, что в Power BI Service этот Gateway настроен корректно и ссылается на тот же источник данных, который вы используете локально.  
   - Иначе, даже опубликовав отчёт, вы можете столкнуться с ошибками при обновлении, если учётные данные или адрес сервера отличаются.

4. **Тестовое обновление в сервисе**  
   - После публикации обновлённой модели можно вручную запустить Refresh в Power BI Service (на вкладке Datasets → «Refresh now»).  
   - Если всё прошло успешно и без ошибок, а в визуалах видны новые данные, значит, публикация действительно «дошла» и изменения применились.

---

## 6. Итог

Когда клиент говорит: «У нас в MySQL появились новые данные, а в дашборде их не видно», — одна из распространённых причин заключается в том, что все исправления и актуальные настройки остались только в локальном файле Power BI Desktop. Без нажатия «Publish» в облако (Power BI Service) сервис продолжает работать со старой моделью, не учитывая все свежие корректировки и логику запроса.  

**Вывод**: всегда нужно убедиться, что после локальных правок и тестов в Desktop вы опубликовали обновлённый отчёт в нужный рабочий пространство (Workspace) Power BI Service. Только тогда конечные пользователи, заходя через браузер, увидят обновлённые визуалы и новые данные из MySQL.
~~~

## 20. «“пустые” записи»
### 20.1.
Я тебя спросил:
~~~
В пункте 9 своего ответа пункта 2.2 ты писал:
```
- Ошибки в самой базе (например, “пустые” записи, проблемы с индексацией или блокировки транзакций).
```
Опиши подробнее, каким образом «“пустые” записи» может приводить к проблеме клиента.
~~~

### 20.2.
Ты ответил:
~~~
Ниже подробно описано, как так называемые «пустые» записи в базе MySQL (записи без значимых значений в ключевых полях или с большим количеством `NULL`-полей) могут приводить к тому, что в Power BI не отображаются новые данные или возникают другие проблемы при обновлении отчёта.

---

## 1. Что понимать под «пустыми» записями

1. **Запись с пропущенными (NULL) значениями в ключевых полях**  
   - Например, есть таблица заказов, у которой обязательным полем является `OrderID`, но в базе встречаются строки с `NULL` в этом поле.  
   - Или же в измерительной (справочной) таблице отсутствует `DimensionKey`, в результате чего связь «факт–измерение» не срабатывает.

2. **Записи с пустыми (пустая строка или пробелы) значениями**  
   - Формально столбец не `NULL`, но содержит только пробелы или пустой текст (`''`).  
   - Для Power BI подобная строка может выглядеть как «ошибочная» или «нет данных» и отбрасываться при фильтрации или ошибочно трактоваться (например, при попытке преобразовать пустой текст в число).

3. **«Заглушки» или тестовые строки**  
   - В некоторых ERP- или CRM-системах разработчики могут создавать «пустые» записи для тестирования или инициализации таблицы, но забывать чистить их.  
   - Такие записи могут не нести полезной информации для отчёта, но при этом они присутствуют в выборках и иногда мешают корректной агрегации или связям.

---

## 2. Как «пустые» записи мешают отображению новых данных

1. **Нарушение связей (Relationships)**  
   - Если в базе появляются записи с `NULL` или пустым значением в поле, которое используется как ключ в отношениях Power BI (например, `ProductID`), то при загрузке такая запись «теряется» — Power BI не может сопоставить её с таблицей измерений (Dimension) и не показывает в визуалах.  
   - При этом может создаться впечатление, что «новые данные не подтягиваются», хотя часть из них просто не прошла фильтрацию из-за отсутствующего или некорректного ключевого значения.

2. **Ошибка при агрегации и фильтрах**  
   - Если «пустой» столбец используется для фильтра (слайсера) или группировки, Power BI может помещать все такие записи в категорию `(Blank)` или вообще не включать их в визуал в зависимости от настроек.  
   - Пользователь, выбирая определённый фильтр (например, «Заказы за март»), не видит записи, у которых поле «месяц» пустое или не заполнено.

3. **Сбой в вычислениях (Measures) или выражениях DAX**  
   - Наличие пустых значений может привести к тому, что некоторые DAX-функции (например, расчёты дат, сумм, средних) возвращают `Blank` или игнорируют строки.  
   - В ряде случаев это приводит к тому, что новые строки (где поле пока не заполнено) не учитываются в итоговых показателях.

4. **Инкрементальное обновление «пропускает» записи**  
   - Если в Power BI настроено инкрементальное обновление по полю даты (`OrderDate`) или по какому-то ключу, а это поле у части новых строк пустое, такие строки могут не попадать в диапазон данных для обновления.  
   - Физически данные есть в MySQL, но логика Power BI (фильтр по дате или ключу) их не видит и не загружает.

5. **Ошибки при явном преобразовании типов**  
   - Если Power BI ожидает, что поле — число, а в строке оно пустое, при преобразовании в тип `Whole Number` могут возникать проблемы. Часть строк может автоматически конвертироваться в `Null`, а часть вообще выбросит ошибку (если, например, поле содержит пробелы или неразборчивые символы).  
   - В таком случае Power Query либо прерывает загрузку, либо «тихо» отбрасывает проблемные строки — и новые данные не отображаются в отчёте.

---

## 3. Примеры реальных ситуаций

1. **Пустой `OrderID` в таблице «Sales»**  
   - Пользователь добавляет заказы в систему, но из-за сбоя интеграции часть заказов получает `NULL` в столбце `OrderID`.  
   - В Power BI все строки с `NULL` в `OrderID` не могут связаться с таблицей «Calendar» или «Customers»; в визуле «Продажи по клиентам» новые заказы не появляются.

2. **Пустые даты в столбце «InvoiceDate»**  
   - Бухгалтерия вводит данные задним числом, и у некоторых новых счетов дата ещё не заполнена (`NULL`).  
   - При загрузке в Power BI отчёт «Продажи за текущий месяц» эти счета не увидит, потому что у них отсутствует дата, и они не попадают в фильтр периода.

3. **Записи-тесты с пустыми полями**  
   - Тестовые строки при отладке системы сохранились в боевой БД. У них `ProductName` = `''` (пустая строка), а `ProductKey` = `NULL`.  
   - Power BI выдаёт меру «Общее количество товаров», но тестовые строки не участвуют в подсчёте, а иногда порождают `(Blank)`-категорию, что сбивает аналитику.

---

## 4. Как распознать, что проблема именно в «пустых» записях

1. **Сравнить фактическое число строк в MySQL с числом строк в Power BI**  
   - Запустить запрос в MySQL вида `SELECT COUNT(*) FROM table` и сравнить с тем, сколько строк видит Power BI в данной таблице (через «Data view» или с помощью DAX-функций `COUNTROWS`). Если есть расхождение, возможно, часть строк отсекается из-за пустых/некорректных ключей.

2. **Посмотреть на записи, у которых ключевые поля `NULL`**  
   - Выполнить запрос:  
     ```sql
     SELECT *
     FROM table
     WHERE PrimaryKeyColumn IS NULL
        OR KeyField = ''
     ```
     Если таких строк много, и именно они не появляются в отчёте, — значит, проблема в отсутствии значений.

3. **Проверить категории `(Blank)` в визуалах**  
   - В Power BI при наличии пустых/NULL полей они могут отображаться как отдельная категория `(Blank)`. Если заметно, что `(Blank)` содержит ровно то количество записей, которых «не хватает», значит новые данные «падают» в эту категорию, и при фильтрации (отключении `(Blank)`) они не видны.

---

## 5. Как устранить проблему с «пустыми» записями

1. **Обеспечить корректный ввод данных в MySQL**  
   - Установить ограничения (Constraints) и `NOT NULL` на ключевые поля, если логика системы не допускает пустых значений.  
   - Добавить валидацию в приложении, чтобы запрещать ввод заказа без `OrderID` или без даты.

2. **Очистить/обновить существующие пустые записи**  
   - Провести разовую операцию исправления данных: заполнить ключи и важные поля там, где это возможно (либо удалить совсем некорректные записи).  
   - Если нужны «заглушки» (placeholder), создать осмысленные значения (например, «TEST-0000» вместо пустого).

3. **В Power Query учесть логику обработки `NULL`**  
   - При загрузке можно явно фильтровать строки, где ключевые поля пусты или `NULL`, если они точно не нужны в аналитике. Либо, наоборот, помечать их определённым значением («Unknown», «Not provided»), чтобы они учитывались в отчёте.  
   - Добавить шаги преобразования типа (Change Type) с проверкой на `NULL`. Например, если поле пустое, подставлять «0» (для чисел) или «N/A» (для текстовых колонок).

4. **Проверить фильтры и срезы (Slicers) в Power BI**  
   - Убедиться, что (Blank) включён или исключён осознанно. Если нужно видеть и пустые записи, то не стоит фильтровать их из отчёта.  
   - Если, наоборот, пустые записи аналитически бессмысленны, стоит их явно «отсекать» в Power Query или с помощью DAX.

---

### Итог

«Пустые» записи в MySQL — это те, у которых отсутствуют значения в ключевых или важных аналитических полях. Такие строки могут приводить к тому, что:

- **Часть новых данных не отображается** в Power BI, так как из-за `NULL`-значений или пустых строк не срабатывают связи и фильтры.  
- **Визуалы показывают неправильные итоги** (из-за `(Blank)`-категории) или вовсе игнорируют «пустые» строки.  
- **Логика инкрементального обновления** пропускает «пустые» даты или ключи, считая, что они не попадают в диапазон.  

Чтобы решить проблему, важно следить за корректностью данных на уровне базы (MySQL) — избегать или исправлять «пустые» записи в ключевых полях, а в Power BI настраивать очистку, фильтрацию и правильные типы данных, чтобы все значимые (и потенциально полезные) новые записи загружались и были видны в отчёте.
~~~

## 21. «проблемы с индексацией»
### 21.1.
Я тебя спросил:
~~~
В пункте 9 своего ответа пункта 2.2 ты писал:
```
- Ошибки в самой базе (например, “пустые” записи, проблемы с индексацией или блокировки транзакций).
```
Опиши подробнее, каким образом «проблемы с индексацией» может приводить к проблеме клиента.
~~~

### 21.2.
Ты ответил:
~~~
Ниже рассмотрены ситуации, когда **проблемы с индексацией** в MySQL могут приводить к тому, что при запросах из Power BI (через импорт или DirectQuery) часть новых записей не возвращается или не учитывается:

---

## 1. Повреждение (corruption) индекса и пропуск новых строк

1. **Некорректно работающий индекс**  
   - Если в MySQL возникла физическая или логическая ошибка индекса (коррупция структуры B-дерева, повреждение статистики), некоторые запросы могут возвращать не все строки.  
   - С точки зрения Power BI это выглядит так, будто «новые данные пропали», хотя они на самом деле присутствуют в таблице.

2. **Устаревшая статистика индекса**  
   - MySQL (в особенности InnoDB) использует статистику индексов для выбора плана выполнения запроса (query plan). Если статистика давно не обновлялась или были внесены массовые изменения в таблицу (например, большое количество вставок новых строк), оптимизатор MySQL может ошибаться в выборе плана.  
   - Это бывает реже, но в некоторых случаях некорректный план запроса (например, неоптимальное использование индексированных полей) приводит к тому, что часть данных обходится не так, как ожидается, — вплоть до пропуска некоторых строк при определённых условиях (особенно если в коде запроса есть хинты USE/FORCE INDEX).

---

## 2. Использование индексов для фильтрации или джойнов

1. **Неполные (partial) или специфические индексы**  
   - Если в таблице есть сложный составной индекс (composite index) или частичный индекс по определённому условию (например, индекс только по строкам с конкретным значением в колонке), новые записи могут не попадать в индекс, если не удовлетворяют условию.  
   - В норме это не должно «прятать» данные из результатов SELECT, но если запрос или джойн полагается именно на этот индекс (например, через FORCE INDEX) и не находит нужные значения, то Power BI будет видеть «обрезанные» результаты.

2. **Ошибка в join-условиях, зависящих от индекса**  
   - При соединении (JOIN) таблиц MySQL может использовать индексы внешних ключей. Если индекс повреждён или не обновлён, MySQL иногда «пропускает» часть строк.  
   - Например, если Power BI тянет данные через сложный SQL-запрос (или через Generated Query внутри драйвера) с несколькими JOIN-ами, а один из индексов в состоянии corruption, новые записи в связанной таблице могут не находиться.

---

## 3. Влияние транзакций и блокировок (locking) на индексы

1. **Зависшие транзакции, не закончившие обновление индекса**  
   - Если новая запись была вставлена, но по какой-то причине транзакция зависла (и не зафиксировалась полностью), соответствующие изменения в индексе тоже могут не быть доступны для чтения из другого потока/соединения (в зависимости от уровня изоляции).  
   - В таком случае Power BI при подключении к базе не увидит ещё «недокоммиченные» данные (хотя они физически уже в таблице, но транзакция не завершена).  

2. **Долгие блокировки на обновление индекса**  
   - При массовой вставке (bulk insert) или при перестроении индексов (OPTIMIZE TABLE, ALTER TABLE ... ADD INDEX) могут возникать блокировки чтения. Если Power BI в этот момент пытается обновить датасет, соединение может получить ошибку или частичный результат.

---

## 4. Специфические кейсы с «плохими» запросами, использующими индексы

1. **Прямое использование индексов в WHERE**  
   - Если (для оптимизации) в Power Query или на стороне MySQL кода запроса явно прописан хинт (USE INDEX / FORCE INDEX) и этот индекс по каким-то причинам не включает новые записи (например, повреждён, не пересоздан, не актуализирован), то итоговый SELECT вернёт неполный набор строк.  

2. **Проблемы с виртуальными (functional) индексами**  
   - В MySQL существуют функциональные индексы (с MySQL 8.0+), когда индекс строится по выражению над колонкой. Если выражение в новом наборе данных перестало удовлетворять условию индекса (или сам индекс был создан/изменён с ошибкой), новые строки могут не попадать в результирующий набор.

---

## 5. Как это проявляется со стороны Power BI

1. **Периодическое отсутствие записей**  
   - Иногда проблема носит «плавающий» характер: во время выполнения одних запросов данные видны, во время других — нет (если оптимизатор MySQL решил взять другой индекс).  

2. **Отсутствие самых свежих строк**  
   - Чаще всего заметно, что именно «совсем новые» записи (добавленные недавно) не отображаются. Старые данные могут отдаваться корректно, так как они уже находятся в индексе, а вновь вставленные — ещё нет (или индекс повреждён).

3. **Ошибки «Lock wait timeout exceeded»**  
   - При наличии тяжёлых блокировок на индексе Power BI может получить ошибку превышения таймаута ожидания блокировки. Тогда обновление датасета (Refresh) завершается с ошибкой, и новые данные не подтягиваются.

---

## 6. Как проверить и решить проблему с индексацией

1. **Проверить состояние индексов и саму таблицу**  
   - Использовать команды вроде `CHECK TABLE table_name;`, `ANALYZE TABLE table_name;`, `OPTIMIZE TABLE table_name;` для диагностики и восстановления индексов в MySQL.  
   - Убедиться, что нет сообщений об ошибках (например, «Table is corrupt»).

2. **Обновить (перестроить) индексы**  
   - Если `ANALYZE TABLE` или `OPTIMIZE TABLE` указывает на проблемы, стоит их устранить. Иногда приходится заново создать индекс (DROP INDEX ...; CREATE INDEX ...), если он оказался повреждён.  
   - Регулярный анализ статистики индексов в таблицах с большими объёмами INSERT/UPDATE помогает оптимизатору MySQL возвращать полный и актуальный результат.

3. **Проверить уровень изоляции транзакций**  
   - Если используется REPEATABLE READ или SERIALIZABLE, и запрос идёт внутри долгой транзакции, Power BI может «не видеть» новые данные, вставленные другими транзакциями.  
   - Убедиться, что данные действительно зафиксированы (COMMIT) и доступны для чтения на уровне READ COMMITTED (или ниже).

4. **Изучить план запроса (EXPLAIN)**  
   - Если для выборки данных в MySQL используется нестандартный запрос, запущенный через соединение Power BI (или через свои SQL-скрипты), посмотреть `EXPLAIN SELECT ...`. Можно обнаружить, что MySQL выбирает не тот индекс (или делает index ignore).  
   - Настройка/удаление неверных хинтов (FORCE INDEX) иногда решает проблему.

5. **Тестировать выборку напрямую в MySQL**  
   - Выполнить аналогичный запрос, который формирует Power BI, в консоли MySQL (`mysql` CLI или Workbench). Сравнить, совпадает ли набор строк со списком в отчёте Power BI.  
   - Если в MySQL тоже не видно новых записей, значит, проблема действительно в базе (не зафиксированные транзакции, сломанные индексы, некорректная фильтрация).  
   - Если в MySQL напрямую данные видны, а в Power BI нет — тогда нужно смотреть, не кэшируется ли запрос в Power BI, не накладываются ли фильтры, нет ли несоответствия в типах данных и т. п.

---

### Вывод

«Проблемы с индексацией» в MySQL могут привести к тому, что **новые записи либо не попадают в результирующий набор**, либо запрос отрабатывает с ошибкой/таймаутом, и Power BI **не может** корректно отобразить свежие данные. Особенно часто это проявляется, если:

- Индекс оказался повреждённым или неактуальным.  
- Включены жёсткие хинты (USE/FORCE INDEX) в запросах.  
- Есть долгие транзакции или блокировки, мешающие корректному обновлению индекса.

Чтобы исправить это, нужно **проверять и при необходимости восстанавливать индексы** (ANALYZE/OPTIMIZE TABLE), следить за корректностью транзакций и уровнем изоляции, а также **тестировать SQL-запросы напрямую** в MySQL, чтобы убедиться, что база возвращает полный набор данных, доступный Power BI при обновлении.
~~~

## 22. «блокировки транзакций»
### 22.1.
Я тебя спросил:
~~~
В пункте 9 своего ответа пункта 2.2 ты писал:
```
- Ошибки в самой базе (например, “пустые” записи, проблемы с индексацией или блокировки транзакций).
```
Опиши подробнее, каким образом «блокировки транзакций» может приводить к проблеме клиента.
~~~

### 22.2.
Ты ответил:
~~~
Ниже описано, как блокировки транзакций (transaction locks) в MySQL могут препятствовать тому, чтобы новые данные отображались в Power BI после обновления, и к каким симптомам это обычно приводит:

---

## 1. Что такое блокировки транзакций и почему они возникают

1. **Определение**  
   Блокировки транзакций — это механизм, с помощью которого СУБД (в данном случае MySQL) обеспечивает целостность и согласованность данных, когда несколько операций (INSERT, UPDATE, DELETE, SELECT и т. д.) пытаются обращаться к одним и тем же записям одновременно.

2. **Причины появления блокировок**  
   - **Длительные UPDATE/INSERT-операции**: если крупная транзакция обновляет большие объёмы данных, MySQL может удерживать блокировки дольше, чем обычно.  
   - **Неправильная архитектура транзакций**: когда код приложения (ERP-системы или другой интеграции) долго не «коммитит» (не завершает) транзакцию, задерживаются и SELECT-запросы других пользователей.  
   - **Ошибки в приложении**: «забытые» транзакции (например, когда сессия открыта, но по факту завершить операцию не удаётся, и она зависает в состоянии InnoDB lock wait).  

3. **Влияние на чтение данных**  
   Хотя в MySQL обычно чтение (SELECT) без прямого явного запроса блокировки не блокируется записью (за исключением специфических уровней изоляции — например, REPEATABLE READ, SERIALIZABLE), всё же при определённых настройках или сценариях (особенно при использовании LOCK TABLES, либо при конфликте из-за архитектуры транзакций) Power BI- или другие клиенты могут получать «старую» версию данных либо вовсе сталкиваться со сбоями при попытке чтения.

---

## 2. Как блокировки могут мешать обновлению данных в Power BI

1. **Зависание или тайм-аут при выполнении запроса**  
   - Если Power BI при обновлении отправляет запрос на чтение новых данных, а таблица или часть строк заблокированы и база данных «не отдает» результат, процесс может зависать.  
   - По истечении определённого времени (Command Timeout) обновление в Power BI может завершиться с ошибкой или прерваться.

2. **Получение «старых» данных (snapshot)**  
   - В MySQL при определённых уровнях изоляции (например, REPEATABLE READ по умолчанию в InnoDB) запрос может возвращать данные «как на момент начала транзакции», если он попадает в «моментальный снимок» (snapshot).  
   - Если большие транзакции удерживают блокировки, Power BI может не видеть данные, которые были добавлены или изменены после начала этой транзакции, и, следовательно, в отчёте не появятся свежие записи.

3. **Ошибки при инкрементальном обновлении**  
   - Если используется инкрементальное обновление (Incremental Refresh) в Power BI, и часть данных «зависла» в блокированных транзакциях (или не зафиксирована), Power BI может считать, что в нужном диапазоне нет новых строк.  
   - После снятия блокировки и фиксации транзакции эти записи появятся в MySQL, но отчёт может их «пропустить» до следующего цикла обновления.

4. **Параллельная загрузка нескольких таблиц**  
   - Если Power BI подгружает сразу несколько таблиц (Fact и Dimensions), и одна из них блокируется во время INSERT/UPDATE, запросы к другим таблицам могут выполниться быстрее, а заблокированный запрос — зависнуть или упасть с ошибкой.  
   - В итоге модель не будет обновлена корректно (Power BI может откатить всё обновление, если одна из таблиц не загрузилась).

---

## 3. Типичные проявления «проблемы блокировок» в Power BI

1. **Длительная «крутилка» при обновлении**  
   - При ручном обновлении (Refresh) в Power BI Desktop можно увидеть, что один из запросов «висит» дольше обычного. Если в логе (или в Диагностических данных Power Query) проверить, на каком этапе происходит задержка, часто оказывается, что база данных не отвечает из-за lock wait.

2. **Сообщения об ошибке тайм-аута**  
   - Power BI (особенно сервис) может вывести сообщение вроде «The operation has timed out…» или «[MySQL] Lock wait timeout exceeded; try restarting transaction». Это явная индикция, что при выполнении SELECT-запроса MySQL не смог вернуть результат вовремя из-за блокировки.

3. **Частичное обновление данных**  
   - Иногда Power BI завершает обновление «успешно», но фактически часть таблиц не содержит свежих строк. Пользователь видит, что в одних таблицах данные актуальны, а в других — ещё нет, хотя в MySQL по факту уже всё записано. Это может означать, что в момент запросов часть транзакций не была зафиксирована.

4. **Наличие блокировок в MySQL-мониторе**  
   - Если администратор проверяет состояние транзакций (через `SHOW ENGINE INNODB STATUS;` или инструменты администрирования MySQL), может выявиться, что существуют активные long-running транзакции или lock wait на тех таблицах, из которых читает Power BI.

---

## 4. Как убедиться, что проблема именно в блокировках

1. **Проверить MySQL-логи и статус блокировок**  
   - Запустить команду `SHOW PROCESSLIST;` или `SHOW ENGINE INNODB STATUS;` в MySQL, чтобы увидеть, нет ли «зависших» запросов, ожидающих снятия блокировки.  
   - Посмотреть в логе сервера MySQL сообщения вида `Lock wait timeout exceeded…`.

2. **Установить (или сократить) время ожидания команд в Power BI**  
   - В Power BI Desktop можно настроить `Command Timeout`. Если уменьшить тайм-аут и обновление consistently «валится» именно по тайм-ауту, это дополнительный сигнал, что MySQL не отдает результат из-за блокировок или медленной транзакции.

3. **Тестировать обновление, когда база «свободна»**  
   - Если рано утром или в период, когда в базе нет активных изменений, обновление Power BI проходит быстро и успешно, а в часы пик (когда идут INSERT/UPDATE в MySQL) — «висит» или прерывается, вероятна проблема именно с конкурентным доступом и блокировками.

---

## 5. Рекомендации по устранению блокировок

1. **Оптимизировать транзакции**  
   - Убедиться, что операции INSERT/UPDATE в MySQL выполняются эффективно: возможно, разбить крупные транзакции на более мелкие, чтобы не удерживать блокировки слишком долго.  
   - Применять надлежащий уровень изоляции (чаще всего `READ COMMITTED`), если логика приложения это позволяет.

2. **Использовать реплику (реплицированный сервер) для чтения**  
   - Часто в боевых системах используют топологию «master-slave» (primary-replica): чтение для аналитики (включая Power BI) направляют на slave, где нет длительных блокировок записи.  
   - Таким образом, блокировки на мастер-сервере при обновлениях не мешают SELECT-запросам в replica.

3. **Проверить индексы и запросы**  
   - Если SELECT-запрос Power BI сканирует большую таблицу без индексов, MySQL может вынужденно удерживать блокировку на многие строки. Оптимизация (добавление необходимых индексов) снижает время чтения и риск блокировок.  
   - Анализировать план выполнения (EXPLAIN) для основных запросов Power BI.

4. **Настроить параметры lock wait timeout и innodb_lock_wait_timeout**  
   - Если из-за неправильных настроек MySQL слишком быстро отваливается по lock wait timeout, можно скорректировать значение. Но лучше всё же найти и устранить причину долгих блокировок.

5. **Планировать загрузки вне пиков**  
   - Если невозможно изменить структуру транзакций, имеет смысл настроить расписание обновления (Scheduled Refresh) в Power BI на такие часы, когда база менее загружена и нет длительных транзакций.

---

### Итог

Блокировки транзакций в MySQL могут приводить к тому, что Power BI:

- **Не получает доступ к новым данным** из-за зависания или тайм-аута при SELECT.  
- **Отображает «старую» версию** записей в режиме snapshot (зависит от изоляции).  
- **Частично или полностью пропускает свежие строки** при инкрементальном обновлении.

Чтобы решить эту проблему, необходимо:

1. Диагностировать блокировки (через логи, мониторинг MySQL).  
2. Оптимизировать транзакции и/или использовать читающую реплику.  
3. Правильно настраивать индексы, уровень изоляции и расписание обновлений.
~~~

## 23. «задействованы временные таблицы»
### 23.1.
Я тебя спросил:
~~~
В пункте 9 своего ответа пункта 2.2 ты писал:
```
- При обновлении таблиц в MySQL не все данные физически пишутся в те же таблицы, которые подключены к Power BI (могут быть задействованы временные таблицы или staging-слои).
```
Опиши подробнее, каким образом «задействованы временные таблицы» может приводить к проблеме клиента.
~~~

### 23.2.
Ты ответил:
~~~
Ниже описаны основные ситуации, когда использование временных (temporary) или промежуточных (staging) таблиц в MySQL может приводить к тому, что новые данные «не доходят» до Power BI и не отображаются в отчётах:

---

## 1. Данные оказываются в других таблицах, не подключённых к Power BI

1. **Временные (temporary) таблицы MySQL**  
   - В MySQL есть механизм `CREATE TEMPORARY TABLE`, при котором таблица видна только в текущей сессии. После её закрытия такая таблица автоматически удаляется.  
   - Если процесс загрузки или обновления данных (ETL/ELT) записывает новые строки во временную таблицу, а Power BI настроен на чтение постоянной (обычной) таблицы, эти новые строки Power BI никогда не увидит.  
   - Даже если таблица называется так же, как основная (например, `orders_temp` вместо `orders`), при закрытии или окончании транзакции данные исчезают.

2. **Промежуточные (staging) таблицы**  
   - В некоторых сценариях данные сначала записываются в «промежуточную» (staging) таблицу для дальнейшей обработки, преобразования, очистки, а уже потом должны переноситься в боевую («финальную») таблицу, которую читает Power BI.  
   - Если по какой-то причине этот «финальный» шаг не выполняется (скрипт ошибочно завершился или не был запущен), в итоговой таблице данные не появляются, а Power BI видит «пустоту».  
   - Часто разработчики могут решать: «Мы потом допишем скрипт, чтобы переносить данные из staging в основную таблицу», — но забывают это сделать или делают, но с ошибкой.

---

## 2. Разные схемы или базы: Power BI подключён «не туда»

1. **Временные таблицы создаются в другой схеме**  
   - MySQL позволяет создавать временные таблицы в схеме (database), отличной от той, к которой подключается Power BI. Например, staging-данные лежат в `staging_db.orders_temp`, тогда как Power BI смотрит в `production_db.orders`.  
   - Если администратор или разработчик не обновил источник данных (Data Source) в Power BI, отчёт продолжает читать «production_db.orders», где новых записей нет.

2. **Смена ссылок после обновления**  
   - Иногда администраторы меняют логику: «переименуем таблицу orders во что-то вроде orders_old, а на её место поставим новую таблицу». При этом staging-таблица может быть опубликована под нужным именем, но Power BI по-прежнему читает старую ссылку (или вообще не видит новую схему).  
   - В итоге новые данные загружаются в новую таблицу, а отчёт «застрял» на старой.

---

## 3. Ограничения видимости временных таблиц в MySQL

1. **Временные таблицы видны только в текущей сессии**  
   - В MySQL, если вы создаёте временную таблицу (через `CREATE TEMPORARY TABLE`) в сессии А, то сессия Б не сможет её увидеть, даже если это таблица с тем же самым именем.  
   - Power BI, как правило, открывает собственное соединение (сессию). Если таблицу создали в сессии, где выполняется какой-то скрипт, при завершении этого скрипта временная таблица исчезнет. Power BI-сессия просто не обнаружит такой таблицы при запросе.

2. **Проблемы с правами доступа (Permissions)**  
   - Даже если временная или промежуточная таблица создаётся в рамках одной базы, у учётных данных (credentials), которыми Power BI подключается к MySQL, может не быть прав (GRANT) на просмотр этих таблиц.  
   - В таком случае Power BI либо не узнает о существовании таблицы, либо получит ошибку «access denied».

---

## 4. Как проявляется проблема

1. **Пользователь видит, что в базе «есть новые данные», а в отчёте — нет**  
   - В действительности новые записи лежат во временной (staging) таблице, а не в той, к которой подключён Power BI.  
   - Или данные загружаются в staging, но «не доезжают» до основной таблицы по каким-то причинам (скрипты ETL не завершены, ошибки в процедуре переноса и т. п.).

2. **Power BI обновляется без ошибок, но данные не меняются**  
   - Поскольку с точки зрения Power BI «его» таблица не получила новых строк, обновление проходит успешно, но визуалы показывают устаревшую картину.

3. **Случайные совпадения в названиях**  
   - Иногда разработчики называют временные таблицы так же, как боевые (production), или с очень похожим именем. При беглом взгляде кажется, что всё в порядке: «Да мы же используем таблицу `orders`!», а на деле это может быть `orders_temp`, доступная только для внутрисессионной обработки.

---

## 5. Рекомендации по устранению

1. **Убедиться, из какой именно таблицы читает Power BI**  
   - Проверить в Power Query, какой SQL-запрос или какая таблица указана в источнике данных. Если там, например, `SELECT * FROM production_db.orders`, нужно убедиться, что именно в `production_db.orders` физически появляются новые записи.

2. **Проверить логику ETL**  
   - Если в рабочем процессе данные сначала идут во временную таблицу, а затем должны переноситься в постоянную, проверить, действительно ли этот шаг регулярно выполняется и не выдаёт ошибок.  
   - Убедиться, что после переноса данные оказываются в том месте, куда смотрит Power BI (правильная схема, правильное имя таблицы).

3. **При необходимости — объединить источники**  
   - Иногда имеет смысл в Power BI использовать тот же SQL-запрос или view (представление) MySQL, которое агрегирует данные из staging и основной таблицы. Но только если это действительно нужно в бизнес-логике.  
   - В остальных случаях лучше настроить нормальный поток данных (pipeline), чтобы «актуальные» данные всегда лежали в продакшен-таблицах.

4. **Отказаться от временных таблиц в «продакшен-обзоре»**  
   - Если временная таблица нужна лишь для расчётов внутри MySQL или для промежуточных операций, стараться не задействовать её напрямую в отчёте Power BI. Лучше иметь итоговую «боевую» таблицу/представление, которая всегда содержит актуальные данные.

5. **Настройка прав доступа**  
   - Если выяснится, что Power BI действительно должен подтягивать данные из временных (или промежуточных) таблиц, нужно обеспечить, чтобы у учётных данных была возможность видеть эти таблицы (или лучше использовать постоянную staging-таблицу без механизма `TEMPORARY`).  
   - Временные таблицы в MySQL всё равно не будут доступны за пределами сессии, так что чаще используют постоянную таблицу «для временных данных», которую при необходимости чистят скриптами.

---

### Вывод

Когда клиент говорит «Мы обновили базу MySQL, но Power BI не показывает новые строки», одна из возможных причин — новые данные физически записываются не в ту таблицу, к которой подключён отчёт, а во «временную» или «стейджинг»-таблицу. Временные таблицы MySQL удаляются при закрытии сессии и недоступны другим подключениям (включая Power BI), а staging-таблицы могут не прокинуться дальше в боевую схему.  

Чтобы устранить проблему, необходимо проверить схему записей, логику переноса данных, права доступа, а также удостовериться, что финальная таблица, на которую ссылается Power BI, действительно получает новые строки и доступна для чтения в том же виде, в каком это ожидается моделью Power BI.
~~~

## 24. «staging-слои»
### 24.1.
Я тебя спросил:
~~~
В пункте 9 своего ответа пункта 2.2 ты писал:
```
- При обновлении таблиц в MySQL не все данные физически пишутся в те же таблицы, которые подключены к Power BI (могут быть задействованы временные таблицы или staging-слои).
```
Опиши подробнее, каким образом «staging-слои» может приводить к проблеме клиента.
~~~

### 24.2.
Ты ответил:
~~~
Ниже рассмотрено, каким образом использование промежуточных (staging) слоёв и временных таблиц (temporary tables) в процессе загрузки и трансформации данных может приводить к тому, что новые записи не отображаются в отчётах Power BI, даже если в MySQL «кажется», что данные уже есть.

---

## 1. Что такое staging-слои и почему они используются

1. **Staging-слой** (или «промежуточный слой») — это набор временных/промежуточных таблиц (или даже отдельная база), в которые данные сначала **загружаются** из исходных систем, **очищаются**, **трансформируются** и только потом переносятся дальше — в итоговые таблицы, предназначенные для аналитики.  
2. **Зачем это нужно**: зачастую в боевых базах (особенно связанных с ERP, CRM) объём и структура данных могут быть не оптимальны для аналитики; staging-слой позволяет «переварить» большие объёмы, произвести все необходимые преобразования, не блокируя рабочие таблицы, и выдать уже «чистый» результат в финальную таблицу (data mart, data warehouse или просто чистую MySQL-таблицу, к которой подключается Power BI).

---

## 2. Как staging влияет на отображение данных

Если в инфраструктуре клиента предусмотрен staging-слой, могут возникать следующие ситуации:

1. **Данные «застревают» в staging**  
   - При обновлении (ETL-процессе) данные сначала копируются во временные таблицы (staging). Затем планируется, что их перенесут (INSERT или MERGE) в целевые таблицы, из которых и идёт загрузка в Power BI.  
   - Однако, если скрипт переноса по каким-то причинам не запускается (ошибка в расписании, зависший ETL-пакет, конфликт при слиянии данных), новые записи фактически **так и остаются** в staging-таблицах, а в «боевых» таблицах их нет. В итоге Power BI, ссылаясь на боевую таблицу, новых записей не видит.

2. **Power BI подключён не к той таблице**  
   - Иногда данные уже **появились** в staging-таблицах, но по ошибке (или по дизайну) Power BI смотрит не на staging, а на «старую» рабочую таблицу, в которую новые записи не попадают.  
   - Если разработчики решили перенести исторические данные из «боевой» таблицы в staging или наоборот, и при этом не обновили настройки подключения в Power BI, отчёт продолжает обращаться к неактуальной таблице.

3. **Фильтрация или агрегирование на уровне staging**  
   - В процессе загрузки в staging-слой данные могут проходить агрегирование, группировку, фильтрацию (например, отбрасываются «черновые» записи или дубликаты). Если логика фильтрации в staging изменилась, часть новых строк может попросту не попадать в целевую таблицу.  
   - Клиент может быть уверен, что «новые данные в базу записаны», но не догадывается, что они отсеиваются правилами, прописанными в ETL-скриптах при загрузке из staging.

4. **Не синхронизированы расписания (Schedule) обновлений**  
   - Допустим, MySQL-таблица, к которой подключён Power BI, обновляется из staging каждую ночь в 02:00, а сам Power BI обновляется каждый день в 01:30.  
   - В итоге Power BI всегда будет «обгонять» обновление целевой таблицы, поэтому фактически в 01:30 там ещё нет новых данных (они появятся только в 02:00). Из-за этого кажется, что «данные не подтягиваются», хотя на самом деле просто нужно сдвинуть расписание.

5. **Временные таблицы (temporary tables)**  
   - Если используются временные таблицы (например, `CREATE TEMPORARY TABLE ...`), то они могут быть доступны только в рамках текущей сессии или скрипта. После окончания сессии эти таблицы исчезают. Если Power BI подключается позже, этих таблиц уже нет, а данные не были перенесены дальше.  
   - В результате Power BI не получает обновлений, которые «мелькнули» в temp-таблице.

---

## 3. Признаки, что проблема связана со staging-слоем

1. **Видно, что в MySQL есть новые строки, но они в другой схеме**  
   - При запросе в базе данных (через SQL-клиент) обнаруживается, что новые записи находятся в таблице `staging.sales_new`, а «боевая» таблица `production.sales` их не содержит.  
2. **Power BI не выдаёт ошибок**  
   - Обновление может проходить без ошибок, ведь таблица доступна, структура не ломалась, типы данных не менялись — просто **в самой таблице нет новых строк**.  
3. **В логах ETL или в расписании переноса данных есть сбои**  
   - Можно увидеть, что процесс переноса (load, merge, replication) за последние n дней не выполнялся или завершался с ошибкой.

---

## 4. Как проверить и устранить проблему

1. **Уточнить, в каких таблицах хранятся итоговые данные для аналитики**  
   - Может оказаться, что в MySQL есть несколько копий одних и тех же данных (staging, backup, archive, production). Убедиться, что Power BI подключён именно к той таблице, где действительно лежат самые свежие и релевантные записи.

2. **Проверить расписание обновлений и статусы ETL-процессов**  
   - Если есть скрипты или задачи (Jobs) на уровне MySQL или внешнего ETL-инструмента (SSIS, Pentaho, Talend и т. п.), проверить логи и время последнего успешного выполнения.  
   - Убедиться, что целевая таблица, которую читает Power BI, действительно синхронизируется со staging-таблицами до того, как запускается обновление отчёта.

3. **Проверить фильтры и логику преобразования в staging**  
   - Возможно, новые записи не соответствуют критериям отбора (например, нет обязательных полей, неверный статус, дата не попала в интервал) и поэтому не «доезжают» до боевой таблицы.  
   - Важно понять, действительно ли эти записи **должны** быть в отчёте или же их исключение — часть бизнес-логики.

4. **Убедиться, что staging-слой не используется напрямую в отчёте (если это не требуется)**  
   - Иногда в спешке могут настроить Power BI на staging-таблицы, а потом при смене структуры staging или регулярном очищении эти таблицы опустевают. Лучше подключаться к стабильным финальным таблицам, если они существуют.

5. **Синхронизировать расписания (Power BI Refresh и ETL)**  
   - При необходимости настроить, чтобы сначала выполнялся перенос данных из staging в производственные таблицы, и только после этого запускать рефреш в Power BI.  
   - Это позволит гарантировать, что на момент обновления отчёта целевая таблица уже содержит актуальные записи.

---

### Итог

Staging-слои и временные таблицы часто используются для оптимизации загрузки и очистки данных. Если же в процессе что-то идёт не так (не завершается перенос из staging в итоговую таблицу, нарушен порядок выполнения скриптов, Power BI подключён к «старой» таблице), то **все новые данные фактически остаются за бортом**. Внешне может показаться, что «Power BI не тянет данные», хотя на самом деле причина в том, что нужных данных ещё нет в подключённой таблице. Решение — проверить, где именно «ждут» новые строки (в staging или в другой схеме), и убедиться, что итоговые таблицы наполняются корректно и **до** запуска обновления отчёта Power BI.
~~~

## 25. «Отсутствие или неправильная настройка ключевых полей»
### 25.1.
Я тебя спросил:
~~~
В пункте 1 своего ответа пункта 3.2 ты писал:
```
1. **Отсутствие или неправильная настройка ключевых полей**  
   - В реляционных моделях (и в Power BI в частности) связь между таблицами строится через ключевые поля (например, первичный ключ в «факте» ссылается на соответствующий столбец в «измерении»).  
   - Если в Power BI в качестве ключа используется столбец, где значения повторяются или несодержательны (нет уникальных значений), то связь может работать некорректно.  
   - Новые записи в MySQL могут иметь значения ключа, которые не совпадают (или конфликтуют) с уже существующими, из-за чего новые данные не «присоединяются» к нужным строкам и не отображаются в отчёте.
```
Опиши подробнее, каким образом «Отсутствие или неправильная настройка ключевых полей» может приводить к проблеме клиента.
~~~

### 25.2.
Ты ответил:
~~~
Ниже описано, как отсутствие или неправильная настройка ключевых полей в базе MySQL и/или в модели Power BI может привести к тому, что новые данные в отчётах Power BI не отображаются (или отображаются некорректно):

---

## 1. Роль ключевых полей в реляционных моделях и в Power BI

1. **Идентификация записей**  
   - Первичные ключи (Primary Key) и внешние ключи (Foreign Key) — базовый механизм, чтобы однозначно идентифицировать строки в таблицах и связывать таблицы между собой.  
   - В Power BI связи (Relationships) тоже строятся на основе соответствия столбцов-ключей между таблицами «фактов» и «измерений».  

2. **Формирование корректных отношений (Relationships)**  
   - Если таблица «Факт» (Fact) содержит поле `ProductID`, то в таблице «Измерение» (Dimension) обычно есть столбец `ProductID` (ключ) с уникальными значениями, чтобы Power BI мог сопоставить продажи каждого товара с его описанием.  
   - Без ключей, или при неверных ключах, Power BI не может правильно «стыковать» данные фактов с измерениями.

---

## 2. Основные проблемы при отсутствии или неверной настройке ключевых полей

1. **Нет уникальных значений там, где они нужны**  
   - Если Power BI воспринимает какой-то столбец как «ключ» (например, для связи один-к-одному или один-ко-многим), но в реальности в MySQL этот столбец содержит дубли, связь рушится или становится неоднозначной.  
   - В результате новые записи, у которых дублируются значения предполагаемого ключа, «теряются» или неправильно агрегируются.  

2. **Неправильный столбец выбран в качестве ключа**  
   - Бывает, что в базе есть два похожих столбца (например, `ProductID` и `ProductCode`), и в Power BI случайно настроили связь по `ProductCode`, хотя на самом деле ключевым и уникальным является `ProductID`.  
   - При обновлении данные с новыми `ProductID` не находят соответствия в измерении (или наоборот), и в визуалах новые строки не появляются.

3. **Отсутствие первичного ключа**  
   - Если в MySQL таблица не имеет явно заданного первичного ключа, а Power BI (или аналитическая логика) предполагает, что поле `ID` уникально, новые записи могут конфликтовать друг с другом (дубли ID).  
   - Тогда при обновлении часть строк может не загружаться или «затираться» в модели, и в отчёте эти записи не будут видны.

4. **Неверная кардинальность связи в Power BI**  
   - Когда вы настраиваете связь между таблицами в Power BI, нужно указать тип («один-ко-многим», «многие-ко-многим» и т. д.).  
   - Если по логике данных связь должна быть «один → многие», а вы ошибочно выставили «один → один» (One-to-one), Power BI либо заблокирует часть строк (выдаст конфликт), либо будет «подрезать» новые записи, у которых ключ уже встречается.  
   - «Многие-ко-многим» (Many-to-many) тоже может привести к путанице, если по бизнес-логике это не соответствует реальности.

5. **Неверный тип данных ключевого поля**  
   - Если в MySQL поле, выступающее ключом, хранится как `VARCHAR`, а в Power BI оно импортируется как числовое (или наоборот), при сопоставлении значений (фильтрации, связях) часть новых строк может игнорироваться.  
   - Например, если новое значение ключа (ID) — это текст `"00123"`, а Power BI пытается интерпретировать его как число `123`, могут возникнуть конфликты.

6. **Конфликты при добавлении новых значений ключа**  
   - Допустим, в MySQL «перезаписали» какую-то запись, изменив ключ (ID), но в Power BI связь остаётся по старому ключу или старая запись «зависает». Тогда при обновлении отчёта может показаться, что «новые данные не пришли».  
   - Или новые данные имеют ключ, который уже существует в другой строке, — Power BI не сможет корректно их различить.

---

## 3. Как именно это мешает отображению новых данных

1. **Свежие строки не «присоединяются» к измерению**  
   - Если в таблице фактов появилась новая запись с `ProductID = 9999`, а в измерении товаров нет записи с ключом `9999` (или ключ там не считается уникальным), Power BI при построении визуала по измерению «Товар» не сможет сопоставить эти продажи. Визуально может показаться, что продажи «исчезли».

2. **Фильтры и срезы не срабатывают**  
   - При наличии неправильной связи (или отсутствия связи) фильтр по таблице измерений (например, «Выбрать товар “ABC”») не будет отсеивать соответствующие строки в таблице фактов. Новые записи, относящиеся к этому товару, не показываются — отчёт игнорирует их.

3. **Часть данных отображается как `(Blank)`**  
   - Если связь есть, но некоторые новые ключи не совпадают с тем, что Power BI видит в связанной таблице, эти строки могут попадать в категорию `(Blank)` или не отображаться совсем.

4. **Power BI «подозрительно» сворачивает данные**  
   - При неверном ключе Power BI может автоматически сгруппировать несколько разных записей в одну или, наоборот, раскидать одну запись на несколько строк, в зависимости от того, как оно трактует связку ключей.

---

## 4. Как обнаружить проблему

1. **Проверить структуру таблиц в MySQL**  
   - Убедиться, что есть реальный первичный ключ (PRIMARY KEY) или хотя бы уникальный индекс (UNIQUE) на поле, которое выступает идентификатором.  
   - Если ключа нет, возможно, нужно ввести искусственный суррогатный ключ (например, `AUTO_INCREMENT`).

2. **Сравнить данные в таблицах фактов и измерений**  
   - Выбрать из MySQL несколько новых строк факта и посмотреть, совпадают ли их ключи (ID) со значениями в таблице измерения.  
   - Если обнаружится, что измерение не содержит соответствующих ключей (либо содержит дубликаты), станет понятно, почему Power BI «пропускает» записи.

3. **Посмотреть настройку связей (Relationships) в Power BI**  
   - В «Управление связями» (`Manage Relationships`) проверить, какое поле «Источник» (From) и «Приёмник» (To) выбраны, и верен ли тип связи (один-ко-многим, один-к-одному).  
   - Если там стоят «Many-to-many» или «One-to-one», хотя по логике должна быть «One-to-many», это может быть причиной путаницы.

4. **Создать визуальную таблицу без связей**  
   - В Power BI можно создать отдельную таблицу-отчёт (Table visual), загрузив данные напрямую из фактической таблицы. Если в этой «сырой» таблице видно новые записи, а в «сквозном» отчёте с измерением — нет, значит дело в том, что связь их «не проводит».

---

## 5. Решение проблемы

1. **Настроить реальные первичные ключи (Primary Key) в MySQL**  
   - Убедиться, что каждое поле, которое должно уникально определять запись, действительно объявлено в базе как `PRIMARY KEY` или хотя бы `UNIQUE`.  
   - При необходимости создать суррогатный ключ, чтобы избежать повторяющихся значений.

2. **Синхронизировать ключи измерений и фактов**  
   - Если добавляются новые записи в таблицу фактов с ключом `SomeID`, обязательно должны быть соответствующие записи в измерении.  
   - При разработке ETL-процессов или ручных загрузок проверять, что измерение обновляется раньше, чем факты, или что новые ключи гарантированно присутствуют в справочнике.

3. **Исправить связи в Power BI**  
   - Зайти в «Управление связями» и выставить правильные поля:  
     - «Many» (Многие) — там, где фактическая таблица может содержать много записей для одного ключа,  
     - «One» (Один) — там, где в измерении ключ уникален.  
   - Убедиться, что нет лишних Many-to-many, если по бизнес-логике это не нужно.

4. **Проверить тип данных ключей**  
   - Если в MySQL ключ text/VARCHAR, а в Power BI он был автоматически распознан как Number, нужно привести их к одному формату. Например, в Power Query явно указать тип «Text» для ключа, чтобы совпадали с тем, как они хранятся в измерении.

5. **Устранить дубликаты**  
   - Если в измерении (Dimension) или факте (Fact) обнаруживаются дубли ID, решить, как обрабатывать: либо убрать эти дубликаты, либо ввести дополнительный столбец (суррогатный ключ), чтобы уникально идентифицировать строки.

---

### Итог

Когда в MySQL или в модели Power BI отсутствуют явно заданные ключи (или настроены некорректно), **новые данные** из фактической таблицы могут **не присоединяться** к измерениям или не учитываться при фильтрации и агрегации. В итоге пользователь видит, что «после обновления данные не появляются в отчёте». 

Чтобы это исправить:

1. **Убедитесь, что в MySQL в таблицах действительно есть правильные первичные (или уникальные) ключи.**  
2. **Синхронизируйте измерения и факты** — новые ключи должны присутствовать в обоих.  
3. **В Power BI настройте связь** по соответствующим столбцам и выберите **корректную кардинальность** (One-to-many или другую нужную).  

Это гарантирует, что каждая новая строка из MySQL сможет корректно связаться со справочными таблицами и будет отображаться во всех визуалах отчёта.
~~~

## 26. «Некорректная кардинальность (один-к-одному, один-ко-многим, многие-ко-многим)»
### 26.1.
Я тебя спросил:
~~~
В пункте 2 своего ответа пункта 3.2 ты писал:
```
2. **Некорректная кардинальность (один-к-одному, один-ко-многим, многие-ко-многим)**  
   - Если по логике модели таблица должна быть в связке «один-ко-многим», но в Power BI неправильно выбрана «один-к-одному», новые данные могут не попадать в связку или вызывать конфликты.  
   - «Многие-ко-многим» является более сложным типом отношений и, если его использовать неосмотрительно, часть записей может «затеряться» при агрегациях или при наложении фильтров.
```
Опиши подробнее, каким образом «Некорректная кардинальность (один-к-одному, один-ко-многим, многие-ко-многим)» может приводить к проблеме клиента.
~~~

### 26.2.
Ты ответил:
~~~
Ниже описано, почему неправильно заданная **кардинальность** (тип связи) между таблицами в Power BI (например, «One-to-One» вместо «One-to-Many», либо «Many-to-Many» без особой необходимости) может привести к тому, что новые данные из MySQL не будут корректно отображаться в отчёте.

---

## 1. Что такое кардинальность в Power BI

1. **Определение**  
   В Power BI (и вообще в реляционных моделях) «кардинальность» указывает, как соотносятся записи в двух таблицах при соединении (relationship). Основные варианты:
   - **One-to-Many (один-ко-многим)**: в одной таблице каждый ключ (ID) встречается единожды (часто это «таблица измерений»), а в другой — множество раз (часто это «таблица фактов»).  
   - **One-to-One (один-к-одному)**: каждая запись в первой таблице соответствует ровно одной записи во второй (и наоборот).  
   - **Many-to-Many (многие-ко-многим)**: и в первой, и во второй таблице могут быть повторения ключа, а Power BI пытается связать их напрямую.

2. **Как Power BI выбирает кардинальность**  
   - При автоматическом определении связей Power BI может угадать неправильно, особенно если в таблицах есть неполные данные, дубликаты в ключевых полях или схожие названия столбцов.  
   - Пользователь также может вручную настроить связь, выбрав не тот тип (например, поставить «One-to-One», а в реальности там есть повторяющиеся ключи).

---

## 2. Почему неправильная кардинальность мешает видеть новые данные

1. **One-to-One вместо One-to-Many**  
   - Если по логике «таблица измерений» (Dimension) должна иметь уникальные значения в ключевом поле, а «таблица фактов» (Fact) содержит множество записей на каждый ключ, это классическая ситуация «один-ко-многим».  
   - Но если связь задана как «один-к-одному», Power BI будет ожидать, что во второй таблице тоже нет повторов ключа. При появлении новых строк (где ключ повторяется), могут возникать конфликты — часть записей Power BI «не стыкует» или игнорирует, а в некоторых случаях при моделировании появляется предупреждение об ошибке (несоответствие One-to-One).  
   - В итоге новые строки в таблице фактов (где ID повторяется) просто не учитываются при соединении, и визуалы не показывают данные.

2. **Many-to-Many (многие-ко-многим)**  
   - В Power BI можно создавать связи Many-to-Many, когда в обеих таблицах повторяются значения ключевого поля. Это более «гибкий» вариант, но очень часто приводит к нечёткой логике агрегаций или дублированию/пропуску строк при наложении фильтров.  
   - Если в новой партии данных количество повторов ключа увеличивается (например, появляется дополнительный дубль), Power BI может «размыто» сводить данные. В некоторых случаях часть строк не будет отображаться, если фильтры (slicers) работают некорректно при M2M-связи.

3. **Изменения в данных, нарушающие исходную кардинальность**  
   - Предположим, при первоначальном подключении в таблицах действительно была логика «One-to-One». А позже в MySQL добавили записи, и какой-то ключ стал повторяться много раз.  
   - Если в Power BI связь по-прежнему стоит как «One-to-One», то при обновлении могут возникать либо ошибки, либо новые записи «теряются» из-за несоответствия кардинальности.

4. **Проблемы с фильтрацией и двунаправленным фильтром**  
   - В Power BI есть настройка «Cross filter direction» (односторонний или двунаправленный). При «Many-to-Many» или некорректной «One-to-One» связи и двунаправленной фильтрации может получиться так, что часть новых записей просто не отображается, потому что фильтр не может корректно «пройти» через связь.  
   - Фактически, если Power BI «не понимает», как однозначно сопоставить ключи, он может исключить некоторые строки из итогового результата.

---

## 3. Примеры практических ситуаций

1. **Клиент видит, что новые заказы не отображаются**  
   - У клиента две таблицы: `Customers` (справочник клиентов) и `Sales` (фактические продажи). По логике модель должна быть «клиент (один) – продажи (много)».  
   - Но связь в Power BI настроена как One-to-One. Когда появляются новые продажи для уже существующего клиента, Power BI не может связать их, так как считает, что в `Sales` на одного клиента должна быть только одна строка. Новые строки пропускаются.

2. **У таблицы фактов появляется повторяющийся ключ**  
   - Допустим, «Код товара (ProductID)» в факт-таблице встречается несколько раз, а в таблице «Товары (Products)» каждая позиция уникальна. Это нормально для «один-ко-многим».  
   - Если связь ошибочно стоит Many-to-Many или One-to-One, Power BI может интерпретировать повторяющиеся ProductID как конфликт. При обновлении часть строк с тем же ProductID может быть проигнорирована или «сливаться» с уже существующей строкой.

3. **Many-to-Many при большом числе повторяющихся ключей**  
   - Иногда действительно бывает ситуация, где обе таблицы содержат дубли по ключу (например, два классификатора, которые пересекаются). Но если новых данных становится больше, и в одном из измерений появляются дополнительные дубли, в отчёте при фильтрации может появиться «пустое пересечение» или наоборот — дубли.  
   - Часто это приводит к тому, что в новой выборке «нет» данных, хотя фактически они есть, просто Power BI неверно сводит результаты.

---

## 4. Как распознать, что дело в некорректной кардинальности

1. **Сообщения Power BI о конфликте связей**  
   - При обновлении модель может выдавать предупреждения вида «A single value for column ‘…’ cannot be determined…» или «Relationship expects unique values, but duplicates found».  
   - Если вы видите подобные сообщения, значит реальная структура данных не соответствует выбранному типу связи.

2. **Пустые или частично пропущенные строки**  
   - При просмотре таблицы фактов (например, в «Data view» или при построении сводной таблицы) обнаруживается, что новые записи либо сливаются в одну ячейку, либо совсем не отображаются.  
   - Если отключить/удалить связь — вдруг все новые строки появляются. Это знак, что в связке есть проблема.

3. **Тестирование «один-к-одному» на уникальность**  
   - Если в Power BI установлена связь One-to-One, но вы подозреваете, что во второй таблице есть дубли, можно сделать в MySQL или Power BI проверку: `SELECT key_field, COUNT(*) FROM table GROUP BY key_field HAVING COUNT(*) > 1;`. Если такая проверка показывает дубли — значит One-to-One не подходит, нужно переключать на One-to-Many.

4. **Визуалы «пропадают» при использовании срезов**  
   - Если при выборе значения в срезе (slice) пропадают новые данные, это может быть из-за того, что связь Many-to-Many не позволяет Power BI корректно вычислить соответствие между выбранным ключом и записями факт-таблицы.

---

## 5. Как исправить кардинальность в Power BI

1. **Управление связями (Manage Relationships)**  
   - В Power BI Desktop открыть «Model» → «Manage Relationships» и проверить каждую связь. Убедиться, что:
     - Таблица, где ключ действительно уникален, стоит со стороны «One».  
     - Таблица, где ключ повторяется, — со стороны «Many».  
   - Если Power BI поставил «One-to-One», а на самом деле ключи дублируются, переключить на «One-to-Many».

2. **Проверить уникальность ключей в MySQL**  
   - Если предполагалось, что таблица измерений (Dimension) должна иметь уникальные ID, но в реальности у вас там дубли (или наоборот), нужно чистить или корректировать данные в MySQL, добавлять первичные ключи/уникальные индексы.  
   - Это поможет Power BI автоматически определять нужную кардинальность.

3. **Избегать Many-to-Many без острой необходимости**  
   - Если возможно перепроектировать схему (например, вынести «соединительную» таблицу), это лучше, чем напрямую связывать две таблицы, в каждой из которых дубли по ключу.  
   - Many-to-Many в Power BI часто усложняет модель и может приводить к путанице при фильтрации.

4. **Настроить направление фильтра (Cross filter direction)**  
   - Обычно при One-to-Many рекомендуют держать «Single direction»: фильтрация идёт из «One» в «Many».  
   - Двунаправленную (Both) включают осторожно и только при необходимости. Иначе могут появляться циклические связи и некорректные результаты.

---

## 6. Итог

Некорректная кардинальность — частая причина, по которой **новые записи** (особенно те, что повторяют ключи) **не отображаются** в отчёте Power BI. Чаще всего это проявляется, если:

- Требуется связь «один-ко-многим», а в модели указали «один-к-одному».  
- Без необходимости выбрана «многие-ко-многим», в результате чего фильтры и агрегации работают непредсказуемо.  
- В MySQL изначально был уникальный ключ, но после появления новых данных уникальность нарушилась, а связь в Power BI осталась прежней.

Чтобы устранить проблему:

1. Проверьте реальные данные (есть ли дубли?).  
2. В «Manage Relationships» выставьте правильную кардинальность.  
3. Убедитесь, что таблица со стороны «One» действительно содержит уникальные ключи, а «Many» может повторять их.  
4. По возможности не применяйте Many-to-Many без продуманного дизайна и понимания, как Power BI будет фильтровать такие данные.

Таким образом, корректная настройка кардинальности в Power BI гарантирует, что **все новые записи** из MySQL, в том числе с повторяющимися ключами, будут корректно «сопоставлены» и отобразятся в отчёте.
~~~

## 27. «Неактивные связи»
### 27.1.
Я тебя спросил:
~~~
В пункте 3 своего ответа пункта 3.2 ты писал:
```
3. **Неактивные связи**  
   - В Power BI можно иметь несколько связей между двумя таблицами, но лишь одна может быть «активной». Если активная связь не та, которая должна учитывать новые данные, то визуалы (особенно срезы и фильтры) могут по умолчанию работать не с нужной связью.  
   - В результате при обновлении данные как бы загружаются, но не отображаются, потому что Power BI ссылается не на ту связь, которая отражает нужные поля для сопоставления.
```
Опиши подробнее, каким образом «Неактивные связи» может приводить к проблеме клиента.
~~~

### 27.2.
Ты ответил:
~~~
Ниже рассмотрено, как **неактивные связи** между таблицами в модели Power BI могут приводить к тому, что новые данные не отображаются или частично теряются при построении визуалов и фильтров:

---

## 1. Что значит «неактивная» связь в Power BI

1. **Наличие нескольких связей между одними и теми же таблицами**  
   - В Power BI возможно иметь более одной связи между двумя таблицами. Например, в таблице фактов (Sales) есть два разных поля дат (OrderDate и ShipDate), и обе эти даты ссылаются на общую таблицу календаря (Calendar). В итоге может создаться две связи (Sales[OrderDate] → Calendar[Date], Sales[ShipDate] → Calendar[Date]).  
   - Power BI при этом может «активировать» только **одну** связь по умолчанию; все остальные считаются **неактивными**.

2. **Неактивная связь**  
   - «Неактивная» связь физически присутствует в модели, но **не используется** автоматически при фильтрации в визуалах или вычислениях. Чтобы задействовать её, нужно явно использовать функции DAX вроде `USERELATIONSHIP` или иным способом указать, что фильтрация идёт по этой дополнительной связи.  
   - Если связь неактивна, срезы, фильтры и агрегации **по умолчанию** ею не пользуются.

---

## 2. Почему неактивная связь может скрывать новые данные

1. **Визуал ориентируется на неправильную (активную) связь**  
   - Допустим, в фактической таблице есть новое поле (NewDate), по которому вы хотели бы связать её с таблицей «Calendar». Однако в модели уже существовала активная связь по другому полю (OldDate).  
   - Если Power BI использует активную связь (OldDate), новые данные, которые завязаны именно на NewDate, остаются «невидимыми» при наложении фильтра или при срезе дат.  
   - Внешне может показаться, что «новые записи не подтянулись», хотя они есть в модели, просто при построении визуала применяется **не та** связь.

2. **Дополнительная логика в DAX-вычислениях**  
   - Иногда разработчик намеренно создаёт две связи (например, «Заказ по OrderDate» и «Факт отгрузки по ShipDate»). Одна из связей активна (OrderDate → Calendar), другая — нет. Если вдруг бизнес-логика меняется, и ключевой анализ теперь строится по ShipDate, а связь по ShipDate остаётся неактивной, то фильтры по ShipDate не будут срабатывать.  
   - Любые новые записи, где ShipDate лежит за рамками OrderDate, или вообще отличаются, «выпадают» из видимости, так как Power BI по умолчанию не знает, что нужно использовать ShipDate.

3. **Путающиеся фильтры и срезы (slicers)**  
   - При наличии нескольких связей иногда пользователь ставит на отчёт срез (Slicer) по полю из таблицы-измерения, ожидая, что фильтр затронет фактическую таблицу по соответствующему полю. Но если «нужная» связь неактивна, то фильтр не «доходит» до нужных строк — и часть или все новые данные не показываются.

---

## 3. Примеры, как проявляется проблема

1. **Отсутствие новых строк при работе со срезом (Slicer)**  
   - Пользователь выбирает диапазон дат в срезе, но видит только часть записей (или их отсутствие). Проверка показывает, что реальные данные у новых строк лежат в другом поле даты, для которого связь оказалась неактивной.

2. **(Blank) или пустые графики**  
   - Если неактивная связь никак не «присоединяет» новую таблицу-измерение, то при построении визуала Power BI не сможет отфильтровать нужные категории/записи. График или таблица может получаться пустой.  

3. **«Невнятные» итоги в мерах**  
   - Возможно, у вас есть DAX-выражение, где нужно считать продажи именно по дате отгрузки (ShipDate). Но DAX-формула пользуется активной связью (по OrderDate) и игнорирует ShipDate. Итоговые данные не отражают «реальное» состояние по дате отгрузки.

---

## 4. Как выявить неактивные связи и понять, что именно они мешают

1. **Проверить «Manage Relationships» (Управление связями) в Power BI**  
   - В разделе «Модель» или «Управление связями» можно увидеть список всех отношений между таблицами. Для каждого Relationship есть параметр «Активно» (Active). Если связь неактивна, отметка «Активно» будет снята.  
   - Иногда Power BI автоматически отключает связь, если видит, что она вызывает двусмысленность (ambiguous relationship).

2. **Посмотреть на схему модели (Diagram view)**  
   - Неактивные связи отображаются пунктирной линией (в отличие от сплошной линии у активных связей). Если вы видите пунктир, значит связь не участвует в фильтрации по умолчанию.

3. **Проверить DAX-выражения**  
   - Если вы в формулах (Measures) используете `USERELATIONSHIP(Table1[Field], Table2[Field])`, значит ссылка на неактивную связь у вас задействована вручную. Если же наоборот такая функция не прописана, а связь неактивна, Power BI по умолчанию **не будет** использовать её.

4. **Тестовое «Переключение» связи**  
   - Иногда, чтобы проверить, в этом ли проблема, можно временно сделать нужную связь активной и посмотреть, «появятся» ли новые данные в визуале. Если при включении новой связи сразу видно новые записи, значит именно она была нужна.

---

## 5. Способы решения

1. **Активировать нужную связь**  
   - Если вы уверены, что теперь нужна именно эта связь как основная, можно сделать её активной в «Manage Relationships». Но надо быть аккуратным: если в модели уже есть другая активная связь, Power BI может потребовать, чтобы вы сначала отключили (или удалили) вторую связь, дабы избежать неоднозначности.

2. **Использовать DAX-функцию `USERELATIONSHIP`**  
   - Если по смыслу вам нужно при определённых расчётах пользоваться неактивной связью (например, для ShipDate), в соответствующих мерах применяйте формулу вида:  
     ```DAX
     Measure = CALCULATE(
       SUM(Sales[Amount]),
       USERELATIONSHIP(Sales[ShipDate], Calendar[Date])
     )
     ```
   - Тогда Power BI при расчёте этой меры возьмёт именно связь по ShipDate. Таким образом можно чётко разделять аналитику по OrderDate (активная связь) и ShipDate (неактивная связь, задействуемая вручную).

3. **Сократить число связей (или перестроить модель)**  
   - Если возникло несколько связей, но одна из них больше не нужна, лучше удалить неиспользуемую связь, чтобы не создавать путаницы.  
   - Или, наоборот, вынести столбцы в отдельную таблицу (Date dim) и использовать одну связь с помощью дополнительного поля, если логика действительно требует нескольких вариантов дат.

4. **Сделать отдельную таблицу календарей**  
   - Иногда для OrderDate и ShipDate делают две разные таблицы календаря (CalendarOrder и CalendarShip), каждая из которых имеет свою активную связь. Таким образом, в отчёте будут два среза: «Дата заказа» и «Дата отгрузки». Это упрощает пользователю понимание, почему в одном случае новые данные видны, а в другом — нет.

---

## 6. Итог

Когда связь в Power BI **неактивна**, она **не применяется** в визуалах и фильтрах по умолчанию. Если именно по этой связи должны «приходить» новые данные (например, связка с другим полем даты, другим ключом), то в отчёте такие новые строки могут не отображаться — ведь их связь с таблицей-измерением не используется.

**Вывод**: 
- Проверьте, какие связи в модели Power BI активны, и соответствуют ли они реальному пути фильтрации для новых данных.  
- Если нужная связь оказалась неактивной — либо сделайте её активной (если это основная логика), либо используйте `USERELATIONSHIP` в DAX, если требуется альтернативное соединение.  
- Это позволит Power BI корректно подтягивать и показывать все новые данные, которые раньше «оставались за бортом» из-за неправильного или неактивного отношения между таблицами.
~~~

## 28. «Несоответствие типов полей для связей»
### 28.1.
Я тебя спросил:
~~~
В пункте 4 своего ответа пункта 3.2 ты писал:
```
4. **Несоответствие типов полей для связей**  
   - Допустим, в MySQL столбец с ID или кодом хранится как `VARCHAR`, а в Power BI этот же столбец определяется как `числовой`. При сопоставлении могут возникать ошибки, приводящие к тому, что часть значений не стыкуется между таблицами.  
   - В итоге, когда идет обновление, Power BI «видит» несоответствия в данных, и новые строки просто не привязываются к таблице-фильтру или не учитываются в итоговых расчётах.
```
Опиши подробнее, каким образом «Несоответствие типов полей для связей» может приводить к проблеме клиента.
~~~

### 28.2.
Ты ответил:
~~~
Ниже рассмотрено, как именно несоответствие типов данных в полях, используемых для связей (Relationships) между таблицами в Power BI, может приводить к тому, что новые (а иногда и старые) записи не отображаются или не стыкуются в отчёте:

---

## 1. В чём суть проблемы «Несоответствие типов» в полях для связей

1. **Различные типы в MySQL и Power BI**  
   - Допустим, в базе MySQL столбец `OrderID` хранится как `VARCHAR(50)` (т. е. строка), а в Power BI по ошибке он считывается или сконвертирован в число (Whole Number).  
   - При настройке связи (Relationship) в Power BI между двумя таблицами, где одна сторона «ожидает» тип «число», а другая сторона — «текст», может происходить конфликт.  
   - В результате Power BI либо не позволяет создать такую связь вовсе, либо создаёт её, но не учитывает часть данных.

2. **«Числовые» ключи, содержащие нечисловые символы**  
   - Бывают случаи, когда в MySQL поле с ID номинально хранится как число (`INT`), но на практике туда попадают строки формата «00123», или вообще «AB123». Если Power BI конвертирует его в целое число, «00123» станет «123», а «AB123» выдаст ошибку.  
   - При обновлении часть таких значений превращается в `Null` или вызывает сбой преобразования. В итоге новые строки «пропадают» из связей.

3. **Дата/время vs. текст**  
   - Ещё одна распространённая ситуация: в MySQL поле с датой (`DATE`, `DATETIME`) хранится корректно, а Power BI воспринимает его как текст (или наоборот). При сопоставлении дат (например, в таблице календаря) возникает несоответствие: «строка» не равна «дате».  
   - Итог — свежие записи не связываются с календарём и не попадают в нужные диапазоны дат.

---

## 2. Как проявляется проблема в отчёте

1. **Часть (или все) новые записи не видны в визуалах**  
   - При обновлении данных клиент замечает, что в таблице MySQL уже есть новые строки, а в отчёте — нет. Виноват может быть «сломанный» Relationship: если ключ в фактической таблице (Fact) и ключ в таблице измерений (Dimension) не совпадают по типам, они не «стыкуются».  
   - Аггрегации (суммы, подсчёты) и фильтрация (slicers, drill-down) игнорируют несвязанные строки.

2. **(Blank) значения в полях-связях**  
   - Если часть строк не может быть преобразована в нужный тип (например, при попытке конвертировать «ABC123» в число), Power BI заменяет их на `Null` или `(Blank)`.  
   - Тогда в связанных таблицах для таких записей не находится «пар» по Relationship, и в итоге меры (Measures) показывают заниженные итоги, а визуалы — меньше строк, чем в базе.

3. **Ошибка (или предупреждение) преобразования типа**  
   - В Power Query при загрузке данных могут всплывать сообщения вроде «Couldn’t convert to Number» или «Conversion error». Если эти ошибки игнорируются или «поглощаются» (Replace Errors), часть строк просто не доходит до модели.  
   - В сервисе Power BI (при Scheduled Refresh) может появляться ошибка о том, что столбец не соответствует ожидаемому типу.

---

## 3. Типичные сценарии «ломающихся» связей из-за типа полей

1. **MySQL хранит ID как строку (VARCHAR), а в Power BI — число**  
   - В таблице «Факты» поле `OrderID` = `VARCHAR(20)`, а в таблице «Измерение заказов» (Order Dimension) тоже `OrderID`, но в Power BI пользователь вручную поставил тип «Whole Number» (или автоматическое определение решило, что это число).  
   - При загрузке все текстовые значения, содержащие буквы или лидирующие нули, не конвертируются и выпадают из связей.

2. **Дата в MySQL (DATE), а Power BI видит текст**  
   - Иногда при автодетекте Power BI воспринимает поле с датой как текст из-за формата, не совпадающего с региональными настройками (например, MySQL хранит в `YYYY-MM-DD HH:MM:SS`, а Power BI видит другую локаль).  
   - Тогда при попытке связи с таблицей календаря (Calendar Table) ключ «DateKey» не совпадёт с текстовым «DateString». Новые строки, имеющие дату после определённого периода, остаются вне связи.

3. **Число в MySQL, а строка в Power BI (или наоборот)**  
   - Поле в базе `int(11)` (целое), но фактически туда могут попадать нулевые или отрицательные значения, а разработчик в Power BI поставил тип «Text» ради каких-то фильтров. При попытке связи с другими таблицами, где поле — «Whole Number», появляются несоответствия.

---

## 4. Почему страдают именно «новые» данные

1. **Раньше значения «подходили» под тип**  
   - Часто бывает, что в старых записях `OrderID` действительно был чисто цифровой, типа «1001», «1002» — Power BI спокойно конвертировал их в Whole Number.  
   - А при появлении новых заказов с форматом «AB-2301» тип перестал быть числовым, и эти записи отбрасываются. Кажется, что «новых данных нет», хотя старые показываются.

2. **Изменение структуры таблицы в MySQL**  
   - В какой-то момент администратор базы мог сменить тип столбца (с `INT` на `VARCHAR`), или поменялся формат даты (добавилось время). Старые данные остались в допустимом формате, а новые — уже не воспринимаются Power BI.  
   - Тогда визуализация перестаёт видеть часть строк, именно «свежих».

---

## 5. Как обнаружить и устранить проблему

1. **Проверить реальные типы полей в MySQL**  
   - Выполнить `DESCRIBE table_name;` или посмотреть в MySQL Workbench, какой тип **фактически** у столбца (VARCHAR, INT, DATE, DECIMAL и т. д.).  
   - Сравнить с тем, что Power BI «думает» о типе этого столбца (в Power Query → Transform Data → тип столбца).

2. **Привести типы данных к единому формату**  
   - Если действительно нужен текст, в MySQL желательно хранить его как `VARCHAR`, а в Power BI явно ставить тип «Text». Если поле — это число, тогда и в базе, и в Power BI должен быть Numeric/Whole Number.  
   - Для дат/времени аналогично — убедиться, что и в базе, и в Power BI используется тип Date или DateTime (вместо «text»).

3. **Просмотреть шаги Power Query**  
   - Иногда на этапе автодетекта Power BI вставляет «Changed Type» шаг. Нужно убедиться, что там стоит корректный тип. Если при конвертации появляются ошибки, часть новых строк может отсекаться.  
   - При необходимости добавить логику преобразования: `Table.TransformColumnTypes(...)` с учётом нестандартных значений (замена ошибок, устранение лишних символов).

4. **Проверить, что связи (Relationships) активны**  
   - В Power BI → «Управление связями» (Manage Relationships). Если связь неактивна (например, из-за несоответствия типов), нужно её исправить: выбрать оба столбца, которые действительно являются одинаковым типом (Text к Text, Number к Number).  
   - Если в одной таблице «OrderID» — Text, а в другой — Number, нужно в Power Query привести один из них к формату другого.

5. **Убедиться в отсутствии «проблемных» значений**  
   - Если часть новых записей содержит явно некорректный формат (например, «—» или «N/A» вместо числового ID), стоит либо почистить это на уровне базы, либо добавить шаг Power Query, который обрабатывает такие случаи (заменяет `N/A` на `Null` и т. п.).  
   - Иначе при попытке обновить отчёт в Service возникнут ошибки, или строки будут отбрасываться.

---

### Итог

Когда типы полей, используемых в связях (Relationships) между таблицами, не совпадают (например, MySQL хранит ID как текст, а Power BI воспринимает его как число), новые (и иногда старые) записи не будут корректно «стыковаться» между фактами и измерениями. В результате **часть данных теряется** при визуализации, пользователи не видят свежих строк, и кажется, что «обновление не работает». Исправление заключается в том, чтобы:

1. Явно указать **одинаковые** типы столбцов (Text к Text, Number к Number, Date к Date)  
2. Проверить **шаги Power Query** на предмет автоматических или ручных преобразований, которые могут ломать формат  
3. Убедиться, что **связи** в Power BI активны и используют **одинаковый тип** ключевых полей.

Такой аудит и синхронизация типов данных позволит новым записям из MySQL корректно попадать в модель Power BI и отображаться в отчётах.
~~~

## 29. «Проблемы с изоляцией данных в разных таблицах»
### 29.1.
Я тебя спросил:
~~~
В пункте 5 своего ответа пункта 3.2 ты писал:
```
5. **Проблемы с изоляцией данных в разных таблицах**  
   - Если у клиента есть несколько таблиц фактов (Fact) и измерений (Dimension), и логика подразумевает, что новая запись должна связаться с новыми или старыми записями в других таблицах, но соответствующие связи не проставлены или отсутствуют, то для Power BI такая новая запись может оставаться «одинокой».  
   - Например, новая строка в фактической таблице продаж не отображается в визуале, если нет соответствующей строки в справочнике товаров или если связь между «Продажи» и «Товары» не настроена или настроена неверно.
```
Опиши подробнее, каким образом «Проблемы с изоляцией данных в разных таблицах» может приводить к проблеме клиента.
~~~

### 29.2.
Ты ответил:
~~~
Ниже рассмотрены ситуации, при которых «проблемы с изоляцией данных в разных таблицах» (особенно когда есть несколько таблиц фактов и измерений) приводят к тому, что **новые записи** могут не отображаться в Power BI:

---

## 1. Что значит «изоляция» данных в разных таблицах

1. **Раздельное хранение связанной информации**  
   - В реляционной (или аналитической) модели часто используются таблицы фактов (Fact) и измерений (Dimension).  
   - **Fact**-таблица содержит ключевые поля (Foreign Keys) на измерения (Dimension), а также показатели (Measures: сумма продаж, количество, стоимость и т. д.).  
   - **Dimension**-таблицы содержат справочную информацию (например, товары, клиенты, даты, регионы).

2. **Проблема изоляции**  
   - Возникает, когда данные в одной таблице (например, фактической) не согласованы с данными в других (измерениях).  
   - Например, вставили новую строку в факт «Продажи», но в справочнике «Товары» (Dimension) отсутствует соответствующая запись о товаре или ключ (ProductID).  
   - Power BI, при сборке модели и связей, не «находит» нужной записи в измерении, а значит, фактическая строка остаётся «одинокой» и может не отображаться в отчёте (особенно если включены связи «один-ко-многим» или фильтрация «Both»).

---

## 2. Как это проявляется в Power BI

1. **Новые записи не показываются в визуалах**  
   - Допустим, в таблице FactSales появилась запись с `ProductID = 1234`. Если в таблице DimProduct нет строки с таким `ProductID`, тогда связь (Relationship) не даёт Power BI возможности сопоставить эти продажи с конкретным товаром.  
   - Во многих визуалах (особенно если используется фильтр или поля из измерения) такая продажа будет проигнорирована или показана как `(Blank)` в срезах (slicers).

2. **Строки видны только как «(Blank)» в измерении**  
   - В ряде случаев, если Power BI не может найти соответствующую строку в измерении, при использовании измерения (например, «Название товара») эти строки «складываются» в категорию `(Blank)` или вообще пропадают из-под фильтра.  
   - Пользователь видит, что суммарные продажи меньше ожидаемого, а при разборе выясняется, что часть строк попала в «непривязанную» категорию.

3. **Аномалии при Drilldown/Drillthrough**  
   - Если пользователь проваливается (drillthrough) из агрегированного отчёта в подробности, новые строки могут исчезнуть или не отображаться, потому что на детальном уровне Power BI пытается связать таблицу фактов с измерением, и несвязанные записи исключаются.

---

## 3. Основные причины «изолированных» записей

1. **Отсутствие или неверные Foreign Keys**  
   - Если в MySQL (или другой СУБД) не настроены физические внешние ключи (или хотя бы логическая согласованность), то вполне может случиться, что в FactSales вставили `ProductID = 9999`, которого нет в DimProduct.  
   - В результате в Power BI эти строки «выпадают» из связи.

2. **Записи вставлены с неправильным ключом**  
   - Ошибка в коде (ETL-скрипте) или при ручном вводе: связка делается по `ProductKey`, а фактически вставили «левое» значение, либо пустое (`NULL`), либо использовали код старой системы, не совпадающий с кодами в новой.  
   - Внешне «в базе запись есть», но в отчёте она не подцепляется.

3. **Новые записи в одном измерении, но не обновлены в связанной таблице**  
   - Существует также обратная ситуация: добавили новый товар в DimProduct, но при этом в FactSales (фактической таблице) ещё нет продаж по нему, и пользователь полагает, что «всё настроено», — однако как только придут продажи для этого товара, ключ может не совпасть (или ещё не завели запись в другом измерении).  
   - Итог тот же: фактические строки не найдут «путь» к измерению.

4. **Несовпадение типов данных**  
   - Если в DimProduct `ProductID` хранится как `VARCHAR`, а в FactSales — как `INT`, или есть расхождение в кодировках, Power BI при попытке связать может не «увидеть» совпадений.  
   - Такие несоответствия часто приводят к тому, что часть ключей воспринимается Power BI как разные объекты (`"123"` vs `123`).

---

## 4. Пример, как возникает «изоляция»

1. **Таблица FactSales**  
   ```
   OrderID | ProductID | CustomerID | SaleDate | Qty | Amount
   ---------------------------------------------------------
   101     | 9999      | 501        | 2023-10-01 | 2   | 200.00
   102     | 1001      | 502        | 2023-10-02 | 1   | 99.00
   ```
2. **Таблица DimProduct**  
   ```
   ProductID | ProductName
   -----------------------
   1001      | "Notebook X"
   1002      | "Notebook Y"
   ```
   - В DimProduct **нет** записи для `ProductID = 9999`.
3. **Что увидит Power BI**  
   - При связи FactSales → DimProduct (по полю ProductID), строка с `ProductID = 9999` не найдёт соответствия в DimProduct.  
   - В отчёте, где пользователь выводит `ProductName` (из DimProduct) и `Amount`, строка с `9999` либо не попадёт в результат, либо пойдёт в `(Blank)`.

---

## 5. Почему кажется, что «данные не тянутся», хотя они в базе

1. **Пользователь видит, что запись в FactSales присутствует**  
   - «Вот же, мы делали SELECT * FROM FactSales, там есть OrderID=101!»  
   - Но в Power BI отчёт сгруппирован по «ProductName» (из DimProduct), и `9999` не матчит ни одну строчку измерения.

2. **Фильтры и срезы скрывают «пустые» связки**  
   - Если в отчёте установлен фильтр по «ProductName <> Blank», тогда несвязанные записи просто отбрасываются целиком.

---

## 6. Как исправить проблемы с изоляцией данных

1. **Убедиться в согласованности ключей**  
   - В базе MySQL настроить или проверить механизмы Foreign Key (если возможно).  
   - Если есть отдельный процесс (ETL) по загрузке справочников (Dimension), следить, чтобы записи в измерениях появлялись **до** вставки соответствующих строк в факты.  
   - Если нужно, создавать заглушки («Unknown product») для случаев, когда реальный ключ ещё не внесён.

2. **Сверять типы данных**  
   - Проверить, что в Fact и Dimension поля, по которым строится связь, имеют одинаковый тип (текст vs. число, регистр символов, кодировка).  
   - В Power Query убедиться, что столбцы не были автоматически сконвертированы в разные типы (например, один — текст, другой — число).

3. **Настройка связей в Power BI**  
   - Зайти в «Manage Relationships» и проверить, что связь по нужным полям активна, тип связи (Cardinality) корректен: «One-to-many» (и не «Many-to-many», если это не нужно).  
   - При необходимости настроить направление фильтрации (Cross filter direction) — чаще всего «Single», чтобы избежать двусмысленности.

4. **Проверять, нет ли несвязанных ключей**  
   - Запустить запрос в MySQL вида:  
     ```sql
     SELECT f.ProductID
     FROM FactSales f
     LEFT JOIN DimProduct d ON f.ProductID = d.ProductID
     WHERE d.ProductID IS NULL;
     ```  
     Если вернутся строки, значит, часть фактов не имеет соответствия в измерении. Нужно либо добавить такие `ProductID` в `DimProduct`, либо заменить/исправить.

5. **Обучить пользователей о наличии категорий (Blank)**  
   - Если по бизнес-логике возможно, добавить в DimProduct строку «(Unknown product)» для тех случаев, когда ProductID не найден.  
   - Тогда, в крайнем случае, в отчёте появится «Unknown product» вместо полного отсутствия новой записи. Пользователи сразу увидят, что нужно доработать справочник.

---

## 7. Заключение

«Проблемы с изоляцией данных в разных таблицах» возникают, когда **новые записи в одной таблице** (чаще всего фактов) **не находят соответствия** в связанных таблицах (чаще всего измерений). В Power BI это приводит к тому, что эти записи:

- Либо **не отображаются** в визуалах (особенно если используется поле из измерения в Rows/Columns).  
- Либо **сгруппированы под `(Blank)`** и отсеиваются при фильтрации.

Основной путь решения — обеспечить **консистентность ключей** (FK), следить за корректным **порядком загрузки** (сначала обновляются измерения, потом факты), а в Power BI проверить **Manage Relationships**, типы данных и отсутствие автоматической фильтрации `(Blank)`. Тогда все новые записи из MySQL смогут корректно связываться с нужными справочниками и показываться в отчёте.
~~~

## 30. «Ошибочные фильтры в таблицах с отношениями»
### 30.1.
Я тебя спросил:
~~~
В пункте 6 своего ответа пункта 3.2 ты писал:
```
6. **Ошибочные фильтры в таблицах с отношениями**  
   - Если модель Power BI использует фильтрацию «Применять фильтрацию в обеих таблицах» (cross-filter direction = Both), некорректная связь может привести к тому, что фильтр (слайсер) из одной таблицы будет исключать новые записи в другой.  
   - Это особенно часто встречается, когда у таблиц есть вторичные связи через промежуточные таблицы, и неправильная настройка отношений может блокировать вывод нужных данных.
```
Опиши подробнее, каким образом «Ошибочные фильтры в таблицах с отношениями» может приводить к проблеме клиента.
~~~

### 30.2.
Ты ответил:
~~~
Ниже рассмотрены ситуации, когда в **модели Power BI** при наличии связей между таблицами может возникать **ошибочная фильтрация**, приводящая к тому, что **новые записи** (или даже старые) **не отображаются** в отчёте. Особенно часто это встречается при настройке свойства **Cross-filter direction = Both** («Двусторонняя фильтрация») и при наличии сложных цепочек связей.

---

## 1. Как работает фильтрация в таблицах, связанных между собой

1. **Обычная (односторонняя) фильтрация**  
   - По умолчанию в Power BI связь «один-ко-многим» (One-to-Many) передаёт фильтры **со стороны «один»** на сторону «многие», но не наоборот.  
   - Например, если есть таблица **Product** (измерение, «один») и таблица **Sales** (факт, «многие»), то при выборе конкретного товара в таблице Product Power BI автоматически фильтрует записи в Sales (все продажи этого товара).  
   - Но фильтры, наложенные на Sales, не «поднимаются» обратно в Product, если направление фильтрации стоит «Single» (в одну сторону).

2. **Двусторонняя (Both) фильтрация**  
   - Если же включено свойство **Cross-filter direction = Both**, то фильтр распространяется **в обоих направлениях**: выбор в таблице Product повлияет на Sales, *и* выбор в таблице Sales повлияет на Product.  
   - На практике это упрощает работу с некоторыми моделями (особенно при наличии нескольких таблиц-измерений, связанных через факт). Но при неверной настройке может привести к непредвиденным замыканиям фильтра — когда фильтр «гасит» часть данных.

3. **Сложные цепочки связей**  
   - Если в модели есть промежуточные таблицы (например, `TableA` связана с `TableB`, а `TableB` — с `TableC`) и везде включена двусторонняя фильтрация, Power BI может «прокидывать» фильтры по всей цепочке.  
   - При наличии неправильного типа связи, плохих ключей или замкнутых (циклических) отношений может возникать ситуация, когда выбор среза (Slicer) в одной таблице **автоматически исключает** новые записи в другой, хотя логически этого быть не должно.

---

## 2. Типичные причины «ошибочных фильтров» при двусторонней фильтрации

1. **Неверный тип связи (One-to-One, Many-to-Many)**  
   - Если по факту данные должны быть в связи «один-ко-многим», но в Power BI из-за автодетектирования или ручной ошибки связь оказалась «один-к-одному» или «многие-ко-многим», то фильтры начинают распространяться нелогичным образом.  
   - При режиме «многие-ко-многим» (Many-to-Many) Power BI может создавать сложные «пересечения» фильтров: если в одной таблице нет сопоставления для новых записей, они отсекаются и в других таблицах.

2. **Циклические (замкнутые) связи**  
   - Power BI не разрешает прямые циклы в отношениях, однако при наличии двусторонней фильтрации квазицикл может возникать через несколько промежуточных таблиц.  
   - В результате фильтры «самопроизвольно» пересекаются, и часть строк (включая новые) могут отбрасываться, когда вы выбираете что-то в другом срезе.

3. **Автодетектирование связей по похожим столбцам**  
   - Иногда Power BI ошибается при автоматическом обнаружении отношений, связывая поля, которые **не** должны связываться. Если эти столбцы содержат неполные или неподходящие значения, фильтр может исключать записи (особенно если в новых записях значения в одном столбце не совпадают с ожидаемыми).

4. **Механизм «Cross-filter direction = Both» действует там, где не нужен**  
   - В больших моделях (с множеством измерений и фактов) рекомендуется аккуратно использовать «Both», зачастую ставить «Single» (одностороннюю) фильтрацию, кроме случаев, когда двусторонняя действительно необходима.  
   - Если «Both» выставлена повсеместно, при добавлении новых записей их значения могут «не находить» соответствий в других таблицах и автоматически отсеиваться цепочкой фильтров.

---

## 3. Как это проявляется: почему кажется, что новые данные «не подтягиваются»

1. **Визуалы показывают меньше строк, чем есть в базе**  
   - Клиент обновляет MySQL, видит «в базе 5000 строк», а в отчёте, например, только 4800. 200 новых строк пропадают. При этом никаких ошибок нет, связь формально «работает», просто фильтр отсекает часть строк.

2. **Новые записи не видны при выборочном фильтре (Slicer)**  
   - Если в модели есть связь между `TableA` (где появляются новые записи) и `TableB` (где выбран срез или фильтр), и связь «Both», фильтр `TableB` может не иметь значений, соответствующих новым записям.  
   - Power BI решает: «Раз в `TableB` нет такой категории/идентификатора, значит в `TableA` тоже не должно быть соответствующих строк», — и исключает их из визуала.

3. **Сбои в сложных M2M-отношениях**  
   - При связи «многие-ко-многим» Power BI выстраивает специальный механизм сопоставления. Если новые записи в одной таблице не имеют пары в другой, при наложении фильтра могут исчезать. Пользователь замечает это как «не отображаются новые записи».

---

## 4. Пример сценария с неправильным направлением фильтра

Допустим, у нас есть:

- **Таблица Sales** (факт) со столбцом `CustomerID`  
- **Таблица Customers** (измерение) со столбцом `CustomerID` (primary key)  

В норме:
- Связь должна быть «One (Customers) to Many (Sales)», фильтрация идёт от Customers к Sales в режиме Single (по умолчанию).

Однако:
1. Если кто-то **включил Cross-filter direction = Both**, то выбор каких-то записей в Sales (например, по датам или сумме) может отфильтровать часть Customers, у которых нет продаж за выбранные периоды.  
2. Если появились **новые** `CustomerID`, которых ещё нет в Sales (или наоборот), такие записи могут не отображаться в визуалах, когда включён фильтр по другой таблице.  

На практике это приводит к тому, что «свежедобавленный» клиент может не виден быть в списке, пока не появятся соответствующие продажи, или пока фильтры не будут сняты.

---

## 5. Как убедиться, что дело в отношениях и фильтрации

1. **Отключить (или поменять) двустороннюю фильтрацию**  
   - В «Управление связями» (Manage Relationships) выбрать конкретную связь и изменить Cross-filter direction на «Single». Посмотреть, перестали ли «пропадать» новые записи.

2. **Временно удалить связь**  
   - Если разорвать предполагаемую проблемную связь, а новые записи вдруг начинают отображаться (хотя и теряется часть функционала), значит причина в неправильном фильтре по связанной таблице.

3. **Проверить, совпадают ли ключевые значения в обеих таблицах**  
   - Если в новых записях Sales стоит `CustomerID = 999`, а в Customers нет `CustomerID = 999`, при двусторонней фильтрации этот `999` может отсеиваться. Если же Customers — сторона «один», то теоретически в Sales не должно быть такого ID без соответствия, но в реальности бывает, если данные в Customers запаздывают.

4. **Изучить настройки срезов и визуалов**  
   - Возможно, в отчёте настроен срез (Slicer) из таблицы `TableB`. Если новые значения не появились в `TableB`, Power BI не будет отображать соответствующие записи в `TableA`, поскольку «Both»-direction фильтр это исключит.

---

## 6. Рекомендации по устранению «ошибочных фильтров»

1. **Использовать двустороннюю фильтрацию выборочно**  
   - Устанавливать Cross-filter direction = Both только там, где это действительно обосновано (например, при работе с таблицей дат, если она нужна для «взаимной» фильтрации нескольких фактов).  
   - Во всех остальных случаях лучше придерживаться односторонней фильтрации, чтобы избежать цепного влияния.

2. **Следить за корректностью ключевых полей**  
   - Убедиться, что нет «лишних» записей без соответствующего ключа в связанной таблице (CustomerID в Sales, которого нет в Customers). Если такие данные есть — определите, как их обрабатывать (может, нужна строка «Неизвестный клиент» или нужно синхронизировать справочники заранее).

3. **Проверять автоматическую генерацию связей**  
   - Power BI иногда сам создаёт отношения, основываясь на названиях колонок и на частичном совпадении данных. Это может приводить к связи, которая логически не нужна. Отключите в настройках автодетектирование или внимательно проверяйте все автоматически созданные связи.

4. **Посмотреть, не возникает ли цепочка M2M**  
   - Если у вас несколько таблиц связаны между собой (например, Sales ↔ Products, Sales ↔ Customers, Customers ↔ Regions, Regions ↔ Sales2, и т. п.), и везде стоит «Both», то велик риск, что фильтрация «заведётся» по кругу. Упростите модель или уберите часть «Both».

5. **Тестировать модель без фильтров**  
   - Для диагностики создайте простую таблицу/визу без каких-либо срезов, чтобы убедиться, что новые записи действительно загружаются в модель. Если так — значит, именно фильтры (через связи) их отсекают.

---

### Итог

Когда в Power BI **между таблицами установлены связи** с **двусторонней** фильтрацией (**Cross-filter direction = Both**) или некорректно определён тип связи (One-to-One, Many-to-Many), может возникать **«парадокс фильтров»**. Новые записи (или строки без соответствия в другой таблице) оказываются исключёнными из визуалов, хотя физически **они есть** в модели.  

Это создаёт впечатление, что данные **«не подтягиваются»** или **«пропадают»**, хотя на самом деле они **фильтруются** логикой отношений. Решение — аккуратно проверять:

- **Тип отношений** (One-to-Many vs. Many-to-Many),  
- **Настройки направления фильтрации** (Single vs. Both),  
- **Соответствие ключевых значений** в обеих таблицах,  
- **Отсутствие паразитных связей**, созданных автодетектированием.

Корректируя эти моменты, вы устраните ситуацию, при которой «ошибочные» фильтры скрывают новые записи от пользователя.
~~~

## 31. «Изменения структуры в MySQL без обновления модели Power BI»
### 31.1.
Я тебя спросил:
~~~
В пункте 7 своего ответа пункта 3.2 ты писал:
```
7. **Изменения структуры в MySQL без обновления модели Power BI**  
   - Если в MySQL добавлено новое поле или переименовано старое, а в Power BI связь всё ещё ссылается на старое название или старую структуру, то при обновлении эта часть данных может не учитываться.  
   - Внешне может показаться, что просто «новые данные не подтягиваются», хотя на самом деле модель в Power BI не «видит» обновлённые поля в MySQL.
```
Опиши подробнее, каким образом «Изменения структуры в MySQL без обновления модели Power BIи» может приводить к проблеме клиента.
~~~

### 31.2.
Ты ответил:
~~~
Ниже рассмотрено, как изменения в структуре MySQL (добавление, переименование или удаление столбцов/таблиц) без последующей актуализации Power BI могут приводить к тому, что «новые данные не подтягиваются» или отчёт отображает неполную информацию:

---

## 1. Нарушение «синхронизации» между базой и моделью Power BI

1. **Что такое «синхронизация»?**  
   - Power BI, используя Power Query, в определённый момент «считывает» схему (названия, типы столбцов и т. д.) базы данных MySQL.  
   - Если позже в MySQL что-то изменилось (столбцы были добавлены, удалены, переименованы), Power BI **не узнаёт** об этом автоматически, пока вы явно не обновите соответствующие настройки или шаги в Query Editor.

2. **Почему модель «застаётся» в старом виде**  
   - В Power Query могут быть прописаны жёсткие ссылки на конкретные столбцы или старая структура (например, `Table.SelectColumns({"OrderID", "Date", "Amount"})`).  
   - Если в MySQL добавили новый столбец `Discount` или переименовали `OrderID` в `Order_Code`, то Power BI будет продолжать искать «OrderID» или игнорировать «Discount», ведь модель всё ещё использует устаревшую информацию.

---

## 2. Добавление новых полей в MySQL, которых нет в модели Power BI

1. **Новые столбцы не отображаются**  
   - Если в MySQL появилась новая колонка (например, `Discount`, `UpdatedTime`, `Category`), а в Power Query она не добавлена в список выбираемых полей, то при обновлении отчёта эти новые данные попросту не попадут в модель.  
   - В результате пользователь может подумать: «Мы добавили важный столбец, почему в отчёте его нет?» — потому что Power BI продолжает работать со старым набором колонок.

2. **Связи (Relationships) не учитывают новое поле**  
   - Допустим, новый столбец в MySQL является ключевым для связи между таблицами, но в модели Power BI связи по-прежнему выстроены по старому полю. Тогда новые записи, завязанные на новом ключе, не будут стыковаться с другими таблицами и «теряться» при фильтрации.

---

## 3. Удаление или переименование столбцов/таблиц

1. **Ошибки «Column not found»**  
   - Если в MySQL столбец был переименован или удалён, а в Query Editor (M-коде) Power BI по-прежнему есть ссылка на прежнее имя, при обновлении может возникать ошибка:  
     > «The column ‘OldColumnName’ of the table wasn’t found»  
   - Из-за этого весь процесс обновления отчёта может прерываться, и новые данные не будут загружены.

2. **Отключение части данных**  
   - Иногда Power Query «тихо» пропускает шаги, где не может найти удалённый столбец, в зависимости от настроек. Это приводит к тому, что связанные столбцы (и возможно, часть таблицы) попросту не загружаются.  
   - Внешне может показаться, что «обновление прошла, но данные всё равно не пришли».

3. **Нарушение связей из-за переименования ключей**  
   - Если в MySQL переименовали поле, участвующее в связях (к примеру, `CustomerID` → `ClientID`), но в Power BI связь всё ещё настроена на `CustomerID`, то новая логика в базе (и новые записи) не будут корректно сопоставляться с таблицей измерений.

---

## 4. Изменения структуры целой таблицы или схемы

1. **Перенос таблицы в другую схему**  
   - Администратор мог перенести таблицу из `old_schema.Orders` в `new_schema.Orders`, а Power BI продолжает смотреть в `old_schema`.  
   - Все новые записи теперь пишутся в новую схему, а отчёт остаётся с пустой или «замороженной» версией старой таблицы.

2. **Объединение или разделение таблиц**  
   - Если ранее была одна таблица `Orders`, а теперь её разделили на `OrdersHeader` и `OrdersDetails`, при этом Power BI всё ещё подключается к старой `Orders`, которая уже не пополняется. Новые строки уходят в новые таблицы, а отчёт остаётся без изменений.

---

## 5. Режимы Power BI и ошибки из-за несоответствия структуры

1. **Import-режим**  
   - При Import Power BI «забирает» структуру и данные в момент настроек/обновления. Если структура изменилась, а шаги Query Editor не были обновлены, либо произойдёт ошибка, либо часть данных не выгрузится, потому что Power BI ищет несуществующие поля.

2. **DirectQuery**  
   - В режиме DirectQuery при каждом запросе к базе Power BI строит SQL на основе актуальной модели. Если там фигурирует удалённый/переименованный столбец, MySQL вернёт ошибку «Unknown column … in field list», и визуал не загрузится.  
   - Либо новые столбцы вообще не будут доступны, так как модель о них «не знает».

---

## 6. Как это выглядит для пользователя

1. **Пропадание части данных или новых записей**  
   - Пользователь пытается обновить отчёт, но не видит новые строки (или поля). Нет явных ошибок, просто они «не приходят», так как Power BI до сих пор извлекает данные по старым параметрам.

2. **Ошибки обновления, если столбец переименован/удалён**  
   - Либо при ручном обновлении (Refresh) в Desktop появляется сообщение об ошибке, либо в сервисе (Power BI Service) Scheduled Refresh падает с текстом «The column ‘…’ was not found in the table».

3. **Неверные итоги в визуалах**  
   - Если часть столбцов не успели подхватиться, меры (Measures) и расчёты могут давать некорректный результат, и кажется, что «данные не сходятся с реальностью».

---

## 7. Как избежать проблем, связанных с изменением структуры MySQL

1. **Сразу обновлять шаги Power Query**  
   - Если в MySQL были изменения (новые/удалённые столбцы), нужно открыть редактор Power Query и перепроверить все шаги (Table.SelectColumns, Renamed Columns, Changed Type). Обязательно выполнить «Refresh Preview», чтобы подтянуть актуальную схему.

2. **Использовать «Detect data source changes» или проверять вручную**  
   - Power BI не всегда сам укажет, что в базе произошли изменения. Полезно при подозрении на изменения структуры специально нажать «Refresh preview» и посмотреть, не появятся ли предупреждения или новые поля в списке Available Columns.

3. **Управлять связями (Relationships)**  
   - Если переименовали ключ, нужно обновить связь в «Manage Relationships» (или поправить DAX-выражения, если где-то используется `USERELATIONSHIP`).  
   - Убедиться, что Power BI «видит» новый столбец и правильно трактует тип данных.

4. **Проверять типы данных при добавлении/удалении столбцов**  
   - Иногда при добавлении столбца он может иметь тип, не совпадающий с ожиданиями Power BI (число/текст/дата). В Query Editor следует вручную указать нужный тип (Changed Type).

5. **Разработать процедуру «оповещения» при изменениях в схеме**  
   - На уровне базы MySQL или процессов администрирования организовать правило: при любом изменении структуры оповещать команду, которая ведёт Power BI-отчёты, чтобы они внесли корректировки в модель.

6. **Тестировать отчёт после изменений**  
   - Запустить тестовое обновление (Refresh) в Desktop и проверить: появляются ли новые поля и строки, нет ли ошибок и расхождений. Только после этого публиковать обновлённую версию (Publish) в Power BI Service.

---

### Итог

Если в MySQL **изменили структуру** (переименовали столбцы, удалили старые, добавили новые), а в **Power BI** **не** обновили модель и Power Query-шаги, то при рефреше:

- Часть данных не будет загружаться (новые столбцы игнорируются).  
- Могут возникать ошибки «Column not found».  
- Связи и расчёты могут перестать работать для новых записей.  

Выглядит это так, будто «новые данные не подтягиваются», а на самом деле Power BI просто **не знает** об актуальном состоянии таблиц и структур MySQL, продолжая работать со «старой» схемой. Решение — **оперативно обновлять** настройки Query Editor, связи и DAX-выражения после любых изменений на стороне базы.
~~~

## 32. «Добавление новых полей в MySQL»
### 32.1.
Я тебя спросил:
~~~
В пункте 1 своего ответа пункта 4.2 ты писал:
```
- **Добавление новых полей в MySQL**  
  Если в таблицу MySQL добавили столбец, который важен для анализа (например, новая метрика или ключ), а в Power BI не обновили запрос (Power Query) и модель, этот столбец попросту не попадёт в набор данных.  
  - Пример: в базе появилась колонка `DiscountRate`, но в Power BI Query Editor её не добавили в список выбираемых полей (Select columns). Следовательно, при обновлении данные о скидках не подтягиваются.
```
Опиши подробнее, каким образом «Добавление новых полей в MySQL» может приводить к проблеме клиента.
~~~

### 32.2.
Ты ответил:
~~~
Ниже описано, как **добавление новых полей (столбцов) в таблицу MySQL** приводит к тому, что **Power BI не показывает** эти новые данные или метрики, создавая впечатление, что они «не подтягиваются»:

---

## 1. Где именно «теряется» новый столбец между MySQL и Power BI

1. **Структура таблицы в MySQL обновилась**, а модель Power BI осталась прежней  
   - Когда в MySQL добавляют новый столбец (например, `DiscountRate`), в самой базе он сразу виден при выполнении `SELECT * FROM ...`.  
   - Однако, в **Power Query** (часть Power BI), если уже был настроен список конкретных столбцов (SelectColumns), этот новый столбец **не** будет автоматически добавлен в запрос.  
   - В результате даже после обновления отчёта данные из нового столбца не попадают в модель Power BI.

2. **Автодетектирование** не срабатывает «на лету»  
   - Power BI **не** «подсматривает» схему базы на каждом обновлении. Оно ориентируется на текущие шаги M-кода (Power Query). Если там явно не сказано выбрать новый столбец, он останется за бортом.

3. **Пользователь не знает**, что надо вручную обновить запрос  
   - Многие считают, что «если мы добавили столбец в базу, Power BI сам его увидит». Но по умолчанию Power Query не изменяет существующие запросы.  
   - В итоге при каждом обновлении отчёта Power BI продолжает работать со старым набором полей, игнорируя новое поле.

---

## 2. Как это проявляется для клиента

1. **Невозможность построить визуал с новым показателем**  
   - Пользователь хочет отобразить данные о `DiscountRate`, а в списке полей (Fields) Power BI такой колонки нет вообще.  
   - При попытке найти её в Data view/Report view пользователь не видит нового поля.

2. **Ошибочное ощущение, что «ничего не меняется»**  
   - Если новый столбец существенно влияет на бизнес-логику (например, расчёт итоговой цены), пользователь может заметить, что в отчёте цена не учитывает скидку. Это выглядит так, будто отчёт «не видит» новые данные (т. е. «не подтягивает» актуальную логику).

3. **Параллельно нет ошибок**  
   - При добавлении нового столбца MySQL не ломает старую структуру, поэтому Power BI «не жалуется». Ошибок в обновлении нет: всё вроде бы загружается, но нового столбца в модели просто нет.

---

## 3. Причины и механика «пропажи» нового столбца

1. **Явный список столбцов в Power Query**  
   - Во многих случаях, когда вы настраивали Power Query, там автоматически создаётся шаг `Table.SelectColumns`. Он указывает, какие именно столбцы нужно взять из таблицы.  
   - Допустим, было:  
     ```m
     Table.SelectColumns(
       Source, 
       {"OrderID", "ProductID", "Amount", "Date"}
     )
     ```  
     Если теперь в MySQL появился `DiscountRate`, этот шаг по-прежнему **выбирает** **только** `OrderID, ProductID, Amount, Date`. О столбце `DiscountRate` он «не знает» и не добавляет его.

2. **Автогенерация шагов при первом импорте**  
   - При подключении к базе Power BI зачастую сам формирует M-код, где, чтобы повысить надёжность, «жёстко» выбирает конкретные столбцы. Это нужно, чтобы случайно не ломался отчёт при удалении полей в будущем.  
   - Но при добавлении новых полей это оказывается «против» пользователя: новые столбцы не попадают в отчёт автоматически.

3. **Отсутствие явного обновления структуры**  
   - Даже если вы в Power Query нажмёте «Refresh Preview», Power Query покажет в диалоговом окне, что появилась новая колонка, **но** она не добавится в итоговый набор данных автоматически, если есть шаг `Table.SelectColumns`. Нужно вручную открыть «Выбрать столбцы» (Choose Columns) и поставить галочку на новом поле.

---

## 4. «Подводные камни», если поле ключевое для связей

1. **Новая колонка — «ключ»**  
   - Если столбец, добавленный в MySQL, критичен для связи (Relationship) в модели (например, новый идентификатор или код), но в Power BI эта колонка не выбрана, тогда никакая новая запись, где этот ключ нужен, не будет корректно стыковаться.  
   - Это может привести к тому, что **визуал не показывает** новые строки, так как связь не срабатывает («ProductKey» или иной идентификатор отсутствует в модели).

2. **Невозможность использовать поле в DAX**  
   - Если планируется использовать `DiscountRate` в формулах (DAX-меры), но этого поля нет в модели, любая попытка написать что-то типа `= SUMX(Sales, Sales[Amount] * (1 - Sales[DiscountRate]))` приведёт к ошибке «The column ‘Sales[DiscountRate]’ doesn’t exist».  

---

## 5. Почему кажется, что «новые данные не тянутся»

1. **Иллюзия полной синхронизации**  
   - Другие поля (такие же, как были до) продолжают работать, и при обновлении Power BI действительно подтягивает обновлённые записи **в старых столбцах**. Но новый столбец так и не появляется.  
   - Клиент замечает, что «мы в базе видим — у каждой записи теперь есть `DiscountRate`, а в отчёте нет», и делает вывод: «Power BI не видит новые данные».

2. **Возможно, отчёт не падает с ошибкой**  
   - Если поле не используется в существующих визуалах, Power BI молча игнорирует этот столбец. Пользователь только при попытке задействовать новую колонку (или ожидая, что она сама появится) обнаруживает, что её нет.

---

## 6. Как проверить и устранить проблему

1. **Открыть Power Query Editor (Transform Data)**  
   - Посмотреть шаги:  
     - Есть ли `Table.SelectColumns`?  
     - Автоматические шаги «Removed Other Columns»?  
   - Убедиться, что новый столбец виден в списке доступных и что он включён (есть галочка, либо вы удалили шаг удаления «ненужных» столбцов).

2. **Добавить (или разрешить) новый столбец в загрузку**  
   - В Power Query выбрать «Choose Columns…» (или «Select Columns…»), убедиться, что нужный столбец отмечен. Если видите «Remove Other Columns» в шагах, возможно, надо удалить или поправить этот шаг.  
   - После этого нажать «Close & Apply», дождаться обновления, и в Fields должна появиться новая колонка.

3. **Проверить тип данных**  
   - Убедитесь, что новый столбец сразу определяется правильным типом (Number, Text, Date, …). Иначе при загрузке могут быть проблемы в связях или ошибочные конверсии.

4. **Обновить отношения (Relationships), если это ключ**  
   - Если столбец играет роль ключа (Foreign Key, Primary Key и т. п.), возможно, нужно в «Manage Relationships» пересоздать или обновить связь, чтобы Power BI понимал логику сопоставления.

5. **Тестовое обновление**  
   - После внесения правок сделайте «Refresh» в Desktop. Убедитесь, что новый столбец действительно появляется в модельных таблицах (Data view), и что теперь можно его использовать в визуалах.

---

## 7. Итог

Когда в MySQL **добавляют новый столбец** (будь то метрика, ключ или любая дополнительная информация):

1. Power BI **не** подтянет этот столбец **автоматически**, если в Query Editor жёстко выбран фиксированный набор столбцов или есть шаг удаления «лишних» полей.  
2. **В результате** новый столбец **не появляется** в модели и **не виден** в визуалах — создаётся впечатление, что «новые данные» (или новая логика) **не загрузились**.  
3. Чтобы решить это, необходимо **зайти в Power Query**, добавить/актуализировать выбор колонок, **внести** новый столбец в загрузку и при необходимости настроить **связи и типы** данных.  

Только после этих действий новые данные из добавленного поля MySQL станут доступны в отчёте Power BI.
~~~

## 33. «Удаление или переименование существующих полей»
### 33.1.
Я тебя спросил:
~~~
В пункте 1 своего ответа пункта 4.2 ты писал:
```
- **Удаление или переименование существующих полей**  
  Если столбец в MySQL был переименован или удалён, а в Power BI он всё ещё используется (например, в шагах Power Query, в DAX-выражениях, в измерениях или связях), то обновление может выдавать ошибки либо игнорировать часть данных.  
  - Пример: в MySQL столбец `customer_id` переименовали в `client_id`, а в Power BI всё ещё пытаются обращаться к `customer_id`. В итоге при обновлении в отчётах может показываться неполная информация или вовсе возникать сбой.
```
Опиши подробнее, каким образом «Удаление или переименование существующих полей» может приводить к проблеме клиента.
~~~

### 33.2.
Ты ответил:
~~~
Ниже рассмотрено, почему **удаление или переименование существующих полей** в MySQL может привести к тому, что в Power BI при обновлении часть данных не будет отображаться или возникнут ошибки:

---

## 1. Суть проблемы

1. **Power BI хранит сведения о структуре таблиц**  
   - При подключении к MySQL (или любому другому источнику) Power Query в Power BI запоминает названия столбцов и их типы. Затем в шагах (Steps) M-кода часто явно упоминаются эти столбцы (например, `#"Renamed Columns"`, `#"Changed Type"`, `#"SelectColumns"` и т. п.).  
   - Если в базе столбец переименовали или удалили, а Power Query продолжает обращаться к старому названию, обновление отчёта не сможет корректно выполниться.

2. **Использование столбца в визуалах и DAX**  
   - Помимо Power Query, столбец может использоваться в самих визуализациях, мерах (Measures), вычисляемых столбцах (Calculated Columns) или в связях (Relationships). Если поле внезапно исчезло или было переименовано в MySQL, Power BI не найдёт соответствующую колонку в обновлённом наборе данных.

---

## 2. Типичные сценарии удаления или переименования полей

1. **Переименование столбца**  
   - Например, столбец `customer_id` переименовали в `client_id`.   
   - В MySQL запрос `SELECT client_id, name FROM clients` возвращает данные, но в Power BI M-код может оставаться ссылкой на `customer_id`. При обновлении Power BI выдаст ошибку вида «Column ‘customer_id’ not found».

2. **Удаление столбца как «ненужного»**  
   - Администратор базы или разработчики решили, что поле `old_status` более не актуально, и удалили его из схемы. В Power BI же может существовать измерение или фильтр, зависящий от `old_status`. При обновлении отчёта строка с кодом “Column ‘old_status’ not found in the table…” сигнализирует, что запрос Power Query больше не может выбрать это поле.

3. **Объединение / разделение полей**  
   - Иногда два столбца объединяют в один (в MySQL делают `ALTER TABLE` и переносят данные), а старые столбцы убирают. Power BI при этом продолжает искать старые названия.  
   - Или наоборот, один столбец разбили на несколько, а старый удалили. С точки зрения Power BI, попытки прочитать старый столбец завершаются неудачей.

---

## 3. Как именно это мешает подтягиваться новым данным

1. **Ошибки на этапе Power Query**  
   - Когда Power Query не находит в источнике столбец, указанный в шаге `SelectColumns` или `Renamed Columns`, возникает критическая ошибка:  
     > «The column ‘…’ of the table was not found»  
   - Из-за неё весь процесс загрузки данных (Refresh) может прерываться. В итоге отчёт либо не обновляется вообще, либо «съедает» часть записей и выдаёт неполную информацию.

2. **Частичное отсутствие данных**  
   - Если Power BI продолжает работать «в поломанном состоянии» (когда, например, часть шагов проигнорирована), новые строки могут не попадать в модель. Либо целая таблица (где пропал столбец) не загрузится, и это даёт эффект «данные не подтянулись».

3. **Срыв связей (Relationships)**  
   - Если переименовали поле, которое в Power BI было ключом для связи (Relationship) между таблицами, связь становится недействительной. Новые записи, которые полагаются на этот ключ, не будут находить соответствия во второй таблице.  
   - Итог: свежая информация в отчёте либо не отображается, либо уходит в `(Blank)`.

4. **Ошибки в DAX-вычислениях**  
   - Если в формулах (Measures, Calculated Columns) фигурирует старое имя столбца, при попытке обновления DAX может вывести сообщение вроде «Column ‘…’ cannot be found in the current context».  
   - Новые данные (и вообще весь пересчёт мер) могут частично или полностью не сработать.

---

## 4. Как проблема обычно проявляется для пользователя

1. **Полное или частичное падение обновления**  
   - В Power BI Desktop при ручном Refresh может всплыть окно ошибки, а в сервисе Power BI (Scheduled Refresh) — сообщение «The column ‘customer_id’ wasn’t found» и статус «Failed».  
   - Пользователь замечает, что дата последнего успешного обновления старая, и в отчёте нет актуальной информации.

2. **Часть визуалов «краснеет» (ошибка) или исчезает**  
   - Если конкретная визуализация завязана на поле, которое удалили/переименовали, при открытии отчёта Power BI может вывести предупреждение «This visual has one or more fields missing» или «Something’s wrong with one or more fields».  
   - Визуал либо не отображается, либо становится пустым.

3. **Новые поля, которые должны были появиться, отсутствуют**  
   - Случается и обратное: если столбец заменили на новый, но модель не обновили, пользователь так и не видит новый столбец в списке. Кажется, что «мы добавили столбец, но Power BI его не видит».

---

## 5. Как исправить ситуацию

1. **Открыть редактор Power Query и обновить структуру**  
   - В Power BI Desktop → «Transform Data» (Редактор Power Query), проверить все шаги в разделе Applied Steps. Если где-то есть ошибка (красный крестик) с сообщением, что столбца не существует, — нужно убрать или переименовать этот шаг.  
   - Если поле переименовали в MySQL, в шаге `Renamed Columns` изменить старое название на новое. Если удалённое поле больше не нужно, удалить из `Table.SelectColumns` строку, которая его выбирает.

2. **Обновить связи (Relationships)**  
   - Перейти в «Manage Relationships» и посмотреть, не слетела ли связь из-за переименования ключа. Если нужно, заново указать Power BI, что `client_id` — это тот же ключ, что раньше был `customer_id`.  
   - Убедиться, что отношения корректно строятся по существующим полям.

3. **Исправить DAX-выражения**  
   - Если формулы ссылаются на старое имя, открыть Measures / Calculated columns и заменить упоминания старого столбца на новое.  
   - Убедиться, что логика вычислений не нарушена, если старое поле физически удалили и его заменил другой столбец.

4. **Обязательно сделать Refresh Preview**  
   - После коррекции шагов Power Query нужно обновить превью (Refresh Preview) и убедиться, что ошибки исчезли, а обновлённая структура подтянулась.  
   - Затем выполнить полноценное обновление (Refresh) в Power BI Desktop. Если всё успешно, публиковать отчёт в сервис (Publish).

5. **Проверить новый отчёт**  
   - Убедиться, что пользователь видит новые данные, нет ошибок, и столбцы (или ключи) соответствуют тому, что реально в MySQL.  

---

## 6. Рекомендации по работе с переименованиями/удалениями

1. **Не удалять или не переименовывать столбцы без уведомления**  
   - Желательно, чтобы администраторы базы (DBA) и разработчики перед крупными изменениями структуры предупреждали команду, которая занимается отчётами в Power BI, чтобы успеть внести корректировки.

2. **Использовать «Deprecated columns»**  
   - Если нужно избавиться от столбца, сначала пометить его как устаревший (deprecated), чтобы у аналитиков было время убрать его из Power BI.  
   - Затем, когда все отчёты готовы, окончательно удалить столбец из MySQL.

3. **Версионность схем**  
   - В серьёзных проектах поддерживают версионирование (migrations), где чётко прописывается, какой столбец куда переехал, а Power BI-аналитики синхронизируют модель при каждом релизе новой структуры.

---

### Итог

Когда в MySQL **переименовывают** или **удаляют** существующие поля, а в Power BI **не** обновляют соответствующие шаги Power Query, связи и DAX, отчёт **теряет** часть данных либо **выдаёт** ошибки:  
- **Строки ссылаются на несуществующие** колонки, и загрузка срывается.  
- **Связь** (Relationship) ломается, новые записи «не присоединяются».  
- **Визуалы** зависят от старого названия поля и выводят пустые (или ошибочные) результаты.

Решение — **оперативно** внести изменения в модель Power BI:  
- обновить шаги в Power Query (Table.SelectColumns, Renamed Columns и т. д.),  
- скорректировать связи (Relationships),  
- поправить DAX,  
- выполнить тестовое обновление (Refresh).  

Тогда данные снова будут правильно загружаться, и пользователь увидит актуальную картину в отчёте.
~~~

## 34. «Непредусмотренное изменение типа столбца»
### 34.1.
Я тебя спросил:
~~~
В пункте 2 своего ответа пункта 4.2 ты писал:
```
### 2. Изменение типов данных
- **Непредусмотренное изменение типа столбца**  
  Если в MySQL поле было `INT` (числовое), а затем его изменили на `VARCHAR` (текстовое) или наоборот, Power BI может перестать корректно интерпретировать эти данные.  
  - Пример: новый тип данных может не совпадать с тем, что ожидалось в фильтрах или визуализациях (например, число теперь воспринимается как текст, и агрегаты не рассчитываются).  
  - Результат: при загрузке может возникать предупреждение/ошибка, либо новые записи будут пропускаться.
```
Опиши подробнее, каким образом «Непредусмотренное изменение типа столбца» может приводить к проблеме клиента.
~~~

### 34.2.
Ты ответил:
~~~
Ниже рассмотрено, почему **непредусмотренное изменение типа столбца** в MySQL (например, с `INT` на `VARCHAR`, или с `VARCHAR` на `INT`) способно привести к тому, что новые данные не будут корректно отображаться в Power BI:

---

## 1. Сценарий «Было число, стало текстом» (или наоборот)

1. **Изначально в MySQL поле имело тип `INT`**  
   - Power BI при подключении (или при автоматической настройке) распознал этот столбец как числовой (Whole Number или Decimal) и, соответственно, позволял агрегировать это поле (суммировать, считать среднее и т.д.) или использовать в связях как числовой ключ.

2. **Впоследствии тип в MySQL поменяли на `VARCHAR`**  
   - Теперь новые записи фактически хранятся как текст (например, `"0012"`, `"123"`, или даже с буквами: `"A123"`).  
   - При следующем обновлении Power BI столкнётся с расхождением: он **ожидает** число, а **получает** строку.  
   - Результат:  
     - Может возникнуть ошибка преобразования: «Couldn’t convert to Number» (ошибка на этапе Power Query).  
     - Если в самом MySQL при этом хранятся значения, которые не могут быть интерпретированы как чистое число, часть строк будет проигнорирована или заменена на `Null`.  
     - Любые агрегаты (суммы, средние) перестанут корректно рассчитываться.

3. **Итог**  
   - Новые записи, которые не удаётся привести к старому типу (числу), **не попадут** в модель Power BI (или будут загружены как `Null`/пустые).  
   - Пользователю кажется: «Почему новые данные не отобразились?», хотя технически Power BI не смог их корректно обработать.

---

## 2. Сценарий «Был текст, стал числом»

1. **Поле в MySQL было `VARCHAR`**  
   - Power BI расценивал этот столбец как «Text» и, возможно, где-то в моделировании связи или фильтрация строились исходя из строковых значений (например, ID в формате `"ABC123"`).  

2. **Тип поменяли на `INT`**  
   - В новой версии таблицы MySQL предполагается, что все значения — числа (например, 123, 456, 789).  
   - Если в старых данных были символы, не приводящиеся к целому числу (лидерующие нули, буквы, спецсимволы), то при миграции их могли очистить или удалить.  
   - Для Power BI при обновлении:  
     - Если в Query Editor не поменять тип на «Whole Number», то может возникать ошибка «Invalid value» или «Couldn’t convert text to Number».  
     - Если остаться на типе «Text», то реальные числа (например, `123`) будут храниться как `"123"`, и фильтры/связи, ожидающие число, могут неверно сопоставлять данные.

3. **Почему именно «новые данные» могут пропадать**  
   - Старые данные, ещё как-то совпадавшие с предыдущим типом, могут быть **в кэше** или уже «корректно» сконвертированы.  
   - Новые записи, которые приходят после изменения, содержат исключительно числовые значения (или уже в другом формате), и Power BI отсекает их при попытке интерпретации как текст (или наоборот).

---

## 3. Как проявляется проблема

1. **Часть строк не загружается**  
   - В журнале Power Query может быть видно, что загрузилось, например, 9500 строк вместо ожидаемых 10 000. 500 новых строк отбрасываются, потому что у них неверный формат для текущих настроек.

2. **Ошибки преобразования (Conversion Error)**  
   - При ручном обновлении в Desktop всплывает сообщение:  
     > «DataFormat.Error: We couldn’t convert to Number»  
     > «Invalid type in column …»  
   - В сервисе Power BI (Scheduled Refresh) появляются ошибки, и обновление падает.

3. **(Blank) значения в отчетах**  
   - Если Power Query по умолчанию заменяет все «неподходящие» значения на `Null`, то в отчёте могут появиться пустые записи `(Blank)`.  
   - Фильтры и агрегации показывают итоги без этих записей; пользователь замечает недостачу данных.

4. **Нарушение связей (Relationships)**  
   - Если столбец участвовал в связях, Power BI может не находить соответствия для новых ключей, потому что они не сопоставимы с предыдущим типом.  
   - В результате все «новые» записи оказываются вне связи и не показываются при фильтрации или не участвуют в мерах.

---

## 4. Почему это касается именно «непредусмотренных» изменений

1. **Если изменение типа было запланированным**  
   - Администратор БД или команда BI заранее согласует: «Мы меняем тип поля X на тип Y», и в Power BI тоже обновляют M-код (Power Query) и связи, чтобы корректно воспринимать новые данные.  
   - Проблема не возникает или минимальна.

2. **Если изменение сделали «тихо» без уведомления**  
   - Нередко DBA или разработчики меняют схему / тип данных, не проинформировав команду, которая занимается Power BI.  
   - Power BI-модель продолжает работать со старыми предположениями о типах, и при следующем обновлении всё «сыпется».  
   - Именно так и появляется загадка: «Почему вдруг перестали подтягиваться новые записи?»

---

## 5. Как обнаружить и устранить ситуацию

1. **Проверить фактический тип столбца в MySQL**  
   - Использовать `DESCRIBE table_name;` или аналогичные инструменты (MySQL Workbench), чтобы увидеть, действительно ли поле стало `VARCHAR` вместо `INT` (или наоборот).  
   - Возможно, есть и другие изменения (из `DATE` в `DATETIME`, из `DECIMAL` в `DOUBLE` и т. п.).

2. **Посмотреть в Power Query на шаг «Changed Type»**  
   - Открыть редактор Power Query и кликать по Applied Steps. Шаг `Changed Type` может показывать (например) `Int64.Type`, в то время как в реальных данных уже нет чистого int.  
   - В результате появляется ошибка или часть строк становится `Null`.

3. **Исправить тип в Power Query**  
   - Если поле действительно стало строковым, вручную поменять в Power Query на «Text» (или наоборот), и убедиться, что новые значения корректно конвертируются.  
   - Если какие-то строки не поддаются преобразованию (например, содержат буквы), решить, как обрабатывать (Replace Errors, игнорировать, приводить к нулю и т. п.).

4. **Проверить связи (Relationships)**  
   - Если поле участвует в связях, нужно в «Manage Relationships» убедиться, что поля по обе стороны тоже совпадают по типу (оба «текст», оба «число»).  
   - Перенастроить связь, если она слетела (Power BI иногда отключает или делает неактивной связь, если видит несоответствие типов).

5. **Тестовое обновление**  
   - После коррекции в Power Query сделать «Refresh» в Power BI Desktop, посмотреть, исчезли ли ошибки и загрузилась ли новая часть данных.  
   - Затем опубликовать обновлённую модель в сервис, проверив, что там тоже всё обновляется без ошибок.

---

### Итог

«Непредусмотренное изменение типа столбца» в MySQL (например, из `INT` в `VARCHAR` или из `VARCHAR` в `INT`) способно привести к тому, что при обновлении отчётов Power BI:

- **Часть новых записей** не будет корректно загружена (конверсия не удалась, получаем `Null`),  
- **Появятся ошибки** «Couldn’t convert to number/text»,  
- **Нарушатся связи** и фильтры, не находя совпадений по ключевым полям.

Чтобы это устранить, нужно:

1. **Синхронизировать** представления о типе столбца в MySQL и в Power BI (Editor) — либо вернуть старый тип в базе, либо настроить новую логику в Power Query.  
2. **Исправить все шаги** (особенно `Changed Type`) и проверить **связи**.  
3. **Перепроверить** при тестовом обновлении, что теперь новые данные корректно попадают в модель и отображаются в отчёте.
~~~

## 35. «Разрушение связей»
### 35.1.
Я тебя спросил:
~~~
В пункте 3 своего ответа пункта 4.2 ты писал:
```
- **Разрушение связей**  
  Если ключевое поле таблицы (используемое в отношениях) было удалено или переименовано, то связь в Power BI станет некорректной или «неактивной».  
  - В результате при попытке отобразить данные из двух связанных таблиц часть записей (особенно новых) не будет находить «сопоставление», и визуалы будут показывать неполную картину.
```
Опиши подробнее, каким образом «Разрушение связей» может приводить к проблеме клиента.
~~~

### 35.2.
Ты ответил:
~~~
Ниже рассмотрено, как **«разрушение связей»** (то есть потеря или поломка отношений между таблицами, вызванная удалением, переименованием или изменением ключевых полей) в Power BI может приводить к тому, что **новые записи** (а иногда и старые) не отображаются в отчёте:

---

## 1. Что такое «разрушение связей» в контексте Power BI

1. **Суть связей (Relationships)**  
   - В Power BI связь между двумя таблицами (например, между фактом — Sales и измерением — Products) строится по соответствующим столбцам (к примеру, `Sales[ProductID]` ↔ `Products[ProductID]`).  
   - Если эти поля в одной из таблиц изменяются (удалены, переименованы, поменяли тип и т. д.) без синхронизации с моделью, то такая связь перестаёт быть валидной.

2. **Проявление «разрушения»**  
   - В диспетчере связей (Manage Relationships) в Power BI связь может стать неактивной или оказаться помеченной ошибкой.  
   - Либо Power BI при обновлении выдаёт предупреждение/ошибку, что необходимый столбец в одной из таблиц не найден.  
   - В итоге данные из двух таблиц более не «стыкуются» при визуализации.

---

## 2. Типовые причины «разрушения» связей

1. **Удаление ключевого поля в MySQL**  
   - Допустим, раньше в таблице Products был столбец `ProductID` (PRIMARY KEY), а в процессе реорганизации базы его удалили или заменили на `ProdKey`. Если в Power BI связь всё ещё ссылается на `ProductID`, она становится недействительной.

2. **Переименование столбца**  
   - В MySQL `ProductID` переименовали в `ItemID`, а модель Power BI не обновили. При следующем обновлении отчёта Power BI не найдёт старое поле и «потеряет» связь.

3. **Изменение типа или структуры**  
   - Иногда при «более мягкой» форме изменения (например, `ProductID` из `INT` превратили в `VARCHAR` или наоборот) Power BI перестаёт корректно распознавать эту связь. Если «рассинхронизация» сильная, система может счесть поле несовместимым и обнулить или отключить связь.

4. **Перенос столбца в другую таблицу**  
   - Вдобавок, если ключ переместили из одной таблицы в другую (или другая схема), а Power BI по-прежнему смотрит на старое место, связь «ломается», так как нет столбца (или нет данных) по старому пути.

---

## 3. Как «разрушенные» связи влияют на отображение новых данных

1. **Фактическая таблица не «находит» справочник**  
   - Когда связь исчезла или стала неактивной, при построении визуала Power BI не может сопоставить записи в таблице фактов (Fact) с данными измерения (Dimension).  
   - В результате новые (и даже старые) строки могут не отображаться в отчёте при использовании полей из обеих таблиц — они оказываются «изолированными» (та же ситуация, когда Fact «не видит» Dimension).

2. **(Blank) категории или пропуск строк**  
   - Если в отчёте используются поля измерения (например, «Product Name»), а связь со столбцом фактов «ProductID» разрушена, новые продажи остаются без продукта, попадая в `(Blank)` или вовсе не показываются.  
   - Иногда пользователь замечает, что объём продаж «упал», потому что часть строк отсекается как «непривязанные» к измерению.

3. **Ошибки при обновлении**  
   - Power BI может при Refresh выдавать ошибку: «The column ‘ProductID’ was not found in the table ‘Products’». Из-за этого рефреш прерывается, и новые данные вообще не загружаются.  
   - Пользователь видит в отчёте старое состояние (или пустые визуалы).

4. **Невозможность фильтрации и анализа новых полей**  
   - Если новому столбцу (добавленному в Dimension) сопоставлялся ключ, а старая связь разрушена (или не обновлена), при использовании этого столбца в срезе (Slicer) новые записи из Fact не будут отфильтровываться корректно. Визуалы покажут неполную картину.

---

## 4. Пример сценария «разрушения» связи

1. **Было**  
   - Таблица `Sales(Fact)`: поля `SaleID`, `ProductID`, `Quantity`, …  
   - Таблица `Products(Dim)`: поля `ProductID`, `ProductName`, …  
   - Связь в Power BI: `Sales[ProductID] → Products[ProductID] (One-to-Many)`

2. **Стало**  
   - В MySQL решили, что `ProductID` теперь будет называться `ProdCode`. В таблице `Products` удалили `ProductID` и создали `ProdCode`.  
   - При этом в Power BI старая модель ищет `ProductID`. Связь ломается — при обновлении отчёта появляется ошибка или связь становится неактивной.

3. **Результат**  
   - Новые данные о продажах, где есть поле `ProdCode`, вообще не стыкуются со старой логикой `ProductID`. Итог: визуалы «показывают 0» или «(Blank)» для новых продаж, старые данные тоже теряют связь.

---

## 5. Как обнаружить и исправить «разрушенные» связи

1. **Проверка «Manage Relationships»**  
   - Открыть «Model» или «Manage Relationships» в Power BI и посмотреть, нет ли там связей, помеченных восклицательным знаком или выделенных как неактивные.  
   - Если связь неактивна из-за «missing field», Power BI укажет, какого столбца не хватает.

2. **Сравнить структуру MySQL и Power BI**  
   - Выполнить `DESCRIBE Products;` (или аналог) в MySQL, увидеть текущее имя ключевого столбца. Сопоставить с тем, что Power Query и модель Power BI считают ключом.  
   - Если обнаружится расхождение (например, «ProductID» уже нет), значит нужно либо поменять название в Power BI, либо вернуть старое поле в базе (зависит от бизнес-логики).

3. **Обновить (или пересоздать) связь**  
   - В Power BI нужно либо редактировать существующую связь, указав правильный столбец (например, `Sales[ProdCode] → Products[ProdCode]`), либо удалить старую и создать новую.  
   - Убедиться, что кардинальность (One-to-Many / Many-to-One) всё ещё корректна, и что типы данных совпадают (текст к тексту, число к числу).

4. **Уточнить, зачем меняли структуру**  
   - Иногда полезно задать вопрос: «Почему в MySQL переименовали/удалили ключ? Может, нужен новый столбец-идентификатор?»  
   - Если разработчики добавили суррогатный ключ, нужно тоже учесть это в Power BI и перенастроить отношения на новый столбец.

5. **Проверить шаги Power Query**  
   - Если M-код (Query Editor) имел шаги вида `RenameColumns`, `SelectColumns` по старым названиям, их нужно исправить. Иначе Power BI может выдавать ошибку «column not found» ещё до попытки связей в модели.

---

## 6. Рекомендации, чтобы связи не «ломались» в будущем

1. **Согласовывать изменения в БД**  
   - Если планируется переименование/удаление поля в MySQL, заранее уведомить команду, поддерживающую Power BI, чтобы они могли внести правки в модель.  
   - Либо использовать стратегию «не ломаем схему» (например, не удалять старое поле, а оставить «deprecated» с тем же названием, пока все потребители не перейдут на новое).

2. **Включить Foreign Keys в базе**  
   - Если в MySQL использовать настоящие внешние ключи (FK), вероятность случайного удаления/переименования ключевого поля снижается. Так проще отследить, что этот столбец важен для связей.

3. **Регулярно проверять связи в Power BI**  
   - При каждом крупном обновлении базы запускать «Refresh Preview» в Power Query, смотреть на «Manage Relationships», проверять, всё ли осталось валидным.

---

### Итог

«Разрушение связей» возникает, когда ключевое поле (используемое в Relationship) было **изменено** (удалено, переименовано, заменён тип и т. д.) в MySQL, а в Power BI **не** произведено соответствующее обновление модели. Тогда:

- **Новые данные** (и часто старые тоже) **не стыкуются** между таблицами,  
- Записи могут **попадать в (Blank)** категорию или вовсе **не отображаться** в отчёте,  
- При обновлении возможны **ошибки** вида «Column not found» или «Relationship is not valid».  

Чтобы решить проблему, нужно **синхронизировать** модель Power BI с изменённой структурой базы: поправить **шаги Query Editor**, перенастроить **Relationships** (указать новые/правильные столбцы) и убедиться, что **тип данных** и **кардинальность** тоже соответствуют реальной схеме.
~~~

## 36. «Неактуальные M-скрипты»
### 36.1.
Я тебя спросил:
~~~
В пункте 4 своего ответа пункта 4.2 ты писал:
```
- **Неактуальные M-скрипты**  
  Power BI при загрузке данных использует M-код (Power Query) для извлечения и трансформации столбцов. Если в скрипте явно перечислены поля, которых уже нет в базе (или которые были переименованы), при обновлении может возникнуть ошибка либо новые записи (включающие новые поля) не будут учитываться.  
  - Пример: в шаге `Table.SelectColumns` прописан список из 5 столбцов, а в базе теперь их 6 или изменились названия. Power BI будет игнорировать новый столбец и не покажет связанные с ним данные.
```
Опиши подробнее, каким образом «Неактуальные M-скрипты» может приводить к проблеме клиента.
~~~

### 36.2.
Ты ответил:
~~~
Ниже разъясняется, как **неактуальные M-скрипты** (шаги Power Query, написанные на языке M) могут приводить к тому, что свежие данные или новые столбцы из MySQL не попадают в модель Power BI:

---

## 1. Что такое «M-скрипты» (Power Query M-код)

1. **Основной механизм трансформаций**  
   - Когда вы в Power BI в меню «Трансформировать данные» (Power Query Editor) добавляете шаги (фильтрация, переименование столбцов, объединение таблиц и т. д.), под капотом формируется M-код.  
   - Это скриптовый язык (Power Query Formula Language), который описывает последовательность действий над исходными данными.

2. **Почему могут возникать проблемы**  
   - M-код включает жёсткие ссылки на названия столбцов (Table.SelectColumns, Table.RenameColumns и т. п.). Если структура MySQL или названия полей изменились (переименовали, удалили, добавили новые), а M-код не обновили, Power Query выдаст ошибку при попытке найти «старые» названия.  
   - Либо, если речь о новых столбцах, их попросту не будет в списке выбираемых столбцов — и Power Query игнорирует их при загрузке.

---

## 2. Как «неактуальные M-скрипты» мешают отображению новых данных

1. **Игнорирование новых столбцов**  
   - Если в запросе используется, к примеру,  
     ```m
     Table.SelectColumns(
       PreviousStep, 
       {"ID", "Date", "Amount", "Status"}
     )
     ```
     а в MySQL к таблице добавили новый столбец `Discount`, то он никуда не попадёт, поскольку M-код берёт лишь явно перечисленные четыре столбца.  
   - В результате новые данные о скидках (Discount) присутствуют в базе, но Power BI даже не пытается их загрузить.

2. **Ошибки при переименовании или удалении полей**  
   - Если в MySQL столбец `Status` переименовали в `OrderStatus`, а в M-скрипте остался шаг  
     ```m
     Table.RenameColumns(
       PreviousStep, 
       {{"Status", "OrderStatus"}}
     )
     ```
     то при обновлении может возникнуть ошибка «Column ‘Status’ not found». Из-за этого Power BI может остановить загрузку на этом шаге и не дойти до новых данных.

3. **Частичное чтение таблицы (пропуск строк)**  
   - Бывают ситуации, когда из-за неактуального фильтра или условия (в M-коде) новые строки, не удовлетворя «старым» условиям, отбрасываются. Например, если раньше столбец `Category` принимал значения A/B, а теперь появились C/D, но в M-коде есть условие:
     ```m
     Table.SelectRows(
       PreviousStep, 
       each [Category] = "A" or [Category] = "B"
     )
     ```
     тогда строки с C/D ни при каких обстоятельствах не попадут в модель.

---

## 3. Типичные случаи, когда M-код «устаревает»

1. **Table.SelectColumns**  
   - Жёсткое перечисление столбцов. Все добавленные поля в таблице базы данных MySQL будут проигнорированы.

2. **Rename Columns**  
   - Если в базе столбец переименовали, а в M-коде остался старый `{"OldName", "NewName"}`, шаг выдаст ошибку «Column OldName not found».

3. **Removed Columns** или **Remove Other Columns**  
   - Шаг, который удаляет все «лишние» столбцы, кроме определённого списка. Любые новые столбцы в MySQL не попадут в модель.

4. **Фильтры с жёсткой проверкой значений**  
   - Если в базе были добавлены новые значения (статусы, категории), но в M-коде остался «старый» перечень, новые записи будут отсеиваться.

5. **Autogenerated Changed Type**  
   - Автоматический шаг «Changed Type», созданный Power BI, может ожидать один набор полей. Если их структура поменялась (поля переименовали, тип изменили), — появятся ошибки преобразования.

---

## 4. Как проявляется проблема для пользователя

1. **Отчёт «обновляется» без явной ошибки, но новые столбцы не видны**  
   - В Power BI «Refresh» может проходить «успешно» (если нет критичных ошибок), однако в модели и визуалах нет новых полей и данных, которые появились в MySQL.  
   - Пользователь считает, что «что-то не работает», хотя на самом деле M-код просто не выбирает нужные столбцы.

2. **Ошибка при обновлении (Column not found / Rename issue)**  
   - Если старый M-скрипт содержит шаги, которые ищут удалённые или переименованные поля, обновление падает с ошибкой. В Desktop это может всплывать диалогом: «Expression.Error: The column ‘OldName’ of the table wasn’t found».  
   - В Power BI Service (Scheduled Refresh) всё будет отображаться как «Failed to update dataset» с деталями в логе.

3. **Новое поведение фильтров**  
   - Иногда Filter Rows, рассчитанные под старые значения, приводят к тому, что часть новых записей не отображается. Без детальной проверки пользователь видит, что «после обновления база полна новыми данными, а в отчёте их нет».

---

## 5. Как проверить и исправить «неактуальные M-скрипты»

1. **Зайти в Power Query Editor (Transform Data) и просмотреть Applied Steps**  
   - Кликать по каждому шагу и смотреть, нет ли там красной ошибки (иконки, указывающей на сбой).  
   - Обратить внимание на шаги: `Changed Type`, `SelectColumns`, `Removed Columns`, `Rename Columns`, `Filter Rows` — эти часто содержат жёсткие ссылки на старые названия.

2. **Обновить превью (Refresh Preview)**  
   - В редакторе Power Query нажать «Refresh Preview». Если где-то появляется ошибка «Column ‘XXX’ not found» или «Could not convert…», значит, M-код ссылается на неактуальную структуру.

3. **Перепроверить список столбцов**  
   - Сравнить, какие колонки реально есть в MySQL (`DESCRIBE table_name;`) и какие указаны в Power Query. Если в базе есть новое поле, а в `Table.SelectColumns` его нет, — значит, оно «выпадает».  
   - Если есть ссылка на удалённый столбец, нужно либо убрать эту ссылку, либо заменить на другое поле.

4. **Использовать «Choose/Remove Columns» осмотрительно**  
   - Если в M-коде есть шаг `Table.SelectColumns(…), Remove Other Columns`, то при добавлении новых столбцов в будущем они не подтянутся автоматически. Иногда безопаснее удалять только «лишние» конкретные поля, оставляя возможность Power BI взять остальные.

5. **При переименовании поля в MySQL менять названия и в Power BI**  
   - Если MySQL-администратор поменял название (например, `OldName` → `NewName`), нужно зайти в Power Query и либо обновить Step Rename, либо удалить старый шаг и заново его создать на новое имя.

6. **Проверять типы данных в шаге «Changed Type»**  
   - Если в MySQL поле стало `VARCHAR`, а M-скрипт по-прежнему пытается конвертировать в Number, появятся ошибки. Поправьте типы либо вручную, либо откорректируйте M-код.

---

## 6. Итог

«Неактуальные M-скрипты» — это ситуация, когда **Power Query** продолжает использовать **старые ссылки** на столбцы, названия или типы данных, не зная о реальных изменениях в структуре MySQL. В результате:

- **Новые поля** не загружаются, потому что в `Table.SelectColumns` явно указан старый набор.  
- **Изменённые или переименованные столбцы** вызывают ошибки «Column not found».  
- **Фильтрация по старым значениям** отсекает новые записи, которых раньше не было в логике M-кода.

Чтобы решить проблему:

1. Войти в Power Query Editor (Transform Data).  
2. Проверить шаги на предмет «Table.SelectColumns», «RenameColumns», «RemoveOtherColumns», «Filter Rows» и пр.  
3. Обновить их под новую структуру MySQL или настроить так, чтобы они автоматически подхватывали новые поля (где это уместно).  
4. Сделать «Refresh Preview» (и затем полный Refresh) — убедиться, что новые столбцы и записи стали отображаться.  

Таким образом, **актуализация** M-скриптов под свежую схему MySQL позволяет правильно загрузить новые поля/строки и показать их в отчётах Power BI.
~~~

## 37. «Зависимости в шагах трансформации»
### 37.1.
Я тебя спросил:
~~~
В пункте 4 своего ответа пункта 4.2 ты писал:
```
- **Зависимости в шагах трансформации**  
  Некоторые шаги могут опираться на столбец, который был удалён, — из-за этого последующие шаги тоже станут невалидными. Power Query может пропускать часть данных или выдавать «крестик» (ошибку) на этапе обновления.
```
Опиши подробнее, каким образом «Зависимости в шагах трансформации» может приводить к проблеме клиента.
~~~

### 37.2.
Ты ответил:
~~~
Ниже подробно описано, как **«зависимости в шагах трансформации»** внутри Power Query могут приводить к тому, что часть (или все) новые данные из MySQL не отображаются в отчётах Power BI:

---

## 1. Что такое «зависимости в шагах трансформации»

1. **Шаги (Steps) в Power Query**  
   В редакторе Power Query каждый шаг (Step) — это отдельная операция, выполняемая последовательно: импорт данных, фильтрация, добавление столбцов, объединение (merge/append) и т. д.  
   - Результат **каждого** шага используется на входе в **следующий**.  
   - Если где-то в середине цепочки один шаг ломается (например, не находит столбец, на который ссылается), то **все последующие** шаги тоже могут стать невалидными.

2. **Зависимости между шагами**  
   - Один шаг может полагаться на **существование** определённого столбца, который был добавлен/переименован/отфильтрован в предыдущих шагах.  
   - Если этот столбец (или таблица) пропадает, переименовывается или получает другой тип данных, а в следующем шаге всё ещё идёт обращение к «старому» виду, возникнет ошибка или некорректное поведение.

---

## 2. Как удалённый или переименованный столбец ломает последующие шаги

1. **Пример: удалённый столбец**  
   - Пусть в MySQL убрали/переименовали поле `OldColumnName`.  
   - В Power Query может быть шаг `Table.SelectColumns`, где явно указано: `{"OrderID", "Date", "OldColumnName"}`.  
   - Когда Power Query не найдёт `OldColumnName`, появится ошибка:  
     > `Expression.Error: The column 'OldColumnName' of the table was not found…`  
   - Все дальнейшие шаги (группировка, фильтрация, добавление вычисляемых столбцов) **прекращают** выполняться, потому что им на вход не поступили данные из «битого» шага.

2. **Пример: переименованный столбец**  
   - Если в MySQL `OrderDate` переименовали в `TransactionDate`, а в Power Query всё ещё фигурирует шаг `RenameColumns`, который пытается поменять «OrderDate» на «SaleDate», при обновлении шаг не найдёт «OrderDate» и выдаст ошибку.  
   - В результате **новые записи, где поле уже называется `TransactionDate`, не будут учитываться** в финальной таблице, так как цепочка шагов «обрывается» на ошибочном месте.

3. **Условные столбцы (Conditional Columns) или вычисляемые поля**  
   - Если где-то в цепочке создан «условный столбец», проверяющий значения переименованного (или удалённого) поля, это тоже приведёт к сбою: Power Query не увидит исходный столбец и выдаст ошибку, либо всё станет `Null`.  
   - Последующие шаги (например, фильтр «оставлять строки, где условный столбец = X») тоже становятся бессмысленными, и часть данных пропадает.

---

## 3. Почему при сбое в одном шаге могут пропадать новые данные

1. **При остановке на одном шаге все следующие шаги не выполняются**  
   - Power Query строит модель данных шаг за шагом. Если на шаге №3 произошла критическая ошибка, то шаги №4, №5 и т. д. не работают.  
   - Итог: **частично или полностью** данные не доходят до финала. Визуалы Power BI, опираясь на финальный шаг, видят «пустую» таблицу или «урезанный» набор строк.

2. **Необязательная (тихая) ошибка**  
   - В некоторых случаях (зависит от логики Power Query) может не быть явного красного сообщения. Например, если автодетект или «Remove Errors» включён, Power Query может **просто пропустить** строки, которые противоречат старой схеме.  
   - Тогда кажется, что обновление прошло успешно, однако **новые записи** (или даже часть старых) отсеялись, потому что поля, на которые опирались шаги, не совпали.

---

## 4. Примеры, как это выглядит на практике

1. **Визуальный признак**  
   - При открытии «Applied Steps» в Power Query некоторые шаги помечены красным крестиком (Ошибка) или предупреждением. Если кликнуть на такой шаг, появится сообщение, что «Column XXX was not found».  
   - Пользователь может не замечать этого, если сразу нажимает «Закрыть и применить» (Close & Apply), а в итоге данные в отчёте не обновляются.

2. **Новые столбцы MySQL не появляются**  
   - Допустим, в MySQL добавили столбец `NewColumn`, который, по идее, нужен для расчётов. Но в Power Query на одном из шагов явно указано «SelectColumns = (OldColumn1, OldColumn2, OldColumn3)». Новый столбец не вошёл в список, и весь M-код дальше понятия не имеет о `NewColumn`. Визуально кажется, что «данные не приходят».

3. **Прерывание после неудачного объединения (Merge) или развёртывания (Expand)**  
   - Если шаг «Merge Queries» пытается объединить таблицу, где поле переименовали/удалили, он выбросит ошибку. Тогда все дальнейшие манипуляции (Group By, Sort, Calculate Column) не выполнятся, и новые данные, пусть даже загрузившиеся в другую часть модели, не попадут в итоговый набор.

---

## 5. Как обнаружить и устранить проблему зависимостей

1. **Последовательно кликнуть на все шаги в Power Query**  
   - В редакторе (Power Query Editor) справа в панели «Applied Steps» (Применённые шаги) выбрать поочерёдно каждый шаг.  
   - Если в каком-то шаге появляется красное сообщение об ошибке, нужно посмотреть текст: не указывает ли он на «Column … not found» или другую проблему с полями.

2. **Сверить с актуальной схемой MySQL**  
   - Проверить, какие именно столбцы существуют теперь в MySQL (через `DESCRIBE table_name;` или GUI-инструмент). Сравнить с тем, что Power Query пытается использовать.  
   - Если нет совпадения (переименованные или удалённые поля), подкорректировать шаги Power Query (RenameColumns, SelectColumns, т. п.).

3. **Упростить или удалить ненужные шаги**  
   - Если какой-то шаг больше не нужен (например, старый «Conditional Column»), лучше его удалить, чтобы он не мешал цепочке.  
   - Или скорректировать так, чтобы он учитывал новые названия полей, либо не ссылался на удалённый столбец.

4. **Проверить результат каждого шага**  
   - После правок шагов нажимать «Refresh Preview», смотреть, сколько строк осталось и какие столбцы существуют.  
   - Убедиться, что в итоговом шаге видны новые столбцы/значения, если они должны быть.

5. **Наблюдать за ошибками во время «Close & Apply»**  
   - При закрытии редактора и применении изменений (Close & Apply) Power Query запускает обновление. Если появляются диалоговые окна с ошибками, важно их не игнорировать, а прочитать и устранить причины.

---

## 6. Почему это особенно критично для новых данных

1. **Старые данные могли ранее «подходить» под логику**  
   - Раньше столбец назывался `OrderDate`, всё работало. После переименования `OrderDate → DateOfOrder` новые строки (где поле уже `DateOfOrder`) не находят соответствия, а старые (где в исходной таблице до сих пор есть старое поле) продолжали частично грузиться. Может создаться впечатление, что только «новые» записи не приходят.

2. **Часть шагов могла обрабатываться автоматически**  
   - Если старые строки не требовали, к примеру, преобразования типа (или там не было пустых значений), то не возникало ошибки. А в новых записях появились иные форматы (или пустые поля), — следующий шаг отбрасывает их.  
   - Из-за этого в отчёте нет свежих данных, хотя «технически» обновление идёт.

---

## 7. Итог

Когда в Power Query **некоторые шаги зависят** от определённых столбцов (или названий таблиц) и эти столбцы/таблицы **изменились** (были удалены, переименованы, получили другой тип данных) на стороне MySQL, то:

- **Один сбойный шаг** может привести к тому, что **вся** дальнейшая цепочка трансформации **не выполнится**.  
- Power Query либо **выдаёт явную ошибку**, либо **тихо** пропускает строки, несоответствующие старой схеме.  
- В итоге **новые данные** не отображаются в отчёте, хотя физически лежат в MySQL.

### Как решить

1. **Просмотреть все шаги** в «Applied Steps» и найти, где может быть ссылка на удалённый или переименованный столбец.  
2. **Сверить названия** (и типы) с реальной схемой MySQL.  
3. **Исправить или удалить** проблемные шаги, указывающие на несуществующие поля.  
4. **Проверить**, что после этого новые записи появляются в итоговом наборе.

Таким образом, важно регулярно поддерживать **актуальность** шагов Power Query при любом изменении структуры в MySQL, чтобы новые или переименованные столбцы **не ломали** зависимые трансформации и чтобы все новые данные корректно попадали в модель Power BI.
~~~

## 38. «Сбой в расписании обновлений (Scheduled Refresh)»
### 38.1.
Я тебя спросил:
~~~
В пункте 4 своего ответа пункта 4.2 ты писал:
```
### 5. Сбой в расписании обновлений (Scheduled Refresh)
- Если в MySQL что-то радикально поменяли (например, структуру таблиц) и при этом в Power BI не обновили настройки подключения (Gateway и т. п.), могут возникать ошибки на уровне сервиса Power BI.  
- В таких случаях новые данные могут вообще не подтягиваться, хотя локально в Power BI Desktop (при ручном обновлении) всё может выглядеть исправно (или наоборот).
```
Опиши подробнее, каким образом «Сбой в расписании обновлений (Scheduled Refresh)» может приводить к проблеме клиента.
~~~

### 38.2.
Ты ответил:
~~~
Ниже рассмотрено, как **сбой в расписании обновления** (Scheduled Refresh) в Power BI Service может приводить к тому, что **новые данные из MySQL** не отображаются в отчёте, хотя локально в Power BI Desktop кажется, что «всё работает»:

---

## 1. Что такое Scheduled Refresh в контексте Power BI

1. **Обновление отчёта по расписанию**  
   - Когда вы публикуете отчёт в Power BI Service, можно настроить «Расписание обновления» (Schedule Refresh). Это позволяет автоматически подхватывать свежие данные из источника (MySQL или другого) в определённое время (например, каждые несколько часов или раз в день).  
   - Если данные хранятся в режиме Import, Power BI будет переподгружать всю модель (или её инкрементальные части, если настроен Incremental Refresh).  

2. **Роль Gateway (если база на On-Premises)**  
   - Если MySQL-сервер находится в локальной сети, а не в облаке, Power BI Service не может напрямую к нему подключиться. Нужен Data Gateway, который обеспечивает зашифрованный канал.  
   - При настройке расписания нужно указать, какой Gateway использовать, и прописать актуальные учётные данные.  

3. **В чём отличие от ручного обновления в Desktop**  
   - При работе в Power BI Desktop, когда вы жмёте кнопку «Refresh», данные обновляются напрямую с вашей машины (у которой может быть прямой доступ к MySQL).  
   - Однако в сервисе (on.powerbi.com) отчёт обновляется по расписанию через публикацию набора данных (Dataset) и использование Gateway (при необходимости). Если там возник сбой — отчёт **не** станет отображать новые данные, даже если на локальном компьютере у вас всё в порядке.

---

## 2. Как может проявляться «сбой» в расписании

1. **Обновление по расписанию вообще не выполняется**  
   - Пользователь настроил расписание, но оно никогда не срабатывает. Может быть, оно «отключено» (Disabled) или задано в нерабочем режиме (например, у пользователя Pro-аккаунт, а он пытается поставить слишком частую периодичность).  
   - В итоге новые данные не грузятся, а пользователь думает, что раз он «установил» расписание, значит всё должно работать.

2. **Обновление падает с ошибкой**  
   - В «Настройках набора данных» (Dataset settings) → «Refresh history» видны статусы Failed. При этом в самой карточке отчёта может быть написано, что последний успешный рефреш был несколько дней (или недель) назад.  
   - Часто причиной бывает неправильная конфигурация Gateway, устаревшие Credentials, время ожидания (timeout) и т. п.

3. **Неучтённые изменения в базе (структура, права и т. д.)**  
   - Если MySQL структура изменилась (новые столбцы, переименованные поля), а модель Power BI в сервисе не обновлена, Scheduled Refresh выдаёт ошибку. Либо — если часть полей всё ещё совпадает — обновление может «проскочить» без явной ошибки, но новые данные (с учётом новых столбцов) не попадут в отчёт.

4. **Несоответствие расписаний**  
   - Если есть цепочка: MySQL обновляется в 10:00, staging-скрипты переносят данные в 10:30, а Power BI настроен на рефреш в 09:45, то в 09:45 новые данные ещё не успеют попасть в «целевую» таблицу. Кажется, что данные «не подтягиваются».  
   - Или наоборот, MySQL обновляется позже, чем срабатывает рефреш.

5. **Ограничения/лимиты обновлений**  
   - В Power BI Pro можно настроить максимум 8 обновлений в сутки для одного набора данных. Если пользователь пытается делать 9, 10 и т. д., часть из них не срабатывает.  
   - Пользователь может не замечать, что некоторые запуски не прошли, и «пропущенные» обновления приводят к тому, что отчёт не получил свежие данные.

---

## 3. Причины, по которым Scheduled Refresh может «не работать» для новых данных

1. **Неверные учётные данные (Credentials)**  
   - Пароль/логин мог измениться (или устареть) в MySQL, а в настройках набора данных (Data Source credentials) на портале Power BI остался старый. В результате при попытке рефреша сервис выдаёт ошибку авторизации и не загружает новую информацию.

2. **Проблемы с On-Premises Data Gateway**  
   - Если Gateway не запущен, устарел или неправильно настроен, Power BI Service не может достучаться до MySQL.  
   - В Desktop у вас всё может быть ок (вы напрямую подключаетесь), а сервис при расписанном рефреше падает. Новые данные не обновляются, отчёт остаётся со старыми значениями.

3. **Ошибки преобразования в Power Query**  
   - Если в Query Editor прописаны шаги, которые теперь не работают (например, удалён или переименован столбец в MySQL), рефреш может «валиться» либо пропускать часть строк.  
   - Локально при ручном обновлении Desktop может показывать предупреждения, но, если их игнорировать, часть данных всё равно «не приедет».

4. **Time-out или слишком долгий запрос**  
   - При больших объёмах данных и медленной MySQL, Scheduled Refresh может не успеть отработать в отведённое время. Тогда сервис прерывает операцию, и отчёт не обновлён.  
   - В Desktop иногда запрос может выполняться дольше и всё же завершаться, а сервис ограничен настройками (у него жёсткие лимиты, например, 2 часа для датасета, если не Premium).

5. **Недостаточно ролей/доступа**  
   - Если кто-то изменил права доступа (GRANT/REVOKE) в MySQL, сервис Power BI при рефреше может не видеть новые таблицы или столбцы, выдавать «Access denied». Пользователь Desktop, запуская обновление от своего имени, может иметь доступ, а учётка шлюза — нет.

6. **Забыли опубликовать обновлённую модель**  
   - Если вы в Desktop исправили все настройки, добавили новые столбцы, проверили, что локально данные тянутся, но **не** нажали «Publish» в Workspace, то в сервисе всё ещё старая модель. Расписание там относится к старому набору данных, который не умеет загружать эти поля или не учитывает новые связи.

---

## 4. Как распознать, что проблема именно в расписании обновления (Scheduled Refresh)

1. **Локальный (Desktop) рефреш проходит, а в сервисе — нет**  
   - Вы видите, что вручную в Desktop все новые записи появляются, а в опубликованном отчёте (через веб-браузер) — по-прежнему старый набор данных. При этом в «Refresh history» сервис может показывать Fail или вообще отсутствующие запуска.

2. **Дата последнего успешного обновления на портале старая**  
   - В карточке набора данных (DataSet) в Power BI Service можно увидеть «Last refresh succeeded: 5 days ago». Это значит, что за последние 5 дней запланированные (или ручные) обновления не были успешными. Все новые данные за это время не подгружены.

3. **В разделе «Refresh history» видны ошибки**  
   - Может быть «Invalid credentials», «Gateway is offline», «Column <...> not found», «Lock wait timeout exceeded» или прочие причины. Если вы не проверяете этот лог, по умолчанию можно и не заметить, что рефреш падает регулярно.

---

## 5. Способы решения проблем с Scheduled Refresh

1. **Проверить «Refresh history»**  
   - В Power BI Service → Workspace → Datasets → «Schedule Refresh» → «Refresh history». Посмотрите, нет ли там красных надписей Fail. Если да, изучите текст ошибки.

2. **Исправить настройку Gateway / Credentials**  
   - Убедиться, что On-Premises Data Gateway «online» (в Manage Gateways → Status), версия актуальная, и что в «Data source credentials» (учётные данные источника) стоит правильный логин/пароль для MySQL.  
   - Если пароль менялся, введите новый.

3. **Синхронизировать время обновления MySQL и Power BI**  
   - Продумать, когда в MySQL появляются новые записи, и когда Power BI запускает рефреш. Если нужно, сместить расписание, чтобы данные точно были готовы и зафиксированы (COMMIT) в момент чтения.

4. **Проверить тип данных, шаги Power Query**  
   - Если в Desktop были изменения (новые поля, связи) или в MySQL переименовали что-то, привести модель в соответствие и не забыть **переопубликовать** (Publish) отчёт.  
   - Локально всё может быть «исправлено», но сервис продолжает работать со старой версией, в которой есть конфликт.

5. **Учитывать лимиты обновлений**  
   - Для Pro-аккаунтов: не более 8 обновлений в день. Для Free — 1 раз в день. Если нужно чаще, возможно, стоит приобрести Power BI Premium или настроить DirectQuery (приемлемо для небольших объёмов и устойчивой производительности базы).

6. **Ручной «Refresh now» в сервисе**  
   - Можно нажать «Refresh now» в Power BI Service (на наборе данных), посмотреть, каков результат. Если «Completed» без ошибок — значит проблема решена. Если «Failed» — смотрим подробности.

7. **Контролировать структуру и размер набора данных**  
   - Если MySQL сильно выросла, импорт может не успевать в отведённые лимиты. Рассмотрите инкрементальное обновление (Incremental Refresh) или оптимизации запросов.

---

## 6. Итог

Когда **Scheduled Refresh** в Power BI Service **не работает** (ошибки, отключённое расписание, неверные учётные данные, проблемы с Gateway), **новые данные из MySQL** никогда не попадут в опубликованный отчёт, даже если:

- локально в Desktop вы всё видите и обновляете;  
- в MySQL данные уже давно добавлены;  
- никаких явных ошибок Desktop не выдаёт.  

Пользователям отчёта в веб-интерфейсе (App.powerbi.com) будет показываться «старая» версия. Важно:

1. **Регулярно проверять** «Refresh history» и статус Gateway.  
2. **Синхронизировать** изменения структуры в MySQL с моделью Power BI.  
3. **Правильно настраивать расписание** (время и частоту), а также **следить за лимитами** обновлений.  

Только тогда автоматическое обновление будет подтягивать новые записи стабильно и без ошибок.
~~~

## 39. «Изменение структуры отношений (Foreign Keys, Primary Keys)»
### 39.1.
Я тебя спросил:
~~~
В пункте 3 своего ответа пункта 4.2.2 ты писал:
```
3. **Изменение структуры отношений (Foreign Keys, Primary Keys)**  
   - Если на стороне MySQL изменилась логика первичных или внешних ключей, а в Power BI остались старые настройки связей, это может привести к тому, что часть данных не будет подтягиваться в отчёт.  
   - Например, была переименована или удалена таблица-справочник, на которую шла ссылка из основной таблицы. В этом случае Power BI будет видеть «обрыв» связи и игнорировать или отбрасывать новые записи.
```
Опиши подробнее, каким образом «Изменение структуры отношений (Foreign Keys, Primary Keys)» может приводить к проблеме клиента.
~~~

### 39.2.
Ты ответил:
~~~
Ниже рассмотрены ситуации, когда **изменения структуры отношений** (Foreign Keys, Primary Keys) на стороне MySQL приводят к тому, что **новые записи не отображаются** в отчётах Power BI или отображаются неверно:

---

## 1. Что подразумевается под «Изменением структуры отношений»

1. **Перенастройка или удаление внешних ключей (Foreign Keys)**  
   - В MySQL можно переименовать или удалить существующие внешние ключи, а также изменить их логику (например, поменять поле, на которое ссылается FK).  
   - Если в модели Power BI (или в логике загрузки данных) предполагалось, что во внешнем ключе хранится уникальная связь на другую таблицу, а на деле это поле поменялось, — отчет перестаёт корректно сопоставлять эти записи.

2. **Изменение/переименование первичных ключей (Primary Keys)**  
   - Иногда в MySQL меняют структуру таблицы: старое поле, которое было PK, перестаёт им быть, или его переименовали. Вместо него заводят новое поле (например, заменяют автонумерацию на GUID или наоборот).  
   - Если Power BI продолжает считать старое поле «основным ключом», при обновлении часть данных (особенно новых) может не подхватиться, потому что PK в базе уже другой.

3. **Распад или объединение справочных таблиц**  
   - Бывает, что таблицу-справочник (dimension), на которую ссылались внешние ключи, удаляют или объединяют с другой. Если при этом Power BI по-прежнему настроен на «старую» таблицу или старые поля ключей, новые записи будут «теряться» из-за «обрыва» связи.

---

## 2. Как эти изменения влияют на загрузку данных в Power BI

1. **Обрыв связей и несоответствия в Power Query**  
   - В Power BI (особенно в разделе «Model» или при настройке Relationships) мы указываем, какое поле в таблице Fact ссылается на какое поле в таблице Dimension. Если на уровне MySQL FK поменялся, а в Power BI связь осталась старая, новая логика не будет совпадать.  
   - В результате **новые записи** (с новыми значениями ключа) не найдут себе «пару» в справочном измерении, и **не будут** отображаться в отчёте при фильтрации по этому измерению.

2. **Новые строки не находят соответствия**  
   - Например, если в MySQL переименовали `CustomerID` в `ClientID`, а в Power BI связь до сих пор стоит по полю `CustomerID`, то любые новые записи, которые пишутся в поле `ClientID`, будут «невидимы» для Power BI (ведь модель не знает о `ClientID`).  
   - Даже если в MySQL названию столбца соответствует тот же набор значений, Power BI при обновлении выдаст ошибку («Column not found») или просто не подключит эти данные в отношения.

3. **Риск появления дубликатов или конфликтов**  
   - Если старый PK перестал быть уникальным, а Power BI всё ещё считает его уникальным, может возникать ситуация, при которой одна и та же запись в MySQL отображается некорректно или несколько строк «склеиваются».  
   - Либо наоборот, новые строки с потенциально повторяющимся ключом будут игнорироваться Power BI из-за того, что оно ожидает уникальность, а в реальности поле уже не уникально.

4. **Ошибки при инкрементальном обновлении**  
   - Если Power BI использует инкрементальное обновление (Incremental Refresh) и полагается на некое «изменённое поле» (например, LastModifiedDate или ID-последовательность), а в MySQL заменили/изменили этот ключ, Power BI может перестать корректно определять новые и обновлённые записи.  
   - В итоге «свежие» строки не будут попадать в отчёт, несмотря на то, что фактически есть в базе.

---

## 3. Примеры практических сценариев

1. **FK переименован в MySQL**  
   - Допустим, у нас была таблица `Orders` с полем `CustomerID`, которое является внешним ключом, указывающим на таблицу `Customers(CustomerID)`. После реструктуризации в MySQL поле переименовали в `ClientID` и убрали старый FK.  
   - В Power BI связь (Manage Relationships) всё ещё настроена: `Orders.CustomerID` → `Customers.CustomerID`.  
   - Итог: при попытке обновления вы получите либо ошибку (если столбец `CustomerID` в `Orders` исчез), либо новые данные, у которых действительно заполнен `ClientID` (вместо `CustomerID`), не будут сопоставляться и не отобразятся.

2. **Изменённый Primary Key в справочнике**  
   - Справочник товаров (ProductDimension) содержал PK `ProductID`. Администраторы решили перейти на новый ключ `GlobalProductCode`, удалив `ProductID` или сделав его неуникальным.  
   - Фактическая таблица (SalesFact) писала продажи по `GlobalProductCode`, но Power BI продолжает связывать SalesFact → ProductDimension по старому полю `ProductID`.  
   - Новые товары (с `GlobalProductCode`) не попадут в отчёт, так как связь «по старому полю» не работает.

3. **Удалённая таблица-справочник**  
   - Таблица `Regions` была удалена в MySQL или объединена с другой, а внешние ключи в основной таблице `Customers.RegionID` остались «висячими». Power BI при обновлении либо выдаёт ошибку («Table Regions not found»), либо игнорирует этот FK.  
   - Новые записи, у которых прописан `RegionID`, не находят соответствий — и Power BI не показывает эти строки в визуалах.

---

## 4. Как распознать, что проблема именно в изменении структуры отношений

1. **Ошибки при загрузке или обновлении**  
   - Power BI может сообщать: «The column ‘X’ was not found…», «Invalid object name…», «Cannot find field ‘CustomerID’ in the current schema…».  
   - Либо в «Manage Relationships» видна неактивная связь с красным предупреждением.

2. **Отсутствие новых строк, при этом старые показываются**  
   - Старые данные (до изменения FK/PK) могут ещё работать (если физически в таблице ничего не сломалось), а новые — нет, потому что новые записи уже ориентируются на новую логику FK/PK.

3. **Проверка MySQL-схемы**  
   - Если сделать `SHOW CREATE TABLE table_name;` или `SHOW TABLE STATUS;` и увидеть, что FK или PK уже поменялся, а в модели Power BI всё ещё фигурирует старое имя столбца, значит «разсинхрон».

4. **Невидимый столбец**  
   - Иногда MySQL-сообщества или патчи могут скрыть (Deprecate) старый столбец, а Power BI по-прежнему ищет его. Прямые запросы к этому столбцу возвращают ошибку.

---

## 5. Рекомендации по исправлению

1. **Сопоставить текущую структуру MySQL с моделью Power BI**  
   - Узнать, какие изменения были сделаны в базе (какие поля переименовали или удалили, какие FK/PK убрали).  
   - В Power Query или в разделе «Модель» обновить соответствующие шаги, чтобы они ссылались на новые названия и учитывали новую схему.

2. **Обновить связи (Relationships) в Power BI**  
   - Если поле `CustomerID` переименовали в `ClientID`, в «Manage Relationships» нужно указать, что связь идёт теперь по `Orders[ClientID]` → `Customers[ClientID]`.  
   - Если PK поменялся — скорректировать тип и название поля, которое Power BI использует как сторону «One».

3. **Перепроверить уникальность и тип данных**  
   - Если изменился PK, убедиться, что новое поле действительно уникальное (при условии, что это нужно для «One-to-Many»).  
   - Проверить, не появился ли новый формат (число, GUID, текст) вместо старого.

4. **Проверить логику ETL**  
   - Если часть данных идёт из ETL-сценария, в котором жёстко прописаны старые названия FK/PK, нужно адаптировать скрипты, чтобы они вставляли/обновляли новые поля.

5. **Тестировать обновление отчёта**  
   - После внесения правок в модель Power BI сделать «Refresh» и посмотреть, что новые записи теперь отображаются корректно.  
   - Проверить «History» при запланированном обновлении (Scheduled Refresh) в Power BI Service, чтобы не осталось ошибок.

---

### Итог

Когда в MySQL **меняется структура отношений** (Foreign Keys, Primary Keys) — переименовывают ключи, удаляют или заменяют их на новые, — а **в Power BI** при этом **не обновляют** соответствующие связи и поля, отчёт перестаёт корректно отображать **новые данные** (а иногда и часть старых). Визуально создаётся впечатление, что «новые записи не пришли», хотя на самом деле модель Power BI «не знает» о новых/переименованных ключах и потому **не стыкует** факты и измерения. 

**Основное решение** — привести в соответствие структуру Power BI (Power Query, Relationships, DAX) с реальными FK/PK в MySQL:  
1. Исправить названия полей и логику.  
2. Перепроверить уникальность (PK) и связность (FK).  
3. Тщательно протестировать обновление, дабы все новые записи попадали в отчёт.
~~~

## 40. «Разделение таблиц или перенос данных в другие схемы»
### 40.1.
Я тебя спросил:
~~~
В пункте 4 своего ответа пункта 4.2.2 ты писал:
```
4. **Разделение таблиц или перенос данных в другие схемы**  
   - Случается, что разработчики баз данных переносят часть столбцов в другую таблицу или даже в другую схему, а название/настройки подключения в Power BI не меняется. Тогда Power BI при запросе старых таблиц не находит часть данных.  
   - Новые записи могут физически находиться в новой структуре, которая просто не подключена к текущей модели Power BI.
```
Опиши подробнее, каким образом «Разделение таблиц или перенос данных в другие схемы» может приводить к проблеме клиента.
~~~

### 40.2.
Ты ответил:
~~~
Ниже рассмотрено, как **разделение (splitting) таблиц** или **перенос данных в другую схему** MySQL может приводить к тому, что в Power BI **не появляются** новые записи, хотя в базе они есть:

---

## 1. Что значит «Разделение таблиц» и «Перенос данных в другие схемы»

1. **Разделение (Splitting) одной таблицы**  
   - Иногда администраторы или разработчики решают «разбить» существующую крупную таблицу на две (или более) таблицы. Например, была таблица `Orders`, в которой хранилась и «шапка» заказа (Order Header), и позиции заказа (Order Lines). Затем её разделили на `OrderHeader` и `OrderLines`, чтобы улучшить структуру, оптимизировать запросы и т. д.  
   - При этом **название** и **содержимое** исходной таблицы может сильно измениться (или её вообще удаляют), а **часть данных** (новые или все записи) начинает жить в новых таблицах.

2. **Перенос в другую схему (schema)**  
   - В MySQL (и других СУБД) данные могут физически находиться в разных базах (schemas). Разработчики решают, что «теперь таблица `Orders` переезжает из `old_schema` в `new_schema`», и переносят её. В итоге в `old_schema.Orders` могут больше **не попадать** новые строки, а все обновления идут в `new_schema.Orders`.

3. **Изменение схемы без оповещения Power BI**  
   - Если Power BI был настроен читать данные из **старой** таблицы (или из **старой** схемы), но никто не обновил настройки подключения, модель всё ещё ссылается на «старое место».  
   - Новые записи (заполняемые в новой структуре) остаются **невидимы** для Power BI.

---

## 2. Почему после разделения или переноса таблиц новые данные «не доходят» до отчёта

1. **Power BI продолжает опрашивать «старую» таблицу**  
   - Допустим, вы в Power Query явно подключались к `old_schema.Orders`. Если теперь новые заказы записываются в `new_schema.Orders` (или в `OrderHeader` и `OrderLines`), «старая» таблица остаётся «замороженной» и не отражает свежие вставки.  
   - При обновлении (Refresh) отчёта Power BI видит, что в «старой» таблице ничего нового нет, и пользователь решает: «Опять нет новых данных!».

2. **Часть данных перенесена в дополнительные таблицы**  
   - Если из `Orders` выделили столбцы, связанные с логикой позиций (Line Items), в отдельную таблицу `OrderLines`, то старый запрос `SELECT * FROM Orders` больше **не содержит** информацию о позициях.  
   - Теоретически, свежие строчки (особенно если это детальные записи) записываются в `OrderLines`, а Power BI не знает о её существовании и не делает туда запрос.

3. **Изменились ключи и связи**  
   - Иногда при разделении таблицы вводят новые ключи (например, `OrderID` остаётся в `OrderHeader`, а `LineID` создаётся в `OrderLines`). Если в Power BI не настроить новую логику связывания, то фактическая таблица может «потерять» связь с измерениями.  
   - В результате кажется, что «пропали» новые заказы или позиции, хотя физически они лежат в другой таблице/схеме с другими ключами.

---

## 3. Типичные примеры ситуаций

1. **Миграция из `old_schema.Orders` в `new_schema.Orders`**  
   - Администраторы клонируют структуру и данные, затем обновляют приложение, чтобы оно писало заказы в `new_schema.Orders`.  
   - Power BI, по-прежнему настроенный на `old_schema.Orders`, видит только «исторические» данные, а всё новое уходит «мимо».

2. **Разделение таблицы на «шапку» и «позиции»**  
   - Была одна таблица `Sales`, содержала общую информацию и подробности. Теперь созданы `SalesHeader` (итог по чеку/заказу) и `SalesDetail` (строка продажи).  
   - Power BI по-прежнему тянет данные из `SalesHeader`, но не знает о `SalesDetail`. Поэтому при анализе позиций товаров новые продажи не отображаются.

3. **Частичный перенос**  
   - В некоторых случаях новые строки добавляются только в новую таблицу, а старую не трогают (или её используют только для чтения исторических данных). Пока в Power BI не перестроят запросы, «новых» записей в отчёте не будет — они находятся «по другому адресу».

---

## 4. Как пользователь видит проблему

1. **Отчёт не показывает свежие заказы или позиции**  
   - При ручном запросе в MySQL (через Workbench или CLI) пользователь видит, что в `new_schema.Orders` есть новые строки. Но в отчёте Power BI — пусто.  
   - Ошибки при обновлении может и не быть, ведь старая таблица существует, просто она не меняется.

2. **Частичный охват новых данных**  
   - Иногда Power BI видит «шапку» (OrderHeader) с обновлёнными записями, но не видит детальные строки (OrderLines). Итоги продаж неполны, расчёты занижены, диаграммы не учитывают часть позиций.

3. **Сброс/падение обновлений**  
   - Если старая таблица была удалена, а Power BI всё ещё пытается к ней подключиться, тогда при Refresh отчёт может выдавать ошибку:  
     > «Table ‘old_schema.Orders’ doesn’t exist»  
   - Соответственно, никакие данные не обновляются.

---

## 5. Причины, по которым не обновили Power BI

1. **Отсутствие коммуникации**  
   - Разработчики БД/ERP меняют структуру, но не ставят в известность команду, ведущую отчёты.  
   - В итоге Power BI остаётся «привязанным» к прежней структуре.  

2. **Автодетектирование не поможет**  
   - Power BI (особенно при Import) не будет «охотиться» за новыми таблицами само. Если конкретно в шаге Power Query указано: «Тянуть таблицу `old_schema.Orders`», оно так и сделает, не проверяя, куда теперь пишет приложение.

3. **Сложность перестроения**  
   - Бывает, что в отчёте много DAX-вычислений и визуалов, завязанных на старую таблицу. Миграция на новую структуру требует переписывать часть логики, поэтому откладывается «на потом».

---

## 6. Как решить проблему

1. **Уточнить, куда теперь пишутся новые данные**  
   - Связаться с DBA или разработчиками: «Какие таблицы или схемы используются для новой логики?».  
   - Убедиться, что Power BI точно подключается к **актуальному** расположению.

2. **Обновить запросы и модель Power BI**  
   - В Power Query:  
     - Если таблица перенесена, поменять путь к «new_schema.TableName».  
     - Если данные разделены, возможно, нужно **добавить** новую таблицу (OrderLines) и настроить **отношения** (Relationships) с таблицей OrderHeader.  
     - Перепроверить шаги SelectColumns, фильтры, типы данных.

3. **Настроить связи (Relationships)**  
   - Если из одной таблицы сделали две, скорее всего, нужно в Power BI создать две таблицы и связать их по ключу (OrderID или аналог). Иначе Power BI не сможет агрегировать данные из «детальной» части.  
   - Перепроверить меры (Measures) и DAX: они могут требовать JOIN или LOOKUPVALUE на новую таблицу.

4. **Переконструировать отчёт**  
   - Если в отчёте много визуалов, завязанных на старую структуру, возможно, придётся пересобрать часть визуалов, чтобы тянуть данные из новых таблиц.  
   - При необходимости объединять (Merge, Append) или использовать DAX, чтобы снова собрать все нужные колонки в одном View.

5. **Тестировать после правок**  
   - После изменения источника и связей сделать «Refresh» в Desktop, проверить, отображаются ли новые данные.  
   - Если всё хорошо, опубликовать обновлённую модель в Power BI Service и проверить, не возникает ли ошибок.

---

## 7. Вывод

Когда разработчики **разделяют** одну большую таблицу на несколько (Header/Lines, Master/Detail) или **переносят** таблицу в другую схему, а **Power BI** остаётся настроенным на старую структуру, **новые записи** по факту записываются уже «в другое место». Для Power BI, однако, это место неизвестно, поэтому при обновлении отчёта:

- **Не отображаются** новые данные, поскольку они физически хранятся не там, где идёт запрос.  
- Могут возникать **ошибки**, если старая таблица удалена или недоступна.

Чтобы решить проблему, нужно **перенастроить** Power Query на новые таблицы/схемы, проверить/обновить **связи** (Relationships) и при необходимости пересобрать логику DAX и визуалы. Тогда Power BI начнёт получать актуальные данные из актуальной структуры MySQL.
~~~

## 41. «Несоответствие при повторном использовании имён»
### 41.1.
Я тебя спросил:
~~~
В пункте 5 своего ответа пункта 4.2.2 ты писал:
```
5. **Несоответствие при повторном использовании имён**  
   - Иногда администраторы MySQL могут удалить столбец/таблицу и создать новый объект с таким же именем, но другим типом данных или другой логикой. Power BI, «думая», что это та же структура, продолжает обрабатывать данные по старым правилам и даёт ошибку или некорректный результат.

Опиши подробнее, каким образом «Несоответствие при повторном использовании имён» может приводить к проблеме клиента.
~~~

### 41.2.
Ты ответил:
~~~
Ниже рассмотрено, как **повторное использование** в MySQL того же **имени таблицы или столбца** (но при этом меняется его логика, тип, структура) может приводить к тому, что **Power BI** продолжает считать, что это «старый объект», и в результате новые данные не отображаются или появляются ошибки.

---

## 1. В чём суть проблемы при «повторном использовании имени»

1. **Переименование или удаление старого объекта и создание нового с тем же именем**  
   - Администратор MySQL может удалить столбец `ColumnA`, а потом создать **другой** столбец с тем же названием `ColumnA`, но при этом у него уже может быть **другой тип** (например, раньше был `INT`, теперь `VARCHAR`) или даже другое назначение/логика.  
   - Аналогичная ситуация с таблицами: старая таблица `Orders` удаляется, а затем создаётся **другая** таблица `Orders` с иным набором столбцов, типами, индексами и т. д.

2. **Power BI думает, что «это всё та же колонка/таблица»**  
   - Для Power BI (особенно если название не меняется) по умолчанию считается, что объект с тем же именем — это тот же самый объект со старой схемой.  
   - Все шаги Power Query (Table.SelectColumns, Changed Type, Relationships и т. п.) будут по-прежнему ссылаться на «ColumnA» как если бы она была тем же `INT`, что и раньше.  

3. **Нарушение соответствия между фактической структурой и моделью**  
   - В результате могут возникать **расхождения**: Power BI пытается интерпретировать столбец `ColumnA` как число, хотя в MySQL он уже строка. Или наоборот.  
   - Если это таблица, то Power BI полагается на старый набор столбцов (например, `OrderID`, `Amount`), а в реальности там теперь `Order_Code`, `TotalSum` и т. д.

---

## 2. Как это влияет на обновление данных

1. **Ошибки преобразования (Conversion Errors)**  
   - При загрузке Power Query может выдавать:  
     > “Couldn’t convert Text to Number”  
     или  
     > “The column ‘ColumnA’ was not found” (если структура поменялась глубоко).  
   - Т. е. Power BI попытается применить «старый» тип/логику к «новому» полю — и не сможет.  

2. **Неправильные итоги в отчёте**  
   - Если «под капотом» таблица MySQL изменила тип или значения, Power BI может **неправильно обрабатывать** часть данных (например, если строки теперь хранятся как `VARCHAR`, а отчёт ожидает числовую агрегацию).  
   - Новые записи могут «теряться» или вообще не учитываться, создавая впечатление, что «данные не приходят».

3. **Несоответствия в Relationships (связях)**  
   - Если отношение (Relationship) в Power BI зависело от столбца, который был переопределён (например, `CustomerID` — раньше `INT`, а теперь `CHAR`), при обновлении могут пропадать связи или выдаваться предупреждения.  
   - Итог: новые строки не отображаются, потому что Power BI «не видит» корректного пути для сопоставления.

4. **Прерванные сценарии загрузки**  
   - В некоторых случаях Power Query прерывает весь рефреш (Refresh) при первой возникшей ошибке. Значит, отчёт вообще не обновится, и все новые данные останутся «застрявшими».

---

## 3. Пример практической ситуации

Предположим, раньше была таблица `orders` со структурой:

```sql
orders (
    id INT,
    date DATE,
    amount DECIMAL(10,2)
)
```

В Power BI настроен Import, где:

- Модель ожидает столбец `id` (число)  
- Столбец `date` (дата)  
- Столбец `amount` (число)

Затем администратор удаляет/переименовывает эту таблицу и создаёт заново:

```sql
orders (
    id VARCHAR(10),
    order_date DATETIME,
    total_sum VARCHAR(20)
)
```

Но имя таблицы осталось тем же: **`orders`**.

- Power BI при обновлении:
  - Пытается загрузить `id` как `Int64.Type` → «Conversion error»,  
  - Пытается найти столбец `date` → «Column not found» (т. к. теперь называется `order_date`),  
  - Пытается агрегировать `amount` → Но теперь есть `total_sum` как текст.  

Результат: отчёт либо падает с ошибкой, либо загружает часть полей как `Null`, и **свежие записи** вообще не учитываются.

---

## 4. Почему клиент может не сразу заметить проблему

1. **Отчёт «частично» загружается**  
   - Если Power Query «проглатывает» ошибки (например, заменяет невалидные значения `Null`), то может не быть явного сообщения о сбое. Но цифры в отчёте перестают сходиться с реальностью, и новые записи «не видны».  

2. **Разработчик считает, что «имя таблицы/столбца не менялось»**  
   - Пользователь (или команда) видит то же название «orders»/«id» и полагает, что всё как раньше. Но логика содержания изменилась.  

3. **Расхождение обнаруживается только при углублённой проверке**  
   - Возможно, всё кажется в порядке, пока не появится серьёзное несоответствие (у клиента не сходятся обороты или количество заказов). И только тогда выясняется, что таблица давно поменялась.

---

## 5. Как устранить проблему при «повторном использовании имён»

1. **Не «подменять» объекты под старыми именами, если изменилась суть**  
   - Если меняете логику таблицы (или столбца) кардинально, лучше давать новое имя (например, `orders_new`). Тогда и Power BI разработчики увидят, что это другой объект, и обновят модель соответствующим образом.  

2. **Обновить Power Query шаги**  
   - Если по каким-то причинам приходится переиспользовать имя, в Power BI нужно сразу открыть редактор (Transform Data) и:
     - Проверить, что все столбцы действительно имеются в «новой» таблице,  
     - При необходимости удалить/добавить шаги (SelectColumns, RenameColumns, ChangedType),  
     - Изменить типы данных по факту (например, теперь `id` — это текст).  

3. **Пересоздать или обновить связи (Relationships)**  
   - Если ключи и структура изменились, проверить «Manage Relationships». Возможно, придётся удалить старую связь (по полю `id` как `INT`) и создать новую (по `id` как `Text`).  

4. **Проверить вычисления DAX**  
   - Убедиться, что нет мер (Measures) или вычисляемых столбцов, которые ссылаются на «старые» названия полей. Если такие выражения есть, надо поправить их под новую структуру (`order_date` вместо `date`, `total_sum` вместо `amount` и т. п.).  

5. **Тестовое обновление**  
   - После внесения правок в Power Query и модель сделать «Refresh» в Desktop. Если всё корректно, публиковать отчёт в сервис Power BI.  

6. **Настроить уведомления о таких изменениях**  
   - В организации лучше согласовать процесс: если DBA (администратор БД) вносит радикальные правки в структуру с сохранением имени, нужно уведомлять команду BI. Иначе все отчёты, завязанные на «старое имя», будут работать некорректно.  

---

### Итог

Повторное использование старого **имени** при создании **новых** объектов (столбцов, таблиц) в MySQL сбивает с толку Power BI, который «думает», что ничего не поменялось. На практике:

- **Типы данных** (INT vs. VARCHAR),  
- **Названия столбцов**  
- **Логика ключей**  

могут полностью измениться. Power BI продолжает применять «старые настройки» (шаги Power Query, типы, связи), поэтому либо возникает **ошибка**, либо часть новых данных становится **недоступна** или **неправильно интерпретируется**. Решение — явное обновление модели и шагов Power Query всякий раз, когда под старым именем появляется принципиально новый объект в базе.
~~~

## 42. «Зависание кэша метаданных и отсутствие обновления схемы»
### 42.1.
Я тебя спросил:
~~~
В пункте 6 своего ответа пункта 4.2.2 ты писал:
```
6. **Зависание кэша метаданных и отсутствие обновления схемы**  
   - Power BI кэширует схему (metadata) источника данных. Если изменения в базе произошли недавно, а в настройках Power Query не была выполнена «перезагрузка» (Refresh Preview) либо не был обновлён столбец (через «Refresh fields» в Query Editor), то Power BI может работать с устаревшими сведениями о схеме.  
   - В итоге новые столбцы/данные не учитываются при визуализации, или наоборот — отчёт «сыпется» ошибками при обращении к старым столбцам.
```
Опиши подробнее, каким образом «Зависание кэша метаданных и отсутствие обновления схемы» может приводить к проблеме клиента.
~~~

### 42.2.
Ты ответил:
~~~
Ниже подробно описано, как «зависание кэша метаданных» и отсутствие обновления схемы в Power BI (особенно в Power Query) могут приводить к тому, что при изменениях в структуре MySQL **новые данные не отображаются**, а отчёт «живёт» со старой схемой:

---

## 1. Что такое «кэш метаданных» в Power BI

1. **Хранение схемы (metadata)**  
   - При подключении к базе MySQL или другому источнику данных Power BI запрашивает у него информацию о структуре (список таблиц, столбцов, их типы и т. д.).  
   - Эта информация **кэшируется** внутри Power BI (в частности, в Power Query) для ускорения последующих запросов и для автоматического определения типов данных (автодетектирование).

2. **Почему Power BI не обновляет схему «на лету»**  
   - По умолчанию Power BI не отслеживает изменения структуры в базе в режиме реального времени. Если в MySQL добавили или удалили столбец, переименовали таблицу и т. д., Power BI продолжит работать со «старой» схемой, пока пользователь явно не обновит метаданные (например, в редакторе Power Query).

---

## 2. Как выглядит «зависание кэша метаданных» на практике

1. **Метаданные устарели**  
   - Допустим, в MySQL добавили новый столбец `Discount` в таблицу `Sales`. В редакторе Power Query (Query Editor) вы **не** нажимали «Refresh Preview» или «Refresh fields» — модель продолжает считать, что у таблицы `Sales` есть только старые столбцы.  
   - В результате при обновлении отчёта (Refresh) эти новые данные (поле `Discount`) попросту не учитываются: Power Query их не запрашивает, а в модели Power BI столбец не появляется.

2. **Ошибки при обращении к старым столбцам**  
   - Обратная ситуация: в MySQL удалили или переименовали столбец, а кэш (metadata) в Power BI считает, что он по-прежнему существует. При попытке загрузить данные Power Query генерирует SQL вроде `SELECT OldColumn FROM Sales`, и MySQL отвечает:  
     > `Column 'OldColumn' not found`  
   - Это приводит к сбою обновления. Пользователь видит ошибку и не получает новых данных.

3. **Дублирование или некорректная информация о полях**  
   - Бывает, что при изменениях в базе (например, при переименовании поля) Power Query «видит» и новое, и старое название в кэше — отчёт может «падать» с конфликтами или обрабатывать таблицу неправильно.  

---

## 3. Почему клиент может думать, что «новые данные не тянутся»

1. **Нет явных ошибок** (если поле просто добавили, а в Power Query его не запрашивают)  
   - Если база расширилась новым столбцом, но в Power Query он не упомянут и не нужен для существующих шагов, процесс обновления может **не** выдавать ошибок.  
   - Однако «новые» столбцы (а иногда и связанные с ними новые записи) не будут попадать в отчёт. Пользователь замечает, что «столбца/данных нет», хотя в базе они уже есть.

2. **Power Query «замораживает» старую версию схемы**  
   - Может показаться, что «Power BI не видит новые записи», но на самом деле часть данных не загружается, потому что в Query Editor есть жёсткая выборка (например, `Table.SelectColumns`) по старому списку полей.  
   - Кэш метаданных подсказывает Power Query, что других столбцов нет, — в результате всё обновление происходит по «старой схеме» без участия новых полей.

---

## 4. Как именно «зависание кэша» мешает учёту **новых записей**, а не только столбцов

1. **Изменение структуры может менять и способ чтения**  
   - Если, допустим, тип столбца в MySQL поменяли (из `INT` в `VARCHAR`), а в Power Query он остался числовым, при загрузке новых строк могут возникать ошибки конвертации. Даже если часть старых строк проходит, новые (с другим форматом) не подтянутся.  
   - Power Query не перепроверяет автоматически схему: оно продолжает пытаться прочитать поле как число, а новый формат данных «ломает» загрузку.

2. **Зависимость новых строк от новых столбцов**  
   - В ряде случаев новые строки содержат значения только в новых столбцах, а «старые» столбцы могут быть пустыми. Если Power Query не видит этот новый столбец, часть логики фильтрации или вычислений может отбрасывать такие записи.  
   - Например, если есть условие «Filter Rows» (не брать записи, где `Discount < 0`) — но столбец `Discount` в кэше отсутствует, фильтрация может работать некорректно и исключать строки с `NULL` или `Blank`.

---

## 5. Чем это отличается от обычной «неактуальности модели»

1. **Кэш метаданных** — это именно **оперативная** (runtime) информация о структуре, хранящаяся в Power Query. Даже если в MySQL всё хорошо, Power BI без «сброса» (Refresh Preview или «Update Metadata») может не обновить внутреннюю схему.  
2. **Даже при ручном Refresh** отчёта в Desktop или Scheduled Refresh в сервисе Power BI структура **не** обязательно обновится. Данные будут грузиться, но согласно старым сведениям о схеме.

---

## 6. Как обнаружить и устранить проблему

1. **Обновить превью в Power Query**  
   - В Desktop открыть «Transform data» (Редактор Power Query) → в правом верхнем углу таблицы нажать на иконку «Refresh Preview».  
   - Если появились новые столбцы или появились/исчезли ошибки, значит, старая схема изменилась, и теперь Power Query «подтянул» новый список полей.

2. **Проверить шаги `Table.SelectColumns`**  
   - Часто в M-коде используется явное перечисление полей. Если новых полей нет в этом списке, Power BI их игнорирует. Можно либо добавить их вручную, либо использовать другой подход (например, «Remove Other Columns») так, чтобы новые поля подхватывались автоматически.

3. **Пересмотреть «Changed Type»**  
   - Если в MySQL поменяли тип поля (дата стала строкой, число стало текстом и т. п.), нужно зайти в «Applied Steps» и проверить «Changed Type» или прочие трансформации, где Power Query пытался (или пытается) конвертировать данные в старый тип.

4. **Нажать «Detect Data Type» или переопределить тип вручную**  
   - Можно вручную задать нужный тип для нового (или переименованного) столбца. Либо в контекстном меню выбрать «Detect Data Type» заново, чтобы Power Query подхватил изменения.

5. **Удалить/пересоздать источник, если структура сильно поменялась**  
   - Если таблицу в MySQL полностью заменили (другие имена столбцов, другая схема), иногда проще удалить источник данных в Power Query и заново его подключить. Тогда кэш метаданных точно обновится, и вы увидите все новые столбцы.

6. **Настроить уведомления**  
   - Если базу MySQL часто меняют (добавляют поля), можно отключить автодетектирование связей и схемы в настройках Power BI, чтобы вручную контролировать любой момент, когда структура реально изменилась.  
   - Или, наоборот, включать автодетектирование, чтобы Power BI хотя бы предупреждал, что «Появились новые поля, хотите ли обновить модель?».

---

## 7. Вывод

Когда в MySQL меняется структура, а Power BI **не обновляет кэш метаданных** (не перезагружает схему), это создаёт ситуацию, в которой:

- **Новые столбцы** не видны или игнорируются.  
- **Переименованные/удалённые поля** вызывают ошибки при загрузке или «тихо» ломают некоторые шаги Power Query.  
- **Типы данных** остаются «застывшими» на старых значениях, из-за чего новые записи (с другими форматами) могут пропадать или вызывать сбои.

Пользователь видит, что **«данные не подтягиваются»**, хотя формально они уже в MySQL. Решение — **принудительно обновить** схему (через «Refresh Preview», «Update Metadata» или корректировку шагов в Query Editor), проверить/исправить типы столбцов, и только после этого **делать обновление** (Refresh) отчёта, чтобы новые поля и строки корректно загрузились в модель Power BI.
~~~

## 43. «Новые таблицы MySQL без обновления модели Power BI»
### 43.1.
Я тебя спросил:
~~~
В пункте 3 своего ответа пункта 4.2 ты писал:
```
- **Новые таблицы MySQL без обновления модели Power BI**  
  Если добавили новую таблицу/представление (view) в MySQL, и именно там теперь находятся актуальные данные, но в Power BI по-прежнему ссылаются на старую таблицу или вообще на другую схему, то необходимые данные не попадут в отчёт.  
  - Пример: перенесли исторические записи в новую таблицу `sales_history`, а в Power BI всё ещё загружается старая `sales_archive`. Новые данные останутся «за кадром».
```
Опиши подробнее, каким образом «Новые таблицы MySQL без обновления модели Power BI» может приводить к проблеме клиента.
~~~

### 43.2.
Ты ответил:
~~~
Ниже описано, как создание или использование **новых таблиц** (или представлений) в MySQL, при этом **без обновления** модели и запросов (Power Query) в Power BI, может приводить к тому, что **новые данные** не появляются в отчётах:

---

## 1. Сценарий: в MySQL создана новая таблица или перенесены данные

1. **Создание новой таблицы (или View)**  
   - Администраторы или разработчики базы данных решают, что теперь важные данные будут храниться не в старой таблице `old_table`, а в новой — `new_table` (или новое представление `v_sales_data`).  
   - При этом в **Power BI** раньше была настроена загрузка данных из `old_table`, и её никто не поменял.

2. **Перенос (миграция) данных**  
   - Иногда данные **физически переносят**: старую таблицу оставляют «как архив» (например, `sales_archive`), а все новые записи начинаются в `sales_current`.  
   - Или наоборот: объединяют старые данные со свежими в новой таблице `sales_master`, а старые таблицы перестают обновляться.

3. **Power BI всё ещё ссылается на старую таблицу**  
   - Если при этом в **Power Query** (или в настройках источника в Power BI) осталась ссылка на `old_table`, то **никакие новые данные**, находящиеся в `new_table`, не будут подтягиваться: отчёт по-прежнему смотрит туда, где «ничего не обновляется».

---

## 2. Примеры проявления проблемы

1. **«Новые» строки не видны в отчёте**  
   - Администратор видит, что в базе MySQL есть куча новых записей (в `new_table`), но в отчёте Power BI данные «стоят» на прежнем уровне.  
   - Проверка показывает, что Power BI продолжает делать `SELECT * FROM old_table;`, где новых строк уже нет.

2. **Ошибки или пустой результат при обновлении**  
   - Если старую таблицу даже удалили (или переименовали), а Power BI пытается к ней подключиться, может возникать ошибка вида «Table ‘old_table’ doesn’t exist» или «Object not found».  
   - Если старую таблицу оставили, но перестали в неё писать данные, тогда Power BI не выдаёт ошибок, но отображает только устаревшие записи.

3. **Данные доступны в MySQL (через SQL-клиент), а в Power BI — нет**  
   - При выполнении запроса в MySQL Workbench, DBeaver или другом клиенте (`SELECT COUNT(*) FROM new_table`) все новые данные присутствуют.  
   - В Power BI же количества записей не растёт, никакой динамики нет, хотя дата обновления отчёта свежая. Просто он «не смотрит» в новую таблицу.

---

## 3. Причины, по которым модель Power BI не обновилась

1. **Отсутствие ручного обновления настроек Power Query**  
   - Обычно нужно зайти в «Редактор Power Query» и либо **добавить** новую таблицу (через «Get Data» / «Добавить источник данных»), либо **изменить** старый запрос, чтобы он ссылался на `new_table` вместо `old_table`.  
   - Если этого не сделать, Power BI не «угадывает» автоматически, что в MySQL появилась новая таблица.

2. **Автоматическая конфигурация отключена**  
   - Даже если в Power BI включено автодетектирование схемы (при первом подключении), оно не умеет динамически перестраивать запросы, когда в базе появляются новые объекты. Требуется вручную настраивать или обновлять запрос.

3. **Старые ссылки в M-коде**  
   - В редакторе Power Query может существовать шаг вида:
     ```m
     Source = MySQL.Database("servername", "dbname"),
     oldTable = Source{[Name="old_table"]}[Data],
     ```
     Пока вы не замените `old_table` на `new_table`, отчёт продолжит забирать данные именно из старой таблицы.

4. **Новая таблица в другой схеме**  
   - Если MySQL-администратор создал `new_schema.new_table`, а раньше всё лежало в `old_schema.old_table`, Power BI по-прежнему подключается к `old_schema`. Отсюда — несоответствие.

---

## 4. Как понять, что проблема именно в «новой таблице, о которой Power BI не знает»

1. **Сравнение запросов**  
   - В MySQL проверить: `SELECT COUNT(*) FROM old_table;` и `SELECT COUNT(*) FROM new_table;`. Если второй запрос возвращает гораздо больше (или новые) строки, а первый стоит на месте, значит данные ушли в новую таблицу.  
   - В Power Query (или в логе Power BI) посмотреть, какой SQL-запрос генерируется. Если там фигурирует `FROM old_table`, ясно, что отчёт смотрит «не туда».

2. **Проверка структуры/названий**  
   - В «Model» (Power BI) или в редакторе Power Query посмотреть: как называется источник, какие столбцы тянутся. Если нет упоминания о `new_table`, значит отчёт не использует её.

3. **Отсутствие ошибок, но устаревший результат**  
   - Если в Power BI нет явных ошибок, а данные не меняются, весьма вероятно, что нужные записи лежат в новой таблице, которую отчёт даже не знает.  
   - Если старую таблицу не удаляли, Power BI по-прежнему видит «старые» данные, и всё проходит технически без ошибок.

---

## 5. Рекомендации по решению

1. **Обновить запросы Power Query**  
   - Открыть «Transform data» (Редактор Power Query) и изменить источник: либо **добавить новую таблицу** («New Source» → MySQL → выбрать `new_table`), либо **исправить** существующий запрос, чтобы он указывал на новую таблицу.  
   - Убедиться, что все шаги трансформации (Select Columns, Changed Type, Merge Queries и т. п.) корректно применяются к новой структуре.

2. **Удалить/отключить старые запросы**, если они больше не нужны  
   - Если `old_table` не используется, лучше удалить её из Power Query, чтобы не путать пользователя и не приводить к избыточным обновлениям.

3. **Проверить связи (Relationships)**  
   - Если отчёт опирался на старую таблицу как на факт или измерение, нужно перенастроить или воссоздать связи для новой таблицы. Иначе новые записи не будут «стыковаться» с остальными таблицами.

4. **Проверить типы данных и новые столбцы**  
   - Убедиться, что в новой таблице поля имеют правильные типы (текст, число, дата) и в Power BI также определяются корректно.  
   - Если в старой таблице были одни столбцы, а в новой — немного другая структура, возможно, придётся адаптировать логику (измерения, меры и пр.).

5. **Переопубликовать отчёт**  
   - После внесения изменений в Desktop (и успешного локального обновления) обязательно нажать «Publish», чтобы в сервисе Power BI тоже заработала новая таблица.

---

## 6. Итог

Когда в MySQL **добавляют новые таблицы** (или переносят туда актуальные данные), а **модель Power BI** остаётся привязанной к **старым** таблицам, возникает ситуация, что **новые записи** фактически не загружаются в отчёт. Визуально кажется, что «ничего не обновляется», хотя в базе на самом деле всё меняется.

Чтобы решить проблему, нужно:

1. **Явно указать** в Power Query/Power BI, что теперь данные берутся из **новой** таблицы (или View).  
2. **Обновить связи** и шаги трансформации (M-код), если структура поменялась.  
3. **Проверить** (при необходимости) настройки расписания обновлений (Gateway) и типы данных.  

Только после этого **Power BI** начнёт подтягивать **новые записи** из вновь созданной или перенесённой таблицы.
~~~

## 44. Мой ответ клиенту
Я хочу ответить клиенту так:
~~~
Наверняка источником вашей проблемы является изменении схемы данных MySQL, например:
1) Если в MySQL в таблице появилось новое поле, а в Power Query оно не добавлено в список выбираемых полей, то при обновлении отчёта значения этого поля не попадут в модель. 
2) Если в MySQL поле таблицы было переименовано или удалёно, а в Query Editor (M-коде) Power BI по-прежнему есть ссылка на прежнее имя, весь процесс обновления отчёта может прерываться, и новые данные не будут загружены.
3) Иногда Power Query тихо пропускает шаги, где не может найти удалённый столбец, в зависимости от настроек. 
4) Возможно, после изменения структуры таблиц в MySQL некоторые столбцы получили другие типы данных.
Например, если в MySQL поле, выступающее ключом, хранится как `VARCHAR`, а в Power BI оно импортируется как числовое (или наоборот), при сопоставлении значений (фильтрации, связях) часть новых строк может игнорироваться.  
5) Возможно, новый столбец в MySQL является ключевым для связи между таблицами, но в модели Power BI связи по-прежнему выстроены по старому полю. 
В этом случае а диспетчере связей (Manage Relationships) в Power BI связь может стать неактивной или оказаться помеченной ошибкой.  
6) Если Power BI воспринимает какое-то поле как ключ, но в реальности в MySQL теперь это поле содержит дубли, связь в Power BI рушится или становится неоднозначной.  
7) Несогласованность реляционных данных между связаными таблицами (изоляция данных): например, вставили новую строку в факт «Продажи», но в справочнике «Товары» отсутствует соответствующая запись о товаре или ключ (ProductID).  
Power BI, при сборке модели и связей, не находит нужной записи в измерении, а значит, фактическая строка остаётся одинокой и может не отображаться в отчёте (особенно если включены связи «один-ко-многим» или фильтрация «Both»).
8) Циклические (замкнутые) связи.  
Power BI не разрешает прямые циклы в отношениях, однако при наличии двусторонней фильтрации квазицикл может возникать через несколько промежуточных таблиц.  
В результате фильтры самопроизвольно пересекаются, и часть строк (включая новые) могут отбрасываться, когда вы выбираете что-то в другом срезе.
~~~

## 45. Твоя задача
Есть ли в моём ответе фактические ошибки?
Есть ли в моём ответе логические ошибки?
Упустил ли я в ответе нечто важное?

