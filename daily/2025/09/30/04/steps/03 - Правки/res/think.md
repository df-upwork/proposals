1. Пункт 3.1.2.1 изложить в следующей редакции:
3.1.2.1) Альтернативно, если конфигурация PHP использует внешние обработчики сессий (PHP ini setting `session.save_handler = redis` или `memcached`), основная проблема заключается в Race Conditions, когда Session Locking отключен или неэффективен.

2. Пункт 3.3.2 изложить в следующей редакции:
3.3.2) Это действие подразумевает, что либо используется стандартный обработчик `session.save_handler = files` (Сценарий 3.1.1), либо вы предполагали, что он используется.

3. Пункт 3.3.3 изложить в следующей редакции:
3.3.3) В то же время, в тегах проекта указаны Redis и Memcached.

4. Добавить пункты 3.3.3.1, 3.3.3.2, 3.3.3.3 и 3.3.3.4:
3.3.3.1) В экосистеме WordPress эти технологии могут использоваться как для WordPress Object Caching (Причина #2), так и в качестве обработчика для PHP Native Sessions (Сценарий 3.1.2).
3.3.3.2) Важно отметить, что конфигурация WordPress Object Caching полностью независима от конфигурации обработчика PHP Native Sessions (PHP ini setting `session.save_handler`).
3.3.3.3) Распространена конфигурация, когда Redis/Memcached используются для Object Caching, в то время как PHP Native Sessions одновременно используют стандартный обработчик `files`.
3.3.3.4) Учитывая ваши действия по очистке `/tmp` (пункт 3.3.1), наиболее вероятно, что ваша система использует `session.save_handler = files`.

5. Пункт 3.3.12 изложить в следующей редакции:
3.3.12) Проблемы с производительностью и задержки, вызванные PHP Session Locking (Сценарий 3.1.1), приводят к Resource Contention и могут вызывать таймауты (Timeouts) на уровне веб-сервера или PHP-FPM во время высокой нагрузки.