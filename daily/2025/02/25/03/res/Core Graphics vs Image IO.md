Ниже приведена сравнительная таблица основных аспектов **масштабирования изображений** (image resizing) в **Core Graphics (Quartz)** и **Image I/O**.

| **Критерий**                                                        | **Core Graphics (Quartz)**                                                                                                                                                                                                                                                                                                           | **Image I/O**                                                                                                                                                                                                                                                                                                                               |
|:--------------------------------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Уровень/Назначение**                                              | • **Низкоуровневый** фреймворк для 2D-графики: рисование, композиция, отрисовка PDF и т. д.<br/>• Управление масштабированием осуществляется в момент прорисовки (drawing) через `CGContextDrawImage` и настройку качества интерполяции.                                                                                              | • **Низкоуровневый** фреймворк для **чтения и записи** (декодирования/кодирования) изображений в различных форматах (JPEG, PNG, TIFF и т. д.).<br/>• Может создавать **миниатюры** (thumbnails) или выполнять частичный даунсемплинг уже **на этапе декодирования**, что позволяет экономить память и ускорять загрузку крупных изображений. |
| **Основной механизм масштабирования**                               | • При рисовании в `CGContext` задаём `CGInterpolationQuality` (None, Low, Medium, High), которая влияет на способ интерполяции (Nearest Neighbor, Bilinear, Bicubic/Lanczos и т. д. — точный алгоритм «под капотом» может меняться).<br/>• Масштабирование идёт путём «ручной» перерисовки исходного `CGImage` с новым размером.         | • **Частичное декодирование** (даунсемплинг) при создании миниатюр: `CGImageSourceCreateThumbnailAtIndex` с ключами `kCGImageSourceThumbnailMaxPixelSize`, `kCGImageSourceCreateThumbnailFromImageIfLarge` и т. п.<br/>• **Нет** прямого выбора «Bilinear», «Bicubic» и т. д.; алгоритм ресемплинга (усреднение, skip-блоки) скрыт внутри декодера. |
| **Выбор конкретного алгоритма интерполяции**                        | • **Ограниченный** явный выбор: всего 4 уровня качества (`kCGInterpolationNone`, `kCGInterpolationLow`, `kCGInterpolationMedium`, `kCGInterpolationHigh`).<br/>• При `High` обычно используется что-то близкое к Bicubic или Lanczos, но Apple не даёт гарантии, что это всегда тот же самый фильтр во всех версиях macOS.              | • **Нет** прямого API для установки «Bicubic», «Nearest» и т. п.; при генерации миниатюр используется внутренний механизм уменьшения (включая аппаратно ускоренное декодирование).<br/>• Если нужно «точное» масштабирование (Bicubic, Lanczos и др.), обычно сначала декодируют полное изображение, а уже потом масштабируют в Core Graphics/Core Image.                                            |
| **Типичные сценарии**                                               | • Рисование интерфейсов и графических объектов в CGContext, экспорт в PDF, работу с оффскрин-контекстами. Масштабирование — одна из базовых операций (наряду с трансформациями, рендером текста и т. д.).<br/>• Часто используется в приложениях, где нужно **быстро** изменить размер при выводе на экран или сохранении.          | • Эффективное чтение больших файлов, где **не нужен** полный размер (миниатюры, превью).<br/>• Сценарии, когда «пересчитывать» картинку под конкретное разрешение дорого, а хочется «из коробки» считать её уже уменьшенной.<br/>• Предварительное уменьшение перед передачей изображения в Core Graphics или Core Image.                                   |
| **Производительность**                                              | • Традиционно **CPU-ориентирован** (хотя на современных macOS часть операций может использовать GPU-ускорение).<br/>• При масштабировании больших изображений может проигрывать Core Image (которая активнее использует GPU).<br/>• Для простых задач/малых изображений — быстрый и удобный.                                              | • **Оптимизирован под декодирование**; при работе с JPEG/HEIF и т. п. может использовать аппаратное ускорение (особенно на iOS или Apple Silicon).<br/>• «Масштабирование» в Image I/O фактически происходит за счёт неполного чтения или пропуска DCT-блоков, что может быть существенно эффективнее полноценной загрузки всех пикселей.                                          |
| **Настройка цвета/метаданных**                                      | • Интегрирован с ColorSync (цветопрофили) и может работать в связке с Image I/O для чтения/записи метаданных.                                                                                                                                                                                                                         | • Поддерживает множество форматов (JPEG, PNG, GIF, HEIF, RAW и т. д.), чтение/запись EXIF, IPTC, XMP метаданных.<br/>• Может применять `kCGImageSourceCreateThumbnailWithTransform`, учитывая EXIF-ориентацию, для «правильной» миниатюры.                                                                                           |
| **Гибкость и расширяемость**                                        | • Управление «качеством» через один enum; нет тонкого выбора (например, чётко указать «Nearest»).<br/>• Для более сложных методов (кастомные фильтры, суперразрешение и т. д.) нужно уже идти в Core Image или сторонние фреймворки.                                                                                                  | • «Ресайз» фактически ограничен даунсемплингом в момент чтения (увеличение не предусмотрено).<br/>• Если нужно дальше как-то обрабатывать или применять другие фильтры, обычно переходят к Core Graphics / Core Image после декодирования.                                                                                                  |
| **Пример кода (упрощённый)**                                        | **Core Graphics (Swift-псевдокод)**:<br/>```swift\nlet context = CGContext(...)\ncontext.interpolationQuality = .high\nlet rect = CGRect(x: 0, y: 0, width: newWidth, height: newHeight)\ncontext.draw(cgImage, in: rect)\n```                                                                                                          | **Image I/O (Swift-псевдокод)**:<br/>```swift\nlet options: [CFString: Any] = [\n    kCGImageSourceCreateThumbnailFromImageIfLarge: true,\n    kCGImageSourceThumbnailMaxPixelSize: 600\n]\nif let thumbnail = CGImageSourceCreateThumbnailAtIndex(imgSource, 0, options as CFDictionary) {\n    // готовая миниатюра\n}\n```                           |

### Ключевые отличия

1. **Способ масштабирования**  
   - **Core Graphics (Quartz)**: указываем «качество интерполяции» и «рисуем» картинку в нужном размере.  
   - **Image I/O**: даунсемплирует при **декодировании** (создаёт миниатюру), без явной настройки конкретного фильтра.

2. **Контроль над алгоритмом**  
   - **Core Graphics** даёт *ограниченный* выбор (`None/Low/Medium/High`), но всё же можно примерно понимать, какой метод интерполяции включится.  
   - **Image I/O** вообще не даёт выбирать, какая именно интерполяция будет использована (может использовать аппаратное «неполное чтение» для JPEG).

3. **Сценарии**  
   - **Core Graphics**: «классический» API для рисования, удобен, если вам нужно отрендерить (и при этом масштабировать) изображение в CGContext.  
   - **Image I/O**: удобен, чтобы *сразу* получать уменьшенные копии изображений без полного декодирования, экономя время и память.  

Таким образом, в контексте «image resizing techniques» главное отличие в том, что **Core Graphics** позволяет прямо «в коде рисовать» с определённой интерполяцией, а **Image I/O** фокусируется на **чтении/записи** с возможным автоматическим уменьшением (даунсемплингом) без точной настройки метода ресемплинга.