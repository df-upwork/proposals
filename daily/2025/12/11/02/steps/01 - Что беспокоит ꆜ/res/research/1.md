https://gemini.google.com/share/96de85baae13

## **1. Введение и архитектурный контекст инцидента**

В современном ландшафте корпоративной ИТ-инфраструктуры наблюдается фундаментальный конфликт между требованиями безопасности на уровне приложений и унаследованными конфигурациями сетевого периметра. Представленный для анализа инцидент, инициированный клиентом ꆜ (далее — Клиент), является хрестоматийным примером этого конфликта. Проблема проявляется в невозможности выполнения аутентификации через интерфейс командной строки Microsoft Azure (Azure CLI) в операционной системе Windows, функционирующей за корпоративным прокси-сервером с активной функцией SSL/TLS-инспекции (Man-in-the-Middle, MITM).

Ситуация возникла вследствие обновления Azure CLI до версии, использующей среду выполнения Python 3.13. Данное обновление привнесло радикальные изменения в политику верификации сертификатов X.509, сделав ее строго соответствующей стандартам RFC 5280. Это, в свою очередь, выявило скрытые архитектурные несоответствия в сертификатах, генерируемых корпоративным оборудованием безопасности (предположительно Zscaler или Palo Alto Networks). Клиент столкнулся с блокирующей ошибкой ``, указывающей на отсутствие критически важного расширения Key Usage в сертификате удостоверяющего центра (CA) прокси-сервера.

Настоящий отчет ставит своей целью не только диагностику конкретной ошибки, но и всесторонний анализ экосистемы, в которой она возникла. Мы рассмотрим эволюцию стандартов безопасности Python, деконструируем механику работы корпоративных прокси и предложим многоуровневую стратегию решения, соответствующую высоким требованиям Клиента к безопасности. Важность данного анализа подкрепляется профилем Клиента, который является опытным заказчиком на платформе Upwork с бюджетом более 350 тысяч долларов, специализирующимся на сложных облачных архитектурах (AKS, Azure Sentinel, Cosmos DB), что исключает возможность применения тривиальных или небезопасных решений.

## **2. Декомпозиция и идентификация проблемного поля (P†)**

Анализ предоставленного описания задачи (PD) в совокупности с контекстом деятельности Клиента (O.md) позволяет выделить комплекс взаимосвязанных проблем. Это не изолированный сбой, а системная проблема, затрагивающая несколько уровней стека технологий: от спецификаций IETF до реализации CPython и конфигурации сетевых шлюзов.

### **2.1. Критический сбой аутентификации в Azure CLI (P1†)**

Первичной проблемой является полная потеря работоспособности инструмента управления облачной инфраструктурой. Команда az login, являющаяся входной точкой для любых административных действий в Azure, завершается фатальной ошибкой на этапе установления защищенного канала связи.

Ошибка сформулирована как:  
certificate verify failed: CA cert does not include key usage extension (_ssl.c:1028).1  
Этот сбой парализует рабочие процессы Клиента. Учитывая, что Клиент активно занимается проектами, связанными с Azure Kubernetes Service (AKS), Azure DevOps и Azure Policy (P3⁎, P4⁎, P11⁎), невозможность использования CLI блокирует развертывание ресурсов, обновление политик безопасности и управление CI/CD пайплайнами. В контексте почасовой оплаты и жестких дедлайнов на фриланс-бирже, такой простой несет прямые финансовые и репутационные риски.

### **2.2. Несоответствие инфраструктуры PKI стандартам RFC 5280**

Вторая, более глубокая проблема — это выявленное несоответствие корпоративной инфраструктуры открытых ключей (PKI) современным стандартам интернета. Сообщение об ошибке явно указывает на то, что сертификат, используемый прокси-сервером для подписи перехваченного трафика, не содержит расширения Key Usage или специфического флага keyCertSign.1

Это свидетельствует о том, что конфигурация прокси-сервера (Zscaler, Palo Alto и др.) базируется на устаревших практиках генерации сертификатов. Ранее (в Python 3.12 и ниже, а также в старых версиях OpenSSL) такие сертификаты принимались как доверенные, если они просто находились в хранилище доверенных корневых центров. Теперь же валидатор требует структурной корректности сертификата. Это ставит Клиента в ситуацию, когда его локальная сетевая среда технически несовместима с современным инструменарием разработчика, требующим строгого соблюдения RFC.

### **2.3. Неэффективность стандартных механизмов управления доверием**

Третья проблема заключается в том, что привычные рычаги управления конфигурацией SSL в Python перестали работать ожидаемым образом. Клиент предпринял стандартные шаги, описанные в документации Azure и Python:

1. Экспорт корневого сертификата прокси.  
2. Добавление его в файл cacert.pem.  
3. Настройка переменных окружения SSL_CERT_FILE и REQUESTS_CA_BUNDLE.

Однако ошибка сохраняется. Это порождает когнитивный диссонанс и неопределенность: инструменты настройки среды, которые работали годами, в Python 3.13 либо игнорируются, либо работают иначе.4 Клиент подозревает, и анализ подтверждает, что проблема лежит глубже уровня простого наличия сертификата в файле — она в самой структуре сертификата, которую переменные окружения исправить не могут.

### **2.4. Принципиальная недопустимость снижения уровня безопасности**

Четвертая проблема — это ограничение пространства решений. Клиент явно указывает: Goal: Get az login working without disabling verification (insecure workaround). Это требование отсекает самое простое решение — использование флага --insecure или установку AZURE_CLI_DISABLE_CONNECTION_VERIFICATION=1.

Для корпоративного сектора, особенно в проектах, связанных с финансовыми документами (P5⁎: "financial document processing") и безопасностью (P9⁎: "Security Group Usage audit"), отключение проверки SSL недопустимо, так как это открывает вектор атаки для реального перехвата данных злоумышленниками внутри сети или компрометации учетных данных администратора Azure. Клиент осознает риски и требует "secure fixes like using system cert store".

## **3. Глубинный анализ обоснованности выявленных проблем**

В данном разделе мы проведем детальную техническую экспертизу каждой выявленной проблемы, опираясь на изменения в экосистеме Python, спецификации OpenSSL и стандарты IETF. Мы докажем, что проблемы Клиента абсолютно обоснованы и являются следствием глобального тренда на ужесточение безопасности в Open Source сообществе.

### **3.1. Эволюция SSL-контекста в Python 3.13: Сдвиг парадигмы**

Чтобы понять, почему Azure CLI внезапно перестал работать, необходимо проанализировать изменения в языке программирования Python, на котором он написан. Версия Python 3.13 внесла одно из самых значительных изменений в модуль ssl за последние годы.

#### **3.1.1. Внедрение флага VERIFY_X509_STRICT**

До версии 3.13 функция ssl.create_default_context(), которая используется большинством библиотек (включая urllib3 и requests, лежащие в основе Azure CLI Azure SDK), инициализировала контекст OpenSSL с набором флагов, обеспечивающим баланс между безопасностью и совместимостью. Однако в Python 3.13 разработчики CPython приняли решение активировать флаг VERIFY_X509_STRICT по умолчанию.5

Этот флаг передается непосредственно в нативную библиотеку OpenSSL (в функцию X509_VERIFY_PARAM_set_flags). Его назначение — отключить все "обходные пути" (workarounds), которые OpenSSL исторически использовал для поддержки некорректно сформированных, но широко распространенных сертификатов.

| Параметр | Python 3.12 (и ниже) | Python 3.13 | Влияние |
| :---- | :---- | :---- | :---- |
| **VERIFY_X509_STRICT** | Отключен | **Включен** | Принудительная проверка на соответствие RFC 5280. Отказ в обслуживании при малейшем нарушении структуры сертификата. |
| **VERIFY_X509_PARTIAL_CHAIN** | Отключен | **Включен** | Позволяет доверять цепочке, если в доверенном хранилище найден промежуточный сертификат (полезно, но не решает проблему структуры). |
| **Базовая библиотека** | OpenSSL 1.1.1 / 3.0 | OpenSSL 3.0+ | Новые версии OpenSSL сами по себе строже относятся к проверкам. |

Активация VERIFY_X509_STRICT означает, что теперь интерпретатор Python не прощает ошибок, которые ранее игнорировались. Это делает проблему Клиента не локальным сбоем настройки, а системной несовместимостью его сетевого окружения с новой средой выполнения.7

#### **3.1.2. Механизм проверки Key Usage в OpenSSL**

При включенном строгом режиме OpenSSL выполняет проверку расширений сертификата согласно RFC 5280. Одной из таких проверок является валидация назначения ключа (Key Usage).

Если сертификат используется для подписи другого сертификата (что и делает CA прокси-сервера, подписывая фейковый сертификат для management.azure.com), он **должен** иметь:

1. Расширение Basic Constraints с флагом CA:TRUE.  
2. Расширение Key Usage с установленным битом keyCertSign (бит №5).

Ошибка CA cert does not include key usage extension генерируется внутри кода OpenSSL (файл x509_vfy.c), когда валидатор видит, что сертификат выступает в роли эмитента (Issuer), но не имеет явного разрешения на это действие в виде расширения Key Usage.9

Ранее OpenSSL мог "предположить", что если сертификат находится в доверенном хранилище и выглядит как CA, то ему можно доверять подпись, даже если расширение отсутствует. В строгом режиме такие предположения запрещены. Это подтверждает обоснованность наблюдений Клиента: проблема именно в "strict certificate validation in Python 3.13".

### **3.2. Архитектура SSL-инспекции и дефицит конфигурации PKI**

Для полного понимания проблемы необходимо рассмотреть, как работают корпоративные прокси-серверы, такие как Zscaler, и почему их сертификаты часто оказываются "дефектными".

#### **3.2.1. Механика перехвата (MITM)**

В корпоративной сети Клиента трафик не идет напрямую к серверам Microsoft.

1. **Запрос:** Azure CLI инициирует TLS Handshake к login.microsoftonline.com.  
2. **Перехват:** Прокси-сервер перехватывает Client Hello.  
3. **Имитация:** Прокси создает новое соединение с реальным сервером Microsoft, проверяет его сертификат.  
4. **Генерация:** Прокси динамически генерирует поддельный сертификат для login.microsoftonline.com.  
5. **Подпись:** Этот поддельный сертификат подписывается закрытым ключом *промежуточного CA* прокси-сервера (Zscaler Intermediate CA), который установлен на шлюзе.  
6. **Ответ:** Прокси отдает этот сертификат клиенту Azure CLI.

Для того чтобы Azure CLI доверял этому поддельному сертификату, корневой сертификат (Zscaler Root CA), который подписал промежуточный CA, должен быть в доверенном хранилище клиента (cacert.pem).

#### **3.2.2. Анатомия ошибки "Missing Key Usage"**

Проблема возникает на шаге проверки цепочки сертификатов. Azure CLI получает сертификат для login.microsoftonline.com, видит, что он подписан Zscaler Intermediate CA. Затем он проверяет Zscaler Intermediate CA.

В строгом режиме Python 3.13 задает вопрос: "Имеет ли этот Zscaler Intermediate CA право подписывать сертификаты?". Ответ на этот вопрос должен содержаться в расширении Key Usage.

Многие администраторы при настройке Zscaler или генерации CSR (запроса на подпись сертификата) для внутреннего CA используют устаревшие шаблоны или настройки по умолчанию, которые могут опускать расширение Key Usage, полагаясь на устаревшие поля (например, Netscape Cert Type) или просто на факт подписи.

Согласно источникам, в старых версиях OpenSSL и в браузерах это поведение допускалось. Однако RFC 5280, раздел 4.2.1.3, гласит:

"Conforming CAs MUST include this extension in all CA certificates that contain public keys used to validate digital signatures on certificates...".3

Таким образом, инфраструктура Клиента (прокси Zscaler) генерирует сертификаты, которые технически нарушают стандарт IETF. До Python 3.13 это нарушение оставалось незамеченным. Теперь оно стало блокирующим. Это подтверждает гипотезу Клиента: "it lacks required extensions like keyCertSign in Key Usage".1

### **3.3. Анализ неэффективности переменных окружения**

Клиент справедливо недоумевает, почему не сработали SSL_CERT_FILE и REQUESTS_CA_BUNDLE.

В экосистеме Python библиотека requests (используемая Azure CLI) использует пакет certifi как хранилище доверенных сертификатов по умолчанию. Переменная REQUESTS_CA_BUNDLE переопределяет путь к этому файлу.  
Переменная SSL_CERT_FILE является нативной переменной OpenSSL, указывающей на файл с доверенными сертификатами.  
В Python 3.13, даже если Клиент корректно указал путь к cacert.pem, содержащему корневой сертификат Zscaler, происходит следующее:

1. Python успешно загружает cacert.pem.  
2. Он строит цепочку доверия от сертификата сайта до корневого сертификата Zscaler.  
3. **Но:** В процессе валидации этой цепочки включается флаг VERIFY_X509_STRICT.  
4. Валидатор обнаруживает отсутствие Key Usage в одном из сертификатов цепочки (обычно в промежуточном).  
5. Валидация проваливается, несмотря на то, что сертификат "доверенный" (находится в бандле).

То есть, проблема не в *доверии* (trust), а в *соответствии стандарту* (compliance). Добавление дефектного сертификата в список доверенных не делает его корректным с точки зрения RFC 5280. Именно поэтому действия Клиента по обновлению cacert.pem не принесли результата, что делает проблему особенно сложной для диагностики обычными средствами.4

### **3.4. Влияние на бизнес-процессы и профиль Клиента**

Анализ профиля Клиента (O.md) показывает, что он является индивидуальным специалистом высокого уровня, работающим с enterprise-технологиями. Проекты P1⁎ — P18⁎ охватывают весь спектр Azure: от настройки сетей (Firewall, VPN) до DevOps и AI.

* **Azure DevOps (P4⁎, P13⁎):** Использование CI/CD пайплайнов подразумевает автоматизированные скрипты, часто использующие Azure CLI. Сбой az login означает остановку всех автоматизированных деплоев.  
* **Безопасность (P3⁎, P9⁎):** Клиент занимается аудитом безопасности и политиками. Использование небезопасных обходных путей (verify=False) дискредитирует саму суть его работы. Он не может предложить конечному заказчику (например, банку или медицинской организации) решение с отключенной проверкой SSL.  
* **Сложность среды:** Упоминание Palo Alto 11 и Zscaler 12 указывает на работу в жестко регулируемых корпоративных сетях, где изменения инфраструктуры (например, замена сертификата на прокси) требуют длительных согласований.

Следовательно, проблема Клиента не только технически обоснована, но и критична для его профессиональной деятельности. Ему требуется решение, которое можно применить "здесь и сейчас" на стороне клиента (Python/CLI), но которое при этом сохранит криптографическую стойкость соединения.

## **4. Стратегии решения: От тактических исправлений до стратегической перестройки**

На основе проведенного анализа мы предлагаем три стратегии решения проблемы. Они ранжированы от наиболее правильной с точки зрения архитектуры (но сложной в реализации) до наиболее быстрой и прагматичной.

### **4.1. Стратегия А: Фундаментальное исправление инфраструктуры (Infrastructure Remediation)**

Это единственное решение, устраняющее первопричину — некорректность сертификатов. Оно требует вмешательства администраторов безопасности организации, управляющей прокси-сервером.

#### **4.1.1. Диагностика сертификата**

Первым шагом Клиент должен подтвердить диагноз, извлекая и анализируя сертификат.  
Используя команду openssl:

Bash

openssl x509 -in zscaler_intermediate.crt -text -noout

Необходимо проверить секцию X509v3 extensions. В корректном сертификате CA должны присутствовать:

1. **Basic Constraints:** CA:TRUE (желательно critical).  
2. **Key Usage:** Certificate Sign, CRL Sign (обязательно critical).3

Если секция Key Usage отсутствует или в ней нет флага Certificate Sign, сертификат необходимо перевыпустить.

#### **4.1.2. Процедура перевыпуска (Zscaler/Palo Alto)**

Администратор прокси-шлюза должен выполнить следующие действия:

1. Сгенерировать новый CSR (Certificate Signing Request) для промежуточного CA.  
2. При подписании этого CSR корневым центром сертификации (например, Microsoft Active Directory Certificate Services или внутренним OpenSSL CA) необходимо **явно** включить расширения KeyUsage.  
   * В конфигурации OpenSSL (openssl.cnf) это выглядит так:  
     Ini, TOML  
     [ v3_ca ]  
     basicConstraints = critical,CA:true  
     keyUsage = critical, keyCertSign, cRLSign

3. Импортировать новый подписанный сертификат обратно в Zscaler/Palo Alto как "Intermediate CA for SSL Inspection".14  
4. Распространить (если изменился) новый корневой или промежуточный сертификат на рабочие станции.

**Оценка:** Это идеальное решение, полностью соответствующее RFC 5280. Однако для фрилансера (ꆜ) это может быть недостижимо, если у него нет прямого доступа к администрированию шлюзов безопасности компании-заказчика.

### **4.2. Стратегия B: Использование системного хранилища сертификатов (Tactical Solution)**

Это наиболее рекомендуемое решение для Клиента, так как оно позволяет решить проблему локально, не снижая уровень безопасности и не требуя прав администратора домена.

#### **4.2.1. Концепция решения**

По умолчанию Python (и requests) использует библиотеку OpenSSL и файл certifi (текстовый файл с сертификатами). OpenSSL в Python 3.13 настроен строго.  
Однако операционная система Windows имеет собственный механизм проверки сертификатов (CryptoAPI / Schannel), который использует системное хранилище сертификатов (Windows Certificate Store). Реализация проверки в Windows может быть (и часто является) более гибкой в отношении старых корпоративных сертификатов, либо политики GPO могут явно разрешать определенные отклонения для доверенных внутренних CA.

#### **4.2.2. Пакет pip-system-certs**

Пакет pip-system-certs 16 — это инструмент, который "на лету" патчит библиотеки requests и urllib3 в среде Python, заставляя их использовать системное хранилище сертификатов Windows вместо встроенного механизма OpenSSL/certifi.

**Преимущества:**

* **Безопасность:** Проверка SSL *не отключается*. Она просто делегируется операционной системе, которой управляют корпоративные администраторы. Если сертификат доверен Windows, он будет доверен Python.  
* **Простота:** Не нужно возиться с PEM файлами и переменными окружения.  
* **Обход строгости:** Windows CryptoAPI может не применять флаг VERIFY_X509_STRICT в том же виде, что и OpenSSL 3.0, позволяя работать с сертификатами без Key Usage, если они находятся в Trusted Root.

#### **4.2.3. Инструкция по внедрению**

Поскольку Azure CLI содержит свою собственную встроенную среду Python, пакет нужно установить именно туда.

1. Определить путь к Python, используемому Azure CLI. Обычно это:  
   C:Program Files (x86)Microsoft SDKsAzureCLI2python.exe (для 32-bit)  
   или C:Program FilesMicrosoft SDKsAzureCLI2python.exe (для 64-bit).2  
2. Запустить командную строку (PowerShell) от имени администратора.  
3. Выполнить установку пакета:  
   PowerShell  
   & "C:Program FilesMicrosoft SDKsAzureCLI2python.exe" -m pip install pip-system-certs

4. После установки Azure CLI автоматически начнет использовать системные сертификаты. Команда az login должна заработать, так как она будет "видеть" корпоративный CA через системный API.

**Важно:** Это решение работает, потому что pip-system-certs перехватывает вызовы создания SSL-контекста и внедряет свою логику валидации до того, как сработает дефолтный строгий контекст Python 3.13.4

### **4.3. Стратегия C: Даунгрейд версии Azure CLI (Temporary Workaround)**

Если Стратегия B не сработала или недопустима по политикам (запрет на установку сторонних пакетов), остается вариант отката.

* **Действие:** Удалить текущую версию Azure CLI и установить версию **2.76.0** или ниже.  
* **Обоснование:** Версия 2.76.0 использует Python 3.11 или 3.12 (в зависимости от сборки), где флаг VERIFY_X509_STRICT по умолчанию выключен. Это немедленно устранит ошибку CERTIFICATE_VERIFY_FAILED.19  
* **Недостатки:** Это временная мера. Рано или поздно обновление потребуется. Кроме того, старые версии могут содержать уязвимости.

## **5. Детальный обзор затронутых технологий и стандартов**

Для обеспечения полноты отчета и демонстрации экспертного понимания, ниже приведены справочные данные по ключевым компонентам инцидента.

### **5.1. Сравнительный анализ версий Python и SSL**

| Характеристика | Python 3.12 и ранее | Python 3.13 |
| :---- | :---- | :---- |
| **OpenSSL версия** | 1.1.1 или 3.0 (зависит от ОС) | **3.0+** (как правило) |
| **SSLContext.verify_flags** | По умолчанию 0 (стандартная проверка) | **VERIFY_X509_STRICT | VERIFY_X509_PARTIAL_CHAIN** |
| **Обработка Key Usage** | Игнорируется или предупреждение | **Строгая проверка (Fatal Error)** |
| **Реакция на SSL_CERT_FILE** | Стандартная обработка | Изменена логика загрузки контекста (потенциальные проблемы совместимости) |

Как видно из таблицы, переход на Python 3.13 — это не просто смена цифры версии, а смена парадигмы безопасности.5

### **5.2. Роль IETF RFC 5280 в современной криптографии**

Стандарт RFC 5280 "Internet X.509 Public Key Infrastructure Certificate and CRL Profile" является "конституцией" для PKI.  
Раздел 4.2.1.3 четко определяет:

* KeyUsage — это ограничение полномочий ключа.  
* Если бит keyCertSign не установлен, субъект **не имеет права** подписывать сертификаты.

Раньше многие системы игнорировали это правило ради совместимости ("Postel's Law": be liberal in what you accept). Теперь, в эпоху Zero Trust и повышенных требований к кибербезопасности, разработчики библиотек (OpenSSL, Python) переходят к строгому следованию стандартам ("Secure by Default"). Инцидент Клиента — прямое следствие этого глобального перехода.3

## **6. Заключение**

Ситуация, с которой столкнулся Клиент ꆜ, является показательным примером "технологического землетрясения", когда изменения в базовых библиотеках безопасности (Python/OpenSSL) делают неработоспособной устаревшую, но привычную корпоративную инфраструктуру.

1. **Проблема валидна:** Ошибка `` вызвана не багом в Azure CLI, а объективным несоответствием сертификатов прокси-сервера стандартам RFC 5280, соблюдение которых стало обязательным в Python 3.13.  
2. **Инфраструктурный долг:** Корневая причина — отсутствие расширения Key Usage: keyCertSign в сертификатах, генерируемых системами SSL-инспекции (Zscaler/Palo Alto).  
3. **Решение:**  
   * Наиболее **правильным** решением является переконфигурация прокси-серверов для выдачи валидных сертификатов (Стратегия А).  
   * Наиболее **эффективным** для Клиента решением является использование пакета pip-system-certs для интеграции Azure CLI с хранилищем сертификатов Windows, что позволяет обойти строгость OpenSSL, сохраняя безопасность проверки (Стратегия B).  
   * Откат версии Azure CLI до 2.76.0 является допустимой временной мерой (Стратегия C).

Клиенту рекомендуется начать с применения **Стратегии B** (pip install pip-system-certs в среду CLI), так как это позволяет немедленно разблокировать работу над проектами, не дожидаясь реакции корпоративного ИТ-отдела, и при этом полностью соответствует требованию "Get az login working without disabling verification".

## **7. Приложение: Технические детали реализации патча pip-system-certs**

Для технически подкованного Клиента полезно понимать, как именно работает предлагаемое решение.  
Пакет pip-system-certs использует механизм .pth файлов для автоматической загрузки при старте интерпретатора Python. Он находит экземпляры классов, отвечающих за SSL-соединения в популярных библиотеках (requests.adapters.HTTPAdapter), и подменяет метод init_poolmanager.  
Вместо создания стандартного ssl.SSLContext (который в Python 3.13 стал строгим), он создает контекст, который использует wincertstore для получения корневых сертификатов. При валидации сертификата сервера, если OpenSSL выдает ошибку, библиотека может запросить подтверждение у Windows API (CertVerifyCertificateChainPolicy). Если Windows доверяет сертификату (например, потому что он был распространен через Group Policy), соединение разрешается. Это элегантный способ разрешить конфликт между "строгим" Python и "реальным" корпоративным миром Windows.16

#### **Works cited**

1. root CA certificate does not include key usage extension · Issue #4864 · canonical/microk8s, accessed December 11, 2025, [https://github.com/canonical/microk8s/issues/4864](https://github.com/canonical/microk8s/issues/4864)  
2. 2.77.0 raises error: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: Missing Authority Key Identifier (_ssl.c:1032) · Issue #32083 · Azure/azure-cli - GitHub, accessed December 11, 2025, [https://github.com/Azure/azure-cli/issues/32083](https://github.com/Azure/azure-cli/issues/32083)  
3. RFC 5280 - Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile - IETF Datatracker, accessed December 11, 2025, [https://datatracker.ietf.org/doc/html/rfc5280](https://datatracker.ietf.org/doc/html/rfc5280)  
4. Does Python 3.13 ignore SSL_CERT_FILE environment variable by design?, accessed December 11, 2025, [https://stackoverflow.com/questions/79123649/does-python-3-13-ignore-ssl-cert-file-environment-variable-by-design](https://stackoverflow.com/questions/79123649/does-python-3-13-ignore-ssl-cert-file-environment-variable-by-design)  
5. What's New In Python 3.13 — Python 3.14.2 documentation, accessed December 11, 2025, [https://docs.python.org/3/whatsnew/3.13.html](https://docs.python.org/3/whatsnew/3.13.html)  
6. ssl — TLS/SSL wrapper for socket objects — Python 3.14.2 documentation, accessed December 11, 2025, [https://docs.python.org/3/library/ssl.html](https://docs.python.org/3/library/ssl.html)  
7. `ssl`: changing the default `SSLContext.verify_flags`? - Python Discussions, accessed December 11, 2025, [https://discuss.python.org/t/ssl-changing-the-default-sslcontext-verify-flags/30230](https://discuss.python.org/t/ssl-changing-the-default-sslcontext-verify-flags/30230)  
8. `ssl.create_default_context()`: add `VERIFY_X509_STRICT` and `VERIFY_X509_PARTIAL_CHAIN` to the default `verify_flags` · Issue #107361 · python/cpython - GitHub, accessed December 11, 2025, [https://github.com/python/cpython/issues/107361](https://github.com/python/cpython/issues/107361)  
9. OpenSSL: X.509 errors, accessed December 11, 2025, [https://x509errors.org/](https://x509errors.org/)  
10. The -x509_strict flag no longer accepts missing Authority Key Identifier and Subject Key Identifier · Issue #13283 · openssl/openssl - GitHub, accessed December 11, 2025, [https://github.com/openssl/openssl/issues/13283](https://github.com/openssl/openssl/issues/13283)  
11. Azure "az" command and decryption - LIVEcommunity - 1237882, accessed December 11, 2025, [https://live.paloaltonetworks.com/t5/next-generation-firewall/azure-quot-az-quot-command-and-decryption/td-p/1237882](https://live.paloaltonetworks.com/t5/next-generation-firewall/azure-quot-az-quot-command-and-decryption/td-p/1237882)  
12. Python 3.13 Zscaler certificate non-conform, accessed December 11, 2025, [https://community.zscaler.com/s/question/0D5PJ00000Yzt5r0AB/python-313-zscaler-certificate-nonconform](https://community.zscaler.com/s/question/0D5PJ00000Yzt5r0AB/python-313-zscaler-certificate-nonconform)  
13. Configuring Software Protection Intermediate CA Certificate - Zscaler Help, accessed December 11, 2025, [https://help.zscaler.com/unified/configuring-software-protection-intermediate-ca-certificate](https://help.zscaler.com/unified/configuring-software-protection-intermediate-ca-certificate)  
14. Configuring Software Protection Intermediate CA Certificate - Zscaler Help, accessed December 11, 2025, [https://help.zscaler.com/zia/configuring-software-protection-intermediate-ca-certificate](https://help.zscaler.com/zia/configuring-software-protection-intermediate-ca-certificate)  
15. Managing Intermediate CA Certificates Using API - Zscaler Help, accessed December 11, 2025, [https://help.zscaler.com/zia/managing-intermediate-ca-certificates-using-api](https://help.zscaler.com/zia/managing-intermediate-ca-certificates-using-api)  
16. pip-system-certs 5.3 - PyPI, accessed December 11, 2025, [https://pypi.org/project/pip-system-certs/](https://pypi.org/project/pip-system-certs/)  
17. az cli pipelines build list errors with Internal/VPN CA Certs - Developer Community, accessed December 11, 2025, [https://developercommunity.visualstudio.com/t/az-cli-pipelines-build-list-errors-with/10993415?sort=active&topics=ide2](https://developercommunity.visualstudio.com/t/az-cli-pipelines-build-list-errors-with/10993415?sort=active&topics=ide2)  
18. SSL: CERTIFICATE_VERIFY_FAILED certificate verify failed: unable to get local issuer certificate (_ssl.c:1129)'))) - Stack Overflow, accessed December 11, 2025, [https://stackoverflow.com/questions/77442172/ssl-certificate-verify-failed-certificate-verify-failed-unable-to-get-local-is](https://stackoverflow.com/questions/77442172/ssl-certificate-verify-failed-certificate-verify-failed-unable-to-get-local-is)  
19. AZ Login fails with SSL intercept for 2.77.0 · Issue #32206 · Azure/azure-cli - GitHub, accessed December 11, 2025, [https://github.com/Azure/azure-cli/issues/32206](https://github.com/Azure/azure-cli/issues/32206)  
20. RFC compliance | Certificate Authority Service - Google Cloud Documentation, accessed December 11, 2025, [https://docs.cloud.google.com/certificate-authority-service/docs/rfc-compliance](https://docs.cloud.google.com/certificate-authority-service/docs/rfc-compliance)