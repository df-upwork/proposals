## 1. `Def`
~~~
Def(A):
```
B
```
~~~
будет обозначать, что для понятия `B` я использую обозначение `A`.

## 2. `Def_P`
~~~
Def_P(A):
```
B
```
~~~
будет обозначать, что `B` является для меня проблемой, и для этой проблемы я использую обозначение `A`.

## 3. `Def_C`
### 3.1.
```
Def_C(P, A, B)
```
будет обозначать `Def(A, B)` в контексте пункта `P`.
Вне пункта `P` это правило не применяется.
Если до пункта `P` обозначение `A` имело другой смысл, то после пункта `P` обозначение `A` снова будет иметь этот смысл.
По сути, `Def_C` объявляет локальную переменную `A` с областью действия `P`.
В отличие от него, `Def` объявляет глобальную переменную `A` (значение которой действует для всех пунктов, кроме `P`).

### 3.2.
~~~
Def_C(P, A):
```
B
```
~~~
имеет то же значение, что и `Def_C(P, A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 3.3.
```
Def_C([P1, P2, …, Pn], A, B)
```
имеет значение, аналогичное `Def_C(P, A, B)`, только в этом случае обозначение `A` имеет значение `B` в контексте не одного пункта `P`, а всех пунктов [`P1`, `P2`, …, `Pn`], перечисленных в квадратных скобках.

### 3.4.
```
Def_C([P1-Pn], A, B)
```
имеет значение, аналогичное `Def_C([P1, P2, …, Pn], A, B)`: в этом случае обозначение `A` имеет значение `B` в контексте множества всех пунктов между `P1` и `Pn`, включая сами эти пункты.

### 3.5.
~~~
Def_C([P1, P2, …, Pn], A):
```
B
```
~~~
имеет то же значение, что и `Def_C([P1, P2, …, Pn], A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 3.6.
~~~
Def_C([P1-Pn], A):
```
B
```
~~~
имеет то же значение, что и `Def_C([P1-Pn], A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 4. `Def_F`
### 4.1.
Def_C(4-5, `F`):
```
Факт: некое событие, которое случилось в описываем мной случае.
```

### 4.2.
~~~
Def_F:
```
B
```
~~~
будет обозначать, что `B` — это `F`.

### 4.3.
~~~
Def_F(A):
```
B
```
~~~
будет обозначать, что `B` — это `F`, и для него я использую обозначение `A`.

## 5. `Def_Ph`
### 5.1.
Def_C(5, `Ph`):
```
Феномен: `F`, который вызывает у меня удивление.
```

### 5.2.
~~~
Def_Ph(A):
```
B
```
~~~
будет обозначать, что `B` — это `Ph`, и для него я использую обозначение `A`.

## 6. `Def_H`
### 6.1.
Def_C(6, `H`):
```
Гипотеза: некое предположение, требующее проверки.
```

### 6.2.
~~~
Def_H(A):
```
B
```
~~~
будет обозначать, что `B` — это `H`, и для него я использую обозначение `A`.

## 7. `Def_Set`
### 7.1.
```
Def_Set(S, I)
```
будет обозначать, что `S` — множество всех возможных `I`.

### 7.2.
```
Def_Set(S, {I1, I2, …, In})
```
будет обозначать, что `S` — множество, заданное точным перечислением всех его элементов: {`I1`, `I2`, …, `In`}.

## 8. `Def_I`
### 8.1.
```
Def_I(I, S)
```
будет обозначать, что `I` ∈ `S` (`I` — элемент множества `S`).

### 8.2.
~~~
Def_I(I, S):
```
B
```
~~~
будет обозначать, что `I` ∈ `S` и `B` — определение `I`.

## 9. `Use`
```
Use(A)
```
будет обозначать, что в описываемой мной ситуации я использую `A`.

## 10.
Потенциальный клиент опубликовал на Upwork следующий проект:
### 10.1. Title
Sending broadcast push notification at the server

### 10.2. Description
```text
This could be full-time or contract-basis position.
Most important thing is we should add sending broadcast push notification feature right now.
So agency or beginners please do not apply.
We were currently using Firebase push notification.
After adding the broadcast push notification feature, we will think about converting it into OneSignal if that's the way to do.
The guys who have node.js, typescript and docker experience must apply to this job.
If you don't know all of them, please do not waste our time.
```

### 10.3. Tags
Docker
React
Node.js
TypeScript
JavaScript
Firebase Cloud Firestore

## 11. Информация о клиенте
### 11.1. Местоположение
Japan
Kitakyushu

## 11.2. Характеристики компании
### 11.2.1. Сектор экономики
неизвестно
### 11.2.2. Количество сотрудников
неизвестно

## 11.3. Характеристики учётной записи на Upwork
### 11.3.1. Member since
Jul 7, 2025
#### 11.3.2. Hire rate (%)
58
#### 11.3.3. Количество опубликованных проектов (jobs posted)
7
#### 11.3.4. Total spent (USD)
110
#### 11.3.5. Количество оплаченных часов в почасовых проектах
0

## 12.
Def(`C`):
```
клиент пункта 10
```

## 13.
Def(`P`):
```
проект пункта 10
```

## 14.
Def(`PD`):
```
Описание `P` (пункт 10.2 выше)
```

## 15.
Def_F(`POs`):
```
Другие проекты `C` на Upwork:
~~~
1) https://www.upwork.com/jobs/~021945144932981572678
2) https://www.upwork.com/jobs/~021946198340312798764
3) https://www.upwork.com/jobs/~021944577886773602001
4) https://www.upwork.com/jobs/~021942043569245879475
~~~
```

## 16.
Def(`T`):
```
Задача, о которой `C` пишет в `PD`:
~~~
sending broadcast push notification feature
~~~
```

## 17.
N/A

## 18.
Def(`PN-F`):
```
Термин «Firebase push notification» в `PD`
```

## 19.
Def(`PN-B`):
```
Термин «broadcast push notification» в `PD`
```

## 20.
Def(`PNs`):
```
Разница `PN-F` и `PN-B` в понимании `C`.
Обрати внимание, что:
- в отношении `PN-F` `C` пишет: «We were currently using»
- в отношении `PN-B` `C` пишет: «we should add»
```

## 21.
N/A

## 22.
Def(`TM`):
```
FCM Topic Messaging (в контексте `P`)
```

## 23.
Def(`S`):
```
Решение `P` посредством `TM`
```

## 24.
Def(`D`, «мой ответ `C`»).

## 25.
Содержание `D`:
~~~markdown
1) Firebase provides a native mechanism for implementing broadcast messaging: FCM Topic Messaging.
2) My proposed architecture:
2.1) The server-side (`S`) uses the Firebase Admin SDK to perform privileged operations, such as managing device subscriptions to topics and sending messages to them. 
`S` is responsible for all the server-side logic.
2.2) Client-side (`C`):
- requests permission from the user (`U`) to receive notifications
- receives a unique device registration token (`T`) from FCM and sends `T` to `S` for subsequent subscription.
3) High-level interaction flow:
3.1) `C` obtains `T` and sends it to `S`.
3.2) `S` subscribes the device with this `T` to a common topic.
3.3) Subsequently, to send a broadcast notification, an authorized administrator (`A`) sends a single message to FCM via the secure API endpoint `/api/broadcast` (`E1`), specifying this common topic as the recipient.
3.4) FCM, in turn, delivers this message to all subscribed devices.
4) A key architectural limitation of FCM for web clients is that they cannot subscribe to topics independently.
This operation must be performed by `S`.
Consequently, it is necessary to create a server-side API endpoint `/api/subscribe` (`E2`) that will accept the registration `T` from `C` and perform the subscription on its behalf.
5) Access to `E1` and `E2` must be strictly restricted.
Unprotected endpoints for broadcast messaging are vulnerable to spam and attacks.
I recommend implementing this protection in 2 steps:
5.1) Authentication: ensure that the request comes from a known, logged-in `A` (in the case of `E1`) and `U` (in the case of `E2`).
For `E1` I recommend using Firebase ID tokens (`AT`), which `A` will send with each request.
5.2) Authorization: ensure that `A` / `U` has the necessary permissions to perform this action.
5.2.1) I recommend adding a custom claim (`AC`) to `A`, e.g. `{admin: true}`, and verifying it on `S`.
5.2.2) The assignment of `AC` must be performed via a separate, highly secure mechanism, e.g., via a Cloud Function available only to existing `A`s, or via a server-side script.
6) To work with FCM in `C`, it is necessary to install the client SDK and configure a Service Worker.
7) The browser will not provide `T` until `U` explicitly grants the website permission to display notifications. Therefore, permission must be requested from `U` to receive notifications.
8) It is crucial to remember that `T` can change.
I recommend obtaining it on each load of `C` and sending it to `S` if it differs from the previously saved one.
9) For `S` to authenticate and execute Firebase API calls, it requires an identity.
This role is performed by a service account (`SA`): a special type of Google account intended for non-human interactions, such as server-to-server communication.
Including the `SA` key file in the Docker image is a serious security violation.
I recommend injecting the credentials into the container at runtime.
10) Full `U` subscription process:
10.1) `U` opens `C` in the browser.
10.2) `C` initiates the request for permission to display notifications.
10.3) `U` clicks «Allow».
10.4) `C` requests `T` from FCM.
10.5) `C` sends the token to `S` at `E2`.
10.6) `S` subscribes `T` to the common topic `all_users`.
10.7) `U`'s device is ready to receive broadcast notifications.
11) Procedure for initiating a broadcast notification:
11.1) `A` logs into their account in a special administrative panel.
11.2) `A` obtains from Firebase an `AT` containing the `AC`.
11.3) `A` composes the message (title and body) and clicks «Send».
11.4) The admin application makes a `POST` request to `E1`, attaching the `AT` in the `Authorization: Bearer <AT>` header.
11.5) `E1` verifies the validity of the token and the presence of the `AC`.
If the check passes, `S` constructs the message object for FCM and calls the send method.
11.6) FCM receives the request and delivers the notification to all devices subscribed to the `all_users` topic.
~~~

## 26.
Def(`D2`, «начальная часть `D`, переведённая с English на Japanese»).

## 27.
Содержание `D2`:
~~~markdown
1) Firebaseは、ブロードキャストメッセージングを実装するためのネイティブなメカニズムとして、FCM Topic Messagingを提供しています。
2) 私が提案するアーキテクチャ：
2.1) サーバーサイド（`S`）は、Firebase Admin SDKを使用して、トピックへのデバイスのサブスクリプション管理や、それらへのメッセージ送信などの特権的な操作を実行します。
`S`は、すべてのサーバーサイドロジックを担当します。
2.2) クライアントサイド (`C`):
- ユーザー (`U`) から通知を受信するための許可を要求する
- FCMから一意のデバイス登録トークン (`T`) を受信し、その後のサブスクリプションのために `T` を `S` に送信する
3) 高レベルなインタラクションフロー：
3.1) `C`が`T`を取得し、`S`に送信する
3.2) `S`は、この`T`を使用してデバイスを共通のトピックにサブスクライブする
3.3) その後、ブロードキャスト通知を送信するために、承認された管理者（`A`）は、安全なAPIエンドポイント`/api/broadcast`（`E1`）を介してFCMに単一のメッセージを送信し、この共通トピックを受信者として指定します。
3.4) FCMは、今度は、このメッセージをすべてのサブスクライブしているデバイスに配信します。
4) ウェブクライアント向けのFCMのアーキテクチャ上の重要な制約は、独立してトピックにサブスクライブできないことです。
この操作は`S`によって実行される必要があります。
したがって、`C`から登録`T`を受け取り、その代理でサブスクリプションを実行するサーバーサイドAPIエンドポイント `/api/subscribe` (`E2`) を作成する必要があります。
5) `E1`および`E2`へのアクセスは厳密に制限されなければなりません。
保護されていないブロードキャストメッセージング用のエンドポイントは、スパムや攻撃に対して脆弱です。
この保護を2つのステップで実装することをお勧めします：
5.1) 認証：リクエストが、既知のログイン済み`A`（`E1`の場合）および`U`（`E2`の場合）からのものであることを確認する必要があります。
`E1`については、`A`が各リクエストと共に送信する`Firebase ID`トークン（`AT`）を使用することを推奨します。
5.2) 認可: `A` / `U` がこのアクションを実行するために必要な権限を持っていることを確認します。
5.2.1) `A` にカスタムクレーム (`AC`)、例えば `{admin: true}` を追加し、`S` でそれを検証することをお勧めします。
5.2.2) `AC` の割り当ては、既存の `A` のみが利用可能な Cloud Function や、サーバーサイドのスクриプトなど、別の非常に安全なメカニズムを介して実行する必要があります。
6) `C`でFCMを扱うためには、クライアントSDKをインストールし、Service Workerを設定する必要があります。
7) `U`がウェブサイトに通知を表示する許可を明示的に与えるまで、ブラウザは`T`を提供しません。したがって、通知を受信するためには`U`から許可を要求する必要があります。
8) `T`は変更される可能性があるという点を覚えておくことが極めて重要です。
`C`の各ロード時に`T`を取得し、以前に保存されたものと異なる場合は`S`に送信することをお勧めします。
~~~

## 28.
Def(`F`, «фрагмент `D`»).

## 29.
Содержание `F`:
~~~markdown
11.6) FCM receives the request and delivers the notification to all devices subscribed to the `all_users` topic.
~~~

## 30.
Переведи `F` на Japanese, с учётом:
- контекста `D`
- `D2`: уже переведённой части `D`
- всех предыдущих пунктов моего запроса

## 31. Правила перевода
### 31.1.
Переводи именно в той стилистике, как написано на English.
Не делай перевод более вежливым, чем оригинал.

### 31.2.
Те предложения, которые сейчас полностью на Japanese — оставь без изменения.

### 31.3.
#### 31.3.1.
Не используй Markdown: только plain text.
#### 31.3.2.
При этом можно и нужно использовать то форматирование, которое уже есть в оригинале: его не убирай.
#### 31.3.3.
Не форматируй веб-ссылки посредством Markdown, если они не отформатированы так в оригинале. 
Например, не пиши так:
```
[https://www.eca.web.tr/eca-nita-esnek-uclu-eviye-bataryasi-beyaz-102118110-308](https://www.eca.web.tr/eca-nita-esnek-uclu-eviye-bataryasi-beyaz-102118110-308)
```
если в оригинале скобок `[]()` нет.

### 31.4.
Форматируй перевод в точности как оригинал. 
В частности:
*) каждый абзац должен содержать ровно одно предложение
*) между абзацами не должно оставаться пустых строк.
*) кавычки используй те же, что и в оригинале: «» и ``.

### 31.5.
Не используй сокращения типа «don't». Все подобные фразы пиши полностью: «do not».

### 31.6.
Не используй жаргон.
Вместо этого используй официальные термины.
#### 31.6.1.
В частности, фразы в кавычках используй только в том случае, когда они являются точными цитатами.
Не используй фразы в кавычках для применения жаргонных фраз.
Например, следующий фрагмент текста недопустим, потому что там используется жаргонная фраза «пролетел»: 
```
Например, код, который пушит данные о покупке, подключён асинхронно и загружается с небольшой задержкой, а триггер уже «пролетел».
```

### 31.7.
При обсуждении программного обеспечения используй точные официальные термины на английском языке: именно в том виде, как они указаны в официальной англоязычной документации к этому программному обеспечению.

### 31.8.
Не используй «you need» и другие подобные обращённые к клиенту фразы, перекладывающие действия на него.
Помни: я пишу клиенту или потенциальному клиенту.
Делать в любом случае буду я, а не клиент.
Вместо «you need» используй 2 альтернативы:
#### 31.8.1.
Нейтральные фразы типа «it is necessary».
#### 31.8.2.
Глаголы в неопределённой форме.
Например, во фрагменте ниже использованы подобные глаголы «set up», «create»:
```
1.2) Set up the transfer of login events from WordPress to Power BI using Fabric / OneLake.
1.2.1) Set up a «Data Pipeline» from the WordPress database table that stores login events (see point 1.1) to Fabric / OneLake.
1.2.2) Set up a connection from Power BI to Fabric / OneLake to pass login events.
1.3) Create the data model in Power BI.
```
Обрати внимание, в этом фрагменте не говорится, кто именно будет выполнять описанные действия: ответственность не перекладывается на клиента, в отличие от «you need».

### 31.9.
Никогда не переводи понятие «сайт» / «веб-сайт» как «site». 
Вместо этого используй форму «website»: это является более профессиональным.

### 31.10.
Никогда не переводи понятие «пункт нумерованного списка» как «item».
Всегда переводи это как «point».

### 31.11.
Вместо «for example» используй «e.g.».