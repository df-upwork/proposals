1) Вам нужно защитить ваши веб-сервисы защищёнными от 2 типов злоумышленников:
1.1) Лица, желающие взломать ваши веб-сервисы.
1.2) Лица, желающие злоупотреблять вашими веб-сервисами.
2) Вектор атаки лица 1.1, будет, скорее всего, направлен не на аутентификацию, а на сценарии после аутентификации: просто потому что в этих сценариях больше лазеек для уязвимостей.
Например, если конкретный запрос к API допускает SQL-инъекцию, то нет разницы, какая там перед этим была аутентификация.
Для защиты от лиц 1.1 я могу провести полный security audit программной реализации ваших сервисов. 
3) Лица 1.2 взламывать ваши сервисы не будут: они будут ими злоупотреблять.
Я могу реализовать в ваших веб-сервисах защиту от злоупотреблений:
3.1) Разделение ключей на «test» и «live»
3.2) Ротация и отзыв ключей (revoke / rotate)
3.3) «Restricted API Keys»: ограничение прав и доступов.
3.3.1) Например, Stripe поддерживает ограниченные ключи (Restricted Keys), указывая, к каким конкретным типам ресурсов (payments, charges, refunds, webhooks и т.д.) и действиям этот ключ может обращаться.
3.3.2) GitHub для той же цели использует «fine-grained personal access tokens», позволяющие ещё точнее задавать, к каким именно репозиториям и действиям (чтение, запись, администрирование и т.д.) может обращаться токен. 
Это даёт возможность выдать ключ только под конкретную задачу, а не под весь аккаунт.
3.4) Логирование и мониторинг вызовов
Надо вести детальный журнал вызовов API (включая информацию, какой ключ использовался).
3.5) Механизмы rate limiting: ограничение частоты запросов к своей инфраструктуре.
3.5.1) Например,  OpenAI (как и многие облачные сервисы) отслеживает скорость запросов (количество запросов в секунду/минуту) и при превышении порога может возвращать ошибки 429 (Too Many Requests).
Это защищает от DDoS-атак или «залпов» вызовов от украденных/скомпрометированных ключей.
3.6) Помесячные и посуточные лимиты
3.6.1) Например, OpenAI для каждого аккаунта устанавливает квоты или лимиты на количество запросов и/или токенов, которые можно использовать в сутки или за определённый период. 
Если объём запросов внезапно превышает допустимый уровень, система может временно блокировать или приостанавливать доступ. 
3.7) Встроенные механизмы предотвращения мошенничества: надо анализировать транзакции и поведение пользователей API для обнаружения мошеннических паттернов.
3.8) Автоматическая невалидность API key при некоторых событиях.
Это реализуется в виде триггеров, которые приостанавливают или снижают доступ, а затем формируют уведомление.
3.9) Мониторинг аномалий: если внезапно API key начинает использоваться «из необычного региона» или с аномально высоким числом запросов, могут включиться дополнительные проверки, приостанавливающие запросы до подтверждения, что это действительно легитимный трафик.
3.10)  Web Application Firewall (WAF).
Это даёт дополнительную защиту от:
3.10.1) Сканирования и брутфорса (подбора токенов);
3.10.2) DDoS-атак на API;
3.10.3) Известных сигнатур вредоносных запросов.
3.11) Привязка расхода к платёжной карте.
Это создаёт дополнительный барьер: мошеннику мало украсть API Key — чтобы «увести» значительные ресурсы, нужен ещё и валидный метод оплаты.
3.12) Сотрудничество с GitHub Secret Scanning
GitHub имеет сервис для автоматического сканирования репозиториев в поисках опубликованных ключей сервисов.
3.13) Префикс для ключей.
Если использовать для ключей префикс (например, `sk-`), то это даст дополнительную возможность быстро находить компрометированные ключи при сканировании любых текстовых файлов и логов.
3.14) Ограничение по источнику запросов (Application restrictions)
За счёт таких ограничений злоумышленнику недостаточно просто заполучить сам ключ — ему нужно ещё находиться под нужным IP или обладать подписанным приложением с корректным сертификатом.
Например:
3.14.1) HTTP-реферер (URL): ключ будет работать только при вызове из определённого домена (или списка доменов).
3.14.2) IP-адреса: ключ будет работать только, если запрос идёт с определённых IPv4/IPv6-адресов или подсетей.
3.14.3) Android-приложения (пакет и SHA1-сертификат): ключ работает только для конкретного приложения с указанным пакетом и отпечатком сертификата.
3.14.4) iOS-приложения (bundle ID): аналогично Android, но для iOS bundle identifier.
3.15) Временные токены и HMAC-подписи
Такая схема затрудняет перехват или «переплей» (replay) запросов, потому что подпись привязана к точному времени и содержимому запроса, и любое изменение заголовков, тела или просрочка таймстемпа делает подпись недействительной.
Например, у Amazon Web Services эта технология называется «AWS Signature Version 4».