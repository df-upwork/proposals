# 1.
## 1.1. 
`L_SOURCE` ≔ (Русский язык)

## 1.2. 
`L_TARGET` ≔ (English)

# 2.
## 2.1.
`D` ≔ (мой ответ `ꆜ`)

## 2.2.
Содержание `D`:
~~~markdown
1) Способ интеграции C++ с MongoDB очевиден — `mongocxx`: https://github.com/mongodb/mongo-cxx-driver
2) А вот для интеграции C++ с React я вижу 5 альтернатив.
Их я описываю в пунктах 3-7 ниже.
Лучшую из них я намеренно описываю последней (пункт 7): чтобы понять, что она — лучшая, надо сначала увидеть недостатки других.
3) REST API на C++
3.1) Суть: бэкенд на C++ реализует HTTP-сервер (используя фреймворки, такие как Drogon, Oat++, или библиотеки вроде Boost.Beast) и предоставляет RESTful эндпоинты.
React использует стандартные HTTP-клиенты (Fetch, Axios).
3.2) Достоинства
3.2.1) REST/JSON является отраслевым стандартом, что упрощает разработку на React, отладку и интеграцию.
3.2.2) Простота развертывания и горизонтального масштабирования (Stateless).
3.2.3) Современные C++ фреймворки обеспечивают высокую пропускную способность и низкую задержку. 
3.3) Недостатки
3.3.1) Реализация веб-сервисов на C++ значительно сложнее и медленнее, чем на языках, ориентированных на веб (Node.js, Python). 
3.3.2) Ограниченная экосистема: меньшее количество зрелых библиотек для типичных веб-задач (аутентификация, интеграции).
3.3.3) Высокие риски безопасности.
C++ является memory-unsafe языком.
Реализация публичных веб-сервисов непосредственно на C++ значительно повышает риски уязвимостей, связанных с управлением памятью (e.g., buffer overflow, use-after-free).
4) gRPC и gRPC-Web
4.1) Суть: gRPC — это высокопроизводительный RPC-фреймворк, использующий Protocol Buffers (Protobuf) для бинарной сериализации и HTTP/2 для транспорта.
4.2) Достоинства
4.2.1) Бинарный формат и HTTP/2 обеспечивают более быструю связь и меньший размер сообщений по сравнению с REST/JSON.
4.2.2) Строгая типизация и генерация кода: контракт API определяется в `.proto` файлах, из которых генерируется код клиента (TypeScript) и сервера (C++), минимизируя ошибки.
4.2.3) Нативная поддержка потоковой передачи данных.
4.3) Недостатки
4.3.1) Браузеры не поддерживают нативный gRPC.
Требуется использование gRPC-Web и развертывание proxy для трансляции запросов между протоколами gRPC-Web и gRPC.
Это усложняет архитектуру и DevOps.
4.3.2) Сложность отладки: бинарный формат затрудняет инспекцию сетевых запросов стандартными инструментами.
5) WebSockets
5.1) Суть: WebSockets — это протокол, обеспечивающий постоянное, полнодуплексное соединение между React и C++ (с использованием библиотек вроде WebSocket++ или uWebSockets).
5.2) Достоинства
5.2.1) Обеспечивает наименьшую задержку и мгновенную двунаправленную передачу данных (Server Push).
5.2.2) Минимальные накладные расходы после установки соединения.
5.3) Недостатки
5.3.1) Непригодность для стандартного CRUD. 
Не оптимизирован для модели запрос-ответ.
Необходимо реализовывать собственный протокол (например, JSON-RPC) поверх него. 
5.3.2)  Управление постоянными соединениями усложняет горизонтальное масштабирование и балансировку нагрузки.
5.3.3) Высокие риски безопасности.
Аналогично пункту 3.3.3, реализация публичного WebSocket сервера на C++ значительно повышает риски критических уязвимостей.
6) GraphQL API на C++
6.1) Достоинства
6.1.1) Эффективность данных: Позволяет клиенту запросить только нужные поля, решая проблему over/under-fetching.
6.1.2) Отличный Developer Experience (DX) в React: Зрелая экосистема на фронтенде (Apollo Client).
6.2) Недостатки
6.2.1) Крайне незрелая экосистема C++
Существует очень мало зрелых и поддерживаемых библиотек для реализации GraphQL-серверов на C++. 
Реализация потребует огромных усилий и несет высокие риски. 
6.2.2) Высокая сложность бэкенда: Сложность реализации парсинга запросов и эффективных резолверов на C++.
6.2.3) Высокие риски безопасности.
Аналогично пункту 3.3.3, реализация сложного парсинга GraphQL запросов на C++ значительно повышает риски критических уязвимостей.
7) Гибридная архитектура (API Gateway + C++)
7.1) Суть: фронтенд взаимодействует с API Gateway, созданным на языке, более приспособленном для веба (e.g., Node.js/TypeScript).
Этот шлюз предоставляет публичный REST или GraphQL API.
Основная бизнес-логика и взаимодействие с MongoDB (используя `mongocxx`, как указано в пункте 1) реализуются в сервисе на C++.
API Gateway взаимодействует с сервисом на C++ через высокопроизводительный внутренний протокол (e.g., нативный gRPC или очереди сообщений).
7.2) Достоинства
7.2.1) Баланс производительности и скорости разработки.
Использует сильные стороны обеих технологий.
Node.js позволяет быстро разрабатывать веб-API и легко интегрируется с React.
C++ используется для реализации основной бизнес-логики и слоя данных.
7.2.2) Разделение ответственности: шлюз обрабатывает веб-аспекты (аутентификация, CORS, маршрутизация), освобождая сервис на C++ от этих задач.
7.2.3) Позволяет использовать богатые экосистемы обеих платформ.
7.2.4) Упрощает итеративную разработку.
7.2.5) Повышенная безопасность.
API Gateway реализуется на memory-safe языке (e.g., Node.js/TypeScript, Go).
Это устраняет целый класс уязвимостей, связанных с управлением памятью, на публичном периметре приложения.
7.3) Недостатки
7.3.1) Больше движущихся частей (два сервиса вместо одного). 
7.3.2) Увеличение задержки: вводит дополнительный сетевой прыжок (React → Gateway → C++).
8) Анализ требований и приоритетов.
8.1) Судя по фразе «design solutions from scratch and iterate with the owner to deliver a working product», приоритетом является скорость разработки и возможность быстрых итераций.
8.2) При этом требование использовать C++ для backend в контексте веб-приложения само по себе является главным препятствием для быстрого создания продукта.
Разработка на C++ значительно сложнее и медленнее, чем на языках, более ориентированных на веб (e.g., Node.js, Python, Go).
9) Выводы 
Исходя из пункта 8.1:
9.1) Реализация веб-слоя непосредственно на C++ (способы пунктов 3, 5, 6) значительно замедлит разработку и усложнит итерации из-за сложности языка и относительной незрелости его веб-экосистемы.
9.2) Способ пункта 4 вводит неоправданную сложность инфраструктуры (Envoy proxy) для нового проекта.
9.3) Поэтому я рекомендую способ пукта 7.
Он обеспечивает наилучший баланс для данного контекста. 
Он удовлетворяет требованию использования C++ backend для реализации основной бизнес-логики, одновременно используя более подходящую технологию (например, Node.js) для веб-слоя. 
Это позволит быстро создать рабочий продукт.

~~~

# 3.
## 3.1.
`D2` ≔ (начальная часть `D`, переведённая с `L_SOURCE` на `L_TARGET`)

## 3.2.
Содержание `D2`:
~~~markdown
~~~

# 4.
## 4.1.
`F` ≔ (фрагмент `D`)

## 4.2.
Содержание `F`:
~~~markdown
1) Способ интеграции C++ с MongoDB очевиден — `mongocxx`: https://github.com/mongodb/mongo-cxx-driver
2) А вот для интеграции C++ с React я вижу 5 альтернатив.
Их я описываю в пунктах 3-7 ниже.
Лучшую из них я намеренно описываю последней (пункт 7): чтобы понять, что она — лучшая, надо сначала увидеть недостатки других.
~~~

# 5. `᛭T`
Переведи `F` на `L_TARGET`, с учётом:
- контекста `D`
- `D2`: уже переведённой части `D`
- `᛭O`

# 6. Правила перевода
## 6.1.
Переводи именно в той стилистике, как написано на `L_SOURCE`.
Не делай перевод более вежливым, чем оригинал.

## 6.2.
Те предложения, которые сейчас полностью на `L_TARGET` — оставь без изменения.

## 6.3.
### 6.3.1.
Не используй Markdown: только plain text.
### 6.3.2.
При этом можно и нужно использовать то форматирование, которое уже есть в оригинале: его не убирай.
### 6.3.3.
Не форматируй веб-ссылки посредством Markdown, если они не отформатированы так в оригинале. 
Например, не пиши так:
```
[https://www.eca.web.tr/eca-nita-esnek-uclu-eviye-bataryasi-beyaz-102118110-308](https://www.eca.web.tr/eca-nita-esnek-uclu-eviye-bataryasi-beyaz-102118110-308)
```
если в оригинале скобок `[]()` нет.

## 6.4.
Форматируй перевод в точности как оригинал. 
В частности:
*) каждый абзац должен содержать ровно одно предложение
*) между абзацами не должно оставаться пустых строк.
*) кавычки используй те же, что и в оригинале: «» и ``.

## 6.5.
Не используй сокращения типа «don't». Все подобные фразы пиши полностью: «do not».

## 6.6.
Не используй жаргон.
Вместо этого используй официальные термины.
### 6.6.1.
В частности, фразы в кавычках используй только в том случае, когда они являются точными цитатами.
Не используй фразы в кавычках для применения жаргонных фраз.
Например, следующий фрагмент текста недопустим, потому что там используется жаргонная фраза «пролетел»: 
```
Например, код, который пушит данные о покупке, подключён асинхронно и загружается с небольшой задержкой, а триггер уже «пролетел».
```

## 6.7.
При обсуждении программного обеспечения используй точные официальные термины на английском языке: именно в том виде, как они указаны в официальной англоязычной документации к этому программному обеспечению.

## 6.8.
Не используй «you need» и другие подобные обращённые к клиенту фразы, перекладывающие действия на него.
Помни: я пишу клиенту или потенциальному клиенту.
Делать в любом случае буду я, а не клиент.
Вместо «you need» используй 2 альтернативы:
### 6.8.1.
Нейтральные фразы типа «it is necessary».
### 6.8.2.
Глаголы в неопределённой форме.
Например, во фрагменте ниже использованы подобные глаголы «set up», «create»:
```
1.2) Set up the transfer of login events from WordPress to Power BI using Fabric / OneLake.
1.2.1) Set up a «Data Pipeline» from the WordPress database table that stores login events (see point 1.1) to Fabric / OneLake.
1.2.2) Set up a connection from Power BI to Fabric / OneLake to pass login events.
1.3) Create the data model in Power BI.
```
Обрати внимание, в этом фрагменте не говорится, кто именно будет выполнять описанные действия: ответственность не перекладывается на клиента, в отличие от «you need».

## 6.9.
Никогда не переводи понятие «сайт» / «веб-сайт» как «site». 
Вместо этого используй форму «website»: это является более профессиональным.

## 6.10.
Никогда не переводи понятие «пункт нумерованного списка» как «item».
Всегда переводи это как «point».

## 6.11.
Вместо «for example» используй «e.g.».
При этом не забывай, что в начале предложения эта фраза должна начинатся с заглавной буквы: «E.g.»