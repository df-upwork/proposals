https://gemini.google.com/share/d74df08f2942

## R⬆₁: Агрессивная нормализация запросов и заголовков (VCL Sanitization)

### Суть
Данная рекомендация заключается во внедрении в процедуру `vcl_recv` строгой логики очистки `req.url` от маркетинговых меток и сортировки параметров запроса.
Мера направлена на устранение комбинаторного взрыва кэша («Cache Bloat»), который возникает из-за уникальности ссылок с параметрами отслеживания и является первопричиной генерации миллионов избыточных объектов метаданных.
Дополнительно рекомендация включает нормализацию заголовка `User-Agent` до ограниченного набора групп и удаление заголовка `Vary: User-Agent` из ответов бэкенда для предотвращения фрагментации кэша.
Для реализации используются возможности языка VCL, включая регулярные выражения `regsuball` и функции модуля `std` или `vmod_querystring`.
Это действие блокирует бесконечный рост потребления памяти на уровне логики приложения, предотвращая попадание мусорных объектов в хранилище.

### Оценка
100

### Достоинства
Этот метод устраняет фундаментальную причину исчерпания памяти, останавливая генерацию паразитной нагрузки до того, как она затронет подсистему аллокации.
Реализация выполняется полностью средствами конфигурации VCL и не требует простоя сервера, смены ядра или установки системных пакетов.
Значительно повышается коэффициент попадания в кэш (Hit Rate), так как пользователи из разных рекламных каналов начинают получать один и тот же кэшированный объект.
Снижается нагрузка на бэкенд, поскольку Varnish перестает запрашивать генерацию уникальных страниц для каждого клика по рекламе.
Мера предотвращает массовое создание записей `hit-for-miss` в транзитном хранилище, снижая риск его переполнения.

### Недостатки
Некорректно составленные регулярные выражения несут риск случайного удаления функционально важных параметров фильтрации, что может нарушить работу навигации на сайте.
Требуется глубокий аудит используемых приложением параметров для формирования безопасного списка исключений.
Внедрение логики сортировки и очистки добавляет незначительные вычислительные накладные расходы на процессор при обработке каждого запроса.
Изменения применяются только к новым запросам и не очищают автоматически уже накопленный в памяти мусор без перезагрузки сервиса.

## R⬆₂: Явное ограничение размера временного хранилища (Transient Storage Bounding)

### Суть
Рекомендация предписывает изменить параметры запуска демона `varnishd`, добавив явный флаг `-s Transient=malloc,SIZE` с жестким лимитом (например, 2 ГБ).
В стандартной конфигурации Varnish использует для временных объектов (hit-for-miss, shortlived) неограниченное хранилище, которое при атаках или сбоях занимает всю доступную память сервера.
Установка лимита переводит механизм работы транзитного буфера в режим вытеснения (LRU), заставляя систему удалять старые записи вместо бесконечной аллокации новых страниц.
Это создает гарантированный предохранитель от аварийного завершения процесса (OOM Killer) даже в ситуациях массовой генерации некэшируемых ответов с заголовками `Set-Cookie`.
Данная мера компенсирует архитектурную особенность Varnish, которая по умолчанию не ограничивает потребление памяти для служебных нужд.

### Оценка
98

### Достоинства
Это единственная гарантированная защита от падения сервера из-за исчерпания памяти по вектору транзитных объектов, обеспечивающая стабильность процесса.
Метод обеспечивает предсказуемость потребления ресурсов, четко разделяя бюджет памяти между основным контентом и техническими буферами.
Реализация требует минимальных усилий по правке файла сервиса systemd и не зависит от сложности кода VCL.
Защита работает автономно и спасает доступность сервиса даже в случае логических ошибок на стороне веб-приложения или бэкенда.
Решение позволяет избежать эффекта «Thundering Herd» при рестартах, сохраняя работоспособность системы даже при заполненном транзитном буфере.

### Недостатки
Установка слишком малого лимита может привести к преждевременному удалению записей о пропусках кэширования, что увеличит нагрузку на бэкенд.
Метод является средством сдерживания последствий, а не устранения причины возникновения паразитного трафика.
Для применения настройки требуется перезапуск процесса Varnish, что влечет за собой полный сброс накопленного кэша.
Необходимо экспериментально подобрать оптимальный размер хранилища, чтобы не нарушить передачу больших файлов медленным клиентам.

## R⬆₃: Замена системного аллокатора на jemalloc (Allocator Swap)

### Суть
Данная рекомендация заключается в принудительном переключении процесса `varnishd` на использование библиотеки `jemalloc` вместо стандартного системного аллокатора `glibc`.
Это достигается путем установки пакета `jemalloc` и настройки переменной окружения `LD_PRELOAD` в конфигурации systemd сервиса Varnish.
Аллокатор `jemalloc` использует эффективные алгоритмы управления памятью (арены), минимизируя внешнюю фрагментацию кучи в многопоточных приложениях.
Особенно критично это решение для архитектуры ARM64 (AWS Graviton), где стандартный `glibc` демонстрирует низкую эффективность утилизации памяти.
Метод устраняет разрыв между потреблением памяти, фиксируемым внутренними счетчиками Varnish, и реальным резидентным размером процесса (RSS).

### Оценка
95

### Достоинства
Метод радикально снижает уровень фрагментации памяти, освобождая от 20% до 40% RAM, которая ранее терялась в дырах кучи.
Устраняется ложная диагностика утечки памяти, делая мониторинг потребления ресурсов прозрачным и соответствующим реальности.
Повышается общая производительность системы и снижается нагрузка на CPU за счет уменьшения конкуренции потоков за блокировки памяти.
Является официально рекомендованной практикой от разработчиков Varnish Software для высоконагруженных промышленных систем.
Решает проблему на низком системном уровне, работая прозрачно для любой конфигурации VCL.

### Недостатки
Требует вмешательства в системные зависимости и конфигурацию загрузки сервиса, что технически сложнее правки VCL.
В дистрибутиве Amazon Linux 2023 пакет может требовать подключения дополнительных репозиториев или ручной установки.
Эффект стабилизации памяти проявляется на длительной дистанции работы процесса, а не мгновенно.
Существует небольшой риск несовместимости с конкретными версиями системных библиотек, требующий предварительного тестирования.

## R⬆₄: Корректировка лимитов основного хранилища (Headroom Adjustment)

### Суть
Рекомендация сводится к пересчету параметра `-s malloc,SIZE` с учетом реальных накладных расходов на метаданные (около 1 КБ на объект) и резерва для ОС.
Для сервера с 32 ГБ RAM безопасный лимит составляет не более 18-20 ГБ, чтобы оставить запас под ядро, транзитное хранилище и стеки потоков.
Игнорирование накладных расходов при установке лимита (например, установка 28 ГБ на 32 ГБ RAM) гарантированно приводит к OOM при заполнении кэша миллионами мелких объектов.
Данная мера является необходимой корректировкой ожиданий клиента относительно реальной емкости сервера в условиях высокой кардинальности данных.
Это действие устраняет самообман администратора, полагающего, что параметр `-s` контролирует абсолютно всё потребление памяти процесса.

### Оценка
85

### Достоинства
Предотвращает вытеснение полезных процессов и срабатывание OOM Killer за счет честного учета всех потребителей ресурсов.
Обеспечивает необходимый запас памяти (headroom) для пиковых нагрузок и временных всплесков потребления рабочими пространствами.
Является простой и быстрой мерой стабилизации, которую можно применить немедленно до внедрения более сложных архитектурных изменений.
Повышает общую стабильность операционной системы, оставляя ресурсы для сетевого стека и дискового кэша.
Легко объясняется клиенту через простую математику умножения количества объектов на размер метаданных.

### Недостатки
Уменьшение лимита сокращает объем полезного кэша, что может незначительно снизить Hit Rate и увеличить нагрузку на бэкенд.
Мера является пассивной защитой и не решает проблемы неэффективного использования памяти (дубликатов или фрагментации).
Без устранения причины раздувания кэша (Cache Bloat) освобожденный запас памяти будет быстро заполнен метаданными мусорных объектов.
Требует перезапуска сервиса для вступления новых лимитов в силу.
Необходимо периодически пересматривать размер резерва при изменении профиля трафика или количества объектов.

## Вердикт

### Суть
Проведенный анализ показывает, что проблемы клиента `ꆜ` вызваны сложным взаимодействием архитектурной уязвимости (Cache Bloat), отсутствием предохранителей (Unbounded Transient) и неэффективностью системного окружения (glibc/4k pages).
Клиент ошибочно интерпретирует ситуацию как программную утечку памяти, пытаясь решить ее тюнингом параметров вытеснения, которые бессильны против потока уникальных метаданных.
Наивысший приоритет имеет внедрение **R⬆₁**, так как без нормализации запросов система будет продолжать генерировать мусорные данные быстрее, чем любые механизмы очистки смогут их удалять.
Критически важным для эксплуатационной надежности является немедленное применение **R⬆₂**, создающего жесткий барьер от полного исчерпания памяти и падения сервера.
Для долгосрочной стабильности и производительности на платформе Graviton настоятельно рекомендуется внедрить **R⬆₃** и рассмотреть корректировку лимитов согласно **R⬆₄**.