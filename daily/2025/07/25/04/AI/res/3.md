

# **Пошаговое руководство по реализации широковещательных push-уведомлений с использованием Firebase Cloud Messaging, Node.js, TypeScript и Docker**

## **Введение**

### **Цель документа**

Настоящий документ представляет собой исчерпывающее техническое руководство по реализации системы широковещательных push-уведомлений. Решение основано на использовании службы Firebase Cloud Messaging (FCM) и, в частности, её механизма обмена сообщениями по темам (Topic Messaging). Руководство предназначено для интеграции в существующую технологическую инфраструктуру, включающую серверную часть на Node.js с TypeScript и развертывание с использованием Docker, в точном соответствии с требованиями проекта.

### **Архитектурный обзор**

Предлагаемая архитектура состоит из двух основных компонентов, работающих согласованно для обеспечения функциональности широковещательных уведомлений.1

1. Серверный компонент: Бэкенд-приложение, разработанное на Node.js и TypeScript. Оно использует Firebase Admin SDK для выполнения привилегированных операций, таких как управление подписками устройств на темы и отправка сообщений по этим темам. Этот компонент отвечает за всю серверную логику.  
2. Клиентский компонент: Код на стороне клиента (JavaScript), работающий в веб\-браузере пользователя. Его основная задача — запрашивать у пользователя разрешение на получение уведомлений, получать от FCM уникальный регистрационный токен устройства и передавать этот токен на сервер для последующей подписки.

Высокоуровневая схема взаимодействия выглядит следующим образом: клиентское приложение получает токен и отправляет его на сервер. Сервер подписывает устройство с этим токеном на общую тему. В дальнейшем, для отправки широковетельного уведомления, сервер отправляет одно сообщение в FCM, указывая в качестве адресата эту общую тему. FCM, в свою очередь, доставляет это сообщение всем подписанным устройствам.

### **Ключевые характеристики и ограничения FCM Topic Messaging**

Для корректного понимания возможностей и ограничений выбранного подхода необходимо ознакомиться с его ключевыми характеристиками. Механизм Topic Messaging спроектирован для определённых сценариев использования, и его производительность и поведение зависят от ряда факторов. Несоответствие ожиданий и реальных возможностей технологии может привести к архитектурным просчетам на более поздних этапах проекта. В таблице ниже приведены основные параметры и ограничения данного механизма.

| Параметр | Ограничение / Характеристика | Источник(и) |
| :---- | :---- | :---- |
| Основной сценарий использования | Контент для общедоступной информации (например, новости, погода). Не предназначен для конфиденциальных данных. | 2 |
| Оптимизация | Пропускная способность, а не задержка. Для быстрой доставки отдельным устройствам или малым группам следует использовать прямую отправку по токенам. | 2 |
| Количество подписок на одну тему | Неограниченно. | 2 |
| Количество тем на один экземпляр приложения | Один экземпляр приложения может быть подписан не более чем на 2000 тем. | 2 |
| Частота запросов на подписку | Ограничена на уровне проекта. Чрезмерное количество запросов за короткий промежуток времени приведёт к ошибке 429 RESOURCE\_EXHAUSTED. | 2 |
| Лимит пакетной подписки | Один запрос subscribeToTopic через Admin SDK может содержать до 1000 регистрационных токенов. | 2 |
| Подписка с веб\-клиента | Не поддерживается. Подписки должны управляться на стороне сервера через Admin SDK. | 6 |

## **Часть 1\. Фундаментальная конфигурация Firebase**

Этот раздел описывает обязательные однократные шаги по настройке, которые необходимо выполнить в консолях Google Cloud и Firebase. Эти действия создают необходимые учётные данные и конфигурации API для функционирования приложения.

### **1.1. Настройка проекта Firebase и активация FCM**

Первым шагом является создание и конфигурирование проекта в Firebase, который будет служить центральным узлом для управления уведомлениями.

1. Перейти в Firebase console.  
2. Нажать кнопку «Добавить проект».  
3. Для создания нового проекта необходимо ввести его название. Firebase автоматически сгенерирует уникальный идентификатор проекта. Для добавления Firebase к существующему проекту Google Cloud следует выбрать его из выпадающего списка.  
4. Принять условия использования Firebase и нажать «Продолжить».  
5. Завершить процесс создания проекта, нажав «Создать проект».8

После создания проекта необходимо убедиться, что Firebase Cloud Messaging API активирован. Для веб\-приложений, использующих SDK версии 6.7.0 или более поздней, также требуется вручную активировать FCM Registration API в Google Cloud Console.9

### **1.2. Генерация и безопасное хранение ключа сервисного аккаунта**

Для того чтобы серверное приложение могло аутентифицироваться и выполнять вызовы API Firebase, ему необходима идентификация. Эту роль выполняет сервисный аккаунт — специальный тип учётной записи Google, предназначенный для не-человеческих взаимодействий, таких как взаимодействие между серверами.8

Для аутентификации сервисного аккаунта в средах, не относящихся к Google Cloud (например, при локальной разработке в Docker), используется файл с приватным ключом в формате JSON.

Процедура генерации ключа:

1. В Firebase console перейти в «Настройки проекта» → «Сервисные аккаунты».  
2. Нажать кнопку «Сгенерировать новый закрытый ключ».  
3. Подтвердить действие, нажав «Сгенерировать ключ».8

После этого будет загружен JSON-файл, содержащий учётные данные сервисного аккаунта.

Крайне важно обеспечить безопасное хранение этого файла. Он предоставляет административный доступ к вашему проекту Firebase. Категорически запрещается включать этот файл в систему контроля версий (например, Git) или размещать его в общедоступных местах. Несоблюдение этого правила представляет собой серьёзную угрозу безопасности.10 Рекомендуемый и безопасный способ использования этого ключа в среде Docker будет подробно описан в Части 4 настоящего руководства.

### **1.3. Конфигурация веб\-учётных данных (VAPID-ключ)**

Веб-интерфейс FCM использует веб\-учётные данные, называемые VAPID (Voluntary Application Server Identification), для авторизации запросов на отправку уведомлений в поддерживаемые веб\-push сервисы браузеров.9 Для подписки веб\-приложения на push-уведомления необходимо связать пару VAPID-ключей с проектом Firebase.

Процедура генерации ключа:

1. В Firebase console перейти в «Настройки проекта» → вкладка «Cloud Messaging».  
2. Прокрутить до раздела «Веб-конфигурация».  
3. На вкладке «Сертификаты Web Push» нажать «Сгенерировать пару ключей».9

Консоль отобразит уведомление о генерации пары ключей, а также строку публичного ключа и дату его добавления. Этот публичный ключ потребуется для реализации клиентской части приложения, описанной в Части 3\.

## **Часть 2\. Реализация на стороне сервера: Бэкенд на Node.js и TypeScript**

Этот раздел содержит полное описание кода и логики для серверной службы. Приложение будет разработано с использованием Node.js и TypeScript в соответствии с требованиями проекта.

### **2.1. Инициализация проекта и установка Firebase Admin SDK**

Для начала необходимо создать новый проект Node.js и установить Firebase Admin SDK.

1. Создать новую директорию для проекта и инициализировать проект Node.js с помощью команды npm init \-y.  
2. Настроить проект для работы с TypeScript, установив необходимые зависимости (typescript, @types/node, ts-node) и создав файл конфигурации tsconfig.json.  
3. Установить пакет firebase-admin и сохранить его в зависимостях проекта. Эта команда добавит Firebase Admin SDK в проект.8  
   Bash  
   npm install firebase-admin \--save

4. Установить фреймворк Express для создания API-эндпоинтов, а также соответствующие typings.  
   Bash  
   npm install express  
   npm install @types/express \--save-dev

Необходимо убедиться, что среда выполнения соответствует требованиям Admin SDK, а именно используется Node.js версии 18 или выше.8

### **2.2. Безопасная инициализация Firebase Admin SDK**

Инициализация SDK является точкой входа для всех серверных взаимодействий с Firebase. Рекомендуемый способ инициализации для сред, не относящихся к Google (например, локальная разработка или развертывание в Docker), — это использование переменной окружения GOOGLE\_APPLICATION\_CREDENTIALS.8 Этот подход позволяет отделить учётные данные от кода приложения.

SDK автоматически обнаружит эту переменную окружения, которая должна содержать путь к JSON-файлу ключа сервисного аккаунта, сгенерированному в Части 1.2.

Ниже приведён пример файла src/firebase.ts, который выполняет инициализацию SDK.

TypeScript

import { initializeApp, applicationDefault } from 'firebase-admin/app';  
import { getMessaging } from 'firebase-admin/messaging';

// Инициализация Firebase Admin SDK.  
// Метод applicationDefault() автоматически находит учётные данные  
// через переменную окружения GOOGLE\_APPLICATION\_CREDENTIALS.  
initializeApp({  
  credential: applicationDefault(),  
});

// Получение доступа к сервису Cloud Messaging.  
export const messaging \= getMessaging();

console.log('Firebase Admin SDK инициализирован успешно.');

Этот код импортирует необходимые функции, вызывает initializeApp с applicationDefault для аутентификации и экспортирует экземпляр сервиса messaging для использования в других частях приложения.

### **2.3. API-эндпоинт для регистрации клиентского устройства и подписки на тему**

Ключевое архитектурное ограничение FCM для веб\-клиентов заключается в том, что они не могут самостоятельно подписываться на темы. Эта операция должна выполняться с серверной стороны с использованием Admin SDK.6 Следовательно, необходимо создать серверный API-эндпоинт, который будет принимать регистрационный токен от клиента и выполнять подписку от его имени.

Ниже приведён пример реализации такого эндпоинта с использованием Express.js в файле src/server.ts.

TypeScript

import express from 'express';  
import { messaging } from './firebase'; // Импорт из нашего файла инициализации

const app \= express();  
app.use(express.json());

const PORT \= process.env.PORT |

| 3000;  
const BROADCAST\_TOPIC \= 'all\_users';

/\*\*  
 \* Эндпоинт для подписки устройства на широковещательную тему.  
 \* Принимает POST-запрос с телом { token: "FCM\_REGISTRATION\_TOKEN" }.  
 \*/  
app.post('/api/subscribe', async (req, res) \=\> {  
  const { token } \= req.body;

  if (\!token) {  
    return res.status(400).send({ error: 'Регистрационный токен не предоставлен.' });  
  }

  try {  
    // Выполнение подписки токена на тему  
    const response \= await messaging.subscribeToTopic(\[token\], BROADCAST\_TOPIC);

    // Admin SDK позволяет подписывать до 1000 токенов за один вызов.  
    // Проверяем количество успешных подписок.  
    if (response.successCount \> 0) {  
      console.log(\`Токен ${token} успешно подписан на тему ${BROADCAST\_TOPIC}\`);  
      res.status(200).send({ message: 'Устройство успешно подписано.' });  
    } else {  
      console.error('Ошибка подписки токена:', response.errors);  
      // Предоставление детальной информации об ошибке  
      const errorDetails \= response.errors.map(err \=\> ({ index: err.index, reason: err.reason }));  
      res.status(500).send({ error: 'Не удалось подписать устройство.', details: errorDetails });  
    }  
  } catch (error) {  
    console.error('Ошибка при вызове subscribeToTopic:', error);  
    res.status(500).send({ error: 'Внутренняя ошибка сервера при подписке.' });  
  }  
});

//... другие эндпоинты

app.listen(PORT, () \=\> {  
  console.log(\`Сервер запущен на порту ${PORT}\`);  
});

Этот код создаёт эндпоинт POST /api/subscribe, который ожидает JSON-объект с полем token. Получив токен, он вызывает метод messaging.subscribeToTopic, передавая ему массив с одним токеном и имя темы (all\_users).5

### **2.4. API-эндпоинт для отправки широковещательных уведомлений на тему**

Основная функция системы — отправка уведомлений всем подписанным пользователям. Для этого создаётся отдельный эндпоинт, который будет инициировать рассылку. В реальном приложении доступ к этому эндпоинту должен быть защищён и доступен только администраторам.

Ниже приведён пример реализации эндпоинта POST /api/broadcast в файле src/server.ts.

TypeScript

//... (код из предыдущего пункта)...

/\*\*  
 \* Эндпоинт для отправки широковещательного уведомления.  
 \* Принимает POST-запрос с телом { title: "...", body: "..." }.  
 \*/  
app.post('/api/broadcast', async (req, res) \=\> {  
  const { title, body } \= req.body;

  if (\!title ||\!body) {  
    return res.status(400).send({ error: 'Необходимо указать заголовок и тело сообщения.' });  
  }

  // Формирование объекта сообщения  
  const message \= {  
    notification: {  
      title: title,  
      body: body,  
    },  
    // Можно также добавить поле \`data\` для передачи кастомных данных  
    // data: {  
    //   customKey: 'customValue'  
    // },  
    topic: BROADCAST\_TOPIC,  
  };

  try {  
    // Отправка сообщения по теме  
    const response \= await messaging.send(message);  
    // При успешной отправке \`response\` является строкой с ID сообщения  
    console.log('Сообщение успешно отправлено:', response);  
    res.status(200).send({ message: 'Уведомление успешно отправлено.', messageId: response });  
  } catch (error) {  
    console.error('Ошибка при отправке сообщения:', error);  
    res.status(500).send({ error: 'Внутренняя ошибка сервера при отправке уведомления.' });  
  }  
});

app.listen(PORT, () \=\> {  
  console.log(\`Сервер запущен на порту ${PORT}\`);  
});

Этот эндпоинт принимает заголовок и текст сообщения, формирует объект message и отправляет его с помощью метода messaging.send.14 Поле

topic указывает FCM, что сообщение предназначено для всех устройств, подписанных на тему all\_users. Поля notification и data позволяют гибко настраивать как видимую часть уведомления, так и скрытые данные для обработки в приложении.1

## **Часть 3\. Реализация на стороне клиента: Интеграция с веб\-приложением**

Этот раздел описывает код на JavaScript, который должен выполняться в браузере пользователя. Он отвечает за получение необходимых разрешений и токенов для взаимодействия с бэкендом.

### **3.1. Конфигурация Firebase Messaging SDK и Service Worker**

Для работы с FCM в веб\-приложении необходимо установить клиентский SDK и настроить Service Worker.

1. Установить клиентский пакет firebase:  
   Bash  
   npm install firebase

2. Инициализировать Firebase в клиентском приложении. Это делается с помощью конфигурационного объекта вашего проекта, который можно найти в настройках проекта в Firebase console.  
   JavaScript  
   // src/firebase-client.js  
   import { initializeApp } from "firebase/app";  
   import { getMessaging } from "firebase/messaging";

   const firebaseConfig \= {  
     apiKey: "...",  
     authDomain: "...",  
     projectId: "...",  
     storageBucket: "...",  
     messagingSenderId: "...",  
     appId: "..."  
   };

   const app \= initializeApp(firebaseConfig);  
   export const messaging \= getMessaging(app);

3. Создать Service Worker. Файл firebase-messaging-sw.js является обязательным для получения уведомлений, когда приложение находится в фоновом режиме или закрыто.2 Его необходимо разместить в корневой директории веб\-приложения.  
   JavaScript  
   // public/firebase-messaging-sw.js  
   importScripts("https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js");  
   importScripts("https://www.gstatic.com/firebasejs/9.22.1/firebase-messaging-compat.js");

   const firebaseConfig \= {  
     apiKey: "...",  
     authDomain: "...",  
     projectId: "...",  
     storageBucket: "...",  
     messagingSenderId: "...",  
     appId: "..."  
   };

   firebase.initializeApp(firebaseConfig);  
   const messaging \= firebase.messaging();

### **3.2. Реализация потока запроса разрешений и получения токена**

Получение регистрационного токена FCM неразрывно связано с получением разрешения от пользователя. Браузер не предоставит токен, пока пользователь явно не разрешит сайту показывать уведомления.7 Таким образом, логика приложения должна включать явный запрос разрешения.

Ниже приведён пример функции, которая реализует этот поток.

JavaScript

// src/notifications.js  
import { getMessaging, getToken } from "firebase/messaging";

// VAPID-ключ, сгенерированный в Части 1.3  
const VAPID\_KEY \= "YOUR\_PUBLIC\_VAPID\_KEY\_HERE";

export async function requestNotificationPermissionAndGetToken() {  
  console.log("Запрос разрешения на показ уведомлений...");  
    
  const permission \= await Notification.requestPermission();  
    
  if (permission \=== "granted") {  
    console.log("Разрешение на уведомления получено.");  
      
    try {  
      const messaging \= getMessaging();  
      const currentToken \= await getToken(messaging, { vapidKey: VAPID\_KEY });  
        
      if (currentToken) {  
        console.log("FCM токен получен:", currentToken);  
        return currentToken;  
      } else {  
        console.log("Не удалось получить регистрационный токен. Запросите разрешение для его генерации.");  
        return null;  
      }  
    } catch (err) {  
      console.error("Произошла ошибка при получении токена.", err);  
      return null;  
    }  
  } else {  
    console.log("Пользователь отклонил запрос на уведомления.");  
    return null;  
  }  
}

Эта функция сначала вызывает Notification.requestPermission(). Если разрешение получено, она вызывает getToken, передавая ему VAPID-ключ.9 В случае успеха функция возвращает полученный токен.

### **3.3. Логика для передачи регистрационного токена на бэкенд-сервер**

После успешного получения токена его необходимо отправить на сервер для подписки на тему. Этот шаг связывает клиентскую и серверную части.

JavaScript

// src/api.js  
export async function subscribeDevice(token) {  
  try {  
    const response \= await fetch('/api/subscribe', {  
      method: 'POST',  
      headers: {  
        'Content-Type': 'application/json',  
      },  
      body: JSON.stringify({ token: token }),  
    });

    if (response.ok) {  
      console.log("Устройство успешно подписано на сервере.");  
      return true;  
    } else {  
      const errorData \= await response.json();  
      console.error("Ошибка при подписке на сервере:", errorData);  
      return false;  
    }  
  } catch (error) {  
    console.error("Сетевая ошибка при попытке подписки:", error);  
    return false;  
  }  
}

Для создания более надёжной и отказоустойчивой системы важно учитывать жизненный цикл токена. Регистрационный токен не является постоянным; он может измениться, например, при очистке данных приложения пользователем или при восстановлении приложения на новом устройстве.16 Поэтому просто получить и отправить токен один раз недостаточно.

Рекомендуется реализовать следующую логику: при каждой загрузке приложения вызывать функцию получения токена. Если токен получен, его следует сравнить с ранее сохранённым (например, в localStorage). Если токен новый или отличается от сохранённого, его необходимо отправить на сервер и обновить в локальном хранилище. Этот подход гарантирует, что на сервере всегда будет актуальный токен для данного устройства, что повышает надёжность доставки уведомлений.

## **Часть 4\. Контейнеризация и развертывание с помощью Docker**

Этот раздел посвящён контейнеризации серверного приложения Node.js/TypeScript и безопасному управлению учётными данными в среде Docker.

### **4.1. Создание Dockerfile для приложения Node.js/TypeScript**

Для создания эффективного и безопасного Docker-образа рекомендуется использовать многоэтапную сборку (multi-stage builds). Этот подход позволяет отделить среду сборки от производственной среды, что значительно уменьшает размер и повышает безопасность итогового образа.18

Ниже представлен пример Dockerfile, реализующий этот подход.

Dockerfile

\# \--- Этап сборки (Builder Stage) \---  
\# Используем образ Node.js с полным набором инструментов для сборки  
FROM node:18\-slim AS builder

WORKDIR /app

\# Копируем package.json и package-lock.json  
COPY package\*.json./

\# Устанавливаем все зависимости, включая devDependencies  
RUN npm install

\# Копируем исходный код  
COPY..

\# Компилируем TypeScript в JavaScript  
RUN npm run build

\# \--- Этап производства (Production Stage) \---  
\# Используем минималистичный образ для уменьшения размера и поверхности атаки  
FROM node:18\-alpine

WORKDIR /app

\# Копируем package.json и package-lock.json  
COPY package\*.json./

\# Устанавливаем только производственные зависимости  
RUN npm install \--omit=dev

\# Копируем скомпилированный код из этапа сборки  
COPY \--from=builder /app/dist./dist

\# Указываем порт, который будет слушать приложение  
EXPOSE 3000

\# Команда для запуска приложения  
CMD \[ "node", "dist/server.js" \]

На этапе builder устанавливаются все зависимости и происходит компиляция TypeScript. На производственном этапе в более легковесный образ node:18-alpine копируются только скомпилированные файлы и производственные зависимости.

### **4.2. Безопасное управление учётными данными в среде Docker**

Как было отмечено ранее, включение файла с ключом сервисного аккаунта непосредственно в Docker-образ является грубым нарушением безопасности.10 Любой, кто получит доступ к образу, получит и доступ к вашим учётным данным.

Отраслевым стандартом и рекомендуемой практикой является инъекция учётных данных в контейнер во время его запуска. Этот подход полностью отделяет секреты от артефакта сборки (образа). Консенсусное решение, подтверждённое многочисленными источниками, заключается в следующем 19:

1. Хранить JSON-файл с ключом на хост-машине, а не в репозитории или образе.  
2. При запуске контейнера монтировать этот файл в файловую систему контейнера с помощью Docker-тома (volume).  
3. Внутри контейнера установить переменную окружения GOOGLE\_APPLICATION\_CREDENTIALS, указав в ней путь к смонтированному файлу.

Код инициализации Admin SDK, представленный в Части 2.2, уже готов к такому подходу, так как он использует applicationDefault(), который ищет эту переменную окружения.

### **4.3. Конфигурация docker-compose.yml для локальной разработки и выполнения**

Для упрощения локальной разработки и запуска контейнера с правильной конфигурацией используется docker-compose. Файл docker-compose.yml описывает сервисы, сети и тома для приложения.

Ниже приведён пример файла docker-compose.yml, который реализует безопасный паттерн управления учётными данными.

YAML

version: '3.8'

services:  
  app:  
    \# Сборка образа из Dockerfile в текущей директории  
    build:.  
    \# Название контейнера  
    container\_name: fcm\_broadcast\_service  
    \# Проброс портов: 3000 на хосте \-\> 3000 в контейнере  
    ports:  
      \- "3000:3000"  
    \# Монтирование тома с учётными данными  
    volumes:  
      \#./service-account.json (на хосте) \-\> /app/service-account.json (в контейнере)  
      \-./service-account.json:/app/service-account.json:ro  
    \# Установка переменной окружения  
    environment:  
      \# Указываем SDK, где искать файл с ключом внутри контейнера  
      \- GOOGLE\_APPLICATION\_CREDENTIALS=/app/service-account.json

Этот файл определяет один сервис app. Ключ volumes монтирует локальный файл service-account.json в контейнер по пути /app/service-account.json в режиме только для чтения (:ro) для дополнительной безопасности. Ключ environment устанавливает переменную GOOGLE\_APPLICATION\_CREDENTIALS в это же значение.21 Для запуска приложения достаточно выполнить команду

docker-compose up \--build.

## **Часть 5\. Сквозной операционный рабочий процесс**

Этот заключительный раздел описывает последовательность действий для использования полностью реализованной системы, от подписки нового пользователя до отправки широковещательного уведомления.

### **5.1. Полный процесс подписки пользователя**

1. Пользователь открывает веб\-приложение в браузере.  
2. Клиентский скрипт определяет, что разрешение на уведомления ещё не предоставлено, и инициирует запрос, отображая стандартное диалоговое окно браузера.  
3. Пользователь нажимает «Разрешить».  
4. Клиентский скрипт, получив подтверждение, запрашивает у FCM регистрационный токен для данного устройства и браузера.  
5. После получения токена клиентский скрипт отправляет его на бэкенд-сервер, делая POST-запрос на эндпоинт /api/subscribe.  
6. Серверное приложение получает токен и с помощью Firebase Admin SDK выполняет вызов subscribeToTopic, подписывая токен на общую тему all\_users.  
7. С этого момента устройство готово к приёму широковещательных уведомлений.

### **5.2. Процедура инициирования широковещательного уведомления**

1. Авторизованный администратор или автоматизированная система инициирует отправку уведомления. Это действие формирует POST-запрос на бэкенд-эндпоинт /api/broadcast.  
2. Тело запроса содержит данные для уведомления, как минимум заголовок (title) и текст (body).  
3. Серверное приложение получает запрос и конструирует объект сообщения для FCM, указывая в качестве цели (topic) тему all\_users.  
4. Сервер вызывает метод send из Firebase Admin SDK для отправки сообщения.  
5. FCM получает запрос и осуществляет маршрутизацию и доставку уведомления на все устройства, которые в данный момент подписаны на тему all\_users и находятся онлайн.

## **Заключение**

В настоящем документе была представлена детальная пошаговая инструкция по проектированию и реализации надёжной, безопасной и масштабируемой системы широковещательных push-уведомлений. Решение полностью соответствует заявленным технологическим требованиям проекта, используя Firebase Cloud Messaging, Node.js, TypeScript и Docker.

Ключевые архитектурные решения, такие как внедрение серверно-опосредованной модели подписки на темы для веб\-клиентов и использование инъекции учётных данных через переменные окружения и тома Docker, были приняты на основе официальной документации и общепринятых отраслевых практик. Такой подход обеспечивает не только функциональность, но и высокий уровень безопасности и поддерживаемости системы.

Реализованная система полностью покрывает требования по отправке уведомлений большой аудитории пользователей и предоставляет прочный фундамент для дальнейшего развития функционала.

#### **Works cited**

1. Firebase Cloud Messaging, accessed July 26, 2025, [https://firebase.google.com/docs/cloud-messaging](https://firebase.google.com/docs/cloud-messaging)  
2. Send messages to topics on Web/JavaScript | Firebase Cloud Messaging \- Google, accessed July 26, 2025, [https://firebase.google.com/docs/cloud-messaging/js/topic-messaging](https://firebase.google.com/docs/cloud-messaging/js/topic-messaging)  
3. Cloud Messaging | FlutterFire, accessed July 26, 2025, [https://firebase.flutter.dev/docs/messaging/usage/](https://firebase.flutter.dev/docs/messaging/usage/)  
4. Cloud Messaging \- Firebase Admin SDK for PHP \- Read the Docs, accessed July 26, 2025, [https://firebase-php.readthedocs.io/en/7.15.0/cloud-messaging.html](https://firebase-php.readthedocs.io/en/7.15.0/cloud-messaging.html)  
5. Manage topics from the server | Firebase Cloud Messaging \- Google, accessed July 26, 2025, [https://firebase.google.com/docs/cloud-messaging/manage-topics](https://firebase.google.com/docs/cloud-messaging/manage-topics)  
6. Web Firebase Cloud Messaging \- How to subscribe to a topic from client side? \[duplicate\], accessed July 26, 2025, [https://stackoverflow.com/questions/56430461/web-firebase-cloud-messaging-how-to-subscribe-to-a-topic-from-client-side](https://stackoverflow.com/questions/56430461/web-firebase-cloud-messaging-how-to-subscribe-to-a-topic-from-client-side)  
7. How to get a registration token for Firebase Cloud Messaging without requesting permission for notifications? \- Stack Overflow, accessed July 26, 2025, [https://stackoverflow.com/questions/43577614/how-to-get-a-registration-token-for-firebase-cloud-messaging-without-requesting](https://stackoverflow.com/questions/43577614/how-to-get-a-registration-token-for-firebase-cloud-messaging-without-requesting)  
8. Add the Firebase Admin SDK to your server \- Google, accessed July 26, 2025, [https://firebase.google.com/docs/admin/setup](https://firebase.google.com/docs/admin/setup)  
9. Set up a JavaScript Firebase Cloud Messaging client app \- Google, accessed July 26, 2025, [https://firebase.google.com/docs/cloud-messaging/js/client](https://firebase.google.com/docs/cloud-messaging/js/client)  
10. Best practices for managing service account keys | IAM Documentation \- Google Cloud, accessed July 26, 2025, [https://cloud.google.com/iam/docs/best-practices-for-managing-service-account-keys](https://cloud.google.com/iam/docs/best-practices-for-managing-service-account-keys)  
11. Best practices for using service accounts | IAM Documentation \- Google Cloud, accessed July 26, 2025, [https://cloud.google.com/iam/docs/best-practices-service-accounts](https://cloud.google.com/iam/docs/best-practices-service-accounts)  
12. Firebase Admin Node.js SDK \- GitHub, accessed July 26, 2025, [https://github.com/firebase/firebase-admin-node](https://github.com/firebase/firebase-admin-node)  
13. How Application Default Credentials works | Authentication \- Google Cloud, accessed July 26, 2025, [https://cloud.google.com/docs/authentication/application-default-credentials](https://cloud.google.com/docs/authentication/application-default-credentials)  
14. Build app server send requests | Firebase Cloud Messaging \- Google, accessed July 26, 2025, [https://firebase.google.com/docs/cloud-messaging/send-message](https://firebase.google.com/docs/cloud-messaging/send-message)  
15. The Ultimate Guide To Firebase Cloud Messaging (FCM) \- Novu, accessed July 26, 2025, [https://novu.co/blog/the-ultimate-guide-to-firebase-cloud-messaging-fcm/](https://novu.co/blog/the-ultimate-guide-to-firebase-cloud-messaging-fcm/)  
16. Best practices for FCM registration token management | Firebase Cloud Messaging \- Google, accessed July 26, 2025, [https://firebase.google.com/docs/cloud-messaging/manage-tokens](https://firebase.google.com/docs/cloud-messaging/manage-tokens)  
17. Managing Cloud Messaging Tokens \- The Firebase Blog, accessed July 26, 2025, [https://firebase.blog/posts/2023/04/managing-cloud-messaging-tokens/](https://firebase.blog/posts/2023/04/managing-cloud-messaging-tokens/)  
18. Building best practices \- Docker Docs, accessed July 26, 2025, [https://docs.docker.com/build/building/best-practices/](https://docs.docker.com/build/building/best-practices/)  
19. Simple way to pass gcloud credentials to a docker container for Terraform google provider, accessed July 26, 2025, [https://www.reddit.com/r/googlecloud/comments/zhbfil/simple\_way\_to\_pass\_gcloud\_credentials\_to\_a\_docker/](https://www.reddit.com/r/googlecloud/comments/zhbfil/simple_way_to_pass_gcloud_credentials_to_a_docker/)  
20. Authentication on GCP with Docker: Application Default Credentials | Dataminded \- Medium, accessed July 26, 2025, [https://medium.com/datamindedbe/authentication-on-gcp-application-default-credentials-477879e31cb5](https://medium.com/datamindedbe/authentication-on-gcp-application-default-credentials-477879e31cb5)  
21. gsutil \+ docker \+ GOOGLE\_APPLICATION\_CREDENTIALS help \#1463 \- GitHub, accessed July 26, 2025, [https://github.com/GoogleCloudPlatform/gsutil/issues/1463](https://github.com/GoogleCloudPlatform/gsutil/issues/1463)  
22. Set environment variables \- Docker Docs, accessed July 26, 2025, [https://docs.docker.com/compose/how-tos/environment-variables/set-environment-variables/](https://docs.docker.com/compose/how-tos/environment-variables/set-environment-variables/)  
23. How to set environment variable into docker container using docker-compose, accessed July 26, 2025, [https://stackoverflow.com/questions/50238621/how-to-set-environment-variable-into-docker-container-using-docker-compose](https://stackoverflow.com/questions/50238621/how-to-set-environment-variable-into-docker-container-using-docker-compose)