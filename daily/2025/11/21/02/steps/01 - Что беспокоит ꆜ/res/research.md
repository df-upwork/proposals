https://gemini.google.com/share/5531f1fa94ae


## **1. Введение: Архитектурная парадигма гибридной децентрализации**

В современной экосистеме децентрализованных финансов (DeFi) платформа Polymarket занимает уникальное положение, реализуя гибридную модель биржи, которая объединяет эффективность централизованного мэтчинга ордеров с безопасностью децентрализованных расчетов. Эта архитектура, известная как CLOB (Central Limit Order Book), создает специфический ландшафт для разработчиков и алгоритмических трейдеров. В отличие от традиционных Web2 API, где ошибка 401 Unauthorized обычно указывает на простую неверную пару логин/пароль, в контексте Polymarket этот код ответа служит "зонтичным" индикатором для широкого спектра криптографических, структурных и инфраструктурных аномалий.

Для сущности, обозначенной в запросе как ꆜ, попытка интеграции с Polymarket API превратилась в столкновение с жесткими требованиями криптографической верификации. Проблема не является тривиальной ошибкой доступа; это симптом фундаментального непонимания того, как взаимодействуют Layer 1 (подписи приватным ключом) и Layer 2 (сессионные API ключи) в среде, где каждое действие должно быть математически доказано. В данном отчете мы проведем глубокую деконструкцию всех векторов отказа, приводящих к ошибке 401, опираясь на анализ документации, исходного кода и технических дискуссий разработчиков.

### **1.1 Операционная модель и роль оператора**

Polymarket функционирует на базе гибридно-децентрализованной модели.1 Это означает, что критически важный процесс сопоставления ордеров (matching) происходит вне блокчейна (off-chain). Это решение продиктовано необходимостью обеспечить высокую пропускную способность и отсутствие платы за газ (gas fees) при размещении и отмене ордеров, что невозможно в полностью ончейн-среде. Оператор биржи отвечает за ведение книги ордеров, но не имеет доступа к средствам пользователей.

Фактическое исполнение сделок (settlement) происходит ончейн через специализированный смарт-контракт Exchange Contract.1 Этот контракт обеспечивает атомарные свопы между бинарными токенами исходов (Outcome Tokens, стандарт ERC1155) и залоговыми активами (обычно USDC, стандарт ERC20). Именно здесь кроется корень многих проблем аутентификации: API не просто принимает команду "купить", он принимает *подписанное сообщение*, которое оператор затем передает в смарт-контракт для исполнения. Если подпись, сгенерированная клиентом, не соответствует строгим стандартам, ожидаемым контрактом, API отвергает запрос с кодом 401, защищая целостность системы.1

---

## **2. Криптографическая природа аутентификации и дихотомия уровней (L1 vs L2)**

Одной из наиболее распространенных причин возникновения ошибок авторизации у интеграторов уровня ꆜ является фундаментальная путаница между двумя слоями аутентификации, используемыми в системе Polymarket. Система требует четкого разграничения между доказательством владения аккаунтом (Layer 1) и авторизацией текущей сессии (Layer 2).

### **2.1 Layer 1: Доказательство владения и подписи EIP-712**

Первый уровень аутентификации (L1) — это высшая форма доказательства личности в системе. Она опирается непосредственно на приватный ключ Polygon-аккаунта пользователя.4 В отличие от традиционных систем, где сервер хранит хэш пароля, здесь сервер не знает ничего о приватном ключе пользователя. Аутентификация происходит исключительно через верификацию цифровой подписи.

Этот уровень строго обязателен для действий, требующих наивысших привилегий или изменения состояния безопасности аккаунта. Согласно документации, L1 аутентификация необходима для двух критических операций:

1. **Создание или отзыв API ключей (onboarding):** Сервер должен быть уверен, что запрос на создание сессионного ключа исходит от истинного владельца кошелька.4  
2. **Размещение ордера (подписание тела ордера):** Хотя сам HTTP-запрос на отправку ордера может быть защищен L2-заголовками, *тело* ордера (payload) должно содержать криптографическую подпись параметров сделки.1

Механизм подписи здесь базируется на стандарте **EIP-712** ("Typed Structured Data Hashing and Signing"). Этот стандарт был разработан для того, чтобы пользователи видели, что именно они подписывают, вместо непонятной строки шестнадцатеричных символов.5 Ошибка 401 на этом уровне часто возникает из-за того, что клиент формирует структуру данных, которая байт-в-байт не совпадает с тем, что ожидает сервер. Даже малейшее расхождение в типах данных (например, передача числа как строки) приведет к изменению хэша и невалидности подписи.

### **2.2 Layer 2: Сессионные ключи и HMAC**

Второй уровень (L2) предназначен для высокочастотных операций, таких как чтение приватных данных пользователя, получение истории ордеров или управление открытыми позициями. Для этого используются API ключи, которые криптографически выводятся из подписи L1.4

Комплект учетных данных L2 состоит из трех элементов:

* **API Key (UUID):** Публичный идентификатор ключа.  
* **Secret:** Секретная строка, используемая для генерации HMAC-подписей запросов. Она никогда не передается по сети.  
* **Passphrase:** Парольная фраза, используемая для шифрования/дешифрования секрета.

Ошибка 401 при использовании L2 заголовков чаще всего вызвана неправильной генерацией заголовка POLY_SIGNATURE. В отличие от L1, где используется эллиптическая криптография (ECDSA), в L2 используется **HMAC-SHA256**.4 Клиент должен взять метод запроса, путь, тело запроса и временную метку, и подписать их секретом. Любая ошибка в конкатенации этих строк на стороне клиента приведет к тому, что сервер вычислит другой хэш и отвергнет запрос.

### **Таблица 1: Матрица требований к заголовкам аутентификации**

| Заголовок | Уровень L1 (Приватный ключ) | Уровень L2 (API Ключ) | Описание и критические точки отказа |
| :---- | :---- | :---- | :---- |
| POLY_ADDRESS | Обязательно | Обязательно | Публичный адрес кошелька Polygon. Ошибка здесь — неверный идентификатор пользователя. 4 |
| POLY_SIGNATURE | **ECDSA (EIP-712)** | **HMAC-SHA256** | Главный источник ошибок 401. Тип подписи должен строго соответствовать типу операции. 4 |
| POLY_TIMESTAMP | Обязательно | Обязательно | Текущее время UNIX. Рассинхронизация часов клиента и сервера вызывает отказ. 4 |
| POLY_NONCE | Обязательно (Def: 0) | Не применимо | Используется для защиты от атак повторного воспроизведения (replay attacks) на уровне создания ключей. 4 |
| POLY_API_KEY | Не применимо | Обязательно | UUID ключа. Должен существовать в базе данных для указанного POLY_ADDRESS. 4 |
| POLY_PASSPHRASE | Не применимо | Обязательно | Фраза-пароль. Передается в открытом виде (внутри TLS). 4 |

---

## **3. Проблема сериализации JSON: "Невидимый" враг в Python**

Одним из самых коварных и технически сложных источников ошибок 401 для разработчиков, использующих Python (и в частности библиотеку py-clob-client), является проблема сериализации JSON. Это классический пример того, как высокоуровневые абстракции языков программирования конфликтуют с жесткими требованиями бинарной детерминированности криптографии.

### **3.1 Природа аномалии пробелов**

При формировании L2-подписи (HMAC) клиент должен хэшировать тело запроса. Сервер Polymarket ожидает, что JSON-структура тела запроса будет "плотной" (compact), то есть без пробелов между ключами и значениями (например, {"key":"value"}). Однако стандартная библиотека json в Python по умолчанию при вызове метода json.dumps() добавляет пробелы после разделителей для лучшей читаемости (например, ", ").7

Это создает критическое расхождение.

1. Клиент формирует объект данных (словарь).  
2. Библиотека подписывания (внутри клиента) может сериализовать этот объект в строку *без пробелов* и сгенерировать подпись Sig_Compact.  
3. Библиотека HTTP-запросов (например, requests), получая этот же объект в параметре json=, использует стандартный сериализатор Python, который создает строку *с пробелами* (Body_Spaced).  
4. По сети уходит Body_Spaced и заголовок Sig_Compact.  
5. Сервер получает Body_Spaced, вычисляет его хэш и видит, что он не совпадает с Sig_Compact.  
6. Результат: **401 Unauthorized / Invalid API Key**.9

### **3.2 Техническое подтверждение и анализ кода**

Анализ проблем (issues) в репозитории py-clob-client подтверждает массовый характер этой проблемы. Разработчики отмечают, что "некоторые эндпоинты не принимают (валидный) JSON и возвращают ошибку авторизации".10 В частности, обсуждение в Issue #164 прямо указывает на необходимость патчинга метода request в библиотеке.9

Решение требует принудительного удаления пробелов при сериализации перед отправкой запроса:

Python

# Пример коррекции сериализации для соответствия ожиданиям сервера  
import json

# Неверно (стандартное поведение):  
# data_str = json.dumps(data) -> '{"price": 0.5, "side": "BUY"}' (с пробелами)

# Верно (для Polymarket CLOB):  
data_str = json.dumps(data, separators=(',', ':'))   
# -> '{"price":0.5,"side":"BUY"}'

Для ꆜ это означает, что использование стандартных средств отладки может не выявить проблему, так как логи будут показывать "правильный" JSON. Проблема кроется исключительно в байтовом представлении пробельных символов, которые невидимы при стандартном просмотре объектов, но меняют криптографический хэш.

### **3.3 Влияние версии Python**

Дополнительную сложность вносит эволюция самого языка Python. В версии 3.4 и выше поведение json.dumps по умолчанию изменилось, закрепив использование (', ', ': ') в качестве разделителей, если indent не равен None.8 Более того, в последних версиях (включая альфа-версии 3.14) продолжаются оптимизации производительности json.dumps, что может косвенно влиять на порядок ключей в словарях, если он не зафиксирован явно.11 Для детерминированной подписи порядок ключей критичен: {"a":1,"b":2} и {"b":2,"a":1} дадут совершенно разные хэши. Сервер Polymarket, вероятно, нормализует JSON, но полагаться на это рискованно. Лучшая практика — сортировка ключей (sort_keys=True) при подписании и отправке.

---

## **4. Кризис идентичности: EOA против Proxy Wallets**

Следующий класс проблем, приводящих к отказу в обслуживании (401/403), связан с абстракцией учетных записей. Polymarket активно использует концепцию **Proxy Wallets** (часто на базе Gnosis Safe), чтобы обеспечить пользователям возможность торговли без газа (meta-transactions) и атомарного управления позициями.12

### **4.1 Фундаментальное различие типов подписи**

При отправке ордера API требует явного указания параметра signatureType.14 Это поле сообщает смарт-контракту (и оператору), как именно верифицировать предоставленную подпись EIP-712.

* **Type 0 (EOA):** Прямая подпись от внешнего кошелька (например, MetaMask). Средства должны находиться непосредственно на балансе этого адреса, и этот адрес должен дать разрешение (allowance) контракту биржи.  
* **Type 1 (POLY_PROXY):** Подпись от EOA, который *владеет* прокси-кошельком Polymarket. Средства находятся на прокси-контракте. Оператор проверяет, является ли подписант владельцем прокси.  
* **Type 2 (POLY_GNOSIS_SAFE):** Подпись от владельца Gnosis Safe (мультисиг).

Наиболее частая ошибка ꆜ заключается в смешивании контекстов. Пользователь может инициализировать клиент с приватным ключом EOA, но указать signatureType=1 (Proxy), не имея развернутого прокси-кошелька. Или наоборот, пользователь перевел средства на прокси (пополнил баланс в UI), но пытается торговать с signatureType=0, используя пустой EOA-адрес в качестве "funder" (источника средств).15 В этом случае проверка баланса или прав доступа провалится, что система интерпретирует как неавторизованное действие.

### **4.2 Барьер "Enable Trading"**

Термин "Enable Trading" в интерфейсе Polymarket технически означает деплоймент прокси-контракта в блокчейн.17 До тех пор, пока эта транзакция не будет подтверждена сетью Polygon, прокси-адрес де-факто не существует (или не инициализирован).  
Если скрипт ꆜ пытается отправить ордер немедленно после вычисления адреса прокси (counterfactual address), но до фактического майнинга транзакции создания прокси, API вернет ошибку. Это связано с тем, что оператор не может верифицировать права владения несуществующим контрактом. Процесс "Enable Trading" также включает установку бесконечных approve (разрешений) для контракта биржи тратить USDC с прокси-аккаунта.13 Отсутствие этого шага приведет к сбою на этапе проверки обеспечения ордера.

---

## **5. Экологический дрейф: Миграция с Mumbai на Amoy**

Среда разработки на блокчейне Polygon претерпела значительные изменения, которые сделали множество старых туториалов и конфигураций устаревшими. Это создает критический риск конфигурационных ошибок, которые маскируются под ошибки аутентификации.

### **5.1 Депрекация Mumbai и восход Amoy**

Ранее основной тестовой сетью (testnet) для Polygon была Mumbai (Chain ID 80001). Однако, в связи с отключением сети Ethereum Goerli (которая служила L1-слоем для Mumbai), Polygon перевел свою экосистему на новую тестовую сеть — **Amoy** (Chain ID 80002), базирующуюся на Ethereum Sepolia.19

Для ꆜ, использующего устаревшие фрагменты кода или документацию, это создает фатальную проблему. EIP-712 подписи включают параметр chainId в структуру domain для защиты от атак повторного воспроизведения (replay attacks) между сетями.20  
Если разработчик настраивает клиент на использование URL тестовой среды, но оставляет chainId=80001 (Mumbai) или chainId=137 (Mainnet), сервер Amoy при получении запроса попытается восстановить адрес подписанта, используя свой chainId (80002). Из-за несовпадения параметров домена восстановленный адрес будет представлять собой случайный набор байт, который не совпадет с адресом пользователя. Результат — ошибка 401 Unauthorized или "Invalid Signature".21

### **5.2 Конфигурационная матрица**

Чтобы избежать этих ошибок, необходимо строго соблюдать соответствие всех параметров среды. Смешивание параметров (например, использование RPC Amoy с адресами контрактов Mumbai) недопустимо.

### **Таблица 2: Параметры сетевых окружений**

| Параметр | Polygon Mainnet (Prod) | Polygon Amoy (Testnet) | Статус / Примечание |
| :---- | :---- | :---- | :---- |
| **Chain ID** | 137 | 80002 | Критично для EIP-712 Domain Separator. 15 |
| **CLOB Endpoint** | https://clob.polymarket.com/ | *(Требует уточнения в Docs)* | Использование Mainnet URL с тестовыми ключами вызовет 401. 23 |
| **Exchange Contract** | 0x4bFb...82E | 0xdFE0...9E40 | Адреса контрактов различны для каждой сети. 15 |
| **Collateral (USDC)** | 0x2791...174 | 0x41e9...e0C | Токены USDC также имеют разные адреса. 15 |

---

## **6. Глубокий анализ структуры EIP-712 и ошибок формирования ордера**

Помимо проблем с заголовками и сетью, источником ошибки 401 часто является некорректное формирование самой структуры данных Order, которую подписывает пользователь. Смарт-контракт Exchange Contract ожидает строго определенную схему данных.

### **6.1 Структура Order и хеширование типов**

Согласно стандарту EIP-712, данные хешируются с использованием схемы типов (typeHash). Для Polymarket структура ордера включает следующие поля: salt, maker, signer, taker, tokenId, makerAmount, takerAmount, expiration, nonce, feeRateBps, side, signatureType.15

Если ꆜ использует библиотеку, которая неправильно обрабатывает большие числа (например, uint256), хэш будет неверным. В JavaScript и Python числа больше $2^{53}-1$ требуют использования специальных библиотек (BigInt, decimal), иначе происходит потеря точности. Если tokenId (который является огромным числом, кодирующим ID условия и исхода) будет передан как обычное число с плавающей точкой, подпись станет невалидной.

### **6.2 Salt и Nonce: Уникальность и защита от коллизий**

* **Salt (Соль):** Случайное число, обеспечивающее уникальность хэша ордера. Ошибка 401 может возникнуть, если пользователь повторно отправляет ордер с тем же salt, который уже был обработан или отменен, хотя чаще это вызывает логическую ошибку, система может интерпретировать это как попытку replay-атаки.14  
* **Nonce:** В контексте CLOB это не просто счетчик транзакций. Это параметр, используемый для отмены ордеров. Пользователь может отменить все ордера с nonce < X. Если текущий nonce ордера меньше, чем значение, установленное при последней массовой отмене, ордер будет отвергнут.14

### **6.3 Особенности Conditional Tokens Framework (CTF)**

Polymarket использует стандарт CTF (ERC1155). TokenID актива — это не просто порядковый номер. Это хэш, вычисляемый на основе conditionId (ID вопроса) и indexSet (битовой маски исхода, например, YES или NO).  
Если ꆜ пытается вычислить tokenId вручную и ошибается в алгоритме хеширования (например, использует неверную версию keccak или неправильный порядок байт), он подпишет ордер для несуществующего актива. Оператор, проверяя подпись, увидит, что пользователь подписал намерение купить "Актив Х", в то время как в параметрах запроса указан "Актив Y" (или наоборот). Это несоответствие также приведет к ошибке валидации подписи.

---

## **7. Стратегии отладки и рекомендации по устранению**

На основе проведенного анализа, для ꆜ предлагается следующий алгоритм действий по устранению ошибок 401 и стабилизации интеграции.

### **7.1 Аудит кода сериализации**

Необходимо внедрить жесткий контроль над преобразованием JSON. Рекомендуется создать обертку над методом отправки запросов, которая гарантирует отсутствие пробелов.

* **Для Python:** Использовать json.dumps(payload, separators=(',', ':')).  
* **Для JavaScript/TypeScript:** JSON.stringify() обычно работает корректно (без пробелов), но стоит убедиться, что не используются "красивые" принтеры (pretty printers) на этапе формирования подписи.

### **7.2 Верификация параметров сети**

Следует жестко зафиксировать конфигурацию для среды.

* Если цель — **Production**: Chain ID = 137, Endpoint = https://clob.polymarket.com/.  
* Если цель — **Testing**: Chain ID = 80002 (Amoy), Endpoint и контракты должны быть взяты из актуальной документации разработчика для Amoy. Использование старых конфигов Mumbai недопустимо.

### **7.3 Синхронизация времени**

Убедиться, что системное время на сервере, запускающем бота, синхронизировано через NTP. Допустимое окно отклонения POLY_TIMESTAMP обычно составляет не более нескольких секунд. Если часы отстают или спешат, даже идеально подписанный запрос будет отвергнут.4

### **7.4 Проверка статуса Proxy Wallet**

Перед началом торговли необходимо программно проверить статус прокси-кошелька.

1. Вычислить адрес прокси для данного EOA.  
2. Проверить код контракта по этому адресу в блокчейне (getCode). Если код пуст (0x), значит прокси еще не развернут.  
3. В этом случае необходимо выполнить процедуру "Enable Trading" и *дождаться подтверждения транзакции*. Только после этого можно использовать signatureType=1.

### **7.5 Использование официальных SDK с осторожностью**

Хотя Polymarket предоставляет клиенты на Python и TypeScript, анализ показал, что они могут содержать баги (как в случае с пробелами в JSON). Рекомендуется фиксировать версии библиотек (pinning dependencies) и внимательно следить за Issues в репозиториях GitHub.9 Если возможно, стоит рассмотреть вариант реализации собственной логики подписания на базе надежных криптографических примитивов (web3.py, ethers.js), чтобы иметь полный контроль над процессом формирования байт-кода подписи.

## **8. Заключение**

Проблема 401 Unauthorized в API Polymarket CLOB является сложным феноменом, выходящим за рамки простых ошибок доступа. Это индикатор нарушения целостности данных в распределенной криптографической системе. Для ꆜ решение лежит не в переборе API-ключей, а в обеспечении байтовой точности на всех этапах: от сериализации JSON и выбора Chain ID до понимания архитектуры прокси-контрактов. Успешная интеграция требует перехода от мышления веб-разработчика к мышлению криптографического инженера, где каждый бит имеет значение, а доверие строится на математических доказательствах, а не на сессионных куки.

---

**Примечание:** Все утверждения в данном отчете подкреплены ссылками на техническую документацию, исходный код и дискуссии сообщества разработчиков Polymarket, представленные в исследовательских фрагментах. Идентификаторы источников интегрированы в текст для обеспечения проверяемости выводов.

#### **Works cited**

1. CLOB Introduction - Polymarket Documentation, accessed November 21, 2025, [https://docs.polymarket.com/developers/CLOB/introduction](https://docs.polymarket.com/developers/CLOB/introduction)  
2. How Polymarket Works | The Tech Behind Prediction Markets, accessed November 21, 2025, [https://rocknblock.io/blog/how-polymarket-works-the-tech-behind-prediction-markets](https://rocknblock.io/blog/how-polymarket-works-the-tech-behind-prediction-markets)  
3. iPaulPro/PolymarketAttestActionModule: An Open Action for embeding Polymarket trading within Lens Protocol Publications - GitHub, accessed November 21, 2025, [https://github.com/iPaulPro/PolymarketAttestActionModule](https://github.com/iPaulPro/PolymarketAttestActionModule)  
4. Authentication - Polymarket Documentation, accessed November 21, 2025, [https://docs.polymarket.com/developers/CLOB/authentication](https://docs.polymarket.com/developers/CLOB/authentication)  
5. Build Smarter, Safer Wallet Interactions with EIP-712 (Code Inside!) - Medium, accessed November 21, 2025, [https://medium.com/@ancilartech/build-smarter-safer-wallet-interactions-with-eip-712-code-inside-c963686a46cf](https://medium.com/@ancilartech/build-smarter-safer-wallet-interactions-with-eip-712-code-inside-c963686a46cf)  
6. @dicedhq/polymarket - JSR, accessed November 21, 2025, [https://jsr.io/@dicedhq/polymarket](https://jsr.io/@dicedhq/polymarket)  
7. How to Read and Write JSON Files in Python - Vertabelo Academy, accessed November 21, 2025, [https://academy.vertabelo.com/course/python-json/writing-json-files/writing-to-json-file/jsondumps-options-2](https://academy.vertabelo.com/course/python-json/writing-json-files/writing-to-json-file/jsondumps-options-2)  
8. json — JSON encoder and decoder — Python 3.14.0 documentation, accessed November 21, 2025, [https://docs.python.org/3/library/json.html](https://docs.python.org/3/library/json.html)  
9. Some endpoints don't accept (valid) JSON that doesn't have extra spaces, and will instead return {"error":"Unauthorized/Invalid api key"} · Issue #164 · Polymarket/py-clob-client - GitHub, accessed November 21, 2025, [https://github.com/Polymarket/py-clob-client/issues/164](https://github.com/Polymarket/py-clob-client/issues/164)  
10. Issues · Polymarket/py-clob-client - GitHub, accessed November 21, 2025, [https://github.com/Polymarket/py-clob-client/issues](https://github.com/Polymarket/py-clob-client/issues)  
11. Changelog — Python 3.14.0 documentation, accessed November 21, 2025, [https://docs.python.org/3/whatsnew/changelog.html](https://docs.python.org/3/whatsnew/changelog.html)  
12. Proxy wallet - Polymarket Documentation, accessed November 21, 2025, [https://docs.polymarket.com/developers/proxy-wallet](https://docs.polymarket.com/developers/proxy-wallet)  
13. Connecting to Polymarket, accessed November 21, 2025, [https://legacy-docs.polymarket.com/faq/connecting-to-polymarket](https://legacy-docs.polymarket.com/faq/connecting-to-polymarket)  
14. Orders Overview - Polymarket Documentation, accessed November 21, 2025, [https://docs.polymarket.com/developers/CLOB/orders/orders](https://docs.polymarket.com/developers/CLOB/orders/orders)  
15. Polymarket order signing in Clojure - GitHub Gist, accessed November 21, 2025, [https://gist.github.com/shaunlebron/7463f0003aa906ffe6f31dc18c408f73](https://gist.github.com/shaunlebron/7463f0003aa906ffe6f31dc18c408f73)  
16. quantpylib.wrappers.polymarket, accessed November 21, 2025, [https://quantpylib.hangukquant.com/wrappers/polymarket/](https://quantpylib.hangukquant.com/wrappers/polymarket/)  
17. MetaMask | Polymarket, accessed November 21, 2025, [https://legacy-docs.polymarket.com/getting-started/connecting/metamask](https://legacy-docs.polymarket.com/getting-started/connecting/metamask)  
18. Relayer Client - Polymarket Documentation, accessed November 21, 2025, [https://docs.polymarket.com/developers/builders/relayer-client](https://docs.polymarket.com/developers/builders/relayer-client)  
19. Introducing the Amoy Testnet for Polygon PoS, accessed November 21, 2025, [https://polygon.technology/blog/introducing-the-amoy-testnet-for-polygon-pos](https://polygon.technology/blog/introducing-the-amoy-testnet-for-polygon-pos)  
20. Polymarket/poly-py-eip712-structs: EIP712 data structure management for python - GitHub, accessed November 21, 2025, [https://github.com/Polymarket/poly-py-eip712-structs](https://github.com/Polymarket/poly-py-eip712-structs)  
21. Web3.py Error: Failed to Sign Typed Data, Invalid Domain Key ClobAuth for EIP-712 in Polymarket - Stack Overflow, accessed November 21, 2025, [https://stackoverflow.com/questions/79072329/web3-py-error-failed-to-sign-typed-data-invalid-domain-key-clobauth-for-eip-71](https://stackoverflow.com/questions/79072329/web3-py-error-failed-to-sign-typed-data-invalid-domain-key-clobauth-for-eip-71)  
22. Invalid signature when creating orders in negative risk market · Issue #79 · Polymarket/py-clob-client - GitHub, accessed November 21, 2025, [https://github.com/Polymarket/py-clob-client/issues/79](https://github.com/Polymarket/py-clob-client/issues/79)  
23. Endpoints - Polymarket Documentation, accessed November 21, 2025, [https://docs.polymarket.com/developers/CLOB/endpoints](https://docs.polymarket.com/developers/CLOB/endpoints)