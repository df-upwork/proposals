1) Да, вы в целом верно перечислили основные возможные причины why a screen of a Python/Flask application shows outdated data from an SQLAlchemy database: «potential stale ORM instances, improper session handling with SQLAlchemy, or caching issues».
Прокомментирую эти причины чуть глубже, по моему опыту:
1.1) The most popular reason: objects are requested from the DB and stored somewhere (for example, in a global scope of the the application's memory or in a cache), and then upon subsequent access, the application reads the already existing objects instead of requesting them again from the DB.
1.2) The second most popular reason — it is the incorrect use of the same session between different HTTP requests.
In most cases, it is best to create a separate session for processing each HTTP request to the Flask application.  
After the work is completed (for example, when it is time to return a response to the client), this session is explicitly committed (commit) or rolled back (rollback), depending on whether the write operations to the database were successful, and then closed and «cleared».
1.3) From the last sentence of the previous paragraph follows another reason: the changes in the session may be not being committed (no `commit()` or `flush()` is called at the right time).   
1.4) The reason in using a multithreaded or multiprocess environment: a wrong configuration of `scoped_session`, where several requests are processed in parallel (for example, in gunicorn/uwsgi), the SQLAlchemy session can be incorrectly «shared» between different threads or processes. 
2) «Despite using `db.session.remove()` and `db.session.expire_all()` to refresh sessions and ORM instances, the problem persists»
Эти методы сами по себе не гарантируют полную «перезагрузку» данных или пересоздание сессии на каждом запросе.  
2.1) `db.session.remove()` удаляет (отвязывает) текущую сессию из текущего контекста (например, из `scoped_session`). 
Однако если где-то в коде или в памяти (например, в глобальной переменной, в singleton-объекте или в каком-то кэше) хранятся объекты, уже полученные из старой сессии, они не станут автоматически «свежими». 
А при последующем доступе к этим объектам приложение может снова использовать «застрявшие» экземпляры, если не было настроено полноценного механизма пересоздания сессии и повторного чтения данных из базы.
2.2) `db.session.expire_all()` делает «протухшими» все объекты, находящиеся в текущей сессии, чтобы при следующем обращении к их полям SQLAlchemy повторно подтягивала данные из базы. 
Но если в коде по-прежнему используются те же объекты между запросами или (что ещё хуже) вообще тот же объект сессии (без завершения запроса, без полного перезапуска), это не спасает от ситуации, когда в следующий HTTP-запрос придёт «недобитая» сессия или старые объекты.
2.3) Хочу особо подчеркнуть: даже если попытаться «принудительно обновить» эти объекты вызовами `remove()` и `expire_all()`, но при этом не пересоздавать сессию для каждого запроса (или не выгружать из памяти старые объекты), проблема останется.  
По моему опыту, это как раз классический кейс, когда разработчики думают, что вызов `db.session.remove()` или `db.session.expire_all()` решит все проблемы, а на деле сессия может по-прежнему неправильно «шариться» между потоками или HTTP-запросами, либо где-то в коде остаётся ссылка на старую сессию.  
3) «The data updates correctly when other functions modify the database»
Так происходит потому, что эти «other functions» могут использовать новый SQLAlchemy-сессионный объект или как минимум корректно завершают работу сессии (делают `commit()` / `rollback()`) и тем самым «сбрасывают» кэш ORM.  
Также они могут явно вызывать `flush()`, из-за чего вся ранее кешированная информация сбрасывается или освежается из базы данных.  
В результате, когда вы в основном сценарии «просто смотрите» на данные и их не видите актуальными, это может быть из-за того, что сессия продолжает работать «по-старому» (кешируя объекты, не делая нужного `commit()` или повторного запроса к БД). 
Но при выполнении другой функции (которая правильно закрывает/пересоздаёт сессию или вызывает `commit()`), кэш принудительно обновляется или создаётся новый объект сессии. 
Тогда при повторном запросе данные уже оказываются актуальными.
Таким образом, феномен «the data updates correctly when other functions modify the database» служит косвенным указателем на то, что в основном сценарии отсутствует корректное завершение или обновление сессии, и именно поэтому вы не видите актуальных данных до тех пор, пока не произойдёт дополнительная операция с БД, «освежающая» состояние ORM.
----
I have completed 532 projects here on Upwork.
My GitHub profiles: https://github.com/dmitrii-fediuk and https://github.com/mage2pro
My websites: https://df.tips?order=views and https://mage2.pro?order=views 