There's no single “one‐liner” explanation, but rather a stack of small differences that add up and make the Node script (SJ) appear roughly 2× slower than the PHP script (SP) under these exact test conditions. In practice, the most common reasons boil down to:

1. **Native C client library in PHP vs. pure JavaScript driver in Node**  
   - PHP’s MySQL extension is tightly bound to native C libraries (libmysqlclient or mysqlnd), which are compiled, highly optimized, and have minimal overhead on each call.  
   - Node’s “mysql” or “mysql2” libraries are (broadly speaking) written in JavaScript and speak the MySQL protocol themselves. Even though they’re quite optimized, every call still has extra overhead in userland JavaScript plus Node’s event loop/promise scheduling.  

2. **Synchronous call in PHP vs. async event loop in Node**  
   - In PHP, `mysqli->prepare()->execute()` is a direct, blocking C function call.  
   - In Node, `await db.query()` returns a promise, which introduces extra overhead in scheduling resolve/reject callbacks on the event loop, even though it’s just a single query in this test.

3. **Possible TCP vs. Unix socket difference**  
   - By default, PHP’s `mysqli_connect('localhost', …)` often connects via a local Unix socket on Linux, which is faster than TCP.  
   - Meanwhile, the Node code is explicitly using `'127.0.0.1'`, forcing a TCP loopback connection. If PHP truly used the Unix socket while Node used TCP, you typically see noticeably higher latency on Node’s side.  
   - You can confirm which transport is actually used by checking MySQL’s process list (e.g. `SHOW PROCESSLIST;`) or forcing a socket in Node (e.g. `mysql.createConnection({socketPath: '/var/run/mysqld/mysqld.sock', …})`).

4. **Different authentication methods or SSL overhead**  
   - If Node is configured to use (or auto‐negotiate) SSL/TLS by default, and PHP is not, then every query in Node pays extra handshake overhead. Check your `mysql2` config or connection options to disable SSL for local testing.  
   - Also note that in the sample, the Node script uses `'user': 'test', 'password': 'test'`, whereas the PHP code shows `'username':'test', 'password':null`. If MySQL is falling back to a different or faster authentication path with no password, that can also skew results.

5. **Timing/benchmark approach**  
   - The Node script uses `process.hrtime.bigint()` inside an async function and then calls `setTimeout(test, 250)`. The `setTimeout` + event loop can add overhead and occasional scheduling delays.  
   - The PHP script is in a simple `for($i=0; $i<10; $i++)` loop with a blocking `usleep(250*1000)`. This typically measures only the query time with minimal extra overhead.

#### Is this difference “expected” or “normal”?

If all you are doing is **single, sequential queries** in a tight loop (especially something trivial like `SELECT 1` or `UPDATE test SET f=1 WHERE id=1` on an in-memory table), you will often see Node appear slower in raw ms/query because of the points above. In real workloads where many queries happen concurrently, Node can shine by interleaving I/O—so the raw single‐query latency matters less. Still, PHP’s C extension for MySQL tends to have a lower floor on overhead for small, fast queries.

#### How can you reduce the gap?

- **Force both to use the same transport.** For Node, try a Unix socket:
  ```js
  const db = await mysql.createConnection({ socketPath: '/var/run/mysqld/mysqld.sock', user: '...', password: '...', database: '...' });
  ```
  or for PHP, explicitly use TCP (`127.0.0.1`) if you want to compare apples to apples.  
- **Disable SSL** on local connections if it’s being used.  
- **Use a connection pool** in Node, or at least ensure you are not reconnecting for every query. (The posted code does keep a single connection, so that’s good. But if you repeated `createConnection()` inside `test()`, it would be even slower.)  
- **Measure concurrency** (e.g., 10 queries at once) to see how each environment behaves under parallel load.  
- **Move the time measurement** so that you only measure the query call itself and not extra overhead from timers or logging.

In summary, yes—**it’s quite common to see Node pay more overhead per individual query** than PHP’s native MySQL driver. But the main culprits are typically:

- Native vs. JavaScript driver differences  
- Event loop and async overhead  
- Socket vs. TCP or SSL usage differences  

Once those are addressed or tested carefully, you’ll often see the difference shrink (though not fully vanish) for trivial statements.