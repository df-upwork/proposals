## 1. `Def`
### 1.1.
```
Def(A, B)
```
будет обозначать, что для понятия `B` я использую обозначение `A`.

### 1.2.
~~~
Def(A):
```
B
```
~~~
имеет то же значение, что и `Def(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 2. `Def_P`
### 2.1.
```
Def_P(A)
```
будет обозначать, что `A` является для меня проблемой.

### 2.2.
```
Def_P(A, B)
```
будет обозначать, что `B` является для меня проблемой, и для этой проблемы я использую обозначение `A`.

### 2.3.
~~~
Def_P(A):
```
B
```
~~~
имеет то же значение, что и `Def_P(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 3. `Def_C`
### 3.1.
```
Def_C(P, A, B)
```
будет обозначать `Def(A, B)` в контексте пункта `P`.
Вне пункта `P` это правило не применяется.
Если до пункта `P` обозначение `A` имело другой смысл, то после пункта `P` обозначение `A` снова будет иметь этот смысл.
По сути, `Def_C` объявляет локальную переменную `A` с областью действия `P`.
В отличие от него, `Def` объявляет глобальную переменную `A` (значение которой действует для всех пунктов, кроме `P`).

### 3.2.
~~~
Def_C(P, A):
```
B
```
~~~
имеет то же значение, что и `Def_C(P, A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 3.3.
```
Def_C([P1, P2, …, Pn], A, B)
```
имеет значение, аналогичное `Def_C(P, A, B)`, только в этом случае обозначение `A` имеет значение `B` в контексте не одного пункта `P`, а всех пунктов [`P1`, `P2`, …, `Pn`], перечисленных в квадратных скобках.

### 3.4.
```
Def_C([P1-Pn], A, B)
```
имеет значение, аналогичное `Def_C([P1, P2, …, Pn], A, B)`: в этом случае обозначение `A` имеет значение `B` в контексте множества всех пунктов между `P1` и `Pn`, включая сами эти пункты.

### 3.5.
~~~
Def_C([P1, P2, …, Pn], A):
```
B
```
~~~
имеет то же значение, что и `Def_C([P1, P2, …, Pn], A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 3.6.
~~~
Def_C([P1-Pn], A):
```
B
```
~~~
имеет то же значение, что и `Def_C([P1-Pn], A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 4. `Def_F`
### 4.1.
Def_C(4-5, `F`):
```
Факт: некое событие, которое случилось в описываем мной случае.
```

### 4.2.
```
Def_F(B)
```
будет обозначать, что `B` — это `F`.

### 4.3.
~~~
Def_F:
```
B
```
~~~
имеет то же значение, что и `Def_F(B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 4.4.
```
Def_F(A, B)
```
будет обозначать, что `B` — это `F`, и для него я использую обозначение `A`.

### 4.5.
~~~
Def_F(A):
```
B
```
~~~
имеет то же значение, что и `Def_F(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 5. `Def_Ph`
### 5.1.
Def_C(5, `Ph`):
```
Феномен: `F`, который вызывает у меня удивление.
```

### 5.2.
```
Def_Ph(B)
```
будет обозначать, что `B` — это `Ph`.

### 5.3.
~~~
Def_Ph:
```
B
```
~~~
имеет то же значение, что и `Def_Ph(B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 5.4.
```
Def_Ph(A, B)
```
будет обозначать, что `B` — это `Ph`, и для него я использую обозначение `A`.

### 5.5.
~~~
Def_Ph(A):
```
B
```
~~~
имеет то же значение, что и `Def_Ph(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 6. `Def_H`
### 6.1.
Def_C(6, `H`):
```
Гипотеза: некое предположение, требующее проверки.
```

### 6.2.
```
Def_H(B)
```
будет обозначать, что `B` — это `H`.

### 6.3.
~~~
Def_H:
```
B
```
~~~
имеет то же значение, что и `Def_H(B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 6.4.
```
Def_H(A, B)
```
будет обозначать, что `B` — это `H`, и для него я использую обозначение `A`.

### 6.5.
~~~
Def_H(A):
```
B
```
~~~
имеет то же значение, что и `Def_H(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 7. `Def_Set`
```
Def_Set(S, I)
```
будет обозначать, что `S` — множество всех возможных `I`.

## 8. `Def_I`
```
Def_I(I, S)
```
будет обозначать, что `I` — элемент множества `S`.

## 9. `Use`
```
Use(A)
```
будет обозначать, что в описываемой мной ситуации я использую `A`.

## 10.
Потенциальный клиент опубликовал на Upwork следующий проект:
### 10.1. Title
Ardupilot: Implement Positition Hold in GUIDED_NOGPS mode using SET_ATTITUDE_TARGET

### 10.2. Description
```text
The goal is to implement position hold in GUIDED_NOGPS flight mode.
There is a ROS2 topic that publish current position and orientation to the target point (will be provided). The data is available only in a radios of 1m from the target. 
Based on that data, we need to implement position hold. 
Since the data is not continuously, we VISION_POSITION_ESTIMATE.
In addition, we don't have any GPS, therefore, we have to use SET_ATTITUDE_TARGET.

Environment:
Companion computer: Jetson Orin NX (Ubuntu 22.04)
Sensor: Realsense D455
Simulator: Gazebo harmonic
ROS2 humble
C++ or Python (preferred)

step 1: Implement it in gazebo simulator
step 2: support/debug real flight
```

### 10.3. Tags
Python
C++
arudpilot
Control Engineering
Robotics

## 11. Информация о клиенте
### 11.1. Местоположение
Israel
Ramat Gan

## 11.2. Характеристики компании
### 11.2.1. Сектор экономики
неизвестно
### 11.2.2. Количество сотрудников
10-99 people

## 11.3. Характеристики учётной записи на Upwork
### 11.3.1. Member since
Apr 5, 2020
#### 11.3.2. Hire rate (%)
25
#### 11.3.3. Количество опубликованных проектов (jobs posted)
8
#### 11.3.4. Total spent
250
#### 11.3.5. Количество оплаченных часов в почасовых проектах
0

## 12.
Def(`C`):
```
клиент пункта 10
```

## 13.
Def(`P`):
```
проект пункта 10
```

## 14.
Def(`Ps`):
```
множество подобных `P` проектов 
```

## 15.
Def(`D`):
```
Описание `P` (пункт 10.2 выше)
```

## 16.
Def(`T`):
```
Конкретная подзадача, о которой `C` пишет в `D`:
~~~
implement position hold in GUIDED_NOGPS flight mode
~~~
Эта подзадача не включает следующие этапы общей задачи:
- Конфигурация Системы и Подготовка Окружения
- Разработка и Настройка Симуляционной Среды
- Интеграционное Тестирование и Отладка в Симуляторе
- Перенос Системы на Реальное Оборудование и Летные Испытания
```

## 17.
Def(`D`, «мой ответ `C`»).

## 18.
Содержание `D`:
~~~markdown
1) Отправка сообщений `VISION_POSITION_ESTIMATE` в расширенный фильтр Калмана (EKF) во время нахождения в режиме `GUIDED_NOGPS` является архитектурно некорректной и не окажет никакого влияния на удержание позиции аппаратом:
1.1) Сообщение MAVLink `VISION_POSITION_ESTIMATE` по своему определению предназначено для передачи данных о положении от внешней системы (например, системы визуальной одометрии) напрямую в EKF полетного контроллера.
EKF объединяет (fuses) эти внешние данные с показаниями инерциальных датчиков (IMU) для формирования точной оценки состояния (положения и скорости) аппарата. 
Затем полетный контроллер использует эту оценку для автономного удержания позиции в таких режимах, как `Loiter` или `Guided`. 
Для работы в таком сценарии без физического GPS-модуля необходимо соответствующим образом сконфигурировать параметры EKF, чтобы он использовал внешний источник навигации.
1.2) Полетный режим `GUIDED_NOGPS` не использует данные о положении или скорости для стабилизации и принимает исключительно команды на установку углов ориентации (`SET_ATTITUDE_TARGET`).
Он был разработан специально для того, чтобы предоставить бортовым компьютерам возможность низкоуровневого управления ориентацией аппарата, аналогично тому, как пилот управляет им в режимах `Stabilize` или `AltHold`.
Исходный код режима в файле `mode_guided_nogps.cpp` подтверждает его простоту: его основная функция заключается в вызове обработчика управления по углам (`ModeGuided::angle_control_run()`), что фактически делает его «прозрачным» каналом для команд ориентации: https://github.com/ArduPilot/ardupilot/blob/master/ArduCopter/mode_guided_nogps.cpp
2) Для задачи удержания позиции применение простого одноконтурного ПИД-регулятора, выход которого напрямую связан с углами наклона, часто приводит к нестабильности, осцилляциям и перерегулированию.
Более надежным и широко распространенным в робототехнике подходом является использование каскадной (многоконтурной) архитектуры управления:
2.1) Внешний контур (контроллер положения). 
Его задача — преобразовать ошибку положения (разницу между целевой и текущей позицией) в целевую скорость. 
Если аппарат находится справа от цели, контроллер генерирует команду на движение влево с определенной скоростью. 
Величина этой скорости пропорциональна удалению от цели. Входом для этого контура является ошибка положения `[error_x, error_y]`, а выходом — вектор целевой скорости `[target_vx, target_vy]`.
2.2) Внутренний контур (контроллер скорости). 
Его задача — минимизировать ошибку скорости (разницу между целевой и текущей скоростью). 
Для изменения скорости необходимо приложить ускорение. 
Таким образом, входом для этого контура является ошибка скорости, а выходом — вектор целевого ускорения `[target_ax, target_ay]`.
3) Для конкретной задачи удержания позиции в одной точке (где целевая скорость равна нулю), архитектуру пункта 2 можно математически упростить и представить в виде единого ПИД-регулятора, работающего с ошибкой положения:
3.1) Пропорциональный член (`P`) реагирует на текущую ошибку положения: `Output_P = Kp * error`. 
Он обеспечивает основную возвращающую силу к цели.
3.2) Производный член (`D`) реагирует на скорость изменения ошибки, что эквивалентно противодействию текущей скорости аппарата: `Output_D = Kd * d(error)/dt`.
Он выполняет функцию демпфирования, предотвращая перерегулирование и затухая колебания.
3.3) Интегральный член (`I`) накапливает ошибку с течением времени: `Output_I = Ki * integral(error)`. 
Его задача — компенсировать постоянные внешние возмущения (например, ветер) или систематические ошибки (например, неидеальную калибровку), которые приводят к статической ошибке (когда аппарат зависает не точно в цели, а с небольшим смещением).
3.4) Итоговый выход ПИД-регуляторов для каждой из горизонтальных осей (`X` и `Y`) будет представлять собой желаемое ускорение `[ax, ay]`, которое необходимо сообщить аппарату для возвращения в целевую точку.
4) ПИД-регулятор пункта 3 выдает абстрактную команду на ускорение, но квадрокоптер управляется путем изменения своей ориентации в пространстве. 
Следовательно, необходим этап преобразования, основанный на законах динамики.
Квадрокоптер создает подъемную силу, направленную в основном вдоль своей вертикальной оси (оси `Z`).
Чтобы создать горизонтальное ускорение, аппарат должен наклониться (создать крен или тангаж), направляя часть вектора тяги в горизонтальную плоскость. 
Целевые углы крена и тангажа можно рассчитать напрямую из желаемых ускорений `[ax, ay]`, полученных от ПИД-регуляторов:
```
target_roll_angle = asin(ay / total_thrust_acceleration)
target_pitch_angle = -asin(ax / total_thrust_acceleration)
```
Полученные углы Эйлера (крен, тангаж) вместе с желаемым углом рыскания (который для задачи удержания позиции можно считать постоянным, например, 0, для сохранения направления) необходимо преобразовать в кватернион. 
Сообщение `SET_ATTITUDE_TARGET` требует представления ориентации именно в этом формате.
5) Так как в вашем случае данные о положении поступают не непрерывно, наивная реализация пунктов 2-4 выше, не учитывающая возможные перерывы в поступлении данных, может привести к катастрофическим последствиям:
5.1) При прекращении поступления данных значение error в ПИД-регуляторе «замерзает». 
Интегральный член может начать бесконтрольно расти (так называемое «насыщение интегратора»), если в момент потери данных существовала статическая ошибка. 
5.2) При возобновлении поступления данных после паузы ошибка может измениться скачкообразно. 
Это вызовет огромный всплеск в производной составляющей (`d(error)/dt`), что приведет к резкой, неконтролируемой команде и рывку аппарата.
6) Правильное решение проблемы пункта 5 — постоянный мониторинг времени поступления последнего сообщения о положении. 
Управляющий цикл должен проверять разницу между текущим временем и временной меткой последнего полученного сообщения. 
Если эта разница превышает заданный порог (например, 200-500 мс), контроллер должен перейти в безопасный режим. 
~~~

## 19.
Def(`D2`, «начальная часть `D`, переведённая с Russian на English»).

## 20.
Содержание `D2`:
~~~markdown
1) Sending `VISION_POSITION_ESTIMATE` messages to the Extended Kalman Filter (EKF) while in `GUIDED_NOGPS` mode is architecturally incorrect and will not affect on the vehicle's position hold:
1.1) The MAVLink `VISION_POSITION_ESTIMATE` message is, by its definition, intended for transmitting position data from an external system (for example, a visual odometry system) directly to the flight controller's EKF.
The EKF fuses these external data with readings from the inertial sensors (IMU, Inertial Measurement Unit) to form an accurate state estimate (position and velocity) of the vehicle.
The flight controller then uses this estimate for autonomous position hold in modes such as `Loiter` or `Guided`.
To operate in such a scenario without a physical GPS module, it is necessary to configure the EKF parameters appropriately to use an external navigation source.
1.2) The `GUIDED_NOGPS` flight mode does not use position or velocity data for stabilization and exclusively accepts commands to set the attitude (`SET_ATTITUDE_TARGET`).
It was developed specifically to provide companion computers with low-level control over the vehicle's attitude, similar to how a pilot controls it in Stabilize or AltHold modes.
The source code of the mode in the `mode_guided_nogps.cpp` file confirms its simplicity: its primary function is to call the angle control handler (`ModeGuided::angle_control_run()`), which effectively makes it a «transparent» channel for attitude commands: https://github.com/ArduPilot/ardupilot/blob/master/ArduCopter/mode_guided_nogps.cpp
2) For the position hold task, the application of a simple single-loop PID controller, whose output is directly linked to the tilt angles, often leads to instability, oscillations, and overshoot.
A more reliable and widespread approach in robotics is the use of a cascaded (multi-loop) control architecture:
2.1) Outer loop (position controller).
Its task is to convert the position error (the difference between the target and current position) into a target velocity.
If the vehicle is to the right of the target, the controller generates a command to move to the left at a certain velocity.
The magnitude of this velocity is proportional to the distance from the target.
The input to this loop is the position error `[error_x, error_y]`, and the output is the target velocity vector `[target_vx, target_vy]`.
2) Inner loop (velocity controller).
Its task is to minimize the velocity error (the difference between the target and current velocity).
To change the velocity, it is necessary to apply an acceleration.
Thus, the input to this loop is the velocity error, and the output is the target acceleration vector `[target_ax, target_ay]`.
3) For the specific task of position hold at a single point (where the target velocity is zero), the architecture of point 2 can be mathematically simplified and represented as a single PID controller operating on the position error:
3.1) The proportional term (`P`) responds to the current position error: `Output_P = Kp * error`. 
It provides the main restoring force toward the target.
3.2) The derivative term (`D`) reacts to the rate of change of the error, which is equivalent to counteracting the current velocity of the vehicle: `Output_D = Kd * d(error)/dt`. 
It provides damping, preventing overshoot and dampening oscillations.
3.3) The integral term (`I`) accumulates the error over time: `Output_I = Ki * integral(error)`. 
Its task is to compensate for constant external disturbances (for example, wind) or systematic errors (for example, imperfect calibration) that lead to a static error (when the vehicle hovers not exactly at the target, but with a slight offset).
3.4) The final output of the PID controllers for each of the horizontal axes (`X` and `Y`) will be the desired acceleration `[ax, ay]`, which must be provided to the vehicle to return it to the target point.
4) The PID controller from point 3 issues an abstract command for acceleration, but the quadcopter is controlled by changing its orientation in space.
Consequently, a transformation step based on the laws of dynamics is necessary.
A quadcopter creates a lift force directed mainly along its vertical axis (the `Z` axis).
To create horizontal acceleration, the vehicle must tilt (create roll or pitch), directing part of the thrust vector into the horizontal plane.
The target roll and pitch angles can be calculated directly from the desired accelerations `[ax, ay]` obtained from the PID controllers:
```
target_roll_angle = asin(ay / total_thrust_acceleration)
target_pitch_angle = -asin(ax / total_thrust_acceleration)
```
~~~

## 21.
Def(`F`, «фрагмент `D`»).

## 22.
Содержание `F`:
~~~markdown
6) Правильное решение проблемы пункта 5 — постоянный мониторинг времени поступления последнего сообщения о положении. 
Управляющий цикл должен проверять разницу между текущим временем и временной меткой последнего полученного сообщения. 
Если эта разница превышает заданный порог (например, 200-500 мс), контроллер должен перейти в безопасный режим. 
~~~

## 23.
Переведи `F` на English, с учётом:
- контекста `D`
- `D2`: уже переведённой части `D`
- всех предыдущих пунктов моего запроса

## 24. Правила перевода
### 24.1.
Переводи именно в той стилистике, как написано на Russian.
Не делай перевод более вежливым, чем оригинал.

### 24.2.
Те предложения, которые сейчас полностью на English — оставь без изменения.

### 24.3.
#### 24.3.1.
Не используй Markdown: только plain text.
#### 24.3.2.
При этом можно и нужно использовать то форматирование, которое уже есть в оригинале: его не убирай.
#### 24.3.3.
Не форматируй веб-ссылки посредством Markdown, если они не отформатированы так в оригинале. 
Например, не пиши так:
```
[https://www.eca.web.tr/eca-nita-esnek-uclu-eviye-bataryasi-beyaz-102118110-308](https://www.eca.web.tr/eca-nita-esnek-uclu-eviye-bataryasi-beyaz-102118110-308)
```
если в оригинале скобок `[]()` нет.

### 24.4.
Форматируй перевод в точности как оригинал. 
В частности:
*) каждый абзац должен содержать ровно одно предложение
*) между абзацами не должно оставаться пустых строк.
*) кавычки используй те же, что и в оригинале: «» и ``.

### 24.5.
Не используй сокращения типа «don't». Все подобные фразы пиши полностью: «do not».

### 24.6.
Не используй жаргон.
Вместо этого используй официальные термины.
#### 24.6.1.
В частности, фразы в кавычках используй только в том случае, когда они являются точными цитатами.
Не используй фразы в кавычках для применения жаргонных фраз.
Например, следующий фрагмент текста недопустим, потому что там используется жаргонная фраза «пролетел»: 
```
Например, код, который пушит данные о покупке, подключён асинхронно и загружается с небольшой задержкой, а триггер уже «пролетел».
```

### 24.7.
При обсуждении программного обеспечения используй точные официальные термины на английском языке: именно в том виде, как они указаны в официальной англоязычной документации к этому программному обеспечению.

### 24.8.
Не используй «you need» и другие подобные обращённые к клиенту фразы, перекладывающие действия на него.
Помни: я пишу клиенту или потенциальному клиенту.
Делать в любом случае буду я, а не клиент.
Вместо «you need» используй 2 альтернативы:
#### 24.8.1.
Нейтральные фразы типа «it is necessary».
#### 24.8.2.
Глаголы в неопределённой форме.
Например, во фрагменте ниже использованы подобные глаголы «set up», «create»:
```
1.2) Set up the transfer of login events from WordPress to Power BI using Fabric / OneLake.
1.2.1) Set up a «Data Pipeline» from the WordPress database table that stores login events (see point 1.1) to Fabric / OneLake.
1.2.2) Set up a connection from Power BI to Fabric / OneLake to pass login events.
1.3) Create the data model in Power BI.
```
Обрати внимание, в этом фрагменте не говорится, кто именно будет выполнять описанные действия: ответственность не перекладывается на клиента, в отличие от «you need».

### 24.9.
Никогда не переводи понятие «сайт» / «веб-сайт» как «site». 
Вместо этого используй форму «website»: это является более профессиональным.

### 24.10.
Никогда не переводи понятие «пункт нумерованного списка» как «item».
Всегда переводи это как «point».