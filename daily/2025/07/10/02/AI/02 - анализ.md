## 1. `Def`
### 1.1.
```
Def(A, B)
```
будет обозначать, что для понятия `B` я использую обозначение `A`.

### 1.2.
~~~
Def(A):
```
B
```
~~~
имеет то же значение, что и `Def(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 2. `Def_P`
### 2.1.
```
Def_P(A)
```
будет обозначать, что `A` является для меня проблемой.

### 2.2.
```
Def_P(A, B)
```
будет обозначать, что `B` является для меня проблемой, и для этой проблемы я использую обозначение `A`.

### 2.3.
~~~
Def_P(A):
```
B
```
~~~
имеет то же значение, что и `Def_P(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 3. `Def_C`
### 3.1.
```
Def_C(P, A, B)
```
будет обозначать `Def(A, B)` в контексте пункта `P`.
Вне пункта `P` это правило не применяется.
Если до пункта `P` обозначение `A` имело другой смысл, то после пункта `P` обозначение `A` снова будет иметь этот смысл.
По сути, `Def_C` объявляет локальную переменную `A` с областью действия `P`.
В отличие от него, `Def` объявляет глобальную переменную `A` (значение которой действует для всех пунктов, кроме `P`).

### 3.2.
~~~
Def_C(P, A):
```
B
```
~~~
имеет то же значение, что и `Def_C(P, A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 3.3.
```
Def_C([P1, P2, …, Pn], A, B)
```
имеет значение, аналогичное `Def_C(P, A, B)`, только в этом случае обозначение `A` имеет значение `B` в контексте не одного пункта `P`, а всех пунктов [`P1`, `P2`, …, `Pn`], перечисленных в квадратных скобках.

### 3.4.
```
Def_C([P1-Pn], A, B)
```
имеет значение, аналогичное `Def_C([P1, P2, …, Pn], A, B)`: в этом случае обозначение `A` имеет значение `B` в контексте множества всех пунктов между `P1` и `Pn`, включая сами эти пункты.

### 3.5.
~~~
Def_C([P1, P2, …, Pn], A):
```
B
```
~~~
имеет то же значение, что и `Def_C([P1, P2, …, Pn], A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 3.6.
~~~
Def_C([P1-Pn], A):
```
B
```
~~~
имеет то же значение, что и `Def_C([P1-Pn], A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 4. `Def_F`
### 4.1.
Def_C(4-5, `F`):
```
Факт: некое событие, которое случилось в описываем мной случае.
```

### 4.2.
```
Def_F(B)
```
будет обозначать, что `B` — это `F`.

### 4.3.
~~~
Def_F:
```
B
```
~~~
имеет то же значение, что и `Def_F(B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 4.4.
```
Def_F(A, B)
```
будет обозначать, что `B` — это `F`, и для него я использую обозначение `A`.

### 4.5.
~~~
Def_F(A):
```
B
```
~~~
имеет то же значение, что и `Def_F(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 5. `Def_Ph`
### 5.1.
Def_C(5, `Ph`):
```
Феномен: `F`, который вызывает у меня удивление.
```

### 5.2.
```
Def_Ph(B)
```
будет обозначать, что `B` — это `Ph`.

### 5.3.
~~~
Def_Ph:
```
B
```
~~~
имеет то же значение, что и `Def_Ph(B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 5.4.
```
Def_Ph(A, B)
```
будет обозначать, что `B` — это `Ph`, и для него я использую обозначение `A`.

### 5.5.
~~~
Def_Ph(A):
```
B
```
~~~
имеет то же значение, что и `Def_Ph(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 6. `Def_H`
### 6.1.
Def_C(6, `H`):
```
Гипотеза: некое предположение, требующее проверки.
```

### 6.2.
```
Def_H(B)
```
будет обозначать, что `B` — это `H`.

### 6.3.
~~~
Def_H:
```
B
```
~~~
имеет то же значение, что и `Def_H(B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 6.4.
```
Def_H(A, B)
```
будет обозначать, что `B` — это `H`, и для него я использую обозначение `A`.

### 6.5.
~~~
Def_H(A):
```
B
```
~~~
имеет то же значение, что и `Def_H(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 7. `Def_Set`
```
Def_Set(S, I)
```
будет обозначать, что `S` — множество всех возможных `I`.

## 8. `Def_I`
```
Def_I(I, S)
```
будет обозначать, что `I` — элемент множества `S`.

## 9. `Use`
```
Use(A)
```
будет обозначать, что в описываемой мной ситуации я использую `A`.

## 10.
Потенциальный клиент опубликовал на Upwork следующий проект:
### 10.1. Title
Ardupilot: Implement Positition Hold in GUIDED_NOGPS mode using SET_ATTITUDE_TARGET

### 10.2. Description
```text
The goal is to implement position hold in GUIDED_NOGPS flight mode.
There is a ROS2 topic that publish current position and orientation to the target point (will be provided). The data is available only in a radios of 1m from the target. Based on that data, we need to implement position hold. Since the data is not continuously, we VISION_POSITION_ESTIMATE.
In addition, we don't have any GPS, therefore, we have to use SET_ATTITUDE_TARGET.

Environment:
Companion computer: Jetson Orin NX (Ubuntu 22.04)
Sensor: Realsense D455
Simulator: Gazebo harmonic
ROS2 humble
C++ or Python (preferred)

step 1: Implement it in gazebo simulator
step 2: support/debug real flight
```

### 10.3. Tags
Python
C++
arudpilot
Control Engineering
Robotics

## 11. Информация о клиенте
### 11.1. Местоположение
Israel
Ramat Gan

## 11.2. Характеристики компании
### 11.2.1. Сектор экономики
неизвестно
### 11.2.2. Количество сотрудников
10-99 people

## 11.3. Характеристики учётной записи на Upwork
### 11.3.1. Member since
Apr 5, 2020
#### 11.3.2. Hire rate (%)
25
#### 11.3.3. Количество опубликованных проектов (jobs posted)
8
#### 11.3.4. Total spent
250
#### 11.3.5. Количество оплаченных часов в почасовых проектах
0

## 12.
Def(`C`):
```
клиент пункта 10
```

## 13.
Def(`P`):
```
проект пункта 10
```

## 14.
Def(`Ps`):
```
множество подобных `P` проектов 
```

## 15.
Def(`D`):
```
Описание `P` (пункт 10.2 выше)
```

## 16.
Def(`T`):
```
Задача, о которой `C` пишет в `D`:
~~~
implement position hold in GUIDED_NOGPS flight mode
~~~
```

## 17. Твоя задача
Напиши на пошаговый алгоритм для `T`.
Этот алгоритм я буду обозначать `Alg-0`.

## 18. Требования к `Alg-0`
### 18.1.
`Alg-0` должен быть на русском языке.
Исключением являются точные официальные термины: смотри пункт 18.2 ниже.

### 18.2.
При обсуждении программного обеспечения используй точные официальные термины на английском языке: именно в том виде, как они указаны в официальной англоязычной документации к этому программному обеспечению.

### 18.3.
Не используй выделение жирным (`**`) и курсив (`*`).

### 18.4.
Названия файлов заключай в backticks.
Например: `header.php`.

### 18.5.
Названия элементов интерфейса заключай в угловые кавычки (`«»`).

### 18.6.
Для путей в интерфейсе используй `→`.
Например: «Current User» → «Personal».

### 18.7.
Не используй жаргон.
Вместо этого используй официальные термины.

#### 18.7.1.
В частности, фразы в кавычках используй только в том случае, когда они являются точными цитатами.
Не используй фразы в кавычках для применения жаргонных фраз.
Например, следующий фрагмент текста недопустим, потому что там используется жаргонная фраза «пролетел»: 
```
Например, код, который пушит данные о покупке, подключён асинхронно и загружается с небольшой задержкой, а триггер уже «пролетел».
```

### 18.8.
Не используй «you need» и другие подобные обращённые к клиенту фразы, перекладывающие действия на него.
Помни: я пишу клиенту или потенциальному клиенту.
Делать в любом случае буду я, а не клиент.
Вместо «you need» используй 2 альтернативы:
#### 18.8.1.
Нейтральные фразы типа «it is necessary».
#### 18.8.2.
Глаголы в неопределённой форме.
Например, во фрагменте ниже использованы подобные глаголы «set up», «create»:
```
1.2) Set up the transfer of login events from WordPress to Power BI using Fabric / OneLake.
1.2.1) Set up a «Data Pipeline» from the WordPress database table that stores login events (see point 1.1) to Fabric / OneLake.
1.2.2) Set up a connection from Power BI to Fabric / OneLake to pass login events.
1.3) Create the data model in Power BI.
```
Обрати внимание, в этом фрагменте не говорится, кто именно будет выполнять описанные действия: ответственность не перекладывается на клиента, в отличие от «you need».

### 18.9.
Каждый шаг `Alg-0` нумеруй.
Например: `1)`.

### 18.10.
Для вложенных шагов используй вложенную нумерацию. 
Например: `1.1)`.

### 18.11.
Для каждого шага `Alg-0` указывай конкретное обоснование из всего задокументированного в моём запросе анализа проекта клиента.

### 18.12.
Если тебе для описания `Alg-0` нужен программный код, то используй Python.

## 19. Требования к твоему программному коду // Общие
### 19.1.
Никогда не пиши в коде свои комментарии.

### 19.2.
Никогда не убирай из кода уже имеющиеся там комментарии.

### 19.3.
Никогда не пиши в коде полностью пустые строки.

### 19.4.
У любой функции должно быть не более одного return point.

### 19.5.
В операциях сопоставления значений переменной и константы константа всегда должна быть расположена слева от переменной.

### 19.6.
#### 19.61.
Строковые константы всегда по возможности обрамляй одинарными кавычами (') вместо двойных (").
#### 19.6.2.
Используй двойные кавычки только в тех случаях, когда они обеспечивают какое-либо конкретное преимущество перед одинарными.
Например, в некоторых языках программирования (Bash, PHP) обрамление строковых констант двойными кавычками позволяет вставлять внутрь этих строковых констант динамически вычисляемые переменные: пользуйся этим. 

