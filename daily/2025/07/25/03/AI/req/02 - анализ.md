## 1. `Def`
~~~
Def(A):
```
B
```
~~~
будет обозначать, что для понятия `B` я использую обозначение `A`.

## 2. `Def_P`
~~~
Def_P(A):
```
B
```
~~~
будет обозначать, что `B` является для меня проблемой, и для этой проблемы я использую обозначение `A`.

## 3. `Def_C`
### 3.1.
```
Def_C(P, A, B)
```
будет обозначать `Def(A, B)` в контексте пункта `P`.
Вне пункта `P` это правило не применяется.
Если до пункта `P` обозначение `A` имело другой смысл, то после пункта `P` обозначение `A` снова будет иметь этот смысл.
По сути, `Def_C` объявляет локальную переменную `A` с областью действия `P`.
В отличие от него, `Def` объявляет глобальную переменную `A` (значение которой действует для всех пунктов, кроме `P`).

### 3.2.
~~~
Def_C(P, A):
```
B
```
~~~
имеет то же значение, что и `Def_C(P, A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 3.3.
```
Def_C([P1, P2, …, Pn], A, B)
```
имеет значение, аналогичное `Def_C(P, A, B)`, только в этом случае обозначение `A` имеет значение `B` в контексте не одного пункта `P`, а всех пунктов [`P1`, `P2`, …, `Pn`], перечисленных в квадратных скобках.

### 3.4.
```
Def_C([P1-Pn], A, B)
```
имеет значение, аналогичное `Def_C([P1, P2, …, Pn], A, B)`: в этом случае обозначение `A` имеет значение `B` в контексте множества всех пунктов между `P1` и `Pn`, включая сами эти пункты.

### 3.5.
~~~
Def_C([P1, P2, …, Pn], A):
```
B
```
~~~
имеет то же значение, что и `Def_C([P1, P2, …, Pn], A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 3.6.
~~~
Def_C([P1-Pn], A):
```
B
```
~~~
имеет то же значение, что и `Def_C([P1-Pn], A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 4. `Def_F`
### 4.1.
Def_C(4-5, `F`):
```
Факт: некое событие, которое случилось в описываем мной случае.
```

### 4.2.
~~~
Def_F:
```
B
```
~~~
будет обозначать, что `B` — это `F`.

### 4.3.
~~~
Def_F(A):
```
B
```
~~~
будет обозначать, что `B` — это `F`, и для него я использую обозначение `A`.

## 5. `Def_Ph`
### 5.1.
Def_C(5, `Ph`):
```
Феномен: `F`, который вызывает у меня удивление.
```

### 5.2.
~~~
Def_Ph(A):
```
B
```
~~~
будет обозначать, что `B` — это `Ph`, и для него я использую обозначение `A`.

## 6. `Def_H`
### 6.1.
Def_C(6, `H`):
```
Гипотеза: некое предположение, требующее проверки.
```

### 6.2.
~~~
Def_H(A):
```
B
```
~~~
будет обозначать, что `B` — это `H`, и для него я использую обозначение `A`.

## 7. `Def_Set`
### 7.1.
```
Def_Set(S, I)
```
будет обозначать, что `S` — множество всех возможных `I`.

### 7.2.
```
Def_Set(S, {I1, I2, …, In})
```
будет обозначать, что `S` — множество, заданное точным перечислением всех его элементов: {`I1`, `I2`, …, `In`}.

## 8. `Def_I`
### 8.1.
```
Def_I(I, S)
```
будет обозначать, что `I` ∈ `S` (`I` — элемент множества `S`).

### 8.2.
~~~
Def_I(I, S):
```
B
```
~~~
будет обозначать, что `I` ∈ `S` и `B` — определение `I`.

## 9. `Use`
```
Use(A)
```
будет обозначать, что в описываемой мной ситуации я использую `A`.

## 10.
Потенциальный клиент опубликовал на Upwork следующий проект:
### 10.1. Title
The goal is to build a prompt-based interface for the Koios service

### 10.2. Description
```text
The goal is to build a prompt-based interface for the Koios service that allows users to submit concepts and preferred terms, which are validated against authoritative sources, stored in an SQL database, and represented in knowledge graphs for enhanced querying and reasoning. The system will leverage best practices from platforms like Lovable (beginner-friendly, AI-driven prototyping) and Bolt (developer-focused, full-stack support) to ensure usability and scalability.The solution includes:Prompt-Based Interface: A user-friendly UI where users can input concepts and terms, with AI assistance to refine and validate submissions.
SQL Database Integration: A structured schema to store the concept dictionary, ensuring persistence and efficient querying.
Knowledge Graph Storage: A graph database (e.g., Neo4j) to represent relationships between concepts, enabling semantic queries and reasoning.
Authoritative Source Validation: An AI-driven validation layer to cross-reference user inputs with authoritative sources.
Scalable Backend: A robust tech stack to handle user prompts, database operations, and graph updates.
```

### 10.3. Tags
Next.js
Neo4j
MySQL
PostgreSQL
AI Agent Development
JavaScript
PHP

## 11. Информация о клиенте
### 11.1. Местоположение
United Kingdom
Winchester

## 11.2. Характеристики компании
### 11.2.1. Сектор экономики
неизвестно
### 11.2.2. Количество сотрудников
неизвестно

## 11.3. Характеристики учётной записи на Upwork
### 11.3.1. Member since
 Nov 26, 2012
#### 11.3.2. Hire rate (%)
44
#### 11.3.3. Количество опубликованных проектов (jobs posted)
32
#### 11.3.4. Total spent (USD)
$7.8K
#### 11.3.5. Количество оплаченных часов в почасовых проектах
883

## 12.
Def(`C`):
```
клиент пункта 10
```

## 13.
Def(`P`):
```
проект пункта 10
```

## 14.
Def(`PD`):
```
Описание `P` (пункт 10.2 выше)
```

## 15.
Def_F(`POs`):
```
Другие проекты `C` на Upwork:
~~~
1) https://www.upwork.com/jobs/~01dca144d5db3375fd
2) https://www.upwork.com/jobs/~01928bf27275b53e70
3) https://www.upwork.com/jobs/~017667dea3f87e603e
4) https://www.upwork.com/jobs/~01534f43eb81353d87
5) https://www.upwork.com/jobs/~01a92b97b2ee320ab3
6) https://www.upwork.com/jobs/~016b06292fdd11bd4f
~~~
```

## 16.
Def(`T`):
```
Задача, о которой `C` пишет в `PD`:
~~~
build a prompt-based interface for the Koios service that allows users to submit concepts and preferred terms, which are validated against authoritative sources, stored in an SQL database, and represented in knowledge graphs for enhanced querying and reasoning
~~~
```

## 17.
Def(`K`):
```
Koios (в контексте `P`)
```

## 18.
### 18.1.
Я тебя спросил:
~~~
1) Проанализируй:
1.1) Каким бизнесом занимается `C`?
1.2) Каким образом он зарабатывает деньги?
1.3) Кто и за что ему платит?
1.4) Какие услуги и кому он предоставляет?
1.5) Кому и что он продаёт?
1.6) Зачем ему нужно решать `T`?
~~~

### 18.2.
Def(`A1`):
```
Твой ответ на вопросы пункта 18.1.
Он содержится в загруженном файле `1.md`.
```

## 19. Твоя задача
1) Проанализируй возможные способы решения `T`:
1.1) Для каждого способа укажи его достоинства и недостатки.
1.2) Затем рекомендуй лучший способ. 
2) На остальные вопросы не отвечай.
3) Уже известную мне информацию не пересказывай.
4) Обязательно используй свой режим «Deep Research».
Твой ответ без режима «Deep Research» — гарантированно неверный.
5) В своём анализе используй авторитетные источники информации на английском языке.
6) Свой ответ дай на русском языке. 