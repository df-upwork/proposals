https://gemini.google.com/share/9bd18b55c21d

## **Введение**

Настоящий отчет представляет собой исчерпывающее техническое исследование проблем, с которыми столкнулся Клиент ꆜ в рамках реализации проекта P⁎. Предметом анализа является критический сбой в работе интерфейса командной строки Azure (Azure CLI), возникающий при взаимодействии с управляющими плоскостями облачной платформы Microsoft Azure. Инцидент характеризуется систематическими ошибками установления защищенных соединений (TLS/SSL handshake), которые начали проявляться после обновления среды выполнения до версии Python 3.13.

В соответствии с требованиями задачи T.md, данный документ не ограничивается простой констатацией факта сбоя. Его цель — глубокая деконструкция архитектурных причин, анализ валидности претензий клиента к поставщику программного обеспечения, а также оценка соответствия инфраструктуры клиента современным криптографическим стандартам. Мы рассматриваем данный инцидент не как изолированный программный баг, а как проявление фундаментального сдвига в парадигме безопасности экосистемы Python, который вскрыл скрытый технический долг в инфраструктуре управления открытыми ключами (PKI) клиента.

Объем и детализация данного отчета обусловлены необходимостью предоставить техническим специалистам, архитекторам безопасности и руководителям проекта P⁎ полную картину происходящего, исключая возможность неверной интерпретации причинно-следственных связей. В отчете детально рассматриваются изменения в модуле ssl языка Python, спецификации RFC 5280, архитектура зависимостей Azure CLI и специфика работы корпоративных прокси-серверов (Middleboxes), осуществляющих инспекцию трафика.

## ---

**1. Феноменология инцидента и контекст проекта P⁎**

### **1.1 Описание наблюдаемой аномалии**

В ходе эксплуатации автоматизированных конвейеров CI/CD и локальных рабочих станций разработчиков в проекте P⁎ была зафиксирована полная потеря связности с API-интерфейсами Azure (Azure Resource Manager, Azure DevOps Artifacts и др.). Сбой происходит при выполнении стандартных команд Azure CLI, таких как az login, az group list или az pipelines build list.

Симптоматика ошибки является строго детерминированной и воспроизводимой. При попытке инициализации HTTPS-соединения клиентское приложение аварийно завершает работу, выдавая трассировку стека, указывающую на исключение в модуле ssl или библиотеке urllib3. Ключевым маркером инцидента является сообщение об ошибке:

certificate verify failed: CA cert does not include key usage extension (_ssl.c:1032)

Данное сообщение, как следует из собранных исследовательских данных 1, однозначно указывает на то, что процесс верификации цепочки сертификатов был прерван на этапе проверки корневого или промежуточного удостоверяющего центра (CA). Ошибка генерируется на уровне C-расширения _ssl.c стандартной библиотеки Python, которое выступает оберткой над криптографической библиотекой OpenSSL.

### **1.2 Операционный контекст Клиента ꆜ**

Клиент ꆜ оперирует в корпоративной среде с высоким уровнем сетевой безопасности. В такой инфраструктуре прямой доступ к ресурсам сети Интернет, как правило, заблокирован, а весь трафик проходит через системы инспекции (Deep Packet Inspection), такие как Zscaler, Palo Alto Networks или Bluecoat. Эти системы реализуют технику Man-in-the-Middle (MITM), динамически подменяя SSL-сертификаты целевых ресурсов (например, management.azure.com) на сертификаты, подписанные внутренним доверенным корневым центром сертификации предприятия.

Проблема возникла внезапно для операционных команд проекта P⁎, так как изменения в инфраструктуре PKI не производились. Катализатором сбоя послужило обновление программных компонентов: либо явное обновление интерпретатора Python до версии 3.13 на сборочных агентах, либо установка новой версии Azure CLI (начиная с версий 2.66.0/2.67.0), которая в ряде дистрибутивов (например, Windows MSI) теперь поставляется со встроенной версией Python 3.13.4

Ситуация усугубляется тем, что откат Azure CLI до предыдущих версий не всегда тривиален из-за особенностей пакетных менеджеров и зависимостей, а остановка конвейеров CI/CD наносит прямой финансовый и репутационный ущерб проекту P⁎, блокируя поставку обновлений программного обеспечения.

## ---

**2. Глубинный анализ архитектурных изменений в Python 3.13**

Для понимания природы возникшей проблемы необходимо проанализировать эволюцию подсистемы безопасности языка Python. Версия 3.13 привнесла радикальные изменения в настройки по умолчанию для контекстов SSL, перейдя от политики "совместимость превыше всего" к политике "безопасность по умолчанию".

### **2.1 Новая парадигма безопасности: PEP и OpenSSL**

В предыдущих версиях Python (до 3.12 включительно) функция ssl.create_default_context(), используемая большинством HTTP-библиотек (включая requests, на которой базируется Azure CLI), создавала контекст с достаточно либеральными настройками верификации. Она полагалась на настройки OpenSSL по умолчанию, которые исторически были снисходительны к отклонениям от стандартов в структуре сертификатов, чтобы не "ломать" работу старых веб-сайтов и внутренних систем.

Однако с выходом Python 3.13 разработчики языка приняли решение ужесточить требования к проверяемым сертификатам. Это было сделано для приведения поведения Python в соответствие с современными практиками безопасности, принятыми в других экосистемах (например, Go, Rust, Java) и браузерах.

Согласно официальной документации и примечаниям к выпуску 5, контекст, создаваемый ssl.create_default_context(), теперь устанавливает два критически важных флага верификации OpenSSL:

1. **VERIFY_X509_STRICT**: Этот флаг переводит библиотеку OpenSSL в режим строгой проверки соответствия стандарту X.509. Он отключает все механизмы обратной совместимости и "воркараунды", которые ранее позволяли принимать некорректно сформированные сертификаты.  
2. **VERIFY_X509_PARTIAL_CHAIN**: Этот флаг позволяет верифицировать цепочки, которые не обязательно ведут к самоподписанному корню, если в доверенном хранилище найден промежуточный сертификат.

Именно включение флага VERIFY_X509_STRICT является непосредственной причиной проблем Клиента ꆜ. Этот флаг заставляет OpenSSL выполнять проверки, которые ранее игнорировались, в частности — проверку расширений KeyUsage (Использование ключа) и BasicConstraints (Основные ограничения) в сертификатах удостоверяющих центров.

### **2.2 Роль библиотеки OpenSSL 3.x**

Важно отметить, что Python сам по себе не реализует криптографические алгоритмы проверки сертификатов. Он делегирует эту задачу системной библиотеке OpenSSL (или той версии, которая слинкована с интерпретатором). В современных дистрибутивах Linux и в Windows-сборках Python используется ветка OpenSSL 3.0 и выше.

OpenSSL 3.0 также претерпел значительные изменения в сторону ужесточения проверок. Когда Python передает флаг X509_V_FLAG_X509_STRICT в API OpenSSL, библиотека активирует логику проверки, описанную в функции x509_vfy.c. Если сертификат, претендующий на роль эмитента (Issuer), не содержит необходимых расширений, OpenSSL возвращает ошибку валидации.

Сообщение "CA cert does not include key usage extension" генерируется именно внутри OpenSSL, когда анализатор цепочки обнаруживает сертификат, который используется для проверки подписи другого сертификата, но при этом не имеет явно установленного бита keyCertSign в расширении KeyUsage.6

## ---

**3. Криптографический аудит: Анатомия стандарта RFC 5280**

Чтобы оценить обоснованность претензий клиента и выполнить анализ по задаче T.md, необходимо обратиться к первоисточнику истины в мире PKI — стандартам IETF.

### **3.1 Расширение Key Usage (Использование ключа)**

Стандарт RFC 5280 "Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile" определяет структуру сертификатов. Раздел 4.2.1.3 детально описывает расширение KeyUsage.8

Расширение KeyUsage определяет цели, для которых может быть использован открытый ключ, содержащийся в сертификате. Это битовая маска, где каждый бит соответствует определенной операции (цифровая подпись, шифрование ключей, подпись сертификатов и т.д.).

Для сертификатов удостоверяющих центров (CA) стандарт устанавливает жесткие требования:

"If the keyUsage extension is present, then the subject public key MUST NOT be used to verify signatures on certificates or CRLs unless the corresponding keyCertSign or cRLSign bit is set."  
(Если расширение keyUsage присутствует, то открытый ключ субъекта НЕ ДОЛЖЕН использоваться для проверки подписей на сертификатах или CRL, если не установлены соответствующие биты keyCertSign или cRLSign.)

Более того, для того чтобы сертификат мог выступать в роли CA (то есть подписывать другие сертификаты), он **обязан** иметь:

1. Расширение BasicConstraints с флагом CA:TRUE.  
2. Если присутствует расширение KeyUsage, в нем **должен** быть установлен бит keyCertSign.

### **3.2 Дефект в инфраструктуре Клиента ꆜ**

Анализ ошибки, возникающей у Клиента ꆜ, показывает, что сертификаты во внутренней инфраструктуре нарушают требования RFC 5280. Возможны два сценария нарушения:

1. **Отсутствие расширения:** Сертификат CA вообще не содержит расширения KeyUsage. В режиме VERIFY_X509_STRICT OpenSSL требует явного наличия этого расширения для CA сертификатов, чтобы исключить двусмысленность использования ключей.7  
2. **Некорректная битовая маска:** Расширение присутствует, но в нем отсутствуют биты keyCertSign (для подписи сертификатов) или cRLSign (для подписи списков отзыва). Например, сертификат мог быть создан с флагами, предназначенными для веб-сервера (digitalSignature, keyEncipherment), но при этом используется как CA.

Такая ситуация типична для сертификатов, генерируемых "на лету" корпоративными прокси-серверами (Zscaler и аналоги) или созданных внутренними командами DevOps с использованием упрощенных конфигураций OpenSSL, которые не включают секции v3_extensions.1 До выхода Python 3.13 эти сертификаты работали "по факту", но де-юре они всегда были некорректными с точки зрения стандартов PKI.

## ---

**4. Azure CLI: Векторы воздействия и экосистема зависимостей**

Azure CLI представляет собой сложное приложение на Python, которое агрегирует множество SDK для управления ресурсами Azure. Понимание того, как именно CLI взаимодействует с Python, критично для диагностики проблемы в проекте P⁎.

### **4.1 Цепочка зависимостей и наследование проблем**

Azure CLI не реализует собственный сетевой стек. Взаимодействие с API Azure строится по следующей цепочке:

1. **Команда пользователя:** az vm list.  
2. **Azure CLI Core:** Обрабатывает команду и аутентификацию.  
3. **Azure SDK for Python (azure-mgmt-*):** Формирует запросы к REST API.  
4. **Azure Core (azure-core):** Предоставляет общий конвейер обработки запросов.  
5. **Requests / Aiohttp:** Высокоуровневые HTTP-клиенты.  
6. **Urllib3:** Низкоуровневый HTTP-клиент, управляющий пулами соединений.  
7. **Модуль ssl (Python):** Создает SSLContext и управляет сокетами.  
8. **OpenSSL:** Выполняет рукопожатие и криптографические операции.

Изменения в звене №7 (Модуль ssl в Python 3.13) автоматически влияют на все вышестоящие уровни. Поскольку urllib3 и requests используют метод ssl.create_default_context() без явного сброса флагов (доверяя настройкам "по умолчанию" как наиболее безопасным), они наследуют флаг VERIFY_X509_STRICT.

### **4.2 Специфика дистрибуции Azure CLI**

Особую сложность в диагностике для Клиента ꆜ представляет способ установки Azure CLI. Существует несколько основных методов, каждый из которых по-разному подвержен проблеме:

#### **4.2.1 Windows MSI (Встроенный Python)**

Официальный установочный пакет MSI для Windows содержит встроенный интерпретатор Python. Это означает, что Azure CLI работает изолированно от системного Python, установленного пользователем. До недавнего времени MSI пакеты использовали Python 3.10 или 3.11. Однако, согласно последним данным из репозитория разработки и примечаний к выпуску 4, Microsoft начала процесс обновления встроенного интерпретатора до версии 3.13 в релизах конца 2024 - начала 2025 года (например, версии 2.66.0+).  
Это объясняет внезапность появления проблемы: администратор мог просто обновить Azure CLI через winget upgrade или скачать новый MSI, не подозревая, что "под капотом" изменилась версия Python и политики безопасности.

#### **4.2.2 Установка через pip**

В средах Linux и macOS разработчики часто устанавливают CLI командой pip install azure-cli. В этом случае CLI использует тот интерпретатор Python, в окружении которого он установлен. Если на сервере CI/CD произошло обновление системного пакета python3 до версии 3.13 (что характерно для rolling-release дистрибутивов или новейших версий Ubuntu/Fedora), Azure CLI немедленно начинает транслировать новые ошибки SSL.

#### **4.2.3 Docker-контейнеры**

Официальные образы mcr.microsoft.com/azure-cli базируются на Azure Linux. Обновление базового образа до версии, включающей Python 3.13, приводит к тому, что тег :latest становится источником сбоя для всех пайплайнов, которые не фиксируют (pin) версии используемых инструментов.

## ---

**5. Анализ обоснованности проблем согласно задаче T.md**

Задача T.md предполагает проведение анализа валидности (validity analysis) выявленных проблем. В контексте инженерии программного обеспечения и управления инцидентами, валидность проблемы определяется ответом на вопрос: "Является ли наблюдаемое поведение дефектом продукта (Bug), ошибкой конфигурации (User Error) или ожидаемым поведением системы (Intended Behavior)?"

В таблице 1 приведен детальный анализ валидности претензий Клиента ꆜ.

**Таблица 1: Матрица валидности инцидента в проекте P⁎**

| Критерий анализа | Оценка | Обоснование |
| :---- | :---- | :---- |
| **Техническая корректность поведения ПО** | **Корректно** | Python 3.13 и Azure CLI работают в строгом соответствии со спецификацией RFC 5280. Отказ в доверии сертификату без KeyUsage является правильным поведением безопасной системы. |
| **Наличие дефекта в Azure CLI** | **Отсутствует** | Azure CLI не содержит кода, вызывающего эту ошибку. Продукт лишь транслирует исключение от нижележащей платформы. Претензия к Microsoft как к разработчику CLI технически необоснованна. |
| **Наличие дефекта в инфраструктуре клиента** | **Присутствует** | Корневая причина сбоя — использование некорректно сгенерированных сертификатов CA во внутренней сети или на прокси-серверах. Это нарушение стандартов PKI. |
| **Операционная валидность (Impact)** | **Высокая** | С точки зрения бизнеса клиента, проблема абсолютно валидна: производственный процесс остановлен. Система, работавшая вчера, не работает сегодня. |
| **Соответствие задаче T.md** | **Подтверждено** | Задача требует выявления проблем. Проблема выявлена: несоответствие инфраструктуры PKI клиента современным стандартам безопасности, enforced by Python 3.13. |

### **5.1 Вывод по анализу T.md**

Проблема Клиента ꆜ является валидной операционной проблемой, вызванной техническим долгом в конфигурации безопасности.  
Ошибочно классифицировать это как "баг" в Python или Azure CLI. Это инцидент соответствия (Compliance Incident).  
Переход на Python 3.13 фактически выступил в роли невольного аудитора безопасности, который выявил нарушения, годами скрывавшиеся за либеральными настройками старых версий OpenSSL.  
Следовательно, в рамках задачи T.md, обоснованность проблемы подтверждается, но вектор решения должен быть направлен не на исправление кода Azure CLI, а на приведение инфраструктуры клиента в соответствие со стандартами.

## ---

**6. Детальный разбор фактора прокси-серверов (Zscaler и аналоги)**

Одной из наиболее частых причин возникновения ошибки CA cert does not include key usage extension в корпоративных средах являются системы SSL-инспекции.3

### **6.1 Механизм возникновения ошибки на прокси**

Корпоративные шлюзы безопасности (Secure Web Gateways, SWG), такие как Zscaler, работают по следующему алгоритму:

1. Клиент (Azure CLI) запрашивает доступ к https://management.azure.com.  
2. Шлюз перехватывает соединение, устанавливает собственный SSL-туннель с сервером Azure.  
3. Шлюз динамически генерирует поддельный сертификат для management.azure.com, подписывая его своим внутренним корневым сертификатом (Root CA), которому доверяют компьютеры в домене компании.  
4. Этот поддельный сертификат отправляется клиенту.

Проблема возникает на шаге 3. Многие конфигурации этих шлюзов используют корневой сертификат, который был создан много лет назад с настройками, достаточными для браузеров того времени (IE, старый Chrome), но недостаточными для строгого режима OpenSSL 3.x/Python 3.13.

Часто корневой сертификат прокси имеет расширение KeyUsage с установленными битами Digital Signature и Key Encipherment, но **без** бита Certificate Sign (keyCertSign). Либо это расширение отсутствует вовсе. Браузеры (Chrome, Edge) часто имеют собственные "белые списки" или эвристики для корпоративных корней, позволяя им работать. Python 3.13 в режиме STRICT не имеет таких исключений.

### **6.2 Влияние на "az login"**

Команда az login особенно уязвима, так как она инициирует сложную последовательность OAuth2-запросов к endpoints Microsoft Entra ID (ранее Azure AD). Эти запросы также перехватываются прокси. Ошибка блокирует возможность получения токенов доступа, что делает невозможной любую дальнейшую работу с облаком. Даже использование Device Code Flow не помогает, так как CLI все равно должен опрашивать endpoint для проверки статуса аутентификации.

## ---

**7. Стратегии ремедиации и рекомендации по устранению**

На основе проведенного анализа предлагается трехуровневая стратегия решения проблемы для Клиента ꆜ. Решения ранжированы от тактических (быстрое восстановление работы) до стратегических (долгосрочное исправление).

### **7.1 Стратегия А: Исправление инфраструктуры (Рекомендуемое стратегическое решение)**

Единственным способом, гарантирующим безопасность и совместимость с будущими версиями ПО, является перевыпуск некорректных сертификатов.

**План действий:**

1. **Аудит сертификатов:** Использовать команду openssl для проверки текущего сертификата прокси или внутреннего CA:  
   Bash  
   openssl x509 -in <путь_к_сертификату_CA> -text -noout | grep -A 5 "Key Usage"

   Если вывод пуст или не содержит Certificate Sign, сертификат подлежит замене.  
2. **Генерация корректного CA:** Создать новый корневой сертификат с правильным файлом конфигурации OpenSSL (openssl.cnf). Пример необходимой секции 9:  
   Ini, TOML  
   [ v3_ca ]  
   basicConstraints = critical,CA:TRUE  
   keyUsage = critical, digitalSignature, cRLSign, keyCertSign

   Критически важно наличие keyCertSign и пометка расширения как critical.  
3. **Ротация:** Распространить новый корневой сертификат через групповые политики (GPO) или системы управления конфигурациями (Ansible, Chef) на все хосты разработчиков и CI/CD агенты.  
4. **Обращение к вендору:** Если сертификат зашит в аппаратное устройство (Black box), открыть тикет в техподдержку вендора (Zscaler, Cisco, etc.) с требованием предоставить патч или инструкцию по генерации RFC-совместимого сертификата CA.3

### **7.2 Стратегия Б: Даунгрейд среды выполнения (Временное решение)**

Если перевыпуск сертификатов невозможен в кратчайшие сроки (бюрократия, сложные процессы согласования), необходимо откатить версию инструментов.

**Варианты:**

1. **Для пользователей MSI:** Удалить текущую версию Azure CLI и установить версию 2.64.0 или более раннюю, которая гарантированно использует Python 3.11/3.12. Отключить автообновление.  
2. **Для Docker:** Использовать теги образов с явным указанием версии, например mcr.microsoft.com/azure-cli:2.64.0, вместо :latest.  
3. **Для Python-скриптов:** Использовать виртуальные окружения (venv) с Python 3.12.

### **7.3 Стратегия В: Программный "Monkey Patching" (Экстренное решение "Break-Glass")**

В ситуациях, когда невозможно ни обновить сертификат, ни откатить версию Python (например, жесткие требования безопасности к версиям ПО), можно применить программное вмешательство для отключения строгой проверки. Это решение **снижает уровень безопасности** и должно использоваться с осторожностью.

Для этого необходимо внедрить скрипт, который модифицирует поведение стандартной библиотеки ssl во время запуска интерпретатора.

Реализация:  
Создать файл loose_ssl.py со следующим содержимым 13:

Python

import ssl

# Сохраняем оригинальную функцию  
_original_create_default_context = ssl.create_default_context

def relaxed_create_default_context(purpose=ssl.Purpose.SERVER_AUTH, *, cafile=None, capath=None, cadata=None):  
    # Создаем контекст стандартным способом  
    ctx = _original_create_default_context(purpose, cafile=cafile, capath=capath, cadata=cadata)  
      
    # Проверяем наличие атрибута, так как в старых Python его нет  
    if hasattr(ssl, "VERIFY_X509_STRICT"):  
        # Снимаем бит строгого режима  
        ctx.verify_flags &= ~ssl.VERIFY_X509_STRICT  
          
    return ctx

# Подменяем функцию в модуле ssl  
ssl.create_default_context = relaxed_create_default_context

Чтобы применить этот патч ко всем запускам Python (и Azure CLI), необходимо установить переменную окружения PYTHONSTARTUP, указывающую на путь к этому файлу:

* Linux/macOS: export PYTHONSTARTUP=/path/to/loose_ssl.py  
* Windows: set PYTHONSTARTUP=C:pathtoloose_ssl.py

**Важно:** Этот метод работает для скриптов Python. Однако для бинарного Azure CLI, установленного через MSI, внедрение может быть сложным, так как он использует собственный изолированный Python. В таком случае может потребоваться модификация файла az.cmd или az (bash script), чтобы включить эту переменную перед запуском основного модуля.14

## ---

**8. Заключение**

Проведенное исследование подтверждает, что сбои в проекте P⁎ у Клиента ꆜ вызваны несоответствием внутренней инфраструктуры PKI требованиям стандарта RFC 5280, соблюдение которых стало обязательным в Python 3.13. Ошибка CA cert does not include key usage extension является индикатором того, что используемые для инспекции трафика сертификаты технически некорректны.

Анализ согласно задаче T.md показывает высокую валидность проблемы как фактора, блокирующего бизнес-процессы, но снимает ответственность с вендора (Microsoft/Python) за программные дефекты. Текущее поведение системы является корректным с точки зрения кибербезопасности.

Для восстановления работоспособности проекта P⁎ рекомендуется немедленно применить тактическое решение в виде фиксации версий Azure CLI (downgrade) или использования переменных окружения для обхода проверок, параллельно запустив процесс генерации и внедрения валидных корневых сертификатов, содержащих флаг keyCertSign. Это позволит ликвидировать технический долг и обеспечить готовность инфраструктуры к будущим ужесточениям стандартов безопасности.

---

*Конец отчета*

#### **Works cited**

1. root CA certificate does not include key usage extension · Issue #4864 · canonical/microk8s, accessed December 11, 2025, [https://github.com/canonical/microk8s/issues/4864](https://github.com/canonical/microk8s/issues/4864)  
2. Elasticsearch CA certificates are rejected by Python 3.13 · Issue #117769 - GitHub, accessed December 11, 2025, [https://github.com/elastic/elasticsearch/issues/117769](https://github.com/elastic/elasticsearch/issues/117769)  
3. az cli pipelines build list errors with Internal/VPN CA Certs - Developer Community, accessed December 11, 2025, [https://developercommunity.visualstudio.com/t/az-cli-pipelines-build-list-errors-with/10993415?sort=active&topics=ide2](https://developercommunity.visualstudio.com/t/az-cli-pipelines-build-list-errors-with/10993415?sort=active&topics=ide2)  
4. Release notes & updates – Azure CLI - Microsoft Learn, accessed December 11, 2025, [https://learn.microsoft.com/en-us/cli/azure/release-notes-azure-cli?view=azure-cli-latest](https://learn.microsoft.com/en-us/cli/azure/release-notes-azure-cli?view=azure-cli-latest)  
5. ssl — TLS/SSL wrapper for socket objects — Python 3.14.2 documentation, accessed December 11, 2025, [https://docs.python.org/3/library/ssl.html](https://docs.python.org/3/library/ssl.html)  
6. LBN for Advisory on legacy Certificates Used with TIBCO Messaging, accessed December 11, 2025, [https://support.tibco.com/s/article/LBN-for-Advisory-on-legacy-Certificates-Used-with-TIBCO-Messaging](https://support.tibco.com/s/article/LBN-for-Advisory-on-legacy-Certificates-Used-with-TIBCO-Messaging)  
7. openssl-verification-options, accessed December 11, 2025, [https://docs.openssl.org/3.1/man1/openssl-verification-options/](https://docs.openssl.org/3.1/man1/openssl-verification-options/)  
8. RFC 5280 - Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile - IETF Datatracker, accessed December 11, 2025, [https://datatracker.ietf.org/doc/html/rfc5280](https://datatracker.ietf.org/doc/html/rfc5280)  
9. Generating a self-signed cert with openssl that works in Chrome 58 - Server Fault, accessed December 11, 2025, [https://serverfault.com/questions/845766/generating-a-self-signed-cert-with-openssl-that-works-in-chrome-58](https://serverfault.com/questions/845766/generating-a-self-signed-cert-with-openssl-that-works-in-chrome-58)  
10. Python 3.13.x SSL security changes, accessed December 11, 2025, [https://discuss.python.org/t/python-3-13-x-ssl-security-changes/91266](https://discuss.python.org/t/python-3-13-x-ssl-security-changes/91266)  
11. Change in python 3.13 that breaks certificate trust - Zscaler Community, accessed December 11, 2025, [https://community.zscaler.com/s/question/0D54u0000AfJDtECQW/change-in-python-313-that-breaks-certificate-trust](https://community.zscaler.com/s/question/0D54u0000AfJDtECQW/change-in-python-313-that-breaks-certificate-trust)  
12. Configure Transport Layer Security Inspection Settings - Global Secure Access, accessed December 11, 2025, [https://learn.microsoft.com/en-us/entra/global-secure-access/how-to-transport-layer-security-settings](https://learn.microsoft.com/en-us/entra/global-secure-access/how-to-transport-layer-security-settings)  
13. Python v3.13 has broken Email delivery due to an SSL change ..., accessed December 11, 2025, [https://stackoverflow.com/questions/79358216/python-v3-13-has-broken-email-delivery-due-to-an-ssl-change](https://stackoverflow.com/questions/79358216/python-v3-13-has-broken-email-delivery-due-to-an-ssl-change)  
14. Quickstart: Create a function in Azure from the command line - Microsoft Learn, accessed December 11, 2025, [https://learn.microsoft.com/en-us/azure/azure-functions/how-to-create-function-azure-cli](https://learn.microsoft.com/en-us/azure/azure-functions/how-to-create-function-azure-cli)  
15. Aliases I have in my global git config - GitHub Gist, accessed December 11, 2025, [https://gist.github.com/sytone/03d9b90abb936830253f60f7f40a1a06](https://gist.github.com/sytone/03d9b90abb936830253f60f7f40a1a06)