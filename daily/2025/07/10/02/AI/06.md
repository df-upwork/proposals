## 1. `Def`
### 1.1.
```
Def(A, B)
```
будет обозначать, что для понятия `B` я использую обозначение `A`.

### 1.2.
~~~
Def(A):
```
B
```
~~~
имеет то же значение, что и `Def(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 2. `Def_P`
### 2.1.
```
Def_P(A)
```
будет обозначать, что `A` является для меня проблемой.

### 2.2.
```
Def_P(A, B)
```
будет обозначать, что `B` является для меня проблемой, и для этой проблемы я использую обозначение `A`.

### 2.3.
~~~
Def_P(A):
```
B
```
~~~
имеет то же значение, что и `Def_P(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 3. `Def_C`
### 3.1.
```
Def_C(P, A, B)
```
будет обозначать `Def(A, B)` в контексте пункта `P`.
Вне пункта `P` это правило не применяется.
Если до пункта `P` обозначение `A` имело другой смысл, то после пункта `P` обозначение `A` снова будет иметь этот смысл.
По сути, `Def_C` объявляет локальную переменную `A` с областью действия `P`.
В отличие от него, `Def` объявляет глобальную переменную `A` (значение которой действует для всех пунктов, кроме `P`).

### 3.2.
~~~
Def_C(P, A):
```
B
```
~~~
имеет то же значение, что и `Def_C(P, A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 3.3.
```
Def_C([P1, P2, …, Pn], A, B)
```
имеет значение, аналогичное `Def_C(P, A, B)`, только в этом случае обозначение `A` имеет значение `B` в контексте не одного пункта `P`, а всех пунктов [`P1`, `P2`, …, `Pn`], перечисленных в квадратных скобках.

### 3.4.
```
Def_C([P1-Pn], A, B)
```
имеет значение, аналогичное `Def_C([P1, P2, …, Pn], A, B)`: в этом случае обозначение `A` имеет значение `B` в контексте множества всех пунктов между `P1` и `Pn`, включая сами эти пункты.

### 3.5.
~~~
Def_C([P1, P2, …, Pn], A):
```
B
```
~~~
имеет то же значение, что и `Def_C([P1, P2, …, Pn], A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 3.6.
~~~
Def_C([P1-Pn], A):
```
B
```
~~~
имеет то же значение, что и `Def_C([P1-Pn], A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 4. `Def_F`
### 4.1.
Def_C(4-5, `F`):
```
Факт: некое событие, которое случилось в описываем мной случае.
```

### 4.2.
```
Def_F(B)
```
будет обозначать, что `B` — это `F`.

### 4.3.
~~~
Def_F:
```
B
```
~~~
имеет то же значение, что и `Def_F(B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 4.4.
```
Def_F(A, B)
```
будет обозначать, что `B` — это `F`, и для него я использую обозначение `A`.

### 4.5.
~~~
Def_F(A):
```
B
```
~~~
имеет то же значение, что и `Def_F(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 5. `Def_Ph`
### 5.1.
Def_C(5, `Ph`):
```
Феномен: `F`, который вызывает у меня удивление.
```

### 5.2.
```
Def_Ph(B)
```
будет обозначать, что `B` — это `Ph`.

### 5.3.
~~~
Def_Ph:
```
B
```
~~~
имеет то же значение, что и `Def_Ph(B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 5.4.
```
Def_Ph(A, B)
```
будет обозначать, что `B` — это `Ph`, и для него я использую обозначение `A`.

### 5.5.
~~~
Def_Ph(A):
```
B
```
~~~
имеет то же значение, что и `Def_Ph(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 6. `Def_H`
### 6.1.
Def_C(6, `H`):
```
Гипотеза: некое предположение, требующее проверки.
```

### 6.2.
```
Def_H(B)
```
будет обозначать, что `B` — это `H`.

### 6.3.
~~~
Def_H:
```
B
```
~~~
имеет то же значение, что и `Def_H(B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 6.4.
```
Def_H(A, B)
```
будет обозначать, что `B` — это `H`, и для него я использую обозначение `A`.

### 6.5.
~~~
Def_H(A):
```
B
```
~~~
имеет то же значение, что и `Def_H(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 7. `Def_Set`
```
Def_Set(S, I)
```
будет обозначать, что `S` — множество всех возможных `I`.

## 8. `Def_I`
```
Def_I(I, S)
```
будет обозначать, что `I` — элемент множества `S`.

## 9. `Use`
```
Use(A)
```
будет обозначать, что в описываемой мной ситуации я использую `A`.

## 10.
Потенциальный клиент опубликовал на Upwork следующий проект:
### 10.1. Title
Ardupilot: Implement Positition Hold in GUIDED_NOGPS mode using SET_ATTITUDE_TARGET

### 10.2. Description
```text
The goal is to implement position hold in GUIDED_NOGPS flight mode.
There is a ROS2 topic that publish current position and orientation to the target point (will be provided). The data is available only in a radios of 1m from the target. 
Based on that data, we need to implement position hold. 
Since the data is not continuously, we VISION_POSITION_ESTIMATE.
In addition, we don't have any GPS, therefore, we have to use SET_ATTITUDE_TARGET.

Environment:
Companion computer: Jetson Orin NX (Ubuntu 22.04)
Sensor: Realsense D455
Simulator: Gazebo harmonic
ROS2 humble
C++ or Python (preferred)

step 1: Implement it in gazebo simulator
step 2: support/debug real flight
```

### 10.3. Tags
Python
C++
arudpilot
Control Engineering
Robotics

## 11. Информация о клиенте
### 11.1. Местоположение
Israel
Ramat Gan

## 11.2. Характеристики компании
### 11.2.1. Сектор экономики
неизвестно
### 11.2.2. Количество сотрудников
10-99 people

## 11.3. Характеристики учётной записи на Upwork
### 11.3.1. Member since
Apr 5, 2020
#### 11.3.2. Hire rate (%)
25
#### 11.3.3. Количество опубликованных проектов (jobs posted)
8
#### 11.3.4. Total spent
250
#### 11.3.5. Количество оплаченных часов в почасовых проектах
0

## 12.
Def(`C`):
```
клиент пункта 10
```

## 13.
Def(`P`):
```
проект пункта 10
```

## 14.
Def(`Ps`):
```
множество подобных `P` проектов 
```

## 15.
Def(`D`):
```
Описание `P` (пункт 10.2 выше)
```

## 16.
Def(`T`):
```
Конкретная подзадача, о которой `C` пишет в `D`:
~~~
implement position hold in GUIDED_NOGPS flight mode
~~~
Эта подзадача не включает следующие этапы общей задачи:
- Конфигурация Системы и Подготовка Окружения
- Разработка и Настройка Симуляционной Среды
- Интеграционное Тестирование и Отладка в Симуляторе
- Перенос Системы на Реальное Оборудование и Летные Испытания
```

## 17.
Def(`S1`):
```
Моё решение `T`
```

## 18. 
Содержание `S1`:
~~~
1) Sending `VISION_POSITION_ESTIMATE` to the Extended Kalman Filter (EKF) while in `GUIDED_NOGPS` mode is incorrect and will not affect on the quadcopter's position hold:
1.1) `VISION_POSITION_ESTIMATE` is intended to transmit position data directly to the EKF in the flight controller from an external system (e.g., a visual odometry system).
The EKF then combines these external data with readings from the inertial sensors (Inertial Measurement Unit, IMU) to estimate the quadcopter's state (position and velocity).
The flight controller then uses this estimate for autonomous position hold in modes such as `Loiter` or `Guided`.
To operate in this scenario without a physical GPS module, the EKF parameters must be configured to use an external navigation source.
1.2) The `GUIDED_NOGPS` flight mode does not use position or velocity data for stabilization and exclusively accepts commands to set the attitude (`SET_ATTITUDE_TARGET`).
This mode was developed specifically to give companion computers low-level control over the quadcopter's attitude, similar to how a pilot controls it in `Stabilize` or `AltHold` modes.
The simplicity of this mode is evident in the source code:  https://github.com/ArduPilot/ardupilot/blob/master/ArduCopter/mode_guided_nogps.cpp
Its primary function is to call the angle control handler (`ModeGuided::angle_control_run()`), effectively making it a transparent channel for attitude commands. 
2) For the position hold task, applying a simple single-loop PID controller, whose output is directly linked to the tilt angles, often leads to instability, oscillations, and overshoot.
A more reliable and widespread approach in robotics is the use of a cascaded (multi-loop) control architecture:
2.1) The outer loop (the position controller).
Its task is to convert the position error (the difference between the target and current position) into a target velocity.
If the quadcopter is to the right of the target, the controller generates a command to move to the left at a certain velocity.
The magnitude of this velocity is proportional to the distance from the target.
The input to this loop is the position error `[error_x, error_y]`, and the output is the target velocity vector `[target_vx, target_vy]`.
2.2) The inner loop (the velocity controller).
Its task is to minimize the velocity error (the difference between the target and current velocity).
To change the velocity, an acceleration must be applied.
Thus, the input to this loop is the velocity error, and the output is the target acceleration vector `[target_ax, target_ay]`.
3) For the specific task of holding the quadcopter at a single point (where the target velocity is zero), the architecture of point 2 can be simplified to a single PID controller operating on the position error:
3.1) The proportional term (`P`) responds to the current position error: `Output_P = Kp * error`. 
It provides the main restoring force toward the target.
3.2) The derivative term (`D`) reacts to the rate of change of the error, which is equivalent to counteracting the current velocity of the quadcopter: `Output_D = Kd * d(error)/dt`. 
It provides damping to prevent overshoot and oscillations.
3.3) The integral term (`I`) accumulates the error over time: `Output_I = Ki * integral(error)`. 
Its task is to compensate for constant external disturbances (e.g., wind) or systematic errors (e.g., imperfect calibration) which lead to static errors (e.g., when the quadcopter hovers slightly off  the target).
3.4) The final output of the PID controllers for each of the horizontal axes (`X` and `Y`) is the desired acceleration `[ax, ay]`, which must be provided to the quadcopter to return it to the target point.
4) The PID controller from point 3 issues an abstract command for acceleration, but the quadcopter is controlled by changing its orientation in space.
Consequently, a transformation step based on the laws of dynamics is necessary.
A quadcopter creates a lift force directed mainly along its vertical axis (the `Z` axis).
To create horizontal acceleration, the quadcopter must tilt (create roll or pitch), directing part of the thrust vector into the horizontal plane.
The target roll and pitch angles can be calculated directly from the desired accelerations `[ax, ay]` obtained from the PID controllers:
```
target_roll_angle = asin(ay / total_thrust_acceleration)
target_pitch_angle = -asin(ax / total_thrust_acceleration)
```
The resulting Euler angles (roll, pitch), along with the desired yaw angle (which for the position hold task can be considered constant, e.g., 0, to maintain the heading), must be converted into a quaternion.
The `SET_ATTITUDE_TARGET` message requires the orientation to be represented precisely in this format.
5) Since in your case the position data arrives discontinuously, a naive implementation of points 2-4 above, which does not account for possible interruptions in data arrival, can lead to catastrophic consequences:
5.1) When the data feed is interrupted, the error value in the PID controller "freezes".
The integral term can begin to grow uncontrollably (so-called "integrator windup"), if a static error existed at the moment of data loss.
5.2) Upon the resumption of data input following a pause, the error can change abruptly.
This will cause a massive spike in the derivative component (`d(error)/dt`), which will lead to a sharp, uncontrolled command and a jerk of the quadcopter.
6) The correct solution to the problem of point 5 is the constant monitoring of the arrival time of the last position message.
The control loop must check the difference between the current time and the timestamp of the last received message.
If this difference exceeds a specified threshold (e.g., 200-500 ms), the controller must enter a safe mode.
~~~

## 19.
Def(`C1`):
```
«simple single-loop PID controller», упоминаемый в `S1`
```

## 20.
Def(`C2`):
```
«cascaded (multi-loop) control architecture», упоминаемый в `S1`
```

## 21. Твоя задача
Проанализируй `S1`.
Меня смущает, что сначала в пункте 2 говорится о недостатках `C1` и вместо него предлагается `C2`, а затем в пунке 3 вроде бы идёт возвращение к `C1`.
Действительно ли последовательно такое метание от `C1` к `C2`, и затем обратно к `C1`?
 