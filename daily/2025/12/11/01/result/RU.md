1) In points 2-5, I describe 4 main causes of your problem (hereafter — `P†`).
In points 7-10, I outline my 4 main recommendations.
2) `⋇1`: cache bloat
Ваш сайт `RunRepeat.com` (hereafter — `Rᨀ`) использует фасетный поиск (цвет, размер) и рекламные метки (`gclid`, `utm`). 
Это создает комбинаторный взрыв URL (cache bloat). 
Varnish (hereafter — `Vᨀ`) по умолчанию считает `/shoe?color=red` и `/shoe?gclid=123` разными объектами. 
Если не делать агрессивную нормализацию (очистку и сортировку параметров) до кэширования, память будет забиваться мусором быстрее, чем любые политики eviction смогут её освободить.
3) `⋇2`: Unbounded transient storage
`Vᨀ` использует специальное хранилище `Transient` для короткоживущих объектов и технических записей `hit-for-miss`, создаваемых при невозможности кэширования.
По умолчанию это хранилище использует системный аллокатор `malloc` и не имеет ограничения по максимальному объему потребляемой памяти.
При наплыве трафика с уникальными метками или Cookies, которые бэкенд помечает как `private`, `Vᨀ` бесконтрольно заполняет RAM этими временными записями до полного падения сервера (OOM).
4) `⋇3`: metadata overhead
Параметр конфигурации `-s malloc,SIZE` ограничивает только объем памяти для тела объектов, но игнорирует затраты на их метаданные.
Каждый объект в кэше требует около 1 КБ оперативной памяти для служебных структур (`struct obj`, `objcore`), хранящихся вне лимитируемой области.
Из-за проблемы `⋇1` количество объектов может достигать десятков миллионов, что приводит к потреблению десятков гигабайт памяти исключительно на метаданные.
5) `⋇4`: heap fragmentation
Стандартный системный аллокатор `glibc` (hereafter — `Gᨀ`), используемый в Linux по умолчанию, неэффективен для многопоточной работы `Vᨀ` с частым выделением памяти.
Это приводит к внешней фрагментации кучи, когда операционная система считает память занятой процессом, хотя внутри она свободна, но разбита на мелкие участки.
На архитектуре AWS Graviton (ARM64) проблема фрагментации `Gᨀ` проявляется особенно остро, вызывая рост RSS процесса.
6) In points 7-10, I outline my 4 main recommendations for eliminating `P†`.
7) `R1`
7.1) Суть
Внедрить в процедуру `vcl_recv` строгую логику очистки `req.url` от маркетинговых меток (`gclid`, `fbclid`, `utm_`) и уникальных идентификаторов сессий перед вычислением хэша.
7.2) Реализация
7.2.1) Использовать модуль `vmod_std` (функция `std.querysort`) или `vmod_querystring` для алфавитной сортировки параметров запроса, что приводит их к каноническому виду.
7.2.2) Нормализовать заголовок `User-Agent` до ограниченного набора групп (например, mobile/desktop) 
7.2.3) Удалять заголовок `Cookie` для статических ресурсов.
7.3) Результат
7.3.1) Предотвращение `⋇1` посредством превращения потенциальных дубликатов в единичные экземпляры объектов в памяти.
7.3.2) Устранение первопричины `⋇3`.
8) `R2`
8.1) Суть
Добавить флаг `-s Transient=malloc,SIZE` (например, `-s Transient=malloc,2G`) к параметрам запуска демона `varnishd` (hereafter — `VDᨀ`).
8.2) Обоснование
В стандартной конфигурации `Vᨀ` использует для временных объектов (hit-for-miss, shortlived) неограниченное хранилище, которое при атаках или сбоях занимает всю доступную память.
Установка жесткого лимита заставляет `Vᨀ` применять алгоритм вытеснения (LRU) к временным объектам при достижении порога, вместо аллокации новых страниц памяти.
Это создает гарантированный аварийный барьер, предотвращающий падение сервера (OOM) даже при шквале запросов с `Set-Cookie` или уникальными параметрами.
`R2` компенсирует архитектурную уязвимость `Vᨀ`, связанную с `unbounded` природой транзитного хранилища по умолчанию.
9) `R3`
9.1) Суть
Перевести `VDᨀ` на использование библиотеки `jemalloc` (hereafter — `Jᨀ`) вместо `Gᨀ`.
9.2) Реализация
Установить пакет `Gᨀ`.
Настроить переменную окружения `LD_PRELOAD` или параметров линковки в unit-файле `systemd`.
9.3) Обоснование
`Jᨀ` использует эффективные алгоритмы управления памятью (арены, классы размеров), минимизируя внешнюю фрагментацию кучи в многопоточных приложениях.
Особенно критично это решение для архитектуры ARM64 (AWS Graviton), где `Gᨀ` демонстрирует низкую эффективность утилизации памяти.
9.4) Результат
`R3` решает `⋇4`, устраняя разрыв между потреблением памяти, фиксируемым `Vᨀ`, и реальным резидентным размером процесса (RSS).
10) `R4`
10.1) Суть
Уменьшение значения параметра `-s malloc,SIZE` `VDᨀ` до уровня, оставляющего достаточный запас (headroom) для метаданных и операционных расходов.
Для сервера с 32 ГБ RAM безопасным значением является 18-20 ГБ, а не 25-28 ГБ, как часто ошибочно устанавливают администраторы.
Расчет должен учитывать формулу: RAM минус резерв ОС, минус лимит Transient, минус память под метаданные (1 КБ на объект).
10.2) Достоинства
10.2.1) `R4` предотвращает срабатывание OOM Killer в штатном режиме работы за счет честного учета всех потребителей памяти внутри процесса.
10.2.2) `R4` позволяет системе работать стабильно даже в моменты пиковых нагрузок по количеству объектов, амортизируя рост накладных расходов.
10.2.3) `R4` обеспечивает пространство для маневра при временном увеличении потребления памяти рабочими пространствами (workspace).
10.2.4) Простота реализации позволяет быстро применить `R4` как временное решение для стабилизации.

