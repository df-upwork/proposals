## 1. `Def`
### 1.1.
```
Def(A, B)
```
будет обозначать, что для понятия `B` я использую обозначение `A`.

### 1.2.
~~~
Def(A):
```
B
```
~~~
имеет то же значение, что и `Def(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 2. `Def_P`
### 2.1.
```
Def_P(A)
```
будет обозначать, что `A` является для меня проблемой.

### 2.2.
```
Def_P(A, B)
```
будет обозначать, что `B` является для меня проблемой, и для этой проблемы я использую обозначение `A`.

### 2.3.
~~~
Def_P(A):
```
B
```
~~~
имеет то же значение, что и `Def_P(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 3. `Def_C`
### 3.1.
```
Def_C(P, A, B)
```
будет обозначать `Def(A, B)` в контексте пункта `P`.
Вне пункта `P` это правило не применяется.
Если до пункта `P` обозначение `A` имело другой смысл, то после пункта `P` обозначение `A` снова будет иметь этот смысл.
По сути, `Def_C` объявляет локальную переменную `A` с областью действия `P`.
В отличие от него, `Def` объявляет глобальную переменную `A` (значение которой действует для всех пунктов, кроме `P`).

### 3.2.
~~~
Def_C(P, A):
```
B
```
~~~
имеет то же значение, что и `Def_C(P, A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 3.3.
```
Def_C([P1, P2, …, Pn], A, B)
```
имеет значение, аналогичное `Def_C(P, A, B)`, только в этом случае обозначение `A` имеет значение `B` в контексте не одного пункта `P`, а всех пунктов [`P1`, `P2`, …, `Pn`], перечисленных в квадратных скобках.

### 3.4.
```
Def_C([P1-Pn], A, B)
```
имеет значение, аналогичное `Def_C([P1, P2, …, Pn], A, B)`: в этом случае обозначение `A` имеет значение `B` в контексте множества всех пунктов между `P1` и `Pn`, включая сами эти пункты.

### 3.5.
~~~
Def_C([P1, P2, …, Pn], A):
```
B
```
~~~
имеет то же значение, что и `Def_C([P1, P2, …, Pn], A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 3.6.
~~~
Def_C([P1-Pn], A):
```
B
```
~~~
имеет то же значение, что и `Def_C([P1-Pn], A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 4. `Def_F`
### 4.1.
Def_C(4-5, `F`):
```
Факт: некое событие, которое случилось в описываем мной случае.
```

### 4.2.
```
Def_F(B)
```
будет обозначать, что `B` — это `F`.

### 4.3.
~~~
Def_F:
```
B
```
~~~
имеет то же значение, что и `Def_F(B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 4.4.
```
Def_F(A, B)
```
будет обозначать, что `B` — это `F`, и для него я использую обозначение `A`.

### 4.5.
~~~
Def_F(A):
```
B
```
~~~
имеет то же значение, что и `Def_F(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 5. `Def_Ph`
### 5.1.
Def_C(5, `Ph`):
```
Феномен: `F`, который вызывает у меня удивление.
```

### 5.2.
```
Def_Ph(B)
```
будет обозначать, что `B` — это `Ph`.

### 5.3.
~~~
Def_Ph:
```
B
```
~~~
имеет то же значение, что и `Def_Ph(B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 5.4.
```
Def_Ph(A, B)
```
будет обозначать, что `B` — это `Ph`, и для него я использую обозначение `A`.

### 5.5.
~~~
Def_Ph(A):
```
B
```
~~~
имеет то же значение, что и `Def_Ph(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 6. `Def_H`
### 6.1.
Def_C(6, `H`):
```
Гипотеза: некое предположение, требующее проверки.
```

### 6.2.
```
Def_H(B)
```
будет обозначать, что `B` — это `H`.

### 6.3.
~~~
Def_H:
```
B
```
~~~
имеет то же значение, что и `Def_H(B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

### 6.4.
```
Def_H(A, B)
```
будет обозначать, что `B` — это `H`, и для него я использую обозначение `A`.

### 6.5.
~~~
Def_H(A):
```
B
```
~~~
имеет то же значение, что и `Def_H(A, B)`.
Такой синтаксис я буду использовать, когда для записи `B` мне нужно несколько строк текста.

## 7. `Def_Set`
```
Def_Set(S, I)
```
будет обозначать, что `S` — множество всех возможных `I`.

## 8. `Def_I`
```
Def_I(I, S)
```
будет обозначать, что `I` — элемент множества `S`.

## 9. `Use`
```
Use(A)
```
будет обозначать, что в описываемой мной ситуации я использую `A`.

## 10.
Потенциальный клиент опубликовал на Upwork следующий проект:
### 10.1. Title
Azure IoT Backend Engineer Needed to Fix Production API and Portal Errors (Short-Term)

### 10.2. Description
```markdown
We operate a production IoT platform that connects field devices to Azure IoT Hub, Azure SQL, and a custom web portal for client-facing access. 
Currently, critical backend endpoints are failing and preventing organizations from managing their users and devices.
We need a senior Azure/.NET backend developer to diagnose and fix:
- `/api/user/roles` endpoint returning HTTP 500
- Broken user/device assignment for some organizations
- Missing or corrupted role/org mapping data
- Role seeding or creation logic failures
- Diagnostic logging issues (errors are silent or unreported)

Tech stack:
- Azure App Service, Azure SQL Database
- Azure IoT Hub (device provisioning, registry, device twin)
- .NET Core (RESTful API)
- React frontend (optional context only)
- Application Insights for logging

We estimate the fix to take 2–4 weeks and would like to start immediately. 
Strong experience with production Azure systems, SQL troubleshooting, and REST API diagnostics is essential.
```

### 10.3. Tags
C#
SQL
Microsoft Azure
Azure IoT HuB
Microsoft Azure SQL Database

### 10.4. Questions
#### 10.4.1. «Have you diagnosed and fixed 500 errors in an Azure App Service before? If so, describe the issue and how you resolved it»
#### 10.4.2. «Have you worked with Azure IoT Hub and device provisioning/telemetry? Briefly explain your role in that project.»

## 11. Информация о клиенте
### 11.1. Местоположение
Canada
Toronto

## 11.2. Характеристики компании
### 11.2.1. Сектор экономики
неизвестно
### 11.2.2. Количество сотрудников
10-99 people

## 11.3. Характеристики учётной записи на Upwork
### 11.3.1. Member since
Sep 25, 2020
#### 11.3.2. Hire rate (%)
50%
#### 11.3.3. Количество опубликованных проектов (jobs posted)
6
#### 11.3.4. Total spent
$310
#### 11.3.5. Количество оплаченных часов в почасовых проектах
0

## 12.
Def(`C`):
```
клиент пункта 10
```

## 13.
Def(`P`):
```
проект пункта 10
```

## 14.
Def(`Ps`):
```
множество подобных `P` проектов 
```

## 15.
Def(`D`):
```
Описание `P` (пункт 10.2 выше)
```

## 16.
Def_P(`P1`):
```
Одна из проблем, о которой `C` пишет в `D`:
~~~
`/api/user/roles` endpoint returning HTTP 500
~~~
```

## 17.
Def_P(`P2`):
```
Одна из проблем, о которой `C` пишет в `D`:
~~~
Broken user/device assignment for some organizations
~~~
```

## 18.
Def_P(`P3`):
```
Одна из проблем, о которой `C` пишет в `D`:
~~~
Missing or corrupted role/org mapping data
~~~
```

## 19.
Def_P(`P4`):
```
Одна из проблем, о которой `C` пишет в `D`:
~~~
Role seeding or creation logic failures
~~~
```

## 20.
Def_P(`P5`):
```
Одна из проблем, о которой `C` пишет в `D`:
~~~
errors are silent or unreported
~~~
```

## 21.
Def(`P1-D`):
```
диагностика `P1`
```

## 22.
Def(`P1-D-W1`):
```
`P1-D` посредством «App Service logs».
Платформа Azure App Service предоставляет встроенный набор инструментов для логирования, который является первой линией обороны при диагностике ошибок. 
Активация этих механизмов через портал Azure — это фундаментальный шаг, который необходимо выполнить перед началом любого глубокого анализа.
```

## 23.
Def(`P1-D-W2`):
```
`P1-D` посредством «Web Server Logging».
Журналы веб-сервера (IIS) фиксируют метаданные о каждом входящем HTTP-запросе, включая URL-адрес, HTTP-метод, код состояния ответа, время обработки, IP-адрес клиента и User-Agent.
Эти журналы чрезвычайно полезны для выявления общих паттернов сбоев. 
Например, анализ этих логов может показать, что все запросы к определенному эндпоинту или все POST-запросы завершаются с ошибкой 500, в то время как другие запросы обрабатываются корректно. 
Это помогает значительно сузить область поиска проблемы. 
Кроме того, наличие записи о запросе в журнале веб-сервера подтверждает, что запрос успешно прошел через сетевую инфраструктуру Azure и достиг вашего экземпляра App Service.
```

## 24.
Def(`P1-D-W3`):
```
`P1-D` посредством опции «Detailed Error Messages».
Эта опция заставляет IIS возвращать клиенту подробную HTML-страницу с описанием ошибки вместо стандартной страницы "500 - Internal Server Error".
```

## 25.
Def(`P1-D-W4`):
```
`P1-D` посредством «Failed Request Tracing».
Это мощный инструмент диагностики на уровне IIS, который создает подробные XML-файлы трассировки для запросов, завершившихся сбоем. 
Трассировка фиксирует каждый этап обработки запроса различными модулями IIS, показывая, сколько времени занял каждый этап и где именно произошла ошибка.
Этот механизм незаменим для диагностики проблем, связанных с конфигурацией. 
```

## 26.
Def(`P1-D-W5`):
```
`P1-D` посредством «Log Stream».
Функция Log Stream (Поток журналов) предоставляет возможность наблюдать за логами приложения и веб-сервера в режиме реального времени. 
Это незаменимый инструмент для отладки проблем, которые трудно воспроизвести, или для анализа сбоев, происходящих в момент запуска приложения. 
Практическое применение Log Stream заключается в открытии консоли потока и последующем выполнении действий, которые провоцируют ошибку. 
Например, можно перезапустить App Service и наблюдать за журналами инициализации, чтобы отловить сбои на этапе старта.
В потоке отображаются как логи веб-сервера, так и логи приложения, что позволяет получить комплексную картину происходящего.
```

## 27.
Def(`P1-D-W6`):
```
`P1-D` посредством «stdout».
Для приложений ASP.NET Core, развернутых в App Service, журналы стандартного вывода (stdout) являются критически важным, а зачастую и единственным, источником информации при диагностике сбоев на этапе запуска.
Многие фатальные ошибки, такие как HTTP Error 500.30 - ANCM In-Process Start Failure, происходят до того, как стандартные системы логирования, включая ILogger и Application Insights, успевают полностью инициализироваться и начать работу.
Причина этого кроется в архитектуре хостинга. Модуль ASP.NET Core (ANCM) для IIS выступает в роли обратного прокси. 
Он отвечает за запуск рабочего процесса вашего приложения ( dotnet.exe ) и перенаправление трафика к нему. 
Если процесс dotnet.exe падает сразу после запуска из-за необработанного исключения в коде инициализации (например, в Program.cs), ANCM фиксирует этот сбой и возвращает клиенту ошибку 500.30.
В такой ситуации журналы приложения не будут содержать никаких записей, так как само приложение так и не запустилось.
Единственный способ увидеть исходное исключение — это включить перенаправление стандартного вывода (stdout) и стандартного потока ошибок (stderr) процесса dotnet.exe в файл.
```

## 28.
Def(`P1-D-W7`):
```
`P1-D` посредством «Application Insights».
Для диагностики ошибок в коде приложения .NET на Azure это основной и самый мощный инструмент, на порядок более информативный, чем базовые логи App Service. Он позволяет видеть полные стеки исключений, трассировки зависимостей (например, неудачные SQL-запросы), параметры запросов и т. д. 
```

## 29. Твоя задача
Напиши пошаговую инструкцию для `P1-D-W7`.

## 30. Правила ответа
### 30.1.
Инструкция должна быть на русском языке.
Исключением являются точные официальные термины: смотри пункт 30.2 ниже.

### 30.2.
При обсуждении программного обеспечения используй точные официальные термины на английском языке: именно в том виде, как они указаны в официальной англоязычной документации к этому программному обеспечению.

### 30.3.
Не используй выделение жирным (`**`) и курсив (`*`).

### 30.4.
Названия файлов заключай в backticks.
Например: `header.php`.

### 30.5.
Названия элементов интерфейса заключай в угловые кавычки (`«»`).

### 30.6.
Для путей в интерфейсе используй `→`.
Например: «Current User» → «Personal».

### 30.7.
Не используй жаргон.
Вместо этого используй официальные термины.

#### 30.7.1.
В частности, фразы в кавычках используй только в том случае, когда они являются точными цитатами.
Не используй фразы в кавычках для применения жаргонных фраз.
Например, следующий фрагмент текста недопустим, потому что там используется жаргонная фраза «пролетел»: 
```
Например, код, который пушит данные о покупке, подключён асинхронно и загружается с небольшой задержкой, а триггер уже «пролетел».
```

### 30.8.
Не используй «you need» и другие подобные обращённые к клиенту фразы, перекладывающие действия на него.
Помни: я пишу клиенту или потенциальному клиенту.
Делать в любом случае буду я, а не клиент.
Вместо «you need» используй 2 альтернативы:
#### 30.8.1.
Нейтральные фразы типа «it is necessary».
#### 30.8.2.
Глаголы в неопределённой форме.
Например, во фрагменте ниже использованы подобные глаголы «set up», «create»:
```
1.2) Set up the transfer of login events from WordPress to Power BI using Fabric / OneLake.
1.2.1) Set up a «Data Pipeline» from the WordPress database table that stores login events (see point 1.1) to Fabric / OneLake.
1.2.2) Set up a connection from Power BI to Fabric / OneLake to pass login events.
1.3) Create the data model in Power BI.
```
Обрати внимание, в этом фрагменте не говорится, кто именно будет выполнять описанные действия: ответственность не перекладывается на клиента, в отличие от «you need».